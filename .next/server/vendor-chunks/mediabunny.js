"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mediabunny";
exports.ids = ["vendor-chunks/mediabunny"];
exports.modules = {

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/shared/mp3-misc.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/shared/mp3-misc.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FRAME_HEADER_SIZE: () => (/* binding */ FRAME_HEADER_SIZE),\n/* harmony export */   INFO: () => (/* binding */ INFO),\n/* harmony export */   MPEG_V1_BITRATES: () => (/* binding */ MPEG_V1_BITRATES),\n/* harmony export */   MPEG_V2_BITRATES: () => (/* binding */ MPEG_V2_BITRATES),\n/* harmony export */   SAMPLING_RATES: () => (/* binding */ SAMPLING_RATES),\n/* harmony export */   XING: () => (/* binding */ XING),\n/* harmony export */   computeMp3FrameSize: () => (/* binding */ computeMp3FrameSize),\n/* harmony export */   decodeSynchsafe: () => (/* binding */ decodeSynchsafe),\n/* harmony export */   encodeSynchsafe: () => (/* binding */ encodeSynchsafe),\n/* harmony export */   getXingOffset: () => (/* binding */ getXingOffset),\n/* harmony export */   readFrameHeader: () => (/* binding */ readFrameHeader)\n/* harmony export */ });\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nconst FRAME_HEADER_SIZE = 4;\n// These are in kbps:\nconst MPEG_V1_BITRATES = {\n    // Layer 3\n    1: [-1, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1],\n    // Layer 2\n    2: [-1, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1],\n    // Layer 1\n    3: [-1, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1],\n};\nconst MPEG_V2_BITRATES = {\n    // Layer 3\n    1: [-1, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, -1],\n    // Layer 2\n    2: [-1, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, -1],\n    // Layer 1\n    3: [-1, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, -1],\n};\nconst SAMPLING_RATES = {\n    // MPEG Version 2.5\n    0: [11025, 12000, 8000, -1],\n    // MPEG Version 2 (ISO/IEC 13818-3)\n    2: [22050, 24000, 16000, -1],\n    // MPEG Version 1 (ISO/IEC 11172-3)\n    3: [44100, 48000, 32000, -1],\n};\n/** 'Xing' */\nconst XING = 0x58696e67;\n/** 'Info' */\nconst INFO = 0x496e666f;\nconst computeMp3FrameSize = (layer, bitrate, sampleRate, padding) => {\n    if (layer === 3) {\n        // Layer 1\n        return Math.floor((12 * bitrate / sampleRate + padding) * 4);\n    }\n    else {\n        return Math.floor((144 * bitrate / sampleRate) + padding);\n    }\n};\nconst getXingOffset = (mpegVersionId, channel) => {\n    return mpegVersionId === 3\n        ? (channel === 3 ? 21 : 36)\n        : (channel === 3 ? 13 : 21);\n};\nconst readFrameHeader = (word, remainingBytes) => {\n    const firstByte = word >>> 24;\n    const secondByte = (word >>> 16) & 0xff;\n    const thirdByte = (word >>> 8) & 0xff;\n    const fourthByte = word & 0xff;\n    if (firstByte !== 0xff && secondByte !== 0xff && thirdByte !== 0xff && fourthByte !== 0xff) {\n        return {\n            header: null,\n            bytesAdvanced: 4,\n        };\n    }\n    if (firstByte !== 0xff) {\n        return { header: null, bytesAdvanced: 1 };\n    }\n    if ((secondByte & 0xe0) !== 0xe0) {\n        return { header: null, bytesAdvanced: 1 };\n    }\n    const mpegVersionId = (secondByte >> 3) & 0x3;\n    const layer = (secondByte >> 1) & 0x3;\n    const bitrateIndex = (thirdByte >> 4) & 0xf;\n    const frequencyIndex = (thirdByte >> 2) & 0x3;\n    const padding = (thirdByte >> 1) & 0x1;\n    const channel = (fourthByte >> 6) & 0x3;\n    const modeExtension = (fourthByte >> 4) & 0x3;\n    const copyright = (fourthByte >> 3) & 0x1;\n    const original = (fourthByte >> 2) & 0x1;\n    const emphasis = fourthByte & 0x3;\n    const kilobitRate = mpegVersionId === 3\n        ? MPEG_V1_BITRATES[layer]?.[bitrateIndex]\n        : MPEG_V2_BITRATES[layer]?.[bitrateIndex];\n    if (!kilobitRate || kilobitRate === -1) {\n        return { header: null, bytesAdvanced: 1 };\n    }\n    const bitrate = kilobitRate * 1000;\n    const sampleRate = SAMPLING_RATES[mpegVersionId]?.[frequencyIndex];\n    if (!sampleRate || sampleRate === -1) {\n        return { header: null, bytesAdvanced: 1 };\n    }\n    const frameLength = computeMp3FrameSize(layer, bitrate, sampleRate, padding);\n    if (remainingBytes !== null && remainingBytes < frameLength) {\n        // The frame doesn't fit into the rest of the file\n        return { header: null, bytesAdvanced: 1 };\n    }\n    let audioSamplesInFrame;\n    if (mpegVersionId === 3) {\n        audioSamplesInFrame = layer === 3 ? 384 : 1152;\n    }\n    else {\n        if (layer === 3) {\n            audioSamplesInFrame = 384;\n        }\n        else if (layer === 2) {\n            audioSamplesInFrame = 1152;\n        }\n        else {\n            audioSamplesInFrame = 576;\n        }\n    }\n    return {\n        header: {\n            totalSize: frameLength,\n            mpegVersionId,\n            layer,\n            bitrate,\n            frequencyIndex,\n            sampleRate,\n            channel,\n            modeExtension,\n            copyright,\n            original,\n            emphasis,\n            audioSamplesInFrame,\n        },\n        bytesAdvanced: 1,\n    };\n};\nconst encodeSynchsafe = (unsynchsafed) => {\n    let mask = 0x7f;\n    let synchsafed = 0;\n    let unsynchsafedRest = unsynchsafed;\n    while ((mask ^ 0x7fffffff) !== 0) {\n        synchsafed = unsynchsafedRest & ~mask;\n        synchsafed <<= 1;\n        synchsafed |= unsynchsafedRest & mask;\n        mask = ((mask + 1) << 8) - 1;\n        unsynchsafedRest = synchsafed;\n    }\n    return synchsafed;\n};\nconst decodeSynchsafe = (synchsafed) => {\n    let mask = 0x7f000000;\n    let unsynchsafed = 0;\n    while (mask !== 0) {\n        unsynchsafed >>= 1;\n        unsynchsafed |= synchsafed & mask;\n        mask >>= 8;\n    }\n    return unsynchsafed;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc2hhcmVkL21wMy1taXNjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWF0Y2gtY3V0LWdlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9tZWRpYWJ1bm55L2Rpc3QvbW9kdWxlcy9zaGFyZWQvbXAzLW1pc2MuanM/OWJjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAyNS1wcmVzZW50LCBWYW5pbGFneSBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmV4cG9ydCBjb25zdCBGUkFNRV9IRUFERVJfU0laRSA9IDQ7XG4vLyBUaGVzZSBhcmUgaW4ga2JwczpcbmV4cG9ydCBjb25zdCBNUEVHX1YxX0JJVFJBVEVTID0ge1xuICAgIC8vIExheWVyIDNcbiAgICAxOiBbLTEsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIC0xXSxcbiAgICAvLyBMYXllciAyXG4gICAgMjogWy0xLCAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDM4NCwgLTFdLFxuICAgIC8vIExheWVyIDFcbiAgICAzOiBbLTEsIDMyLCA2NCwgOTYsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAyODgsIDMyMCwgMzUyLCAzODQsIDQxNiwgNDQ4LCAtMV0sXG59O1xuZXhwb3J0IGNvbnN0IE1QRUdfVjJfQklUUkFURVMgPSB7XG4gICAgLy8gTGF5ZXIgM1xuICAgIDE6IFstMSwgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwLCAxNzYsIDE5MiwgMjI0LCAyNTYsIC0xXSxcbiAgICAvLyBMYXllciAyXG4gICAgMjogWy0xLCA4LCAxNiwgMjQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjAsIC0xXSxcbiAgICAvLyBMYXllciAxXG4gICAgMzogWy0xLCA4LCAxNiwgMjQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjAsIC0xXSxcbn07XG5leHBvcnQgY29uc3QgU0FNUExJTkdfUkFURVMgPSB7XG4gICAgLy8gTVBFRyBWZXJzaW9uIDIuNVxuICAgIDA6IFsxMTAyNSwgMTIwMDAsIDgwMDAsIC0xXSxcbiAgICAvLyBNUEVHIFZlcnNpb24gMiAoSVNPL0lFQyAxMzgxOC0zKVxuICAgIDI6IFsyMjA1MCwgMjQwMDAsIDE2MDAwLCAtMV0sXG4gICAgLy8gTVBFRyBWZXJzaW9uIDEgKElTTy9JRUMgMTExNzItMylcbiAgICAzOiBbNDQxMDAsIDQ4MDAwLCAzMjAwMCwgLTFdLFxufTtcbi8qKiAnWGluZycgKi9cbmV4cG9ydCBjb25zdCBYSU5HID0gMHg1ODY5NmU2Nztcbi8qKiAnSW5mbycgKi9cbmV4cG9ydCBjb25zdCBJTkZPID0gMHg0OTZlNjY2ZjtcbmV4cG9ydCBjb25zdCBjb21wdXRlTXAzRnJhbWVTaXplID0gKGxheWVyLCBiaXRyYXRlLCBzYW1wbGVSYXRlLCBwYWRkaW5nKSA9PiB7XG4gICAgaWYgKGxheWVyID09PSAzKSB7XG4gICAgICAgIC8vIExheWVyIDFcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEyICogYml0cmF0ZSAvIHNhbXBsZVJhdGUgKyBwYWRkaW5nKSAqIDQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDE0NCAqIGJpdHJhdGUgLyBzYW1wbGVSYXRlKSArIHBhZGRpbmcpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgZ2V0WGluZ09mZnNldCA9IChtcGVnVmVyc2lvbklkLCBjaGFubmVsKSA9PiB7XG4gICAgcmV0dXJuIG1wZWdWZXJzaW9uSWQgPT09IDNcbiAgICAgICAgPyAoY2hhbm5lbCA9PT0gMyA/IDIxIDogMzYpXG4gICAgICAgIDogKGNoYW5uZWwgPT09IDMgPyAxMyA6IDIxKTtcbn07XG5leHBvcnQgY29uc3QgcmVhZEZyYW1lSGVhZGVyID0gKHdvcmQsIHJlbWFpbmluZ0J5dGVzKSA9PiB7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gd29yZCA+Pj4gMjQ7XG4gICAgY29uc3Qgc2Vjb25kQnl0ZSA9ICh3b3JkID4+PiAxNikgJiAweGZmO1xuICAgIGNvbnN0IHRoaXJkQnl0ZSA9ICh3b3JkID4+PiA4KSAmIDB4ZmY7XG4gICAgY29uc3QgZm91cnRoQnl0ZSA9IHdvcmQgJiAweGZmO1xuICAgIGlmIChmaXJzdEJ5dGUgIT09IDB4ZmYgJiYgc2Vjb25kQnl0ZSAhPT0gMHhmZiAmJiB0aGlyZEJ5dGUgIT09IDB4ZmYgJiYgZm91cnRoQnl0ZSAhPT0gMHhmZikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZGVyOiBudWxsLFxuICAgICAgICAgICAgYnl0ZXNBZHZhbmNlZDogNCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGZpcnN0Qnl0ZSAhPT0gMHhmZikge1xuICAgICAgICByZXR1cm4geyBoZWFkZXI6IG51bGwsIGJ5dGVzQWR2YW5jZWQ6IDEgfTtcbiAgICB9XG4gICAgaWYgKChzZWNvbmRCeXRlICYgMHhlMCkgIT09IDB4ZTApIHtcbiAgICAgICAgcmV0dXJuIHsgaGVhZGVyOiBudWxsLCBieXRlc0FkdmFuY2VkOiAxIH07XG4gICAgfVxuICAgIGNvbnN0IG1wZWdWZXJzaW9uSWQgPSAoc2Vjb25kQnl0ZSA+PiAzKSAmIDB4MztcbiAgICBjb25zdCBsYXllciA9IChzZWNvbmRCeXRlID4+IDEpICYgMHgzO1xuICAgIGNvbnN0IGJpdHJhdGVJbmRleCA9ICh0aGlyZEJ5dGUgPj4gNCkgJiAweGY7XG4gICAgY29uc3QgZnJlcXVlbmN5SW5kZXggPSAodGhpcmRCeXRlID4+IDIpICYgMHgzO1xuICAgIGNvbnN0IHBhZGRpbmcgPSAodGhpcmRCeXRlID4+IDEpICYgMHgxO1xuICAgIGNvbnN0IGNoYW5uZWwgPSAoZm91cnRoQnl0ZSA+PiA2KSAmIDB4MztcbiAgICBjb25zdCBtb2RlRXh0ZW5zaW9uID0gKGZvdXJ0aEJ5dGUgPj4gNCkgJiAweDM7XG4gICAgY29uc3QgY29weXJpZ2h0ID0gKGZvdXJ0aEJ5dGUgPj4gMykgJiAweDE7XG4gICAgY29uc3Qgb3JpZ2luYWwgPSAoZm91cnRoQnl0ZSA+PiAyKSAmIDB4MTtcbiAgICBjb25zdCBlbXBoYXNpcyA9IGZvdXJ0aEJ5dGUgJiAweDM7XG4gICAgY29uc3Qga2lsb2JpdFJhdGUgPSBtcGVnVmVyc2lvbklkID09PSAzXG4gICAgICAgID8gTVBFR19WMV9CSVRSQVRFU1tsYXllcl0/LltiaXRyYXRlSW5kZXhdXG4gICAgICAgIDogTVBFR19WMl9CSVRSQVRFU1tsYXllcl0/LltiaXRyYXRlSW5kZXhdO1xuICAgIGlmICgha2lsb2JpdFJhdGUgfHwga2lsb2JpdFJhdGUgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7IGhlYWRlcjogbnVsbCwgYnl0ZXNBZHZhbmNlZDogMSB9O1xuICAgIH1cbiAgICBjb25zdCBiaXRyYXRlID0ga2lsb2JpdFJhdGUgKiAxMDAwO1xuICAgIGNvbnN0IHNhbXBsZVJhdGUgPSBTQU1QTElOR19SQVRFU1ttcGVnVmVyc2lvbklkXT8uW2ZyZXF1ZW5jeUluZGV4XTtcbiAgICBpZiAoIXNhbXBsZVJhdGUgfHwgc2FtcGxlUmF0ZSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHsgaGVhZGVyOiBudWxsLCBieXRlc0FkdmFuY2VkOiAxIH07XG4gICAgfVxuICAgIGNvbnN0IGZyYW1lTGVuZ3RoID0gY29tcHV0ZU1wM0ZyYW1lU2l6ZShsYXllciwgYml0cmF0ZSwgc2FtcGxlUmF0ZSwgcGFkZGluZyk7XG4gICAgaWYgKHJlbWFpbmluZ0J5dGVzICE9PSBudWxsICYmIHJlbWFpbmluZ0J5dGVzIDwgZnJhbWVMZW5ndGgpIHtcbiAgICAgICAgLy8gVGhlIGZyYW1lIGRvZXNuJ3QgZml0IGludG8gdGhlIHJlc3Qgb2YgdGhlIGZpbGVcbiAgICAgICAgcmV0dXJuIHsgaGVhZGVyOiBudWxsLCBieXRlc0FkdmFuY2VkOiAxIH07XG4gICAgfVxuICAgIGxldCBhdWRpb1NhbXBsZXNJbkZyYW1lO1xuICAgIGlmIChtcGVnVmVyc2lvbklkID09PSAzKSB7XG4gICAgICAgIGF1ZGlvU2FtcGxlc0luRnJhbWUgPSBsYXllciA9PT0gMyA/IDM4NCA6IDExNTI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobGF5ZXIgPT09IDMpIHtcbiAgICAgICAgICAgIGF1ZGlvU2FtcGxlc0luRnJhbWUgPSAzODQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGF5ZXIgPT09IDIpIHtcbiAgICAgICAgICAgIGF1ZGlvU2FtcGxlc0luRnJhbWUgPSAxMTUyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXVkaW9TYW1wbGVzSW5GcmFtZSA9IDU3NjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgIHRvdGFsU2l6ZTogZnJhbWVMZW5ndGgsXG4gICAgICAgICAgICBtcGVnVmVyc2lvbklkLFxuICAgICAgICAgICAgbGF5ZXIsXG4gICAgICAgICAgICBiaXRyYXRlLFxuICAgICAgICAgICAgZnJlcXVlbmN5SW5kZXgsXG4gICAgICAgICAgICBzYW1wbGVSYXRlLFxuICAgICAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgICAgIG1vZGVFeHRlbnNpb24sXG4gICAgICAgICAgICBjb3B5cmlnaHQsXG4gICAgICAgICAgICBvcmlnaW5hbCxcbiAgICAgICAgICAgIGVtcGhhc2lzLFxuICAgICAgICAgICAgYXVkaW9TYW1wbGVzSW5GcmFtZSxcbiAgICAgICAgfSxcbiAgICAgICAgYnl0ZXNBZHZhbmNlZDogMSxcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBlbmNvZGVTeW5jaHNhZmUgPSAodW5zeW5jaHNhZmVkKSA9PiB7XG4gICAgbGV0IG1hc2sgPSAweDdmO1xuICAgIGxldCBzeW5jaHNhZmVkID0gMDtcbiAgICBsZXQgdW5zeW5jaHNhZmVkUmVzdCA9IHVuc3luY2hzYWZlZDtcbiAgICB3aGlsZSAoKG1hc2sgXiAweDdmZmZmZmZmKSAhPT0gMCkge1xuICAgICAgICBzeW5jaHNhZmVkID0gdW5zeW5jaHNhZmVkUmVzdCAmIH5tYXNrO1xuICAgICAgICBzeW5jaHNhZmVkIDw8PSAxO1xuICAgICAgICBzeW5jaHNhZmVkIHw9IHVuc3luY2hzYWZlZFJlc3QgJiBtYXNrO1xuICAgICAgICBtYXNrID0gKChtYXNrICsgMSkgPDwgOCkgLSAxO1xuICAgICAgICB1bnN5bmNoc2FmZWRSZXN0ID0gc3luY2hzYWZlZDtcbiAgICB9XG4gICAgcmV0dXJuIHN5bmNoc2FmZWQ7XG59O1xuZXhwb3J0IGNvbnN0IGRlY29kZVN5bmNoc2FmZSA9IChzeW5jaHNhZmVkKSA9PiB7XG4gICAgbGV0IG1hc2sgPSAweDdmMDAwMDAwO1xuICAgIGxldCB1bnN5bmNoc2FmZWQgPSAwO1xuICAgIHdoaWxlIChtYXNrICE9PSAwKSB7XG4gICAgICAgIHVuc3luY2hzYWZlZCA+Pj0gMTtcbiAgICAgICAgdW5zeW5jaHNhZmVkIHw9IHN5bmNoc2FmZWQgJiBtYXNrO1xuICAgICAgICBtYXNrID4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gdW5zeW5jaHNhZmVkO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/shared/mp3-misc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/adts/adts-muxer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/adts/adts-muxer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdtsMuxer: () => (/* binding */ AdtsMuxer)\n/* harmony export */ });\n/* harmony import */ var _codec_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../codec.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/* harmony import */ var _muxer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../muxer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/muxer.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\nclass AdtsMuxer extends _muxer_js__WEBPACK_IMPORTED_MODULE_0__.Muxer {\n    constructor(output, format) {\n        super(output);\n        this.header = new Uint8Array(7);\n        this.headerBitstream = new _misc_js__WEBPACK_IMPORTED_MODULE_1__.Bitstream(this.header);\n        this.audioSpecificConfig = null;\n        this.format = format;\n        this.writer = output._writer;\n    }\n    async start() {\n        // Nothing needed here\n    }\n    async getMimeType() {\n        return 'audio/aac';\n    }\n    async addEncodedVideoPacket() {\n        throw new Error('ADTS does not support video.');\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        // https://wiki.multimedia.cx/index.php/ADTS (last visited: 2025/08/17)\n        const release = await this.mutex.acquire();\n        try {\n            this.validateAndNormalizeTimestamp(track, packet.timestamp, packet.type === 'key');\n            if (!this.audioSpecificConfig) {\n                (0,_codec_js__WEBPACK_IMPORTED_MODULE_2__.validateAudioChunkMetadata)(meta);\n                const description = meta?.decoderConfig?.description;\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(description);\n                this.audioSpecificConfig = (0,_codec_js__WEBPACK_IMPORTED_MODULE_2__.parseAacAudioSpecificConfig)((0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.toUint8Array)(description));\n                const { objectType, frequencyIndex, channelConfiguration } = this.audioSpecificConfig;\n                const profile = objectType - 1;\n                this.headerBitstream.writeBits(12, 0b1111_11111111); // Syncword\n                this.headerBitstream.writeBits(1, 0); // MPEG Version\n                this.headerBitstream.writeBits(2, 0); // Layer\n                this.headerBitstream.writeBits(1, 1); // Protection absence\n                this.headerBitstream.writeBits(2, profile); // Profile\n                this.headerBitstream.writeBits(4, frequencyIndex); // MPEG-4 Sampling Frequency Index\n                this.headerBitstream.writeBits(1, 0); // Private bit\n                this.headerBitstream.writeBits(3, channelConfiguration); // MPEG-4 Channel Configuration\n                this.headerBitstream.writeBits(1, 0); // Originality\n                this.headerBitstream.writeBits(1, 0); // Home\n                this.headerBitstream.writeBits(1, 0); // Copyright ID bit\n                this.headerBitstream.writeBits(1, 0); // Copyright ID start\n                this.headerBitstream.skipBits(13); // Frame length\n                this.headerBitstream.writeBits(11, 0x7ff); // Buffer fullness\n                this.headerBitstream.writeBits(2, 0); // Number of AAC frames minus 1\n                // Omit CRC check\n            }\n            const frameLength = packet.data.byteLength + this.header.byteLength;\n            this.headerBitstream.pos = 30;\n            this.headerBitstream.writeBits(13, frameLength);\n            const startPos = this.writer.getPos();\n            this.writer.write(this.header);\n            this.writer.write(packet.data);\n            if (this.format._options.onFrame) {\n                const frameBytes = new Uint8Array(frameLength);\n                frameBytes.set(this.header, 0);\n                frameBytes.set(packet.data, this.header.byteLength);\n                this.format._options.onFrame(frameBytes, startPos);\n            }\n            await this.writer.flush();\n        }\n        finally {\n            release();\n        }\n    }\n    async addSubtitleCue() {\n        throw new Error('ADTS does not support subtitles.');\n    }\n    async finalize() { }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL2FkdHMvYWR0cy1tdXhlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0Y7QUFDekI7QUFDekI7QUFDN0Isd0JBQXdCLDRDQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywrQ0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxRUFBMEI7QUFDMUM7QUFDQSxnQkFBZ0IsZ0RBQU07QUFDdEIsMkNBQTJDLHNFQUEyQixDQUFDLHNEQUFZO0FBQ25GLHdCQUF3QixtREFBbUQ7QUFDM0U7QUFDQSxxRUFBcUU7QUFDckUsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsNERBQTREO0FBQzVELG1FQUFtRTtBQUNuRSxzREFBc0Q7QUFDdEQseUVBQXlFO0FBQ3pFLHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxtREFBbUQ7QUFDbkQsMkRBQTJEO0FBQzNELHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGNoLWN1dC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL2FkdHMvYWR0cy1tdXhlci5qcz9iNmZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDI1LXByZXNlbnQsIFZhbmlsYWd5IGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgcGFyc2VBYWNBdWRpb1NwZWNpZmljQ29uZmlnLCB2YWxpZGF0ZUF1ZGlvQ2h1bmtNZXRhZGF0YSB9IGZyb20gJy4uL2NvZGVjLmpzJztcbmltcG9ydCB7IGFzc2VydCwgQml0c3RyZWFtLCB0b1VpbnQ4QXJyYXkgfSBmcm9tICcuLi9taXNjLmpzJztcbmltcG9ydCB7IE11eGVyIH0gZnJvbSAnLi4vbXV4ZXIuanMnO1xuZXhwb3J0IGNsYXNzIEFkdHNNdXhlciBleHRlbmRzIE11eGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvdXRwdXQsIGZvcm1hdCkge1xuICAgICAgICBzdXBlcihvdXRwdXQpO1xuICAgICAgICB0aGlzLmhlYWRlciA9IG5ldyBVaW50OEFycmF5KDcpO1xuICAgICAgICB0aGlzLmhlYWRlckJpdHN0cmVhbSA9IG5ldyBCaXRzdHJlYW0odGhpcy5oZWFkZXIpO1xuICAgICAgICB0aGlzLmF1ZGlvU3BlY2lmaWNDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgdGhpcy53cml0ZXIgPSBvdXRwdXQuX3dyaXRlcjtcbiAgICB9XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgbmVlZGVkIGhlcmVcbiAgICB9XG4gICAgYXN5bmMgZ2V0TWltZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnYXVkaW8vYWFjJztcbiAgICB9XG4gICAgYXN5bmMgYWRkRW5jb2RlZFZpZGVvUGFja2V0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FEVFMgZG9lcyBub3Qgc3VwcG9ydCB2aWRlby4nKTtcbiAgICB9XG4gICAgYXN5bmMgYWRkRW5jb2RlZEF1ZGlvUGFja2V0KHRyYWNrLCBwYWNrZXQsIG1ldGEpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwL0FEVFMgKGxhc3QgdmlzaXRlZDogMjAyNS8wOC8xNylcbiAgICAgICAgY29uc3QgcmVsZWFzZSA9IGF3YWl0IHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUFuZE5vcm1hbGl6ZVRpbWVzdGFtcCh0cmFjaywgcGFja2V0LnRpbWVzdGFtcCwgcGFja2V0LnR5cGUgPT09ICdrZXknKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hdWRpb1NwZWNpZmljQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVBdWRpb0NodW5rTWV0YWRhdGEobWV0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBtZXRhPy5kZWNvZGVyQ29uZmlnPy5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9TcGVjaWZpY0NvbmZpZyA9IHBhcnNlQWFjQXVkaW9TcGVjaWZpY0NvbmZpZyh0b1VpbnQ4QXJyYXkoZGVzY3JpcHRpb24pKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9iamVjdFR5cGUsIGZyZXF1ZW5jeUluZGV4LCBjaGFubmVsQ29uZmlndXJhdGlvbiB9ID0gdGhpcy5hdWRpb1NwZWNpZmljQ29uZmlnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb2ZpbGUgPSBvYmplY3RUeXBlIC0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlckJpdHN0cmVhbS53cml0ZUJpdHMoMTIsIDBiMTExMV8xMTExMTExMSk7IC8vIFN5bmN3b3JkXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJCaXRzdHJlYW0ud3JpdGVCaXRzKDEsIDApOyAvLyBNUEVHIFZlcnNpb25cbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlckJpdHN0cmVhbS53cml0ZUJpdHMoMiwgMCk7IC8vIExheWVyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJCaXRzdHJlYW0ud3JpdGVCaXRzKDEsIDEpOyAvLyBQcm90ZWN0aW9uIGFic2VuY2VcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlckJpdHN0cmVhbS53cml0ZUJpdHMoMiwgcHJvZmlsZSk7IC8vIFByb2ZpbGVcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlckJpdHN0cmVhbS53cml0ZUJpdHMoNCwgZnJlcXVlbmN5SW5kZXgpOyAvLyBNUEVHLTQgU2FtcGxpbmcgRnJlcXVlbmN5IEluZGV4XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJCaXRzdHJlYW0ud3JpdGVCaXRzKDEsIDApOyAvLyBQcml2YXRlIGJpdFxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyQml0c3RyZWFtLndyaXRlQml0cygzLCBjaGFubmVsQ29uZmlndXJhdGlvbik7IC8vIE1QRUctNCBDaGFubmVsIENvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlckJpdHN0cmVhbS53cml0ZUJpdHMoMSwgMCk7IC8vIE9yaWdpbmFsaXR5XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJCaXRzdHJlYW0ud3JpdGVCaXRzKDEsIDApOyAvLyBIb21lXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJCaXRzdHJlYW0ud3JpdGVCaXRzKDEsIDApOyAvLyBDb3B5cmlnaHQgSUQgYml0XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJCaXRzdHJlYW0ud3JpdGVCaXRzKDEsIDApOyAvLyBDb3B5cmlnaHQgSUQgc3RhcnRcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlckJpdHN0cmVhbS5za2lwQml0cygxMyk7IC8vIEZyYW1lIGxlbmd0aFxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyQml0c3RyZWFtLndyaXRlQml0cygxMSwgMHg3ZmYpOyAvLyBCdWZmZXIgZnVsbG5lc3NcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlckJpdHN0cmVhbS53cml0ZUJpdHMoMiwgMCk7IC8vIE51bWJlciBvZiBBQUMgZnJhbWVzIG1pbnVzIDFcbiAgICAgICAgICAgICAgICAvLyBPbWl0IENSQyBjaGVja1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnJhbWVMZW5ndGggPSBwYWNrZXQuZGF0YS5ieXRlTGVuZ3RoICsgdGhpcy5oZWFkZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyQml0c3RyZWFtLnBvcyA9IDMwO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJCaXRzdHJlYW0ud3JpdGVCaXRzKDEzLCBmcmFtZUxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMud3JpdGVyLmdldFBvcygpO1xuICAgICAgICAgICAgdGhpcy53cml0ZXIud3JpdGUodGhpcy5oZWFkZXIpO1xuICAgICAgICAgICAgdGhpcy53cml0ZXIud3JpdGUocGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybWF0Ll9vcHRpb25zLm9uRnJhbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcmFtZUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZnJhbWVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZyYW1lQnl0ZXMuc2V0KHRoaXMuaGVhZGVyLCAwKTtcbiAgICAgICAgICAgICAgICBmcmFtZUJ5dGVzLnNldChwYWNrZXQuZGF0YSwgdGhpcy5oZWFkZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtYXQuX29wdGlvbnMub25GcmFtZShmcmFtZUJ5dGVzLCBzdGFydFBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGFkZFN1YnRpdGxlQ3VlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FEVFMgZG9lcyBub3Qgc3VwcG9ydCBzdWJ0aXRsZXMuJyk7XG4gICAgfVxuICAgIGFzeW5jIGZpbmFsaXplKCkgeyB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/adts/adts-muxer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/codec-data.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/codec-data.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AvcNalUnitType: () => (/* binding */ AvcNalUnitType),\n/* harmony export */   HevcNalUnitType: () => (/* binding */ HevcNalUnitType),\n/* harmony export */   determineVideoPacketType: () => (/* binding */ determineVideoPacketType),\n/* harmony export */   extractAv1CodecInfoFromPacket: () => (/* binding */ extractAv1CodecInfoFromPacket),\n/* harmony export */   extractAvcDecoderConfigurationRecord: () => (/* binding */ extractAvcDecoderConfigurationRecord),\n/* harmony export */   extractAvcNalUnits: () => (/* binding */ extractAvcNalUnits),\n/* harmony export */   extractHevcDecoderConfigurationRecord: () => (/* binding */ extractHevcDecoderConfigurationRecord),\n/* harmony export */   extractHevcNalUnits: () => (/* binding */ extractHevcNalUnits),\n/* harmony export */   extractNalUnitTypeForHevc: () => (/* binding */ extractNalUnitTypeForHevc),\n/* harmony export */   extractVp9CodecInfoFromPacket: () => (/* binding */ extractVp9CodecInfoFromPacket),\n/* harmony export */   findNalUnitsInAnnexB: () => (/* binding */ findNalUnitsInAnnexB),\n/* harmony export */   iterateAv1PacketObus: () => (/* binding */ iterateAv1PacketObus),\n/* harmony export */   parseModesFromVorbisSetupPacket: () => (/* binding */ parseModesFromVorbisSetupPacket),\n/* harmony export */   parseOpusIdentificationHeader: () => (/* binding */ parseOpusIdentificationHeader),\n/* harmony export */   parseOpusTocByte: () => (/* binding */ parseOpusTocByte),\n/* harmony export */   serializeAvcDecoderConfigurationRecord: () => (/* binding */ serializeAvcDecoderConfigurationRecord),\n/* harmony export */   serializeHevcDecoderConfigurationRecord: () => (/* binding */ serializeHevcDecoderConfigurationRecord),\n/* harmony export */   transformAnnexBToLengthPrefixed: () => (/* binding */ transformAnnexBToLengthPrefixed)\n/* harmony export */ });\n/* harmony import */ var _codec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./codec.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n// References for AVC/HEVC code:\n// ISO 14496-15\n// Rec. ITU-T H.264\n// Rec. ITU-T H.265\n// https://stackoverflow.com/questions/24884827\nvar AvcNalUnitType;\n(function (AvcNalUnitType) {\n    AvcNalUnitType[AvcNalUnitType[\"IDR\"] = 5] = \"IDR\";\n    AvcNalUnitType[AvcNalUnitType[\"SPS\"] = 7] = \"SPS\";\n    AvcNalUnitType[AvcNalUnitType[\"PPS\"] = 8] = \"PPS\";\n    AvcNalUnitType[AvcNalUnitType[\"SPS_EXT\"] = 13] = \"SPS_EXT\";\n})(AvcNalUnitType || (AvcNalUnitType = {}));\nvar HevcNalUnitType;\n(function (HevcNalUnitType) {\n    HevcNalUnitType[HevcNalUnitType[\"RASL_N\"] = 8] = \"RASL_N\";\n    HevcNalUnitType[HevcNalUnitType[\"RASL_R\"] = 9] = \"RASL_R\";\n    HevcNalUnitType[HevcNalUnitType[\"BLA_W_LP\"] = 16] = \"BLA_W_LP\";\n    HevcNalUnitType[HevcNalUnitType[\"RSV_IRAP_VCL23\"] = 23] = \"RSV_IRAP_VCL23\";\n    HevcNalUnitType[HevcNalUnitType[\"VPS_NUT\"] = 32] = \"VPS_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"SPS_NUT\"] = 33] = \"SPS_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"PPS_NUT\"] = 34] = \"PPS_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"PREFIX_SEI_NUT\"] = 39] = \"PREFIX_SEI_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"SUFFIX_SEI_NUT\"] = 40] = \"SUFFIX_SEI_NUT\";\n})(HevcNalUnitType || (HevcNalUnitType = {}));\n/** Finds all NAL units in an AVC packet in Annex B format. */\nconst findNalUnitsInAnnexB = (packetData) => {\n    const nalUnits = [];\n    let i = 0;\n    while (i < packetData.length) {\n        let startCodePos = -1;\n        let startCodeLength = 0;\n        for (let j = i; j < packetData.length - 3; j++) {\n            // Check for 3-byte start code (0x000001)\n            if (packetData[j] === 0 && packetData[j + 1] === 0 && packetData[j + 2] === 1) {\n                startCodePos = j;\n                startCodeLength = 3;\n                break;\n            }\n            // Check for 4-byte start code (0x00000001)\n            if (j < packetData.length - 4\n                && packetData[j] === 0\n                && packetData[j + 1] === 0\n                && packetData[j + 2] === 0\n                && packetData[j + 3] === 1) {\n                startCodePos = j;\n                startCodeLength = 4;\n                break;\n            }\n        }\n        if (startCodePos === -1) {\n            break; // No more start codes found\n        }\n        // If this isn't the first start code, extract the previous NAL unit\n        if (i > 0 && startCodePos > i) {\n            const nalData = packetData.subarray(i, startCodePos);\n            if (nalData.length > 0) {\n                nalUnits.push(nalData);\n            }\n        }\n        i = startCodePos + startCodeLength;\n    }\n    // Extract the last NAL unit if there is one\n    if (i < packetData.length) {\n        const nalData = packetData.subarray(i);\n        if (nalData.length > 0) {\n            nalUnits.push(nalData);\n        }\n    }\n    return nalUnits;\n};\n/** Finds all NAL units in an AVC packet in length-prefixed format. */\nconst findNalUnitsInLengthPrefixed = (packetData, lengthSize) => {\n    const nalUnits = [];\n    let offset = 0;\n    const dataView = new DataView(packetData.buffer, packetData.byteOffset, packetData.byteLength);\n    while (offset + lengthSize <= packetData.length) {\n        let nalUnitLength;\n        if (lengthSize === 1) {\n            nalUnitLength = dataView.getUint8(offset);\n        }\n        else if (lengthSize === 2) {\n            nalUnitLength = dataView.getUint16(offset, false);\n        }\n        else if (lengthSize === 3) {\n            nalUnitLength = (dataView.getUint16(offset, false) << 8) + dataView.getUint8(offset + 2);\n        }\n        else if (lengthSize === 4) {\n            nalUnitLength = dataView.getUint32(offset, false);\n        }\n        else {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assertNever)(lengthSize);\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false);\n        }\n        offset += lengthSize;\n        const nalUnit = packetData.subarray(offset, offset + nalUnitLength);\n        nalUnits.push(nalUnit);\n        offset += nalUnitLength;\n    }\n    return nalUnits;\n};\nconst removeEmulationPreventionBytes = (data) => {\n    const result = [];\n    const len = data.length;\n    for (let i = 0; i < len; i++) {\n        // Look for the 0x000003 pattern\n        if (i + 2 < len && data[i] === 0x00 && data[i + 1] === 0x00 && data[i + 2] === 0x03) {\n            result.push(0x00, 0x00); // Push the first two bytes\n            i += 2; // Skip the 0x03 byte\n        }\n        else {\n            result.push(data[i]);\n        }\n    }\n    return new Uint8Array(result);\n};\n/** Converts an AVC packet in Annex B format to length-prefixed format. */\nconst transformAnnexBToLengthPrefixed = (packetData) => {\n    const NAL_UNIT_LENGTH_SIZE = 4;\n    const nalUnits = findNalUnitsInAnnexB(packetData);\n    if (nalUnits.length === 0) {\n        // If no NAL units were found, it's not valid Annex B data\n        return null;\n    }\n    let totalSize = 0;\n    for (const nalUnit of nalUnits) {\n        totalSize += NAL_UNIT_LENGTH_SIZE + nalUnit.byteLength;\n    }\n    const avccData = new Uint8Array(totalSize);\n    const dataView = new DataView(avccData.buffer);\n    let offset = 0;\n    // Write each NAL unit with its length prefix\n    for (const nalUnit of nalUnits) {\n        const length = nalUnit.byteLength;\n        dataView.setUint32(offset, length, false);\n        offset += 4;\n        avccData.set(nalUnit, offset);\n        offset += nalUnit.byteLength;\n    }\n    return avccData;\n};\nconst extractAvcNalUnits = (packetData, decoderConfig) => {\n    if (decoderConfig.description) {\n        // Stream is length-prefixed. Let's extract the size of the length prefix from the decoder config\n        const bytes = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.toUint8Array)(decoderConfig.description);\n        const lengthSizeMinusOne = bytes[4] & 0b11;\n        const lengthSize = (lengthSizeMinusOne + 1);\n        return findNalUnitsInLengthPrefixed(packetData, lengthSize);\n    }\n    else {\n        // Stream is in Annex B format\n        return findNalUnitsInAnnexB(packetData);\n    }\n};\nconst extractNalUnitTypeForAvc = (data) => {\n    return data[0] & 0x1F;\n};\n/** Builds an AvcDecoderConfigurationRecord from an AVC packet in Annex B format. */\nconst extractAvcDecoderConfigurationRecord = (packetData) => {\n    try {\n        const nalUnits = findNalUnitsInAnnexB(packetData);\n        const spsUnits = nalUnits.filter(unit => extractNalUnitTypeForAvc(unit) === AvcNalUnitType.SPS);\n        const ppsUnits = nalUnits.filter(unit => extractNalUnitTypeForAvc(unit) === AvcNalUnitType.PPS);\n        const spsExtUnits = nalUnits.filter(unit => extractNalUnitTypeForAvc(unit) === AvcNalUnitType.SPS_EXT);\n        if (spsUnits.length === 0) {\n            return null;\n        }\n        if (ppsUnits.length === 0) {\n            return null;\n        }\n        // Let's get the first SPS for profile and level information\n        const spsData = spsUnits[0];\n        const bitstream = new _misc_js__WEBPACK_IMPORTED_MODULE_0__.Bitstream(removeEmulationPreventionBytes(spsData));\n        bitstream.skipBits(1); // forbidden_zero_bit\n        bitstream.skipBits(2); // nal_ref_idc\n        const nal_unit_type = bitstream.readBits(5);\n        if (nal_unit_type !== 7) { // SPS NAL unit type is 7\n            console.error('Invalid SPS NAL unit type');\n            return null;\n        }\n        const profile_idc = bitstream.readAlignedByte();\n        const constraint_flags = bitstream.readAlignedByte();\n        const level_idc = bitstream.readAlignedByte();\n        const record = {\n            configurationVersion: 1,\n            avcProfileIndication: profile_idc,\n            profileCompatibility: constraint_flags,\n            avcLevelIndication: level_idc,\n            lengthSizeMinusOne: 3, // Typically 4 bytes for length field\n            sequenceParameterSets: spsUnits,\n            pictureParameterSets: ppsUnits,\n            chromaFormat: null,\n            bitDepthLumaMinus8: null,\n            bitDepthChromaMinus8: null,\n            sequenceParameterSetExt: null,\n        };\n        if (profile_idc === 100\n            || profile_idc === 110\n            || profile_idc === 122\n            || profile_idc === 144) {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // seq_parameter_set_id\n            const chroma_format_idc = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream);\n            if (chroma_format_idc === 3) {\n                bitstream.skipBits(1); // separate_colour_plane_flag\n            }\n            const bit_depth_luma_minus8 = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream);\n            const bit_depth_chroma_minus8 = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream);\n            record.chromaFormat = chroma_format_idc;\n            record.bitDepthLumaMinus8 = bit_depth_luma_minus8;\n            record.bitDepthChromaMinus8 = bit_depth_chroma_minus8;\n            record.sequenceParameterSetExt = spsExtUnits;\n        }\n        return record;\n    }\n    catch (error) {\n        console.error('Error building AVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\n/** Serializes an AvcDecoderConfigurationRecord into the format specified in Section 5.3.3.1 of ISO 14496-15. */\nconst serializeAvcDecoderConfigurationRecord = (record) => {\n    const bytes = [];\n    // Write header\n    bytes.push(record.configurationVersion);\n    bytes.push(record.avcProfileIndication);\n    bytes.push(record.profileCompatibility);\n    bytes.push(record.avcLevelIndication);\n    bytes.push(0xFC | (record.lengthSizeMinusOne & 0x03)); // Reserved bits (6) + lengthSizeMinusOne (2)\n    // Reserved bits (3) + numOfSequenceParameterSets (5)\n    bytes.push(0xE0 | (record.sequenceParameterSets.length & 0x1F));\n    // Write SPS\n    for (const sps of record.sequenceParameterSets) {\n        const length = sps.byteLength;\n        bytes.push(length >> 8); // High byte\n        bytes.push(length & 0xFF); // Low byte\n        for (let i = 0; i < length; i++) {\n            bytes.push(sps[i]);\n        }\n    }\n    bytes.push(record.pictureParameterSets.length);\n    // Write PPS\n    for (const pps of record.pictureParameterSets) {\n        const length = pps.byteLength;\n        bytes.push(length >> 8); // High byte\n        bytes.push(length & 0xFF); // Low byte\n        for (let i = 0; i < length; i++) {\n            bytes.push(pps[i]);\n        }\n    }\n    if (record.avcProfileIndication === 100\n        || record.avcProfileIndication === 110\n        || record.avcProfileIndication === 122\n        || record.avcProfileIndication === 144) {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(record.chromaFormat !== null);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(record.bitDepthLumaMinus8 !== null);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(record.bitDepthChromaMinus8 !== null);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(record.sequenceParameterSetExt !== null);\n        bytes.push(0xFC | (record.chromaFormat & 0x03)); // Reserved bits + chroma_format\n        bytes.push(0xF8 | (record.bitDepthLumaMinus8 & 0x07)); // Reserved bits + bit_depth_luma_minus8\n        bytes.push(0xF8 | (record.bitDepthChromaMinus8 & 0x07)); // Reserved bits + bit_depth_chroma_minus8\n        bytes.push(record.sequenceParameterSetExt.length);\n        // Write SPS Ext\n        for (const spsExt of record.sequenceParameterSetExt) {\n            const length = spsExt.byteLength;\n            bytes.push(length >> 8); // High byte\n            bytes.push(length & 0xFF); // Low byte\n            for (let i = 0; i < length; i++) {\n                bytes.push(spsExt[i]);\n            }\n        }\n    }\n    return new Uint8Array(bytes);\n};\nconst extractHevcNalUnits = (packetData, decoderConfig) => {\n    if (decoderConfig.description) {\n        // Stream is length-prefixed. Let's extract the size of the length prefix from the decoder config\n        const bytes = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.toUint8Array)(decoderConfig.description);\n        const lengthSizeMinusOne = bytes[21] & 0b11;\n        const lengthSize = (lengthSizeMinusOne + 1);\n        return findNalUnitsInLengthPrefixed(packetData, lengthSize);\n    }\n    else {\n        // Stream is in Annex B format\n        return findNalUnitsInAnnexB(packetData);\n    }\n};\nconst extractNalUnitTypeForHevc = (data) => {\n    return (data[0] >> 1) & 0x3F;\n};\n/** Builds a HevcDecoderConfigurationRecord from an HEVC packet in Annex B format. */\nconst extractHevcDecoderConfigurationRecord = (packetData) => {\n    try {\n        const nalUnits = findNalUnitsInAnnexB(packetData);\n        const vpsUnits = nalUnits.filter(unit => extractNalUnitTypeForHevc(unit) === HevcNalUnitType.VPS_NUT);\n        const spsUnits = nalUnits.filter(unit => extractNalUnitTypeForHevc(unit) === HevcNalUnitType.SPS_NUT);\n        const ppsUnits = nalUnits.filter(unit => extractNalUnitTypeForHevc(unit) === HevcNalUnitType.PPS_NUT);\n        const seiUnits = nalUnits.filter(unit => extractNalUnitTypeForHevc(unit) === HevcNalUnitType.PREFIX_SEI_NUT\n            || extractNalUnitTypeForHevc(unit) === HevcNalUnitType.SUFFIX_SEI_NUT);\n        if (spsUnits.length === 0 || ppsUnits.length === 0)\n            return null;\n        const sps = spsUnits[0];\n        const bitstream = new _misc_js__WEBPACK_IMPORTED_MODULE_0__.Bitstream(removeEmulationPreventionBytes(sps));\n        bitstream.skipBits(16); // NAL header\n        bitstream.readBits(4); // sps_video_parameter_set_id\n        const sps_max_sub_layers_minus1 = bitstream.readBits(3);\n        const sps_temporal_id_nesting_flag = bitstream.readBits(1);\n        const { general_profile_space, general_tier_flag, general_profile_idc, general_profile_compatibility_flags, general_constraint_indicator_flags, general_level_idc, } = parseProfileTierLevel(bitstream, sps_max_sub_layers_minus1);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // sps_seq_parameter_set_id\n        const chroma_format_idc = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream);\n        if (chroma_format_idc === 3)\n            bitstream.skipBits(1); // separate_colour_plane_flag\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // pic_width_in_luma_samples\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // pic_height_in_luma_samples\n        if (bitstream.readBits(1)) { // conformance_window_flag\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // conf_win_left_offset\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // conf_win_right_offset\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // conf_win_top_offset\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // conf_win_bottom_offset\n        }\n        const bit_depth_luma_minus8 = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream);\n        const bit_depth_chroma_minus8 = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // log2_max_pic_order_cnt_lsb_minus4\n        const sps_sub_layer_ordering_info_present_flag = bitstream.readBits(1);\n        const maxNum = sps_sub_layer_ordering_info_present_flag ? 0 : sps_max_sub_layers_minus1;\n        for (let i = maxNum; i <= sps_max_sub_layers_minus1; i++) {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // sps_max_dec_pic_buffering_minus1[i]\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // sps_max_num_reorder_pics[i]\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // sps_max_latency_increase_plus1[i]\n        }\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // log2_min_luma_coding_block_size_minus3\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // log2_diff_max_min_luma_coding_block_size\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // log2_min_luma_transform_block_size_minus2\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // log2_diff_max_min_luma_transform_block_size\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // max_transform_hierarchy_depth_inter\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // max_transform_hierarchy_depth_intra\n        if (bitstream.readBits(1)) { // scaling_list_enabled_flag\n            if (bitstream.readBits(1)) {\n                skipScalingListData(bitstream);\n            }\n        }\n        bitstream.skipBits(1); // amp_enabled_flag\n        bitstream.skipBits(1); // sample_adaptive_offset_enabled_flag\n        if (bitstream.readBits(1)) { // pcm_enabled_flag\n            bitstream.skipBits(4); // pcm_sample_bit_depth_luma_minus1\n            bitstream.skipBits(4); // pcm_sample_bit_depth_chroma_minus1\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // log2_min_pcm_luma_coding_block_size_minus3\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // log2_diff_max_min_pcm_luma_coding_block_size\n            bitstream.skipBits(1); // pcm_loop_filter_disabled_flag\n        }\n        const num_short_term_ref_pic_sets = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream);\n        skipAllStRefPicSets(bitstream, num_short_term_ref_pic_sets);\n        if (bitstream.readBits(1)) { // long_term_ref_pics_present_flag\n            const num_long_term_ref_pics_sps = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream);\n            for (let i = 0; i < num_long_term_ref_pics_sps; i++) {\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // lt_ref_pic_poc_lsb_sps[i]\n                bitstream.skipBits(1); // used_by_curr_pic_lt_sps_flag[i]\n            }\n        }\n        bitstream.skipBits(1); // sps_temporal_mvp_enabled_flag\n        bitstream.skipBits(1); // strong_intra_smoothing_enabled_flag\n        let min_spatial_segmentation_idc = 0;\n        if (bitstream.readBits(1)) { // vui_parameters_present_flag\n            min_spatial_segmentation_idc = parseVuiForMinSpatialSegmentationIdc(bitstream, sps_max_sub_layers_minus1);\n        }\n        // Parse PPS for parallelismType\n        let parallelismType = 0;\n        if (ppsUnits.length > 0) {\n            const pps = ppsUnits[0];\n            const ppsBitstream = new _misc_js__WEBPACK_IMPORTED_MODULE_0__.Bitstream(removeEmulationPreventionBytes(pps));\n            ppsBitstream.skipBits(16); // NAL header\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(ppsBitstream); // pps_pic_parameter_set_id\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(ppsBitstream); // pps_seq_parameter_set_id\n            ppsBitstream.skipBits(1); // dependent_slice_segments_enabled_flag\n            ppsBitstream.skipBits(1); // output_flag_present_flag\n            ppsBitstream.skipBits(3); // num_extra_slice_header_bits\n            ppsBitstream.skipBits(1); // sign_data_hiding_enabled_flag\n            ppsBitstream.skipBits(1); // cabac_init_present_flag\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(ppsBitstream); // num_ref_idx_l0_default_active_minus1\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(ppsBitstream); // num_ref_idx_l1_default_active_minus1\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readSignedExpGolomb)(ppsBitstream); // init_qp_minus26\n            ppsBitstream.skipBits(1); // constrained_intra_pred_flag\n            ppsBitstream.skipBits(1); // transform_skip_enabled_flag\n            if (ppsBitstream.readBits(1)) { // cu_qp_delta_enabled_flag\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(ppsBitstream); // diff_cu_qp_delta_depth\n            }\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readSignedExpGolomb)(ppsBitstream); // pps_cb_qp_offset\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readSignedExpGolomb)(ppsBitstream); // pps_cr_qp_offset\n            ppsBitstream.skipBits(1); // pps_slice_chroma_qp_offsets_present_flag\n            ppsBitstream.skipBits(1); // weighted_pred_flag\n            ppsBitstream.skipBits(1); // weighted_bipred_flag\n            ppsBitstream.skipBits(1); // transquant_bypass_enabled_flag\n            const tiles_enabled_flag = ppsBitstream.readBits(1);\n            const entropy_coding_sync_enabled_flag = ppsBitstream.readBits(1);\n            if (!tiles_enabled_flag && !entropy_coding_sync_enabled_flag)\n                parallelismType = 0;\n            else if (tiles_enabled_flag && !entropy_coding_sync_enabled_flag)\n                parallelismType = 2;\n            else if (!tiles_enabled_flag && entropy_coding_sync_enabled_flag)\n                parallelismType = 3;\n            else\n                parallelismType = 0;\n        }\n        const arrays = [\n            ...(vpsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: HevcNalUnitType.VPS_NUT,\n                        nalUnits: vpsUnits,\n                    },\n                ]\n                : []),\n            ...(spsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: HevcNalUnitType.SPS_NUT,\n                        nalUnits: spsUnits,\n                    },\n                ]\n                : []),\n            ...(ppsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: HevcNalUnitType.PPS_NUT,\n                        nalUnits: ppsUnits,\n                    },\n                ]\n                : []),\n            ...(seiUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: extractNalUnitTypeForHevc(seiUnits[0]),\n                        nalUnits: seiUnits,\n                    },\n                ]\n                : []),\n        ];\n        const record = {\n            configurationVersion: 1,\n            generalProfileSpace: general_profile_space,\n            generalTierFlag: general_tier_flag,\n            generalProfileIdc: general_profile_idc,\n            generalProfileCompatibilityFlags: general_profile_compatibility_flags,\n            generalConstraintIndicatorFlags: general_constraint_indicator_flags,\n            generalLevelIdc: general_level_idc,\n            minSpatialSegmentationIdc: min_spatial_segmentation_idc,\n            parallelismType,\n            chromaFormatIdc: chroma_format_idc,\n            bitDepthLumaMinus8: bit_depth_luma_minus8,\n            bitDepthChromaMinus8: bit_depth_chroma_minus8,\n            avgFrameRate: 0,\n            constantFrameRate: 0,\n            numTemporalLayers: sps_max_sub_layers_minus1 + 1,\n            temporalIdNested: sps_temporal_id_nesting_flag,\n            lengthSizeMinusOne: 3,\n            arrays,\n        };\n        return record;\n    }\n    catch (error) {\n        console.error('Error building HEVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\nconst parseProfileTierLevel = (bitstream, maxNumSubLayersMinus1) => {\n    const general_profile_space = bitstream.readBits(2);\n    const general_tier_flag = bitstream.readBits(1);\n    const general_profile_idc = bitstream.readBits(5);\n    let general_profile_compatibility_flags = 0;\n    for (let i = 0; i < 32; i++) {\n        general_profile_compatibility_flags = (general_profile_compatibility_flags << 1) | bitstream.readBits(1);\n    }\n    const general_constraint_indicator_flags = new Uint8Array(6);\n    for (let i = 0; i < 6; i++) {\n        general_constraint_indicator_flags[i] = bitstream.readBits(8);\n    }\n    const general_level_idc = bitstream.readBits(8);\n    const sub_layer_profile_present_flag = [];\n    const sub_layer_level_present_flag = [];\n    for (let i = 0; i < maxNumSubLayersMinus1; i++) {\n        sub_layer_profile_present_flag.push(bitstream.readBits(1));\n        sub_layer_level_present_flag.push(bitstream.readBits(1));\n    }\n    if (maxNumSubLayersMinus1 > 0) {\n        for (let i = maxNumSubLayersMinus1; i < 8; i++) {\n            bitstream.skipBits(2); // reserved_zero_2bits\n        }\n    }\n    for (let i = 0; i < maxNumSubLayersMinus1; i++) {\n        if (sub_layer_profile_present_flag[i])\n            bitstream.skipBits(88);\n        if (sub_layer_level_present_flag[i])\n            bitstream.skipBits(8);\n    }\n    return {\n        general_profile_space,\n        general_tier_flag,\n        general_profile_idc,\n        general_profile_compatibility_flags,\n        general_constraint_indicator_flags,\n        general_level_idc,\n    };\n};\nconst skipScalingListData = (bitstream) => {\n    for (let sizeId = 0; sizeId < 4; sizeId++) {\n        for (let matrixId = 0; matrixId < (sizeId === 3 ? 2 : 6); matrixId++) {\n            const scaling_list_pred_mode_flag = bitstream.readBits(1);\n            if (!scaling_list_pred_mode_flag) {\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // scaling_list_pred_matrix_id_delta\n            }\n            else {\n                const coefNum = Math.min(64, 1 << (4 + (sizeId << 1)));\n                if (sizeId > 1) {\n                    (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readSignedExpGolomb)(bitstream); // scaling_list_dc_coef_minus8\n                }\n                for (let i = 0; i < coefNum; i++) {\n                    (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readSignedExpGolomb)(bitstream); // scaling_list_delta_coef\n                }\n            }\n        }\n    }\n};\nconst skipAllStRefPicSets = (bitstream, num_short_term_ref_pic_sets) => {\n    const NumDeltaPocs = [];\n    for (let stRpsIdx = 0; stRpsIdx < num_short_term_ref_pic_sets; stRpsIdx++) {\n        NumDeltaPocs[stRpsIdx] = skipStRefPicSet(bitstream, stRpsIdx, num_short_term_ref_pic_sets, NumDeltaPocs);\n    }\n};\nconst skipStRefPicSet = (bitstream, stRpsIdx, num_short_term_ref_pic_sets, NumDeltaPocs) => {\n    let NumDeltaPocsThis = 0;\n    let inter_ref_pic_set_prediction_flag = 0;\n    let RefRpsIdx = 0;\n    if (stRpsIdx !== 0) {\n        inter_ref_pic_set_prediction_flag = bitstream.readBits(1);\n    }\n    if (inter_ref_pic_set_prediction_flag) {\n        if (stRpsIdx === num_short_term_ref_pic_sets) {\n            const delta_idx_minus1 = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream);\n            RefRpsIdx = stRpsIdx - (delta_idx_minus1 + 1);\n        }\n        else {\n            RefRpsIdx = stRpsIdx - 1;\n        }\n        bitstream.readBits(1); // delta_rps_sign\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // abs_delta_rps_minus1\n        // The number of iterations is NumDeltaPocs[RefRpsIdx] + 1\n        const numDelta = NumDeltaPocs[RefRpsIdx] ?? 0;\n        for (let j = 0; j <= numDelta; j++) {\n            const used_by_curr_pic_flag = bitstream.readBits(1);\n            if (!used_by_curr_pic_flag) {\n                bitstream.readBits(1); // use_delta_flag\n            }\n        }\n        NumDeltaPocsThis = NumDeltaPocs[RefRpsIdx];\n    }\n    else {\n        const num_negative_pics = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream);\n        const num_positive_pics = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream);\n        for (let i = 0; i < num_negative_pics; i++) {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // delta_poc_s0_minus1[i]\n            bitstream.readBits(1); // used_by_curr_pic_s0_flag[i]\n        }\n        for (let i = 0; i < num_positive_pics; i++) {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // delta_poc_s1_minus1[i]\n            bitstream.readBits(1); // used_by_curr_pic_s1_flag[i]\n        }\n        NumDeltaPocsThis = num_negative_pics + num_positive_pics;\n    }\n    return NumDeltaPocsThis;\n};\nconst parseVuiForMinSpatialSegmentationIdc = (bitstream, sps_max_sub_layers_minus1) => {\n    if (bitstream.readBits(1)) { // aspect_ratio_info_present_flag\n        const aspect_ratio_idc = bitstream.readBits(8);\n        if (aspect_ratio_idc === 255) {\n            bitstream.readBits(16); // sar_width\n            bitstream.readBits(16); // sar_height\n        }\n    }\n    if (bitstream.readBits(1)) { // overscan_info_present_flag\n        bitstream.readBits(1); // overscan_appropriate_flag\n    }\n    if (bitstream.readBits(1)) { // video_signal_type_present_flag\n        bitstream.readBits(3); // video_format\n        bitstream.readBits(1); // video_full_range_flag\n        if (bitstream.readBits(1)) {\n            bitstream.readBits(8); // colour_primaries\n            bitstream.readBits(8); // transfer_characteristics\n            bitstream.readBits(8); // matrix_coeffs\n        }\n    }\n    if (bitstream.readBits(1)) { // chroma_loc_info_present_flag\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // chroma_sample_loc_type_top_field\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // chroma_sample_loc_type_bottom_field\n    }\n    bitstream.readBits(1); // neutral_chroma_indication_flag\n    bitstream.readBits(1); // field_seq_flag\n    bitstream.readBits(1); // frame_field_info_present_flag\n    if (bitstream.readBits(1)) { // default_display_window_flag\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // def_disp_win_left_offset\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // def_disp_win_right_offset\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // def_disp_win_top_offset\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // def_disp_win_bottom_offset\n    }\n    if (bitstream.readBits(1)) { // vui_timing_info_present_flag\n        bitstream.readBits(32); // vui_num_units_in_tick\n        bitstream.readBits(32); // vui_time_scale\n        if (bitstream.readBits(1)) { // vui_poc_proportional_to_timing_flag\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // vui_num_ticks_poc_diff_one_minus1\n        }\n        if (bitstream.readBits(1)) {\n            skipHrdParameters(bitstream, true, sps_max_sub_layers_minus1);\n        }\n    }\n    if (bitstream.readBits(1)) { // bitstream_restriction_flag\n        bitstream.readBits(1); // tiles_fixed_structure_flag\n        bitstream.readBits(1); // motion_vectors_over_pic_boundaries_flag\n        bitstream.readBits(1); // restricted_ref_pic_lists_flag\n        const min_spatial_segmentation_idc = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream);\n        // skip the rest\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // max_bytes_per_pic_denom\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // max_bits_per_min_cu_denom\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // log2_max_mv_length_horizontal\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // log2_max_mv_length_vertical\n        return min_spatial_segmentation_idc;\n    }\n    return 0;\n};\nconst skipHrdParameters = (bitstream, commonInfPresentFlag, maxNumSubLayersMinus1) => {\n    let nal_hrd_parameters_present_flag = false;\n    let vcl_hrd_parameters_present_flag = false;\n    let sub_pic_hrd_params_present_flag = false;\n    if (commonInfPresentFlag) {\n        nal_hrd_parameters_present_flag = bitstream.readBits(1) === 1;\n        vcl_hrd_parameters_present_flag = bitstream.readBits(1) === 1;\n        if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {\n            sub_pic_hrd_params_present_flag = bitstream.readBits(1) === 1;\n            if (sub_pic_hrd_params_present_flag) {\n                bitstream.readBits(8); // tick_divisor_minus2\n                bitstream.readBits(5); // du_cpb_removal_delay_increment_length_minus1\n                bitstream.readBits(1); // sub_pic_cpb_params_in_pic_timing_sei_flag\n                bitstream.readBits(5); // dpb_output_delay_du_length_minus1\n            }\n            bitstream.readBits(4); // bit_rate_scale\n            bitstream.readBits(4); // cpb_size_scale\n            if (sub_pic_hrd_params_present_flag) {\n                bitstream.readBits(4); // cpb_size_du_scale\n            }\n            bitstream.readBits(5); // initial_cpb_removal_delay_length_minus1\n            bitstream.readBits(5); // au_cpb_removal_delay_length_minus1\n            bitstream.readBits(5); // dpb_output_delay_length_minus1\n        }\n    }\n    for (let i = 0; i <= maxNumSubLayersMinus1; i++) {\n        const fixed_pic_rate_general_flag = bitstream.readBits(1) === 1;\n        let fixed_pic_rate_within_cvs_flag = true; // Default assumption if general is true\n        if (!fixed_pic_rate_general_flag) {\n            fixed_pic_rate_within_cvs_flag = bitstream.readBits(1) === 1;\n        }\n        let low_delay_hrd_flag = false; // Default assumption\n        if (fixed_pic_rate_within_cvs_flag) {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // elemental_duration_in_tc_minus1[i]\n        }\n        else {\n            low_delay_hrd_flag = bitstream.readBits(1) === 1;\n        }\n        let CpbCnt = 1; // Default if low_delay is true\n        if (!low_delay_hrd_flag) {\n            const cpb_cnt_minus1 = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // cpb_cnt_minus1[i]\n            CpbCnt = cpb_cnt_minus1 + 1;\n        }\n        if (nal_hrd_parameters_present_flag) {\n            skipSubLayerHrdParameters(bitstream, CpbCnt, sub_pic_hrd_params_present_flag);\n        }\n        if (vcl_hrd_parameters_present_flag) {\n            skipSubLayerHrdParameters(bitstream, CpbCnt, sub_pic_hrd_params_present_flag);\n        }\n    }\n};\nconst skipSubLayerHrdParameters = (bitstream, CpbCnt, sub_pic_hrd_params_present_flag) => {\n    for (let i = 0; i < CpbCnt; i++) {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // bit_rate_value_minus1[i]\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // cpb_size_value_minus1[i]\n        if (sub_pic_hrd_params_present_flag) {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // cpb_size_du_value_minus1[i]\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.readExpGolomb)(bitstream); // bit_rate_du_value_minus1[i]\n        }\n        bitstream.readBits(1); // cbr_flag[i]\n    }\n};\n/** Serializes an HevcDecoderConfigurationRecord into the format specified in Section 8.3.3.1 of ISO 14496-15. */\nconst serializeHevcDecoderConfigurationRecord = (record) => {\n    const bytes = [];\n    bytes.push(record.configurationVersion);\n    bytes.push(((record.generalProfileSpace & 0x3) << 6)\n        | ((record.generalTierFlag & 0x1) << 5)\n        | (record.generalProfileIdc & 0x1F));\n    bytes.push((record.generalProfileCompatibilityFlags >>> 24) & 0xFF);\n    bytes.push((record.generalProfileCompatibilityFlags >>> 16) & 0xFF);\n    bytes.push((record.generalProfileCompatibilityFlags >>> 8) & 0xFF);\n    bytes.push(record.generalProfileCompatibilityFlags & 0xFF);\n    bytes.push(...record.generalConstraintIndicatorFlags);\n    bytes.push(record.generalLevelIdc & 0xFF);\n    bytes.push(0xF0 | ((record.minSpatialSegmentationIdc >> 8) & 0x0F)); // Reserved + high nibble\n    bytes.push(record.minSpatialSegmentationIdc & 0xFF); // Low byte\n    bytes.push(0xFC | (record.parallelismType & 0x03));\n    bytes.push(0xFC | (record.chromaFormatIdc & 0x03));\n    bytes.push(0xF8 | (record.bitDepthLumaMinus8 & 0x07));\n    bytes.push(0xF8 | (record.bitDepthChromaMinus8 & 0x07));\n    bytes.push((record.avgFrameRate >> 8) & 0xFF); // High byte\n    bytes.push(record.avgFrameRate & 0xFF); // Low byte\n    bytes.push(((record.constantFrameRate & 0x03) << 6)\n        | ((record.numTemporalLayers & 0x07) << 3)\n        | ((record.temporalIdNested & 0x01) << 2)\n        | (record.lengthSizeMinusOne & 0x03));\n    bytes.push(record.arrays.length & 0xFF);\n    for (const arr of record.arrays) {\n        bytes.push(((arr.arrayCompleteness & 0x01) << 7)\n            | (0 << 6)\n            | (arr.nalUnitType & 0x3F));\n        bytes.push((arr.nalUnits.length >> 8) & 0xFF); // High byte\n        bytes.push(arr.nalUnits.length & 0xFF); // Low byte\n        for (const nal of arr.nalUnits) {\n            bytes.push((nal.length >> 8) & 0xFF); // High byte\n            bytes.push(nal.length & 0xFF); // Low byte\n            for (let i = 0; i < nal.length; i++) {\n                bytes.push(nal[i]);\n            }\n        }\n    }\n    return new Uint8Array(bytes);\n};\nconst extractVp9CodecInfoFromPacket = (packet) => {\n    // eslint-disable-next-line @stylistic/max-len\n    // https://storage.googleapis.com/downloads.webmproject.org/docs/vp9/vp9-bitstream-specification-v0.7-20170222-draft.pdf\n    // http://downloads.webmproject.org/docs/vp9/vp9-bitstream_superframe-and-uncompressed-header_v1.0.pdf\n    const bitstream = new _misc_js__WEBPACK_IMPORTED_MODULE_0__.Bitstream(packet);\n    // Frame marker (0b10)\n    const frameMarker = bitstream.readBits(2);\n    if (frameMarker !== 2) {\n        return null;\n    }\n    // Profile\n    const profileLowBit = bitstream.readBits(1);\n    const profileHighBit = bitstream.readBits(1);\n    const profile = (profileHighBit << 1) + profileLowBit;\n    // Skip reserved bit for profile 3\n    if (profile === 3) {\n        bitstream.skipBits(1);\n    }\n    // show_existing_frame\n    const showExistingFrame = bitstream.readBits(1);\n    if (showExistingFrame === 1) {\n        return null;\n    }\n    // frame_type (0 = key frame)\n    const frameType = bitstream.readBits(1);\n    if (frameType !== 0) {\n        return null;\n    }\n    // Skip show_frame and error_resilient_mode\n    bitstream.skipBits(2);\n    // Sync code (0x498342)\n    const syncCode = bitstream.readBits(24);\n    if (syncCode !== 0x498342) {\n        return null;\n    }\n    // Color config\n    let bitDepth = 8;\n    if (profile >= 2) {\n        const tenOrTwelveBit = bitstream.readBits(1);\n        bitDepth = tenOrTwelveBit ? 12 : 10;\n    }\n    // Color space\n    const colorSpace = bitstream.readBits(3);\n    let chromaSubsampling = 0;\n    let videoFullRangeFlag = 0;\n    if (colorSpace !== 7) { // 7 is CS_RGB\n        const colorRange = bitstream.readBits(1);\n        videoFullRangeFlag = colorRange;\n        if (profile === 1 || profile === 3) {\n            const subsamplingX = bitstream.readBits(1);\n            const subsamplingY = bitstream.readBits(1);\n            // 0 = 4:2:0 vertical\n            // 1 = 4:2:0 colocated\n            // 2 = 4:2:2\n            // 3 = 4:4:4\n            chromaSubsampling = !subsamplingX && !subsamplingY\n                ? 3 // 0,0 = 4:4:4\n                : subsamplingX && !subsamplingY\n                    ? 2 // 1,0 = 4:2:2\n                    : 1; // 1,1 = 4:2:0 colocated (default)\n            // Skip reserved bit\n            bitstream.skipBits(1);\n        }\n        else {\n            // For profile 0 and 2, always 4:2:0\n            chromaSubsampling = 1; // Using colocated as default\n        }\n    }\n    else {\n        // RGB is always 4:4:4\n        chromaSubsampling = 3;\n        videoFullRangeFlag = 1;\n    }\n    // Parse frame size\n    const widthMinusOne = bitstream.readBits(16);\n    const heightMinusOne = bitstream.readBits(16);\n    const width = widthMinusOne + 1;\n    const height = heightMinusOne + 1;\n    // Calculate level based on dimensions\n    const pictureSize = width * height;\n    let level = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.last)(_codec_js__WEBPACK_IMPORTED_MODULE_1__.VP9_LEVEL_TABLE).level; // Default to highest level\n    for (const entry of _codec_js__WEBPACK_IMPORTED_MODULE_1__.VP9_LEVEL_TABLE) {\n        if (pictureSize <= entry.maxPictureSize) {\n            level = entry.level;\n            break;\n        }\n    }\n    // Map color_space to standard values\n    const matrixCoefficients = colorSpace === 7\n        ? 0\n        : colorSpace === 2\n            ? 1\n            : colorSpace === 1\n                ? 6\n                : 2;\n    const colourPrimaries = colorSpace === 2\n        ? 1\n        : colorSpace === 1\n            ? 6\n            : 2;\n    const transferCharacteristics = colorSpace === 2\n        ? 1\n        : colorSpace === 1\n            ? 6\n            : 2;\n    return {\n        profile,\n        level,\n        bitDepth,\n        chromaSubsampling,\n        videoFullRangeFlag,\n        colourPrimaries,\n        transferCharacteristics,\n        matrixCoefficients,\n    };\n};\n/** Iterates over all OBUs in an AV1 packet bistream. */\nconst iterateAv1PacketObus = function* (packet) {\n    // https://aomediacodec.github.io/av1-spec/av1-spec.pdf\n    const bitstream = new _misc_js__WEBPACK_IMPORTED_MODULE_0__.Bitstream(packet);\n    const readLeb128 = () => {\n        let value = 0;\n        for (let i = 0; i < 8; i++) {\n            const byte = bitstream.readAlignedByte();\n            value |= ((byte & 0x7f) << (i * 7));\n            if (!(byte & 0x80)) {\n                break;\n            }\n            // Spec requirement\n            if (i === 7 && (byte & 0x80)) {\n                return null;\n            }\n        }\n        // Spec requirement\n        if (value >= 2 ** 32 - 1) {\n            return null;\n        }\n        return value;\n    };\n    while (bitstream.getBitsLeft() >= 8) {\n        // Parse OBU header\n        bitstream.skipBits(1);\n        const obuType = bitstream.readBits(4);\n        const obuExtension = bitstream.readBits(1);\n        const obuHasSizeField = bitstream.readBits(1);\n        bitstream.skipBits(1);\n        // Skip extension header if present\n        if (obuExtension) {\n            bitstream.skipBits(8);\n        }\n        // Read OBU size if present\n        let obuSize;\n        if (obuHasSizeField) {\n            const obuSizeValue = readLeb128();\n            if (obuSizeValue === null)\n                return; // It was invalid\n            obuSize = obuSizeValue;\n        }\n        else {\n            // Calculate remaining bits and convert to bytes, rounding down\n            obuSize = Math.floor(bitstream.getBitsLeft() / 8);\n        }\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(bitstream.pos % 8 === 0);\n        yield {\n            type: obuType,\n            data: packet.subarray(bitstream.pos / 8, bitstream.pos / 8 + obuSize),\n        };\n        // Move to next OBU\n        bitstream.skipBits(obuSize * 8);\n    }\n};\n/**\n * When AV1 codec information is not provided by the container, we can still try to extract the information by digging\n * into the AV1 bitstream.\n */\nconst extractAv1CodecInfoFromPacket = (packet) => {\n    // https://aomediacodec.github.io/av1-spec/av1-spec.pdf\n    for (const { type, data } of iterateAv1PacketObus(packet)) {\n        if (type !== 1) {\n            continue; // 1 == OBU_SEQUENCE_HEADER\n        }\n        const bitstream = new _misc_js__WEBPACK_IMPORTED_MODULE_0__.Bitstream(data);\n        // Read sequence header fields\n        const seqProfile = bitstream.readBits(3);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const stillPicture = bitstream.readBits(1);\n        const reducedStillPictureHeader = bitstream.readBits(1);\n        let seqLevel = 0;\n        let seqTier = 0;\n        let bufferDelayLengthMinus1 = 0;\n        if (reducedStillPictureHeader) {\n            seqLevel = bitstream.readBits(5);\n        }\n        else {\n            // Parse timing_info_present_flag\n            const timingInfoPresentFlag = bitstream.readBits(1);\n            if (timingInfoPresentFlag) {\n                // Skip timing info (num_units_in_display_tick, time_scale, equal_picture_interval)\n                bitstream.skipBits(32); // num_units_in_display_tick\n                bitstream.skipBits(32); // time_scale\n                const equalPictureInterval = bitstream.readBits(1);\n                if (equalPictureInterval) {\n                    // Skip num_ticks_per_picture_minus_1 (uvlc)\n                    // Since this is variable length, we'd need to implement uvlc reading\n                    // For now, we'll return null as this is rare\n                    return null;\n                }\n            }\n            // Parse decoder_model_info_present_flag\n            const decoderModelInfoPresentFlag = bitstream.readBits(1);\n            if (decoderModelInfoPresentFlag) {\n                // Store buffer_delay_length_minus_1 instead of just skipping\n                bufferDelayLengthMinus1 = bitstream.readBits(5);\n                bitstream.skipBits(32); // num_units_in_decoding_tick\n                bitstream.skipBits(5); // buffer_removal_time_length_minus_1\n                bitstream.skipBits(5); // frame_presentation_time_length_minus_1\n            }\n            // Parse operating_points_cnt_minus_1\n            const operatingPointsCntMinus1 = bitstream.readBits(5);\n            // For each operating point\n            for (let i = 0; i <= operatingPointsCntMinus1; i++) {\n                // operating_point_idc[i]\n                bitstream.skipBits(12);\n                // seq_level_idx[i]\n                const seqLevelIdx = bitstream.readBits(5);\n                if (i === 0) {\n                    seqLevel = seqLevelIdx;\n                }\n                if (seqLevelIdx > 7) {\n                    // seq_tier[i]\n                    const seqTierTemp = bitstream.readBits(1);\n                    if (i === 0) {\n                        seqTier = seqTierTemp;\n                    }\n                }\n                if (decoderModelInfoPresentFlag) {\n                    // decoder_model_present_for_this_op[i]\n                    const decoderModelPresentForThisOp = bitstream.readBits(1);\n                    if (decoderModelPresentForThisOp) {\n                        const n = bufferDelayLengthMinus1 + 1;\n                        bitstream.skipBits(n); // decoder_buffer_delay[op]\n                        bitstream.skipBits(n); // encoder_buffer_delay[op]\n                        bitstream.skipBits(1); // low_delay_mode_flag[op]\n                    }\n                }\n                // initial_display_delay_present_flag\n                const initialDisplayDelayPresentFlag = bitstream.readBits(1);\n                if (initialDisplayDelayPresentFlag) {\n                    // initial_display_delay_minus_1[i]\n                    bitstream.skipBits(4);\n                }\n            }\n        }\n        const highBitdepth = bitstream.readBits(1);\n        let bitDepth = 8;\n        if (seqProfile === 2 && highBitdepth) {\n            const twelveBit = bitstream.readBits(1);\n            bitDepth = twelveBit ? 12 : 10;\n        }\n        else if (seqProfile <= 2) {\n            bitDepth = highBitdepth ? 10 : 8;\n        }\n        let monochrome = 0;\n        if (seqProfile !== 1) {\n            monochrome = bitstream.readBits(1);\n        }\n        let chromaSubsamplingX = 1;\n        let chromaSubsamplingY = 1;\n        let chromaSamplePosition = 0;\n        if (!monochrome) {\n            if (seqProfile === 0) {\n                chromaSubsamplingX = 1;\n                chromaSubsamplingY = 1;\n            }\n            else if (seqProfile === 1) {\n                chromaSubsamplingX = 0;\n                chromaSubsamplingY = 0;\n            }\n            else {\n                if (bitDepth === 12) {\n                    chromaSubsamplingX = bitstream.readBits(1);\n                    if (chromaSubsamplingX) {\n                        chromaSubsamplingY = bitstream.readBits(1);\n                    }\n                }\n            }\n            if (chromaSubsamplingX && chromaSubsamplingY) {\n                chromaSamplePosition = bitstream.readBits(2);\n            }\n        }\n        return {\n            profile: seqProfile,\n            level: seqLevel,\n            tier: seqTier,\n            bitDepth,\n            monochrome,\n            chromaSubsamplingX,\n            chromaSubsamplingY,\n            chromaSamplePosition,\n        };\n    }\n    return null;\n};\nconst parseOpusIdentificationHeader = (bytes) => {\n    const view = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.toDataView)(bytes);\n    const outputChannelCount = view.getUint8(9);\n    const preSkip = view.getUint16(10, true);\n    const inputSampleRate = view.getUint32(12, true);\n    const outputGain = view.getInt16(16, true);\n    const channelMappingFamily = view.getUint8(18);\n    let channelMappingTable = null;\n    if (channelMappingFamily) {\n        channelMappingTable = bytes.subarray(19, 19 + 2 + outputChannelCount);\n    }\n    return {\n        outputChannelCount,\n        preSkip,\n        inputSampleRate,\n        outputGain,\n        channelMappingFamily,\n        channelMappingTable,\n    };\n};\n// From https://datatracker.ietf.org/doc/html/rfc6716, in 48 kHz samples\nconst OPUS_FRAME_DURATION_TABLE = [\n    480, 960, 1920, 2880,\n    480, 960, 1920, 2880,\n    480, 960, 1920, 2880,\n    480, 960,\n    480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n];\nconst parseOpusTocByte = (packet) => {\n    const config = packet[0] >> 3;\n    return {\n        durationInSamples: OPUS_FRAME_DURATION_TABLE[config],\n    };\n};\n// Based on vorbis_parser.c from FFmpeg.\nconst parseModesFromVorbisSetupPacket = (setupHeader) => {\n    // Verify that this is a Setup header.\n    if (setupHeader.length < 7) {\n        throw new Error('Setup header is too short.');\n    }\n    if (setupHeader[0] !== 5) {\n        throw new Error('Wrong packet type in Setup header.');\n    }\n    const signature = String.fromCharCode(...setupHeader.slice(1, 7));\n    if (signature !== 'vorbis') {\n        throw new Error('Invalid packet signature in Setup header.');\n    }\n    // Reverse the entire buffer.\n    const bufSize = setupHeader.length;\n    const revBuffer = new Uint8Array(bufSize);\n    for (let i = 0; i < bufSize; i++) {\n        revBuffer[i] = setupHeader[bufSize - 1 - i];\n    }\n    // Initialize a Bitstream on the reversed buffer.\n    const bitstream = new _misc_js__WEBPACK_IMPORTED_MODULE_0__.Bitstream(revBuffer);\n    // --- Find the framing bit.\n    // In FFmpeg code, we scan until get_bits1() returns 1.\n    let gotFramingBit = 0;\n    while (bitstream.getBitsLeft() > 97) {\n        if (bitstream.readBits(1) === 1) {\n            gotFramingBit = bitstream.pos;\n            break;\n        }\n    }\n    if (gotFramingBit === 0) {\n        throw new Error('Invalid Setup header: framing bit not found.');\n    }\n    // --- Search backwards for a valid mode header.\n    // We try to “guess” the number of modes by reading a fixed pattern.\n    let modeCount = 0;\n    let gotModeHeader = false;\n    let lastModeCount = 0;\n    while (bitstream.getBitsLeft() >= 97) {\n        const tempPos = bitstream.pos;\n        const a = bitstream.readBits(8);\n        const b = bitstream.readBits(16);\n        const c = bitstream.readBits(16);\n        // If a > 63 or b or c nonzero, assume we’ve gone too far.\n        if (a > 63 || b !== 0 || c !== 0) {\n            bitstream.pos = tempPos;\n            break;\n        }\n        bitstream.skipBits(1);\n        modeCount++;\n        if (modeCount > 64) {\n            break;\n        }\n        const bsClone = bitstream.clone();\n        const candidate = bsClone.readBits(6) + 1;\n        if (candidate === modeCount) {\n            gotModeHeader = true;\n            lastModeCount = modeCount;\n        }\n    }\n    if (!gotModeHeader) {\n        throw new Error('Invalid Setup header: mode header not found.');\n    }\n    if (lastModeCount > 63) {\n        throw new Error(`Unsupported mode count: ${lastModeCount}.`);\n    }\n    const finalModeCount = lastModeCount;\n    // --- Reinitialize the bitstream.\n    bitstream.pos = 0;\n    // Skip the bits up to the found framing bit.\n    bitstream.skipBits(gotFramingBit);\n    // --- Now read, for each mode (in reverse order), 40 bits then one bit.\n    // That one bit is the mode blockflag.\n    const modeBlockflags = Array(finalModeCount).fill(0);\n    for (let i = finalModeCount - 1; i >= 0; i--) {\n        bitstream.skipBits(40);\n        modeBlockflags[i] = bitstream.readBits(1);\n    }\n    return { modeBlockflags };\n};\n/** Determines a packet's type (key or delta) by digging into the packet bitstream. */\nconst determineVideoPacketType = async (videoTrack, packet) => {\n    (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(videoTrack.codec);\n    switch (videoTrack.codec) {\n        case 'avc':\n            {\n                const decoderConfig = await videoTrack.getDecoderConfig();\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(decoderConfig);\n                const nalUnits = extractAvcNalUnits(packet.data, decoderConfig);\n                const isKeyframe = nalUnits.some(x => extractNalUnitTypeForAvc(x) === AvcNalUnitType.IDR);\n                return isKeyframe ? 'key' : 'delta';\n            }\n            ;\n        case 'hevc':\n            {\n                const decoderConfig = await videoTrack.getDecoderConfig();\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(decoderConfig);\n                const nalUnits = extractHevcNalUnits(packet.data, decoderConfig);\n                const isKeyframe = nalUnits.some((x) => {\n                    const type = extractNalUnitTypeForHevc(x);\n                    return HevcNalUnitType.BLA_W_LP <= type && type <= HevcNalUnitType.RSV_IRAP_VCL23;\n                });\n                return isKeyframe ? 'key' : 'delta';\n            }\n            ;\n        case 'vp8':\n            {\n                // VP8, once again, by far the easiest to deal with.\n                const frameType = packet.data[0] & 0b1;\n                return frameType === 0 ? 'key' : 'delta';\n            }\n            ;\n        case 'vp9':\n            {\n                const bitstream = new _misc_js__WEBPACK_IMPORTED_MODULE_0__.Bitstream(packet.data);\n                if (bitstream.readBits(2) !== 2) {\n                    return null;\n                }\n                ;\n                const profileLowBit = bitstream.readBits(1);\n                const profileHighBit = bitstream.readBits(1);\n                const profile = (profileHighBit << 1) + profileLowBit;\n                // Skip reserved bit for profile 3\n                if (profile === 3) {\n                    bitstream.skipBits(1);\n                }\n                const showExistingFrame = bitstream.readBits(1);\n                if (showExistingFrame) {\n                    return null;\n                }\n                const frameType = bitstream.readBits(1);\n                return frameType === 0 ? 'key' : 'delta';\n            }\n            ;\n        case 'av1':\n            {\n                let reducedStillPictureHeader = false;\n                for (const { type, data } of iterateAv1PacketObus(packet.data)) {\n                    if (type === 1) { // OBU_SEQUENCE_HEADER\n                        const bitstream = new _misc_js__WEBPACK_IMPORTED_MODULE_0__.Bitstream(data);\n                        bitstream.skipBits(4);\n                        reducedStillPictureHeader = !!bitstream.readBits(1);\n                    }\n                    else if (type === 3 // OBU_FRAME_HEADER\n                        || type === 6 // OBU_FRAME\n                        || type === 7 // OBU_REDUNDANT_FRAME_HEADER\n                    ) {\n                        if (reducedStillPictureHeader) {\n                            return 'key';\n                        }\n                        const bitstream = new _misc_js__WEBPACK_IMPORTED_MODULE_0__.Bitstream(data);\n                        const showExistingFrame = bitstream.readBits(1);\n                        if (showExistingFrame) {\n                            return null;\n                        }\n                        const frameType = bitstream.readBits(2);\n                        return frameType === 0 ? 'key' : 'delta';\n                    }\n                }\n                return null;\n            }\n            ;\n        default:\n            {\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assertNever)(videoTrack.codec);\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false);\n            }\n            ;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL2NvZGVjLWRhdGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2QztBQUNtRjtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDbEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBVztBQUN2QixZQUFZLGdEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LHNDQUFzQztBQUN0Qyw4Q0FBOEMsK0NBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsK0NBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQVc7QUFDM0IsZ0JBQWdCLGdEQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWF0Y2gtY3V0LWdlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9tZWRpYWJ1bm55L2Rpc3QvbW9kdWxlcy9zcmMvY29kZWMtZGF0YS5qcz82NjgwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDI1LXByZXNlbnQsIFZhbmlsYWd5IGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgVlA5X0xFVkVMX1RBQkxFIH0gZnJvbSAnLi9jb2RlYy5qcyc7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydE5ldmVyLCBCaXRzdHJlYW0sIGxhc3QsIHJlYWRFeHBHb2xvbWIsIHJlYWRTaWduZWRFeHBHb2xvbWIsIHRvRGF0YVZpZXcsIHRvVWludDhBcnJheSwgfSBmcm9tICcuL21pc2MuanMnO1xuLy8gUmVmZXJlbmNlcyBmb3IgQVZDL0hFVkMgY29kZTpcbi8vIElTTyAxNDQ5Ni0xNVxuLy8gUmVjLiBJVFUtVCBILjI2NFxuLy8gUmVjLiBJVFUtVCBILjI2NVxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjQ4ODQ4MjdcbmV4cG9ydCB2YXIgQXZjTmFsVW5pdFR5cGU7XG4oZnVuY3Rpb24gKEF2Y05hbFVuaXRUeXBlKSB7XG4gICAgQXZjTmFsVW5pdFR5cGVbQXZjTmFsVW5pdFR5cGVbXCJJRFJcIl0gPSA1XSA9IFwiSURSXCI7XG4gICAgQXZjTmFsVW5pdFR5cGVbQXZjTmFsVW5pdFR5cGVbXCJTUFNcIl0gPSA3XSA9IFwiU1BTXCI7XG4gICAgQXZjTmFsVW5pdFR5cGVbQXZjTmFsVW5pdFR5cGVbXCJQUFNcIl0gPSA4XSA9IFwiUFBTXCI7XG4gICAgQXZjTmFsVW5pdFR5cGVbQXZjTmFsVW5pdFR5cGVbXCJTUFNfRVhUXCJdID0gMTNdID0gXCJTUFNfRVhUXCI7XG59KShBdmNOYWxVbml0VHlwZSB8fCAoQXZjTmFsVW5pdFR5cGUgPSB7fSkpO1xuZXhwb3J0IHZhciBIZXZjTmFsVW5pdFR5cGU7XG4oZnVuY3Rpb24gKEhldmNOYWxVbml0VHlwZSkge1xuICAgIEhldmNOYWxVbml0VHlwZVtIZXZjTmFsVW5pdFR5cGVbXCJSQVNMX05cIl0gPSA4XSA9IFwiUkFTTF9OXCI7XG4gICAgSGV2Y05hbFVuaXRUeXBlW0hldmNOYWxVbml0VHlwZVtcIlJBU0xfUlwiXSA9IDldID0gXCJSQVNMX1JcIjtcbiAgICBIZXZjTmFsVW5pdFR5cGVbSGV2Y05hbFVuaXRUeXBlW1wiQkxBX1dfTFBcIl0gPSAxNl0gPSBcIkJMQV9XX0xQXCI7XG4gICAgSGV2Y05hbFVuaXRUeXBlW0hldmNOYWxVbml0VHlwZVtcIlJTVl9JUkFQX1ZDTDIzXCJdID0gMjNdID0gXCJSU1ZfSVJBUF9WQ0wyM1wiO1xuICAgIEhldmNOYWxVbml0VHlwZVtIZXZjTmFsVW5pdFR5cGVbXCJWUFNfTlVUXCJdID0gMzJdID0gXCJWUFNfTlVUXCI7XG4gICAgSGV2Y05hbFVuaXRUeXBlW0hldmNOYWxVbml0VHlwZVtcIlNQU19OVVRcIl0gPSAzM10gPSBcIlNQU19OVVRcIjtcbiAgICBIZXZjTmFsVW5pdFR5cGVbSGV2Y05hbFVuaXRUeXBlW1wiUFBTX05VVFwiXSA9IDM0XSA9IFwiUFBTX05VVFwiO1xuICAgIEhldmNOYWxVbml0VHlwZVtIZXZjTmFsVW5pdFR5cGVbXCJQUkVGSVhfU0VJX05VVFwiXSA9IDM5XSA9IFwiUFJFRklYX1NFSV9OVVRcIjtcbiAgICBIZXZjTmFsVW5pdFR5cGVbSGV2Y05hbFVuaXRUeXBlW1wiU1VGRklYX1NFSV9OVVRcIl0gPSA0MF0gPSBcIlNVRkZJWF9TRUlfTlVUXCI7XG59KShIZXZjTmFsVW5pdFR5cGUgfHwgKEhldmNOYWxVbml0VHlwZSA9IHt9KSk7XG4vKiogRmluZHMgYWxsIE5BTCB1bml0cyBpbiBhbiBBVkMgcGFja2V0IGluIEFubmV4IEIgZm9ybWF0LiAqL1xuZXhwb3J0IGNvbnN0IGZpbmROYWxVbml0c0luQW5uZXhCID0gKHBhY2tldERhdGEpID0+IHtcbiAgICBjb25zdCBuYWxVbml0cyA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHBhY2tldERhdGEubGVuZ3RoKSB7XG4gICAgICAgIGxldCBzdGFydENvZGVQb3MgPSAtMTtcbiAgICAgICAgbGV0IHN0YXJ0Q29kZUxlbmd0aCA9IDA7XG4gICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgcGFja2V0RGF0YS5sZW5ndGggLSAzOyBqKyspIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciAzLWJ5dGUgc3RhcnQgY29kZSAoMHgwMDAwMDEpXG4gICAgICAgICAgICBpZiAocGFja2V0RGF0YVtqXSA9PT0gMCAmJiBwYWNrZXREYXRhW2ogKyAxXSA9PT0gMCAmJiBwYWNrZXREYXRhW2ogKyAyXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0Q29kZVBvcyA9IGo7XG4gICAgICAgICAgICAgICAgc3RhcnRDb2RlTGVuZ3RoID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciA0LWJ5dGUgc3RhcnQgY29kZSAoMHgwMDAwMDAwMSlcbiAgICAgICAgICAgIGlmIChqIDwgcGFja2V0RGF0YS5sZW5ndGggLSA0XG4gICAgICAgICAgICAgICAgJiYgcGFja2V0RGF0YVtqXSA9PT0gMFxuICAgICAgICAgICAgICAgICYmIHBhY2tldERhdGFbaiArIDFdID09PSAwXG4gICAgICAgICAgICAgICAgJiYgcGFja2V0RGF0YVtqICsgMl0gPT09IDBcbiAgICAgICAgICAgICAgICAmJiBwYWNrZXREYXRhW2ogKyAzXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0Q29kZVBvcyA9IGo7XG4gICAgICAgICAgICAgICAgc3RhcnRDb2RlTGVuZ3RoID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRDb2RlUG9zID09PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7IC8vIE5vIG1vcmUgc3RhcnQgY29kZXMgZm91bmRcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIGlzbid0IHRoZSBmaXJzdCBzdGFydCBjb2RlLCBleHRyYWN0IHRoZSBwcmV2aW91cyBOQUwgdW5pdFxuICAgICAgICBpZiAoaSA+IDAgJiYgc3RhcnRDb2RlUG9zID4gaSkge1xuICAgICAgICAgICAgY29uc3QgbmFsRGF0YSA9IHBhY2tldERhdGEuc3ViYXJyYXkoaSwgc3RhcnRDb2RlUG9zKTtcbiAgICAgICAgICAgIGlmIChuYWxEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBuYWxVbml0cy5wdXNoKG5hbERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGkgPSBzdGFydENvZGVQb3MgKyBzdGFydENvZGVMZW5ndGg7XG4gICAgfVxuICAgIC8vIEV4dHJhY3QgdGhlIGxhc3QgTkFMIHVuaXQgaWYgdGhlcmUgaXMgb25lXG4gICAgaWYgKGkgPCBwYWNrZXREYXRhLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBuYWxEYXRhID0gcGFja2V0RGF0YS5zdWJhcnJheShpKTtcbiAgICAgICAgaWYgKG5hbERhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbmFsVW5pdHMucHVzaChuYWxEYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmFsVW5pdHM7XG59O1xuLyoqIEZpbmRzIGFsbCBOQUwgdW5pdHMgaW4gYW4gQVZDIHBhY2tldCBpbiBsZW5ndGgtcHJlZml4ZWQgZm9ybWF0LiAqL1xuY29uc3QgZmluZE5hbFVuaXRzSW5MZW5ndGhQcmVmaXhlZCA9IChwYWNrZXREYXRhLCBsZW5ndGhTaXplKSA9PiB7XG4gICAgY29uc3QgbmFsVW5pdHMgPSBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhwYWNrZXREYXRhLmJ1ZmZlciwgcGFja2V0RGF0YS5ieXRlT2Zmc2V0LCBwYWNrZXREYXRhLmJ5dGVMZW5ndGgpO1xuICAgIHdoaWxlIChvZmZzZXQgKyBsZW5ndGhTaXplIDw9IHBhY2tldERhdGEubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuYWxVbml0TGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoU2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgbmFsVW5pdExlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoU2l6ZSA9PT0gMikge1xuICAgICAgICAgICAgbmFsVW5pdExlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW5ndGhTaXplID09PSAzKSB7XG4gICAgICAgICAgICBuYWxVbml0TGVuZ3RoID0gKGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQsIGZhbHNlKSA8PCA4KSArIGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aFNpemUgPT09IDQpIHtcbiAgICAgICAgICAgIG5hbFVuaXRMZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnROZXZlcihsZW5ndGhTaXplKTtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IGxlbmd0aFNpemU7XG4gICAgICAgIGNvbnN0IG5hbFVuaXQgPSBwYWNrZXREYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbmFsVW5pdExlbmd0aCk7XG4gICAgICAgIG5hbFVuaXRzLnB1c2gobmFsVW5pdCk7XG4gICAgICAgIG9mZnNldCArPSBuYWxVbml0TGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gbmFsVW5pdHM7XG59O1xuY29uc3QgcmVtb3ZlRW11bGF0aW9uUHJldmVudGlvbkJ5dGVzID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIExvb2sgZm9yIHRoZSAweDAwMDAwMyBwYXR0ZXJuXG4gICAgICAgIGlmIChpICsgMiA8IGxlbiAmJiBkYXRhW2ldID09PSAweDAwICYmIGRhdGFbaSArIDFdID09PSAweDAwICYmIGRhdGFbaSArIDJdID09PSAweDAzKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgweDAwLCAweDAwKTsgLy8gUHVzaCB0aGUgZmlyc3QgdHdvIGJ5dGVzXG4gICAgICAgICAgICBpICs9IDI7IC8vIFNraXAgdGhlIDB4MDMgYnl0ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGF0YVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59O1xuLyoqIENvbnZlcnRzIGFuIEFWQyBwYWNrZXQgaW4gQW5uZXggQiBmb3JtYXQgdG8gbGVuZ3RoLXByZWZpeGVkIGZvcm1hdC4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1Bbm5leEJUb0xlbmd0aFByZWZpeGVkID0gKHBhY2tldERhdGEpID0+IHtcbiAgICBjb25zdCBOQUxfVU5JVF9MRU5HVEhfU0laRSA9IDQ7XG4gICAgY29uc3QgbmFsVW5pdHMgPSBmaW5kTmFsVW5pdHNJbkFubmV4QihwYWNrZXREYXRhKTtcbiAgICBpZiAobmFsVW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIElmIG5vIE5BTCB1bml0cyB3ZXJlIGZvdW5kLCBpdCdzIG5vdCB2YWxpZCBBbm5leCBCIGRhdGFcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCB0b3RhbFNpemUgPSAwO1xuICAgIGZvciAoY29uc3QgbmFsVW5pdCBvZiBuYWxVbml0cykge1xuICAgICAgICB0b3RhbFNpemUgKz0gTkFMX1VOSVRfTEVOR1RIX1NJWkUgKyBuYWxVbml0LmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGF2Y2NEYXRhID0gbmV3IFVpbnQ4QXJyYXkodG90YWxTaXplKTtcbiAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhdmNjRGF0YS5idWZmZXIpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIC8vIFdyaXRlIGVhY2ggTkFMIHVuaXQgd2l0aCBpdHMgbGVuZ3RoIHByZWZpeFxuICAgIGZvciAoY29uc3QgbmFsVW5pdCBvZiBuYWxVbml0cykge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBuYWxVbml0LmJ5dGVMZW5ndGg7XG4gICAgICAgIGRhdGFWaWV3LnNldFVpbnQzMihvZmZzZXQsIGxlbmd0aCwgZmFsc2UpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgYXZjY0RhdGEuc2V0KG5hbFVuaXQsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBuYWxVbml0LmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBhdmNjRGF0YTtcbn07XG5leHBvcnQgY29uc3QgZXh0cmFjdEF2Y05hbFVuaXRzID0gKHBhY2tldERhdGEsIGRlY29kZXJDb25maWcpID0+IHtcbiAgICBpZiAoZGVjb2RlckNvbmZpZy5kZXNjcmlwdGlvbikge1xuICAgICAgICAvLyBTdHJlYW0gaXMgbGVuZ3RoLXByZWZpeGVkLiBMZXQncyBleHRyYWN0IHRoZSBzaXplIG9mIHRoZSBsZW5ndGggcHJlZml4IGZyb20gdGhlIGRlY29kZXIgY29uZmlnXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gdG9VaW50OEFycmF5KGRlY29kZXJDb25maWcuZGVzY3JpcHRpb24pO1xuICAgICAgICBjb25zdCBsZW5ndGhTaXplTWludXNPbmUgPSBieXRlc1s0XSAmIDBiMTE7XG4gICAgICAgIGNvbnN0IGxlbmd0aFNpemUgPSAobGVuZ3RoU2l6ZU1pbnVzT25lICsgMSk7XG4gICAgICAgIHJldHVybiBmaW5kTmFsVW5pdHNJbkxlbmd0aFByZWZpeGVkKHBhY2tldERhdGEsIGxlbmd0aFNpemUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gU3RyZWFtIGlzIGluIEFubmV4IEIgZm9ybWF0XG4gICAgICAgIHJldHVybiBmaW5kTmFsVW5pdHNJbkFubmV4QihwYWNrZXREYXRhKTtcbiAgICB9XG59O1xuY29uc3QgZXh0cmFjdE5hbFVuaXRUeXBlRm9yQXZjID0gKGRhdGEpID0+IHtcbiAgICByZXR1cm4gZGF0YVswXSAmIDB4MUY7XG59O1xuLyoqIEJ1aWxkcyBhbiBBdmNEZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZCBmcm9tIGFuIEFWQyBwYWNrZXQgaW4gQW5uZXggQiBmb3JtYXQuICovXG5leHBvcnQgY29uc3QgZXh0cmFjdEF2Y0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkID0gKHBhY2tldERhdGEpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBuYWxVbml0cyA9IGZpbmROYWxVbml0c0luQW5uZXhCKHBhY2tldERhdGEpO1xuICAgICAgICBjb25zdCBzcHNVbml0cyA9IG5hbFVuaXRzLmZpbHRlcih1bml0ID0+IGV4dHJhY3ROYWxVbml0VHlwZUZvckF2Yyh1bml0KSA9PT0gQXZjTmFsVW5pdFR5cGUuU1BTKTtcbiAgICAgICAgY29uc3QgcHBzVW5pdHMgPSBuYWxVbml0cy5maWx0ZXIodW5pdCA9PiBleHRyYWN0TmFsVW5pdFR5cGVGb3JBdmModW5pdCkgPT09IEF2Y05hbFVuaXRUeXBlLlBQUyk7XG4gICAgICAgIGNvbnN0IHNwc0V4dFVuaXRzID0gbmFsVW5pdHMuZmlsdGVyKHVuaXQgPT4gZXh0cmFjdE5hbFVuaXRUeXBlRm9yQXZjKHVuaXQpID09PSBBdmNOYWxVbml0VHlwZS5TUFNfRVhUKTtcbiAgICAgICAgaWYgKHNwc1VuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBwc1VuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGV0J3MgZ2V0IHRoZSBmaXJzdCBTUFMgZm9yIHByb2ZpbGUgYW5kIGxldmVsIGluZm9ybWF0aW9uXG4gICAgICAgIGNvbnN0IHNwc0RhdGEgPSBzcHNVbml0c1swXTtcbiAgICAgICAgY29uc3QgYml0c3RyZWFtID0gbmV3IEJpdHN0cmVhbShyZW1vdmVFbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXMoc3BzRGF0YSkpO1xuICAgICAgICBiaXRzdHJlYW0uc2tpcEJpdHMoMSk7IC8vIGZvcmJpZGRlbl96ZXJvX2JpdFxuICAgICAgICBiaXRzdHJlYW0uc2tpcEJpdHMoMik7IC8vIG5hbF9yZWZfaWRjXG4gICAgICAgIGNvbnN0IG5hbF91bml0X3R5cGUgPSBiaXRzdHJlYW0ucmVhZEJpdHMoNSk7XG4gICAgICAgIGlmIChuYWxfdW5pdF90eXBlICE9PSA3KSB7IC8vIFNQUyBOQUwgdW5pdCB0eXBlIGlzIDdcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgU1BTIE5BTCB1bml0IHR5cGUnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb2ZpbGVfaWRjID0gYml0c3RyZWFtLnJlYWRBbGlnbmVkQnl0ZSgpO1xuICAgICAgICBjb25zdCBjb25zdHJhaW50X2ZsYWdzID0gYml0c3RyZWFtLnJlYWRBbGlnbmVkQnl0ZSgpO1xuICAgICAgICBjb25zdCBsZXZlbF9pZGMgPSBiaXRzdHJlYW0ucmVhZEFsaWduZWRCeXRlKCk7XG4gICAgICAgIGNvbnN0IHJlY29yZCA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25WZXJzaW9uOiAxLFxuICAgICAgICAgICAgYXZjUHJvZmlsZUluZGljYXRpb246IHByb2ZpbGVfaWRjLFxuICAgICAgICAgICAgcHJvZmlsZUNvbXBhdGliaWxpdHk6IGNvbnN0cmFpbnRfZmxhZ3MsXG4gICAgICAgICAgICBhdmNMZXZlbEluZGljYXRpb246IGxldmVsX2lkYyxcbiAgICAgICAgICAgIGxlbmd0aFNpemVNaW51c09uZTogMywgLy8gVHlwaWNhbGx5IDQgYnl0ZXMgZm9yIGxlbmd0aCBmaWVsZFxuICAgICAgICAgICAgc2VxdWVuY2VQYXJhbWV0ZXJTZXRzOiBzcHNVbml0cyxcbiAgICAgICAgICAgIHBpY3R1cmVQYXJhbWV0ZXJTZXRzOiBwcHNVbml0cyxcbiAgICAgICAgICAgIGNocm9tYUZvcm1hdDogbnVsbCxcbiAgICAgICAgICAgIGJpdERlcHRoTHVtYU1pbnVzODogbnVsbCxcbiAgICAgICAgICAgIGJpdERlcHRoQ2hyb21hTWludXM4OiBudWxsLFxuICAgICAgICAgICAgc2VxdWVuY2VQYXJhbWV0ZXJTZXRFeHQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9maWxlX2lkYyA9PT0gMTAwXG4gICAgICAgICAgICB8fCBwcm9maWxlX2lkYyA9PT0gMTEwXG4gICAgICAgICAgICB8fCBwcm9maWxlX2lkYyA9PT0gMTIyXG4gICAgICAgICAgICB8fCBwcm9maWxlX2lkYyA9PT0gMTQ0KSB7XG4gICAgICAgICAgICByZWFkRXhwR29sb21iKGJpdHN0cmVhbSk7IC8vIHNlcV9wYXJhbWV0ZXJfc2V0X2lkXG4gICAgICAgICAgICBjb25zdCBjaHJvbWFfZm9ybWF0X2lkYyA9IHJlYWRFeHBHb2xvbWIoYml0c3RyZWFtKTtcbiAgICAgICAgICAgIGlmIChjaHJvbWFfZm9ybWF0X2lkYyA9PT0gMykge1xuICAgICAgICAgICAgICAgIGJpdHN0cmVhbS5za2lwQml0cygxKTsgLy8gc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJpdF9kZXB0aF9sdW1hX21pbnVzOCA9IHJlYWRFeHBHb2xvbWIoYml0c3RyZWFtKTtcbiAgICAgICAgICAgIGNvbnN0IGJpdF9kZXB0aF9jaHJvbWFfbWludXM4ID0gcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pO1xuICAgICAgICAgICAgcmVjb3JkLmNocm9tYUZvcm1hdCA9IGNocm9tYV9mb3JtYXRfaWRjO1xuICAgICAgICAgICAgcmVjb3JkLmJpdERlcHRoTHVtYU1pbnVzOCA9IGJpdF9kZXB0aF9sdW1hX21pbnVzODtcbiAgICAgICAgICAgIHJlY29yZC5iaXREZXB0aENocm9tYU1pbnVzOCA9IGJpdF9kZXB0aF9jaHJvbWFfbWludXM4O1xuICAgICAgICAgICAgcmVjb3JkLnNlcXVlbmNlUGFyYW1ldGVyU2V0RXh0ID0gc3BzRXh0VW5pdHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGJ1aWxkaW5nIEFWQyBEZWNvZGVyIENvbmZpZ3VyYXRpb24gUmVjb3JkOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbi8qKiBTZXJpYWxpemVzIGFuIEF2Y0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkIGludG8gdGhlIGZvcm1hdCBzcGVjaWZpZWQgaW4gU2VjdGlvbiA1LjMuMy4xIG9mIElTTyAxNDQ5Ni0xNS4gKi9cbmV4cG9ydCBjb25zdCBzZXJpYWxpemVBdmNEZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZCA9IChyZWNvcmQpID0+IHtcbiAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgIC8vIFdyaXRlIGhlYWRlclxuICAgIGJ5dGVzLnB1c2gocmVjb3JkLmNvbmZpZ3VyYXRpb25WZXJzaW9uKTtcbiAgICBieXRlcy5wdXNoKHJlY29yZC5hdmNQcm9maWxlSW5kaWNhdGlvbik7XG4gICAgYnl0ZXMucHVzaChyZWNvcmQucHJvZmlsZUNvbXBhdGliaWxpdHkpO1xuICAgIGJ5dGVzLnB1c2gocmVjb3JkLmF2Y0xldmVsSW5kaWNhdGlvbik7XG4gICAgYnl0ZXMucHVzaCgweEZDIHwgKHJlY29yZC5sZW5ndGhTaXplTWludXNPbmUgJiAweDAzKSk7IC8vIFJlc2VydmVkIGJpdHMgKDYpICsgbGVuZ3RoU2l6ZU1pbnVzT25lICgyKVxuICAgIC8vIFJlc2VydmVkIGJpdHMgKDMpICsgbnVtT2ZTZXF1ZW5jZVBhcmFtZXRlclNldHMgKDUpXG4gICAgYnl0ZXMucHVzaCgweEUwIHwgKHJlY29yZC5zZXF1ZW5jZVBhcmFtZXRlclNldHMubGVuZ3RoICYgMHgxRikpO1xuICAgIC8vIFdyaXRlIFNQU1xuICAgIGZvciAoY29uc3Qgc3BzIG9mIHJlY29yZC5zZXF1ZW5jZVBhcmFtZXRlclNldHMpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gc3BzLmJ5dGVMZW5ndGg7XG4gICAgICAgIGJ5dGVzLnB1c2gobGVuZ3RoID4+IDgpOyAvLyBIaWdoIGJ5dGVcbiAgICAgICAgYnl0ZXMucHVzaChsZW5ndGggJiAweEZGKTsgLy8gTG93IGJ5dGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnl0ZXMucHVzaChzcHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ5dGVzLnB1c2gocmVjb3JkLnBpY3R1cmVQYXJhbWV0ZXJTZXRzLmxlbmd0aCk7XG4gICAgLy8gV3JpdGUgUFBTXG4gICAgZm9yIChjb25zdCBwcHMgb2YgcmVjb3JkLnBpY3R1cmVQYXJhbWV0ZXJTZXRzKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHBwcy5ieXRlTGVuZ3RoO1xuICAgICAgICBieXRlcy5wdXNoKGxlbmd0aCA+PiA4KTsgLy8gSGlnaCBieXRlXG4gICAgICAgIGJ5dGVzLnB1c2gobGVuZ3RoICYgMHhGRik7IC8vIExvdyBieXRlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2gocHBzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVjb3JkLmF2Y1Byb2ZpbGVJbmRpY2F0aW9uID09PSAxMDBcbiAgICAgICAgfHwgcmVjb3JkLmF2Y1Byb2ZpbGVJbmRpY2F0aW9uID09PSAxMTBcbiAgICAgICAgfHwgcmVjb3JkLmF2Y1Byb2ZpbGVJbmRpY2F0aW9uID09PSAxMjJcbiAgICAgICAgfHwgcmVjb3JkLmF2Y1Byb2ZpbGVJbmRpY2F0aW9uID09PSAxNDQpIHtcbiAgICAgICAgYXNzZXJ0KHJlY29yZC5jaHJvbWFGb3JtYXQgIT09IG51bGwpO1xuICAgICAgICBhc3NlcnQocmVjb3JkLmJpdERlcHRoTHVtYU1pbnVzOCAhPT0gbnVsbCk7XG4gICAgICAgIGFzc2VydChyZWNvcmQuYml0RGVwdGhDaHJvbWFNaW51czggIT09IG51bGwpO1xuICAgICAgICBhc3NlcnQocmVjb3JkLnNlcXVlbmNlUGFyYW1ldGVyU2V0RXh0ICE9PSBudWxsKTtcbiAgICAgICAgYnl0ZXMucHVzaCgweEZDIHwgKHJlY29yZC5jaHJvbWFGb3JtYXQgJiAweDAzKSk7IC8vIFJlc2VydmVkIGJpdHMgKyBjaHJvbWFfZm9ybWF0XG4gICAgICAgIGJ5dGVzLnB1c2goMHhGOCB8IChyZWNvcmQuYml0RGVwdGhMdW1hTWludXM4ICYgMHgwNykpOyAvLyBSZXNlcnZlZCBiaXRzICsgYml0X2RlcHRoX2x1bWFfbWludXM4XG4gICAgICAgIGJ5dGVzLnB1c2goMHhGOCB8IChyZWNvcmQuYml0RGVwdGhDaHJvbWFNaW51czggJiAweDA3KSk7IC8vIFJlc2VydmVkIGJpdHMgKyBiaXRfZGVwdGhfY2hyb21hX21pbnVzOFxuICAgICAgICBieXRlcy5wdXNoKHJlY29yZC5zZXF1ZW5jZVBhcmFtZXRlclNldEV4dC5sZW5ndGgpO1xuICAgICAgICAvLyBXcml0ZSBTUFMgRXh0XG4gICAgICAgIGZvciAoY29uc3Qgc3BzRXh0IG9mIHJlY29yZC5zZXF1ZW5jZVBhcmFtZXRlclNldEV4dCkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gc3BzRXh0LmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBieXRlcy5wdXNoKGxlbmd0aCA+PiA4KTsgLy8gSGlnaCBieXRlXG4gICAgICAgICAgICBieXRlcy5wdXNoKGxlbmd0aCAmIDB4RkYpOyAvLyBMb3cgYnl0ZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goc3BzRXh0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xufTtcbmV4cG9ydCBjb25zdCBleHRyYWN0SGV2Y05hbFVuaXRzID0gKHBhY2tldERhdGEsIGRlY29kZXJDb25maWcpID0+IHtcbiAgICBpZiAoZGVjb2RlckNvbmZpZy5kZXNjcmlwdGlvbikge1xuICAgICAgICAvLyBTdHJlYW0gaXMgbGVuZ3RoLXByZWZpeGVkLiBMZXQncyBleHRyYWN0IHRoZSBzaXplIG9mIHRoZSBsZW5ndGggcHJlZml4IGZyb20gdGhlIGRlY29kZXIgY29uZmlnXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gdG9VaW50OEFycmF5KGRlY29kZXJDb25maWcuZGVzY3JpcHRpb24pO1xuICAgICAgICBjb25zdCBsZW5ndGhTaXplTWludXNPbmUgPSBieXRlc1syMV0gJiAwYjExO1xuICAgICAgICBjb25zdCBsZW5ndGhTaXplID0gKGxlbmd0aFNpemVNaW51c09uZSArIDEpO1xuICAgICAgICByZXR1cm4gZmluZE5hbFVuaXRzSW5MZW5ndGhQcmVmaXhlZChwYWNrZXREYXRhLCBsZW5ndGhTaXplKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFN0cmVhbSBpcyBpbiBBbm5leCBCIGZvcm1hdFxuICAgICAgICByZXR1cm4gZmluZE5hbFVuaXRzSW5Bbm5leEIocGFja2V0RGF0YSk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBleHRyYWN0TmFsVW5pdFR5cGVGb3JIZXZjID0gKGRhdGEpID0+IHtcbiAgICByZXR1cm4gKGRhdGFbMF0gPj4gMSkgJiAweDNGO1xufTtcbi8qKiBCdWlsZHMgYSBIZXZjRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmQgZnJvbSBhbiBIRVZDIHBhY2tldCBpbiBBbm5leCBCIGZvcm1hdC4gKi9cbmV4cG9ydCBjb25zdCBleHRyYWN0SGV2Y0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkID0gKHBhY2tldERhdGEpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBuYWxVbml0cyA9IGZpbmROYWxVbml0c0luQW5uZXhCKHBhY2tldERhdGEpO1xuICAgICAgICBjb25zdCB2cHNVbml0cyA9IG5hbFVuaXRzLmZpbHRlcih1bml0ID0+IGV4dHJhY3ROYWxVbml0VHlwZUZvckhldmModW5pdCkgPT09IEhldmNOYWxVbml0VHlwZS5WUFNfTlVUKTtcbiAgICAgICAgY29uc3Qgc3BzVW5pdHMgPSBuYWxVbml0cy5maWx0ZXIodW5pdCA9PiBleHRyYWN0TmFsVW5pdFR5cGVGb3JIZXZjKHVuaXQpID09PSBIZXZjTmFsVW5pdFR5cGUuU1BTX05VVCk7XG4gICAgICAgIGNvbnN0IHBwc1VuaXRzID0gbmFsVW5pdHMuZmlsdGVyKHVuaXQgPT4gZXh0cmFjdE5hbFVuaXRUeXBlRm9ySGV2Yyh1bml0KSA9PT0gSGV2Y05hbFVuaXRUeXBlLlBQU19OVVQpO1xuICAgICAgICBjb25zdCBzZWlVbml0cyA9IG5hbFVuaXRzLmZpbHRlcih1bml0ID0+IGV4dHJhY3ROYWxVbml0VHlwZUZvckhldmModW5pdCkgPT09IEhldmNOYWxVbml0VHlwZS5QUkVGSVhfU0VJX05VVFxuICAgICAgICAgICAgfHwgZXh0cmFjdE5hbFVuaXRUeXBlRm9ySGV2Yyh1bml0KSA9PT0gSGV2Y05hbFVuaXRUeXBlLlNVRkZJWF9TRUlfTlVUKTtcbiAgICAgICAgaWYgKHNwc1VuaXRzLmxlbmd0aCA9PT0gMCB8fCBwcHNVbml0cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3Qgc3BzID0gc3BzVW5pdHNbMF07XG4gICAgICAgIGNvbnN0IGJpdHN0cmVhbSA9IG5ldyBCaXRzdHJlYW0ocmVtb3ZlRW11bGF0aW9uUHJldmVudGlvbkJ5dGVzKHNwcykpO1xuICAgICAgICBiaXRzdHJlYW0uc2tpcEJpdHMoMTYpOyAvLyBOQUwgaGVhZGVyXG4gICAgICAgIGJpdHN0cmVhbS5yZWFkQml0cyg0KTsgLy8gc3BzX3ZpZGVvX3BhcmFtZXRlcl9zZXRfaWRcbiAgICAgICAgY29uc3Qgc3BzX21heF9zdWJfbGF5ZXJzX21pbnVzMSA9IGJpdHN0cmVhbS5yZWFkQml0cygzKTtcbiAgICAgICAgY29uc3Qgc3BzX3RlbXBvcmFsX2lkX25lc3RpbmdfZmxhZyA9IGJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgY29uc3QgeyBnZW5lcmFsX3Byb2ZpbGVfc3BhY2UsIGdlbmVyYWxfdGllcl9mbGFnLCBnZW5lcmFsX3Byb2ZpbGVfaWRjLCBnZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFncywgZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFncywgZ2VuZXJhbF9sZXZlbF9pZGMsIH0gPSBwYXJzZVByb2ZpbGVUaWVyTGV2ZWwoYml0c3RyZWFtLCBzcHNfbWF4X3N1Yl9sYXllcnNfbWludXMxKTtcbiAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBzcHNfc2VxX3BhcmFtZXRlcl9zZXRfaWRcbiAgICAgICAgY29uc3QgY2hyb21hX2Zvcm1hdF9pZGMgPSByZWFkRXhwR29sb21iKGJpdHN0cmVhbSk7XG4gICAgICAgIGlmIChjaHJvbWFfZm9ybWF0X2lkYyA9PT0gMylcbiAgICAgICAgICAgIGJpdHN0cmVhbS5za2lwQml0cygxKTsgLy8gc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcbiAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBwaWNfd2lkdGhfaW5fbHVtYV9zYW1wbGVzXG4gICAgICAgIHJlYWRFeHBHb2xvbWIoYml0c3RyZWFtKTsgLy8gcGljX2hlaWdodF9pbl9sdW1hX3NhbXBsZXNcbiAgICAgICAgaWYgKGJpdHN0cmVhbS5yZWFkQml0cygxKSkgeyAvLyBjb25mb3JtYW5jZV93aW5kb3dfZmxhZ1xuICAgICAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBjb25mX3dpbl9sZWZ0X29mZnNldFxuICAgICAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBjb25mX3dpbl9yaWdodF9vZmZzZXRcbiAgICAgICAgICAgIHJlYWRFeHBHb2xvbWIoYml0c3RyZWFtKTsgLy8gY29uZl93aW5fdG9wX29mZnNldFxuICAgICAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBjb25mX3dpbl9ib3R0b21fb2Zmc2V0XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYml0X2RlcHRoX2x1bWFfbWludXM4ID0gcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pO1xuICAgICAgICBjb25zdCBiaXRfZGVwdGhfY2hyb21hX21pbnVzOCA9IHJlYWRFeHBHb2xvbWIoYml0c3RyZWFtKTtcbiAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBsb2cyX21heF9waWNfb3JkZXJfY250X2xzYl9taW51czRcbiAgICAgICAgY29uc3Qgc3BzX3N1Yl9sYXllcl9vcmRlcmluZ19pbmZvX3ByZXNlbnRfZmxhZyA9IGJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgY29uc3QgbWF4TnVtID0gc3BzX3N1Yl9sYXllcl9vcmRlcmluZ19pbmZvX3ByZXNlbnRfZmxhZyA/IDAgOiBzcHNfbWF4X3N1Yl9sYXllcnNfbWludXMxO1xuICAgICAgICBmb3IgKGxldCBpID0gbWF4TnVtOyBpIDw9IHNwc19tYXhfc3ViX2xheWVyc19taW51czE7IGkrKykge1xuICAgICAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBzcHNfbWF4X2RlY19waWNfYnVmZmVyaW5nX21pbnVzMVtpXVxuICAgICAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBzcHNfbWF4X251bV9yZW9yZGVyX3BpY3NbaV1cbiAgICAgICAgICAgIHJlYWRFeHBHb2xvbWIoYml0c3RyZWFtKTsgLy8gc3BzX21heF9sYXRlbmN5X2luY3JlYXNlX3BsdXMxW2ldXG4gICAgICAgIH1cbiAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBsb2cyX21pbl9sdW1hX2NvZGluZ19ibG9ja19zaXplX21pbnVzM1xuICAgICAgICByZWFkRXhwR29sb21iKGJpdHN0cmVhbSk7IC8vIGxvZzJfZGlmZl9tYXhfbWluX2x1bWFfY29kaW5nX2Jsb2NrX3NpemVcbiAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBsb2cyX21pbl9sdW1hX3RyYW5zZm9ybV9ibG9ja19zaXplX21pbnVzMlxuICAgICAgICByZWFkRXhwR29sb21iKGJpdHN0cmVhbSk7IC8vIGxvZzJfZGlmZl9tYXhfbWluX2x1bWFfdHJhbnNmb3JtX2Jsb2NrX3NpemVcbiAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBtYXhfdHJhbnNmb3JtX2hpZXJhcmNoeV9kZXB0aF9pbnRlclxuICAgICAgICByZWFkRXhwR29sb21iKGJpdHN0cmVhbSk7IC8vIG1heF90cmFuc2Zvcm1faGllcmFyY2h5X2RlcHRoX2ludHJhXG4gICAgICAgIGlmIChiaXRzdHJlYW0ucmVhZEJpdHMoMSkpIHsgLy8gc2NhbGluZ19saXN0X2VuYWJsZWRfZmxhZ1xuICAgICAgICAgICAgaWYgKGJpdHN0cmVhbS5yZWFkQml0cygxKSkge1xuICAgICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdERhdGEoYml0c3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBiaXRzdHJlYW0uc2tpcEJpdHMoMSk7IC8vIGFtcF9lbmFibGVkX2ZsYWdcbiAgICAgICAgYml0c3RyZWFtLnNraXBCaXRzKDEpOyAvLyBzYW1wbGVfYWRhcHRpdmVfb2Zmc2V0X2VuYWJsZWRfZmxhZ1xuICAgICAgICBpZiAoYml0c3RyZWFtLnJlYWRCaXRzKDEpKSB7IC8vIHBjbV9lbmFibGVkX2ZsYWdcbiAgICAgICAgICAgIGJpdHN0cmVhbS5za2lwQml0cyg0KTsgLy8gcGNtX3NhbXBsZV9iaXRfZGVwdGhfbHVtYV9taW51czFcbiAgICAgICAgICAgIGJpdHN0cmVhbS5za2lwQml0cyg0KTsgLy8gcGNtX3NhbXBsZV9iaXRfZGVwdGhfY2hyb21hX21pbnVzMVxuICAgICAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBsb2cyX21pbl9wY21fbHVtYV9jb2RpbmdfYmxvY2tfc2l6ZV9taW51czNcbiAgICAgICAgICAgIHJlYWRFeHBHb2xvbWIoYml0c3RyZWFtKTsgLy8gbG9nMl9kaWZmX21heF9taW5fcGNtX2x1bWFfY29kaW5nX2Jsb2NrX3NpemVcbiAgICAgICAgICAgIGJpdHN0cmVhbS5za2lwQml0cygxKTsgLy8gcGNtX2xvb3BfZmlsdGVyX2Rpc2FibGVkX2ZsYWdcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW1fc2hvcnRfdGVybV9yZWZfcGljX3NldHMgPSByZWFkRXhwR29sb21iKGJpdHN0cmVhbSk7XG4gICAgICAgIHNraXBBbGxTdFJlZlBpY1NldHMoYml0c3RyZWFtLCBudW1fc2hvcnRfdGVybV9yZWZfcGljX3NldHMpO1xuICAgICAgICBpZiAoYml0c3RyZWFtLnJlYWRCaXRzKDEpKSB7IC8vIGxvbmdfdGVybV9yZWZfcGljc19wcmVzZW50X2ZsYWdcbiAgICAgICAgICAgIGNvbnN0IG51bV9sb25nX3Rlcm1fcmVmX3BpY3Nfc3BzID0gcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1fbG9uZ190ZXJtX3JlZl9waWNzX3NwczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBsdF9yZWZfcGljX3BvY19sc2Jfc3BzW2ldXG4gICAgICAgICAgICAgICAgYml0c3RyZWFtLnNraXBCaXRzKDEpOyAvLyB1c2VkX2J5X2N1cnJfcGljX2x0X3Nwc19mbGFnW2ldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYml0c3RyZWFtLnNraXBCaXRzKDEpOyAvLyBzcHNfdGVtcG9yYWxfbXZwX2VuYWJsZWRfZmxhZ1xuICAgICAgICBiaXRzdHJlYW0uc2tpcEJpdHMoMSk7IC8vIHN0cm9uZ19pbnRyYV9zbW9vdGhpbmdfZW5hYmxlZF9mbGFnXG4gICAgICAgIGxldCBtaW5fc3BhdGlhbF9zZWdtZW50YXRpb25faWRjID0gMDtcbiAgICAgICAgaWYgKGJpdHN0cmVhbS5yZWFkQml0cygxKSkgeyAvLyB2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWdcbiAgICAgICAgICAgIG1pbl9zcGF0aWFsX3NlZ21lbnRhdGlvbl9pZGMgPSBwYXJzZVZ1aUZvck1pblNwYXRpYWxTZWdtZW50YXRpb25JZGMoYml0c3RyZWFtLCBzcHNfbWF4X3N1Yl9sYXllcnNfbWludXMxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJzZSBQUFMgZm9yIHBhcmFsbGVsaXNtVHlwZVxuICAgICAgICBsZXQgcGFyYWxsZWxpc21UeXBlID0gMDtcbiAgICAgICAgaWYgKHBwc1VuaXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBwcyA9IHBwc1VuaXRzWzBdO1xuICAgICAgICAgICAgY29uc3QgcHBzQml0c3RyZWFtID0gbmV3IEJpdHN0cmVhbShyZW1vdmVFbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXMocHBzKSk7XG4gICAgICAgICAgICBwcHNCaXRzdHJlYW0uc2tpcEJpdHMoMTYpOyAvLyBOQUwgaGVhZGVyXG4gICAgICAgICAgICByZWFkRXhwR29sb21iKHBwc0JpdHN0cmVhbSk7IC8vIHBwc19waWNfcGFyYW1ldGVyX3NldF9pZFxuICAgICAgICAgICAgcmVhZEV4cEdvbG9tYihwcHNCaXRzdHJlYW0pOyAvLyBwcHNfc2VxX3BhcmFtZXRlcl9zZXRfaWRcbiAgICAgICAgICAgIHBwc0JpdHN0cmVhbS5za2lwQml0cygxKTsgLy8gZGVwZW5kZW50X3NsaWNlX3NlZ21lbnRzX2VuYWJsZWRfZmxhZ1xuICAgICAgICAgICAgcHBzQml0c3RyZWFtLnNraXBCaXRzKDEpOyAvLyBvdXRwdXRfZmxhZ19wcmVzZW50X2ZsYWdcbiAgICAgICAgICAgIHBwc0JpdHN0cmVhbS5za2lwQml0cygzKTsgLy8gbnVtX2V4dHJhX3NsaWNlX2hlYWRlcl9iaXRzXG4gICAgICAgICAgICBwcHNCaXRzdHJlYW0uc2tpcEJpdHMoMSk7IC8vIHNpZ25fZGF0YV9oaWRpbmdfZW5hYmxlZF9mbGFnXG4gICAgICAgICAgICBwcHNCaXRzdHJlYW0uc2tpcEJpdHMoMSk7IC8vIGNhYmFjX2luaXRfcHJlc2VudF9mbGFnXG4gICAgICAgICAgICByZWFkRXhwR29sb21iKHBwc0JpdHN0cmVhbSk7IC8vIG51bV9yZWZfaWR4X2wwX2RlZmF1bHRfYWN0aXZlX21pbnVzMVxuICAgICAgICAgICAgcmVhZEV4cEdvbG9tYihwcHNCaXRzdHJlYW0pOyAvLyBudW1fcmVmX2lkeF9sMV9kZWZhdWx0X2FjdGl2ZV9taW51czFcbiAgICAgICAgICAgIHJlYWRTaWduZWRFeHBHb2xvbWIocHBzQml0c3RyZWFtKTsgLy8gaW5pdF9xcF9taW51czI2XG4gICAgICAgICAgICBwcHNCaXRzdHJlYW0uc2tpcEJpdHMoMSk7IC8vIGNvbnN0cmFpbmVkX2ludHJhX3ByZWRfZmxhZ1xuICAgICAgICAgICAgcHBzQml0c3RyZWFtLnNraXBCaXRzKDEpOyAvLyB0cmFuc2Zvcm1fc2tpcF9lbmFibGVkX2ZsYWdcbiAgICAgICAgICAgIGlmIChwcHNCaXRzdHJlYW0ucmVhZEJpdHMoMSkpIHsgLy8gY3VfcXBfZGVsdGFfZW5hYmxlZF9mbGFnXG4gICAgICAgICAgICAgICAgcmVhZEV4cEdvbG9tYihwcHNCaXRzdHJlYW0pOyAvLyBkaWZmX2N1X3FwX2RlbHRhX2RlcHRoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkU2lnbmVkRXhwR29sb21iKHBwc0JpdHN0cmVhbSk7IC8vIHBwc19jYl9xcF9vZmZzZXRcbiAgICAgICAgICAgIHJlYWRTaWduZWRFeHBHb2xvbWIocHBzQml0c3RyZWFtKTsgLy8gcHBzX2NyX3FwX29mZnNldFxuICAgICAgICAgICAgcHBzQml0c3RyZWFtLnNraXBCaXRzKDEpOyAvLyBwcHNfc2xpY2VfY2hyb21hX3FwX29mZnNldHNfcHJlc2VudF9mbGFnXG4gICAgICAgICAgICBwcHNCaXRzdHJlYW0uc2tpcEJpdHMoMSk7IC8vIHdlaWdodGVkX3ByZWRfZmxhZ1xuICAgICAgICAgICAgcHBzQml0c3RyZWFtLnNraXBCaXRzKDEpOyAvLyB3ZWlnaHRlZF9iaXByZWRfZmxhZ1xuICAgICAgICAgICAgcHBzQml0c3RyZWFtLnNraXBCaXRzKDEpOyAvLyB0cmFuc3F1YW50X2J5cGFzc19lbmFibGVkX2ZsYWdcbiAgICAgICAgICAgIGNvbnN0IHRpbGVzX2VuYWJsZWRfZmxhZyA9IHBwc0JpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJvcHlfY29kaW5nX3N5bmNfZW5hYmxlZF9mbGFnID0gcHBzQml0c3RyZWFtLnJlYWRCaXRzKDEpO1xuICAgICAgICAgICAgaWYgKCF0aWxlc19lbmFibGVkX2ZsYWcgJiYgIWVudHJvcHlfY29kaW5nX3N5bmNfZW5hYmxlZF9mbGFnKVxuICAgICAgICAgICAgICAgIHBhcmFsbGVsaXNtVHlwZSA9IDA7XG4gICAgICAgICAgICBlbHNlIGlmICh0aWxlc19lbmFibGVkX2ZsYWcgJiYgIWVudHJvcHlfY29kaW5nX3N5bmNfZW5hYmxlZF9mbGFnKVxuICAgICAgICAgICAgICAgIHBhcmFsbGVsaXNtVHlwZSA9IDI7XG4gICAgICAgICAgICBlbHNlIGlmICghdGlsZXNfZW5hYmxlZF9mbGFnICYmIGVudHJvcHlfY29kaW5nX3N5bmNfZW5hYmxlZF9mbGFnKVxuICAgICAgICAgICAgICAgIHBhcmFsbGVsaXNtVHlwZSA9IDM7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxpc21UeXBlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcnJheXMgPSBbXG4gICAgICAgICAgICAuLi4odnBzVW5pdHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Q29tcGxldGVuZXNzOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFsVW5pdFR5cGU6IEhldmNOYWxVbml0VHlwZS5WUFNfTlVULFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFsVW5pdHM6IHZwc1VuaXRzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgIC4uLihzcHNVbml0cy5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlDb21wbGV0ZW5lc3M6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYWxVbml0VHlwZTogSGV2Y05hbFVuaXRUeXBlLlNQU19OVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYWxVbml0czogc3BzVW5pdHMsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgLi4uKHBwc1VuaXRzLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheUNvbXBsZXRlbmVzczogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbFVuaXRUeXBlOiBIZXZjTmFsVW5pdFR5cGUuUFBTX05VVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbFVuaXRzOiBwcHNVbml0cyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgICAuLi4oc2VpVW5pdHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Q29tcGxldGVuZXNzOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFsVW5pdFR5cGU6IGV4dHJhY3ROYWxVbml0VHlwZUZvckhldmMoc2VpVW5pdHNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFsVW5pdHM6IHNlaVVuaXRzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcmVjb3JkID0ge1xuICAgICAgICAgICAgY29uZmlndXJhdGlvblZlcnNpb246IDEsXG4gICAgICAgICAgICBnZW5lcmFsUHJvZmlsZVNwYWNlOiBnZW5lcmFsX3Byb2ZpbGVfc3BhY2UsXG4gICAgICAgICAgICBnZW5lcmFsVGllckZsYWc6IGdlbmVyYWxfdGllcl9mbGFnLFxuICAgICAgICAgICAgZ2VuZXJhbFByb2ZpbGVJZGM6IGdlbmVyYWxfcHJvZmlsZV9pZGMsXG4gICAgICAgICAgICBnZW5lcmFsUHJvZmlsZUNvbXBhdGliaWxpdHlGbGFnczogZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3MsXG4gICAgICAgICAgICBnZW5lcmFsQ29uc3RyYWludEluZGljYXRvckZsYWdzOiBnZW5lcmFsX2NvbnN0cmFpbnRfaW5kaWNhdG9yX2ZsYWdzLFxuICAgICAgICAgICAgZ2VuZXJhbExldmVsSWRjOiBnZW5lcmFsX2xldmVsX2lkYyxcbiAgICAgICAgICAgIG1pblNwYXRpYWxTZWdtZW50YXRpb25JZGM6IG1pbl9zcGF0aWFsX3NlZ21lbnRhdGlvbl9pZGMsXG4gICAgICAgICAgICBwYXJhbGxlbGlzbVR5cGUsXG4gICAgICAgICAgICBjaHJvbWFGb3JtYXRJZGM6IGNocm9tYV9mb3JtYXRfaWRjLFxuICAgICAgICAgICAgYml0RGVwdGhMdW1hTWludXM4OiBiaXRfZGVwdGhfbHVtYV9taW51czgsXG4gICAgICAgICAgICBiaXREZXB0aENocm9tYU1pbnVzODogYml0X2RlcHRoX2Nocm9tYV9taW51czgsXG4gICAgICAgICAgICBhdmdGcmFtZVJhdGU6IDAsXG4gICAgICAgICAgICBjb25zdGFudEZyYW1lUmF0ZTogMCxcbiAgICAgICAgICAgIG51bVRlbXBvcmFsTGF5ZXJzOiBzcHNfbWF4X3N1Yl9sYXllcnNfbWludXMxICsgMSxcbiAgICAgICAgICAgIHRlbXBvcmFsSWROZXN0ZWQ6IHNwc190ZW1wb3JhbF9pZF9uZXN0aW5nX2ZsYWcsXG4gICAgICAgICAgICBsZW5ndGhTaXplTWludXNPbmU6IDMsXG4gICAgICAgICAgICBhcnJheXMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBidWlsZGluZyBIRVZDIERlY29kZXIgQ29uZmlndXJhdGlvbiBSZWNvcmQ6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuY29uc3QgcGFyc2VQcm9maWxlVGllckxldmVsID0gKGJpdHN0cmVhbSwgbWF4TnVtU3ViTGF5ZXJzTWludXMxKSA9PiB7XG4gICAgY29uc3QgZ2VuZXJhbF9wcm9maWxlX3NwYWNlID0gYml0c3RyZWFtLnJlYWRCaXRzKDIpO1xuICAgIGNvbnN0IGdlbmVyYWxfdGllcl9mbGFnID0gYml0c3RyZWFtLnJlYWRCaXRzKDEpO1xuICAgIGNvbnN0IGdlbmVyYWxfcHJvZmlsZV9pZGMgPSBiaXRzdHJlYW0ucmVhZEJpdHMoNSk7XG4gICAgbGV0IGdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgICAgZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3MgPSAoZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3MgPDwgMSkgfCBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7XG4gICAgfVxuICAgIGNvbnN0IGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3MgPSBuZXcgVWludDhBcnJheSg2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICBnZW5lcmFsX2NvbnN0cmFpbnRfaW5kaWNhdG9yX2ZsYWdzW2ldID0gYml0c3RyZWFtLnJlYWRCaXRzKDgpO1xuICAgIH1cbiAgICBjb25zdCBnZW5lcmFsX2xldmVsX2lkYyA9IGJpdHN0cmVhbS5yZWFkQml0cyg4KTtcbiAgICBjb25zdCBzdWJfbGF5ZXJfcHJvZmlsZV9wcmVzZW50X2ZsYWcgPSBbXTtcbiAgICBjb25zdCBzdWJfbGF5ZXJfbGV2ZWxfcHJlc2VudF9mbGFnID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhOdW1TdWJMYXllcnNNaW51czE7IGkrKykge1xuICAgICAgICBzdWJfbGF5ZXJfcHJvZmlsZV9wcmVzZW50X2ZsYWcucHVzaChiaXRzdHJlYW0ucmVhZEJpdHMoMSkpO1xuICAgICAgICBzdWJfbGF5ZXJfbGV2ZWxfcHJlc2VudF9mbGFnLnB1c2goYml0c3RyZWFtLnJlYWRCaXRzKDEpKTtcbiAgICB9XG4gICAgaWYgKG1heE51bVN1YkxheWVyc01pbnVzMSA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG1heE51bVN1YkxheWVyc01pbnVzMTsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgYml0c3RyZWFtLnNraXBCaXRzKDIpOyAvLyByZXNlcnZlZF96ZXJvXzJiaXRzXG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhOdW1TdWJMYXllcnNNaW51czE7IGkrKykge1xuICAgICAgICBpZiAoc3ViX2xheWVyX3Byb2ZpbGVfcHJlc2VudF9mbGFnW2ldKVxuICAgICAgICAgICAgYml0c3RyZWFtLnNraXBCaXRzKDg4KTtcbiAgICAgICAgaWYgKHN1Yl9sYXllcl9sZXZlbF9wcmVzZW50X2ZsYWdbaV0pXG4gICAgICAgICAgICBiaXRzdHJlYW0uc2tpcEJpdHMoOCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGdlbmVyYWxfcHJvZmlsZV9zcGFjZSxcbiAgICAgICAgZ2VuZXJhbF90aWVyX2ZsYWcsXG4gICAgICAgIGdlbmVyYWxfcHJvZmlsZV9pZGMsXG4gICAgICAgIGdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzLFxuICAgICAgICBnZW5lcmFsX2NvbnN0cmFpbnRfaW5kaWNhdG9yX2ZsYWdzLFxuICAgICAgICBnZW5lcmFsX2xldmVsX2lkYyxcbiAgICB9O1xufTtcbmNvbnN0IHNraXBTY2FsaW5nTGlzdERhdGEgPSAoYml0c3RyZWFtKSA9PiB7XG4gICAgZm9yIChsZXQgc2l6ZUlkID0gMDsgc2l6ZUlkIDwgNDsgc2l6ZUlkKyspIHtcbiAgICAgICAgZm9yIChsZXQgbWF0cml4SWQgPSAwOyBtYXRyaXhJZCA8IChzaXplSWQgPT09IDMgPyAyIDogNik7IG1hdHJpeElkKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxpbmdfbGlzdF9wcmVkX21vZGVfZmxhZyA9IGJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgICAgIGlmICghc2NhbGluZ19saXN0X3ByZWRfbW9kZV9mbGFnKSB7XG4gICAgICAgICAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBzY2FsaW5nX2xpc3RfcHJlZF9tYXRyaXhfaWRfZGVsdGFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZWZOdW0gPSBNYXRoLm1pbig2NCwgMSA8PCAoNCArIChzaXplSWQgPDwgMSkpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZUlkID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkU2lnbmVkRXhwR29sb21iKGJpdHN0cmVhbSk7IC8vIHNjYWxpbmdfbGlzdF9kY19jb2VmX21pbnVzOFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZWZOdW07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZWFkU2lnbmVkRXhwR29sb21iKGJpdHN0cmVhbSk7IC8vIHNjYWxpbmdfbGlzdF9kZWx0YV9jb2VmXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHNraXBBbGxTdFJlZlBpY1NldHMgPSAoYml0c3RyZWFtLCBudW1fc2hvcnRfdGVybV9yZWZfcGljX3NldHMpID0+IHtcbiAgICBjb25zdCBOdW1EZWx0YVBvY3MgPSBbXTtcbiAgICBmb3IgKGxldCBzdFJwc0lkeCA9IDA7IHN0UnBzSWR4IDwgbnVtX3Nob3J0X3Rlcm1fcmVmX3BpY19zZXRzOyBzdFJwc0lkeCsrKSB7XG4gICAgICAgIE51bURlbHRhUG9jc1tzdFJwc0lkeF0gPSBza2lwU3RSZWZQaWNTZXQoYml0c3RyZWFtLCBzdFJwc0lkeCwgbnVtX3Nob3J0X3Rlcm1fcmVmX3BpY19zZXRzLCBOdW1EZWx0YVBvY3MpO1xuICAgIH1cbn07XG5jb25zdCBza2lwU3RSZWZQaWNTZXQgPSAoYml0c3RyZWFtLCBzdFJwc0lkeCwgbnVtX3Nob3J0X3Rlcm1fcmVmX3BpY19zZXRzLCBOdW1EZWx0YVBvY3MpID0+IHtcbiAgICBsZXQgTnVtRGVsdGFQb2NzVGhpcyA9IDA7XG4gICAgbGV0IGludGVyX3JlZl9waWNfc2V0X3ByZWRpY3Rpb25fZmxhZyA9IDA7XG4gICAgbGV0IFJlZlJwc0lkeCA9IDA7XG4gICAgaWYgKHN0UnBzSWR4ICE9PSAwKSB7XG4gICAgICAgIGludGVyX3JlZl9waWNfc2V0X3ByZWRpY3Rpb25fZmxhZyA9IGJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICB9XG4gICAgaWYgKGludGVyX3JlZl9waWNfc2V0X3ByZWRpY3Rpb25fZmxhZykge1xuICAgICAgICBpZiAoc3RScHNJZHggPT09IG51bV9zaG9ydF90ZXJtX3JlZl9waWNfc2V0cykge1xuICAgICAgICAgICAgY29uc3QgZGVsdGFfaWR4X21pbnVzMSA9IHJlYWRFeHBHb2xvbWIoYml0c3RyZWFtKTtcbiAgICAgICAgICAgIFJlZlJwc0lkeCA9IHN0UnBzSWR4IC0gKGRlbHRhX2lkeF9taW51czEgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFJlZlJwc0lkeCA9IHN0UnBzSWR4IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7IC8vIGRlbHRhX3Jwc19zaWduXG4gICAgICAgIHJlYWRFeHBHb2xvbWIoYml0c3RyZWFtKTsgLy8gYWJzX2RlbHRhX3Jwc19taW51czFcbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIGlzIE51bURlbHRhUG9jc1tSZWZScHNJZHhdICsgMVxuICAgICAgICBjb25zdCBudW1EZWx0YSA9IE51bURlbHRhUG9jc1tSZWZScHNJZHhdID8/IDA7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IG51bURlbHRhOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZWRfYnlfY3Vycl9waWNfZmxhZyA9IGJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgICAgIGlmICghdXNlZF9ieV9jdXJyX3BpY19mbGFnKSB7XG4gICAgICAgICAgICAgICAgYml0c3RyZWFtLnJlYWRCaXRzKDEpOyAvLyB1c2VfZGVsdGFfZmxhZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE51bURlbHRhUG9jc1RoaXMgPSBOdW1EZWx0YVBvY3NbUmVmUnBzSWR4XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG51bV9uZWdhdGl2ZV9waWNzID0gcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pO1xuICAgICAgICBjb25zdCBudW1fcG9zaXRpdmVfcGljcyA9IHJlYWRFeHBHb2xvbWIoYml0c3RyZWFtKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1fbmVnYXRpdmVfcGljczsgaSsrKSB7XG4gICAgICAgICAgICByZWFkRXhwR29sb21iKGJpdHN0cmVhbSk7IC8vIGRlbHRhX3BvY19zMF9taW51czFbaV1cbiAgICAgICAgICAgIGJpdHN0cmVhbS5yZWFkQml0cygxKTsgLy8gdXNlZF9ieV9jdXJyX3BpY19zMF9mbGFnW2ldXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1fcG9zaXRpdmVfcGljczsgaSsrKSB7XG4gICAgICAgICAgICByZWFkRXhwR29sb21iKGJpdHN0cmVhbSk7IC8vIGRlbHRhX3BvY19zMV9taW51czFbaV1cbiAgICAgICAgICAgIGJpdHN0cmVhbS5yZWFkQml0cygxKTsgLy8gdXNlZF9ieV9jdXJyX3BpY19zMV9mbGFnW2ldXG4gICAgICAgIH1cbiAgICAgICAgTnVtRGVsdGFQb2NzVGhpcyA9IG51bV9uZWdhdGl2ZV9waWNzICsgbnVtX3Bvc2l0aXZlX3BpY3M7XG4gICAgfVxuICAgIHJldHVybiBOdW1EZWx0YVBvY3NUaGlzO1xufTtcbmNvbnN0IHBhcnNlVnVpRm9yTWluU3BhdGlhbFNlZ21lbnRhdGlvbklkYyA9IChiaXRzdHJlYW0sIHNwc19tYXhfc3ViX2xheWVyc19taW51czEpID0+IHtcbiAgICBpZiAoYml0c3RyZWFtLnJlYWRCaXRzKDEpKSB7IC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICBjb25zdCBhc3BlY3RfcmF0aW9faWRjID0gYml0c3RyZWFtLnJlYWRCaXRzKDgpO1xuICAgICAgICBpZiAoYXNwZWN0X3JhdGlvX2lkYyA9PT0gMjU1KSB7XG4gICAgICAgICAgICBiaXRzdHJlYW0ucmVhZEJpdHMoMTYpOyAvLyBzYXJfd2lkdGhcbiAgICAgICAgICAgIGJpdHN0cmVhbS5yZWFkQml0cygxNik7IC8vIHNhcl9oZWlnaHRcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYml0c3RyZWFtLnJlYWRCaXRzKDEpKSB7IC8vIG92ZXJzY2FuX2luZm9fcHJlc2VudF9mbGFnXG4gICAgICAgIGJpdHN0cmVhbS5yZWFkQml0cygxKTsgLy8gb3ZlcnNjYW5fYXBwcm9wcmlhdGVfZmxhZ1xuICAgIH1cbiAgICBpZiAoYml0c3RyZWFtLnJlYWRCaXRzKDEpKSB7IC8vIHZpZGVvX3NpZ25hbF90eXBlX3ByZXNlbnRfZmxhZ1xuICAgICAgICBiaXRzdHJlYW0ucmVhZEJpdHMoMyk7IC8vIHZpZGVvX2Zvcm1hdFxuICAgICAgICBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7IC8vIHZpZGVvX2Z1bGxfcmFuZ2VfZmxhZ1xuICAgICAgICBpZiAoYml0c3RyZWFtLnJlYWRCaXRzKDEpKSB7XG4gICAgICAgICAgICBiaXRzdHJlYW0ucmVhZEJpdHMoOCk7IC8vIGNvbG91cl9wcmltYXJpZXNcbiAgICAgICAgICAgIGJpdHN0cmVhbS5yZWFkQml0cyg4KTsgLy8gdHJhbnNmZXJfY2hhcmFjdGVyaXN0aWNzXG4gICAgICAgICAgICBiaXRzdHJlYW0ucmVhZEJpdHMoOCk7IC8vIG1hdHJpeF9jb2VmZnNcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYml0c3RyZWFtLnJlYWRCaXRzKDEpKSB7IC8vIGNocm9tYV9sb2NfaW5mb19wcmVzZW50X2ZsYWdcbiAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBjaHJvbWFfc2FtcGxlX2xvY190eXBlX3RvcF9maWVsZFxuICAgICAgICByZWFkRXhwR29sb21iKGJpdHN0cmVhbSk7IC8vIGNocm9tYV9zYW1wbGVfbG9jX3R5cGVfYm90dG9tX2ZpZWxkXG4gICAgfVxuICAgIGJpdHN0cmVhbS5yZWFkQml0cygxKTsgLy8gbmV1dHJhbF9jaHJvbWFfaW5kaWNhdGlvbl9mbGFnXG4gICAgYml0c3RyZWFtLnJlYWRCaXRzKDEpOyAvLyBmaWVsZF9zZXFfZmxhZ1xuICAgIGJpdHN0cmVhbS5yZWFkQml0cygxKTsgLy8gZnJhbWVfZmllbGRfaW5mb19wcmVzZW50X2ZsYWdcbiAgICBpZiAoYml0c3RyZWFtLnJlYWRCaXRzKDEpKSB7IC8vIGRlZmF1bHRfZGlzcGxheV93aW5kb3dfZmxhZ1xuICAgICAgICByZWFkRXhwR29sb21iKGJpdHN0cmVhbSk7IC8vIGRlZl9kaXNwX3dpbl9sZWZ0X29mZnNldFxuICAgICAgICByZWFkRXhwR29sb21iKGJpdHN0cmVhbSk7IC8vIGRlZl9kaXNwX3dpbl9yaWdodF9vZmZzZXRcbiAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBkZWZfZGlzcF93aW5fdG9wX29mZnNldFxuICAgICAgICByZWFkRXhwR29sb21iKGJpdHN0cmVhbSk7IC8vIGRlZl9kaXNwX3dpbl9ib3R0b21fb2Zmc2V0XG4gICAgfVxuICAgIGlmIChiaXRzdHJlYW0ucmVhZEJpdHMoMSkpIHsgLy8gdnVpX3RpbWluZ19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICBiaXRzdHJlYW0ucmVhZEJpdHMoMzIpOyAvLyB2dWlfbnVtX3VuaXRzX2luX3RpY2tcbiAgICAgICAgYml0c3RyZWFtLnJlYWRCaXRzKDMyKTsgLy8gdnVpX3RpbWVfc2NhbGVcbiAgICAgICAgaWYgKGJpdHN0cmVhbS5yZWFkQml0cygxKSkgeyAvLyB2dWlfcG9jX3Byb3BvcnRpb25hbF90b190aW1pbmdfZmxhZ1xuICAgICAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyB2dWlfbnVtX3RpY2tzX3BvY19kaWZmX29uZV9taW51czFcbiAgICAgICAgfVxuICAgICAgICBpZiAoYml0c3RyZWFtLnJlYWRCaXRzKDEpKSB7XG4gICAgICAgICAgICBza2lwSHJkUGFyYW1ldGVycyhiaXRzdHJlYW0sIHRydWUsIHNwc19tYXhfc3ViX2xheWVyc19taW51czEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChiaXRzdHJlYW0ucmVhZEJpdHMoMSkpIHsgLy8gYml0c3RyZWFtX3Jlc3RyaWN0aW9uX2ZsYWdcbiAgICAgICAgYml0c3RyZWFtLnJlYWRCaXRzKDEpOyAvLyB0aWxlc19maXhlZF9zdHJ1Y3R1cmVfZmxhZ1xuICAgICAgICBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7IC8vIG1vdGlvbl92ZWN0b3JzX292ZXJfcGljX2JvdW5kYXJpZXNfZmxhZ1xuICAgICAgICBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7IC8vIHJlc3RyaWN0ZWRfcmVmX3BpY19saXN0c19mbGFnXG4gICAgICAgIGNvbnN0IG1pbl9zcGF0aWFsX3NlZ21lbnRhdGlvbl9pZGMgPSByZWFkRXhwR29sb21iKGJpdHN0cmVhbSk7XG4gICAgICAgIC8vIHNraXAgdGhlIHJlc3RcbiAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBtYXhfYnl0ZXNfcGVyX3BpY19kZW5vbVxuICAgICAgICByZWFkRXhwR29sb21iKGJpdHN0cmVhbSk7IC8vIG1heF9iaXRzX3Blcl9taW5fY3VfZGVub21cbiAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBsb2cyX21heF9tdl9sZW5ndGhfaG9yaXpvbnRhbFxuICAgICAgICByZWFkRXhwR29sb21iKGJpdHN0cmVhbSk7IC8vIGxvZzJfbWF4X212X2xlbmd0aF92ZXJ0aWNhbFxuICAgICAgICByZXR1cm4gbWluX3NwYXRpYWxfc2VnbWVudGF0aW9uX2lkYztcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuY29uc3Qgc2tpcEhyZFBhcmFtZXRlcnMgPSAoYml0c3RyZWFtLCBjb21tb25JbmZQcmVzZW50RmxhZywgbWF4TnVtU3ViTGF5ZXJzTWludXMxKSA9PiB7XG4gICAgbGV0IG5hbF9ocmRfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcgPSBmYWxzZTtcbiAgICBsZXQgdmNsX2hyZF9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZyA9IGZhbHNlO1xuICAgIGxldCBzdWJfcGljX2hyZF9wYXJhbXNfcHJlc2VudF9mbGFnID0gZmFsc2U7XG4gICAgaWYgKGNvbW1vbkluZlByZXNlbnRGbGFnKSB7XG4gICAgICAgIG5hbF9ocmRfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSkgPT09IDE7XG4gICAgICAgIHZjbF9ocmRfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSkgPT09IDE7XG4gICAgICAgIGlmIChuYWxfaHJkX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnIHx8IHZjbF9ocmRfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgICAgIHN1Yl9waWNfaHJkX3BhcmFtc19wcmVzZW50X2ZsYWcgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSkgPT09IDE7XG4gICAgICAgICAgICBpZiAoc3ViX3BpY19ocmRfcGFyYW1zX3ByZXNlbnRfZmxhZykge1xuICAgICAgICAgICAgICAgIGJpdHN0cmVhbS5yZWFkQml0cyg4KTsgLy8gdGlja19kaXZpc29yX21pbnVzMlxuICAgICAgICAgICAgICAgIGJpdHN0cmVhbS5yZWFkQml0cyg1KTsgLy8gZHVfY3BiX3JlbW92YWxfZGVsYXlfaW5jcmVtZW50X2xlbmd0aF9taW51czFcbiAgICAgICAgICAgICAgICBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7IC8vIHN1Yl9waWNfY3BiX3BhcmFtc19pbl9waWNfdGltaW5nX3NlaV9mbGFnXG4gICAgICAgICAgICAgICAgYml0c3RyZWFtLnJlYWRCaXRzKDUpOyAvLyBkcGJfb3V0cHV0X2RlbGF5X2R1X2xlbmd0aF9taW51czFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdHN0cmVhbS5yZWFkQml0cyg0KTsgLy8gYml0X3JhdGVfc2NhbGVcbiAgICAgICAgICAgIGJpdHN0cmVhbS5yZWFkQml0cyg0KTsgLy8gY3BiX3NpemVfc2NhbGVcbiAgICAgICAgICAgIGlmIChzdWJfcGljX2hyZF9wYXJhbXNfcHJlc2VudF9mbGFnKSB7XG4gICAgICAgICAgICAgICAgYml0c3RyZWFtLnJlYWRCaXRzKDQpOyAvLyBjcGJfc2l6ZV9kdV9zY2FsZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYml0c3RyZWFtLnJlYWRCaXRzKDUpOyAvLyBpbml0aWFsX2NwYl9yZW1vdmFsX2RlbGF5X2xlbmd0aF9taW51czFcbiAgICAgICAgICAgIGJpdHN0cmVhbS5yZWFkQml0cyg1KTsgLy8gYXVfY3BiX3JlbW92YWxfZGVsYXlfbGVuZ3RoX21pbnVzMVxuICAgICAgICAgICAgYml0c3RyZWFtLnJlYWRCaXRzKDUpOyAvLyBkcGJfb3V0cHV0X2RlbGF5X2xlbmd0aF9taW51czFcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBtYXhOdW1TdWJMYXllcnNNaW51czE7IGkrKykge1xuICAgICAgICBjb25zdCBmaXhlZF9waWNfcmF0ZV9nZW5lcmFsX2ZsYWcgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSkgPT09IDE7XG4gICAgICAgIGxldCBmaXhlZF9waWNfcmF0ZV93aXRoaW5fY3ZzX2ZsYWcgPSB0cnVlOyAvLyBEZWZhdWx0IGFzc3VtcHRpb24gaWYgZ2VuZXJhbCBpcyB0cnVlXG4gICAgICAgIGlmICghZml4ZWRfcGljX3JhdGVfZ2VuZXJhbF9mbGFnKSB7XG4gICAgICAgICAgICBmaXhlZF9waWNfcmF0ZV93aXRoaW5fY3ZzX2ZsYWcgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSkgPT09IDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxvd19kZWxheV9ocmRfZmxhZyA9IGZhbHNlOyAvLyBEZWZhdWx0IGFzc3VtcHRpb25cbiAgICAgICAgaWYgKGZpeGVkX3BpY19yYXRlX3dpdGhpbl9jdnNfZmxhZykge1xuICAgICAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBlbGVtZW50YWxfZHVyYXRpb25faW5fdGNfbWludXMxW2ldXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb3dfZGVsYXlfaHJkX2ZsYWcgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSkgPT09IDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IENwYkNudCA9IDE7IC8vIERlZmF1bHQgaWYgbG93X2RlbGF5IGlzIHRydWVcbiAgICAgICAgaWYgKCFsb3dfZGVsYXlfaHJkX2ZsYWcpIHtcbiAgICAgICAgICAgIGNvbnN0IGNwYl9jbnRfbWludXMxID0gcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBjcGJfY250X21pbnVzMVtpXVxuICAgICAgICAgICAgQ3BiQ250ID0gY3BiX2NudF9taW51czEgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYWxfaHJkX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnKSB7XG4gICAgICAgICAgICBza2lwU3ViTGF5ZXJIcmRQYXJhbWV0ZXJzKGJpdHN0cmVhbSwgQ3BiQ250LCBzdWJfcGljX2hyZF9wYXJhbXNfcHJlc2VudF9mbGFnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmNsX2hyZF9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZykge1xuICAgICAgICAgICAgc2tpcFN1YkxheWVySHJkUGFyYW1ldGVycyhiaXRzdHJlYW0sIENwYkNudCwgc3ViX3BpY19ocmRfcGFyYW1zX3ByZXNlbnRfZmxhZyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3Qgc2tpcFN1YkxheWVySHJkUGFyYW1ldGVycyA9IChiaXRzdHJlYW0sIENwYkNudCwgc3ViX3BpY19ocmRfcGFyYW1zX3ByZXNlbnRfZmxhZykgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ3BiQ250OyBpKyspIHtcbiAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBiaXRfcmF0ZV92YWx1ZV9taW51czFbaV1cbiAgICAgICAgcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pOyAvLyBjcGJfc2l6ZV92YWx1ZV9taW51czFbaV1cbiAgICAgICAgaWYgKHN1Yl9waWNfaHJkX3BhcmFtc19wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgICAgIHJlYWRFeHBHb2xvbWIoYml0c3RyZWFtKTsgLy8gY3BiX3NpemVfZHVfdmFsdWVfbWludXMxW2ldXG4gICAgICAgICAgICByZWFkRXhwR29sb21iKGJpdHN0cmVhbSk7IC8vIGJpdF9yYXRlX2R1X3ZhbHVlX21pbnVzMVtpXVxuICAgICAgICB9XG4gICAgICAgIGJpdHN0cmVhbS5yZWFkQml0cygxKTsgLy8gY2JyX2ZsYWdbaV1cbiAgICB9XG59O1xuLyoqIFNlcmlhbGl6ZXMgYW4gSGV2Y0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkIGludG8gdGhlIGZvcm1hdCBzcGVjaWZpZWQgaW4gU2VjdGlvbiA4LjMuMy4xIG9mIElTTyAxNDQ5Ni0xNS4gKi9cbmV4cG9ydCBjb25zdCBzZXJpYWxpemVIZXZjRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmQgPSAocmVjb3JkKSA9PiB7XG4gICAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgICBieXRlcy5wdXNoKHJlY29yZC5jb25maWd1cmF0aW9uVmVyc2lvbik7XG4gICAgYnl0ZXMucHVzaCgoKHJlY29yZC5nZW5lcmFsUHJvZmlsZVNwYWNlICYgMHgzKSA8PCA2KVxuICAgICAgICB8ICgocmVjb3JkLmdlbmVyYWxUaWVyRmxhZyAmIDB4MSkgPDwgNSlcbiAgICAgICAgfCAocmVjb3JkLmdlbmVyYWxQcm9maWxlSWRjICYgMHgxRikpO1xuICAgIGJ5dGVzLnB1c2goKHJlY29yZC5nZW5lcmFsUHJvZmlsZUNvbXBhdGliaWxpdHlGbGFncyA+Pj4gMjQpICYgMHhGRik7XG4gICAgYnl0ZXMucHVzaCgocmVjb3JkLmdlbmVyYWxQcm9maWxlQ29tcGF0aWJpbGl0eUZsYWdzID4+PiAxNikgJiAweEZGKTtcbiAgICBieXRlcy5wdXNoKChyZWNvcmQuZ2VuZXJhbFByb2ZpbGVDb21wYXRpYmlsaXR5RmxhZ3MgPj4+IDgpICYgMHhGRik7XG4gICAgYnl0ZXMucHVzaChyZWNvcmQuZ2VuZXJhbFByb2ZpbGVDb21wYXRpYmlsaXR5RmxhZ3MgJiAweEZGKTtcbiAgICBieXRlcy5wdXNoKC4uLnJlY29yZC5nZW5lcmFsQ29uc3RyYWludEluZGljYXRvckZsYWdzKTtcbiAgICBieXRlcy5wdXNoKHJlY29yZC5nZW5lcmFsTGV2ZWxJZGMgJiAweEZGKTtcbiAgICBieXRlcy5wdXNoKDB4RjAgfCAoKHJlY29yZC5taW5TcGF0aWFsU2VnbWVudGF0aW9uSWRjID4+IDgpICYgMHgwRikpOyAvLyBSZXNlcnZlZCArIGhpZ2ggbmliYmxlXG4gICAgYnl0ZXMucHVzaChyZWNvcmQubWluU3BhdGlhbFNlZ21lbnRhdGlvbklkYyAmIDB4RkYpOyAvLyBMb3cgYnl0ZVxuICAgIGJ5dGVzLnB1c2goMHhGQyB8IChyZWNvcmQucGFyYWxsZWxpc21UeXBlICYgMHgwMykpO1xuICAgIGJ5dGVzLnB1c2goMHhGQyB8IChyZWNvcmQuY2hyb21hRm9ybWF0SWRjICYgMHgwMykpO1xuICAgIGJ5dGVzLnB1c2goMHhGOCB8IChyZWNvcmQuYml0RGVwdGhMdW1hTWludXM4ICYgMHgwNykpO1xuICAgIGJ5dGVzLnB1c2goMHhGOCB8IChyZWNvcmQuYml0RGVwdGhDaHJvbWFNaW51czggJiAweDA3KSk7XG4gICAgYnl0ZXMucHVzaCgocmVjb3JkLmF2Z0ZyYW1lUmF0ZSA+PiA4KSAmIDB4RkYpOyAvLyBIaWdoIGJ5dGVcbiAgICBieXRlcy5wdXNoKHJlY29yZC5hdmdGcmFtZVJhdGUgJiAweEZGKTsgLy8gTG93IGJ5dGVcbiAgICBieXRlcy5wdXNoKCgocmVjb3JkLmNvbnN0YW50RnJhbWVSYXRlICYgMHgwMykgPDwgNilcbiAgICAgICAgfCAoKHJlY29yZC5udW1UZW1wb3JhbExheWVycyAmIDB4MDcpIDw8IDMpXG4gICAgICAgIHwgKChyZWNvcmQudGVtcG9yYWxJZE5lc3RlZCAmIDB4MDEpIDw8IDIpXG4gICAgICAgIHwgKHJlY29yZC5sZW5ndGhTaXplTWludXNPbmUgJiAweDAzKSk7XG4gICAgYnl0ZXMucHVzaChyZWNvcmQuYXJyYXlzLmxlbmd0aCAmIDB4RkYpO1xuICAgIGZvciAoY29uc3QgYXJyIG9mIHJlY29yZC5hcnJheXMpIHtcbiAgICAgICAgYnl0ZXMucHVzaCgoKGFyci5hcnJheUNvbXBsZXRlbmVzcyAmIDB4MDEpIDw8IDcpXG4gICAgICAgICAgICB8ICgwIDw8IDYpXG4gICAgICAgICAgICB8IChhcnIubmFsVW5pdFR5cGUgJiAweDNGKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goKGFyci5uYWxVbml0cy5sZW5ndGggPj4gOCkgJiAweEZGKTsgLy8gSGlnaCBieXRlXG4gICAgICAgIGJ5dGVzLnB1c2goYXJyLm5hbFVuaXRzLmxlbmd0aCAmIDB4RkYpOyAvLyBMb3cgYnl0ZVxuICAgICAgICBmb3IgKGNvbnN0IG5hbCBvZiBhcnIubmFsVW5pdHMpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goKG5hbC5sZW5ndGggPj4gOCkgJiAweEZGKTsgLy8gSGlnaCBieXRlXG4gICAgICAgICAgICBieXRlcy5wdXNoKG5hbC5sZW5ndGggJiAweEZGKTsgLy8gTG93IGJ5dGVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaChuYWxbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcyk7XG59O1xuZXhwb3J0IGNvbnN0IGV4dHJhY3RWcDlDb2RlY0luZm9Gcm9tUGFja2V0ID0gKHBhY2tldCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAc3R5bGlzdGljL21heC1sZW5cbiAgICAvLyBodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vZG93bmxvYWRzLndlYm1wcm9qZWN0Lm9yZy9kb2NzL3ZwOS92cDktYml0c3RyZWFtLXNwZWNpZmljYXRpb24tdjAuNy0yMDE3MDIyMi1kcmFmdC5wZGZcbiAgICAvLyBodHRwOi8vZG93bmxvYWRzLndlYm1wcm9qZWN0Lm9yZy9kb2NzL3ZwOS92cDktYml0c3RyZWFtX3N1cGVyZnJhbWUtYW5kLXVuY29tcHJlc3NlZC1oZWFkZXJfdjEuMC5wZGZcbiAgICBjb25zdCBiaXRzdHJlYW0gPSBuZXcgQml0c3RyZWFtKHBhY2tldCk7XG4gICAgLy8gRnJhbWUgbWFya2VyICgwYjEwKVxuICAgIGNvbnN0IGZyYW1lTWFya2VyID0gYml0c3RyZWFtLnJlYWRCaXRzKDIpO1xuICAgIGlmIChmcmFtZU1hcmtlciAhPT0gMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gUHJvZmlsZVxuICAgIGNvbnN0IHByb2ZpbGVMb3dCaXQgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7XG4gICAgY29uc3QgcHJvZmlsZUhpZ2hCaXQgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7XG4gICAgY29uc3QgcHJvZmlsZSA9IChwcm9maWxlSGlnaEJpdCA8PCAxKSArIHByb2ZpbGVMb3dCaXQ7XG4gICAgLy8gU2tpcCByZXNlcnZlZCBiaXQgZm9yIHByb2ZpbGUgM1xuICAgIGlmIChwcm9maWxlID09PSAzKSB7XG4gICAgICAgIGJpdHN0cmVhbS5za2lwQml0cygxKTtcbiAgICB9XG4gICAgLy8gc2hvd19leGlzdGluZ19mcmFtZVxuICAgIGNvbnN0IHNob3dFeGlzdGluZ0ZyYW1lID0gYml0c3RyZWFtLnJlYWRCaXRzKDEpO1xuICAgIGlmIChzaG93RXhpc3RpbmdGcmFtZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gZnJhbWVfdHlwZSAoMCA9IGtleSBmcmFtZSlcbiAgICBjb25zdCBmcmFtZVR5cGUgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7XG4gICAgaWYgKGZyYW1lVHlwZSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gU2tpcCBzaG93X2ZyYW1lIGFuZCBlcnJvcl9yZXNpbGllbnRfbW9kZVxuICAgIGJpdHN0cmVhbS5za2lwQml0cygyKTtcbiAgICAvLyBTeW5jIGNvZGUgKDB4NDk4MzQyKVxuICAgIGNvbnN0IHN5bmNDb2RlID0gYml0c3RyZWFtLnJlYWRCaXRzKDI0KTtcbiAgICBpZiAoc3luY0NvZGUgIT09IDB4NDk4MzQyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDb2xvciBjb25maWdcbiAgICBsZXQgYml0RGVwdGggPSA4O1xuICAgIGlmIChwcm9maWxlID49IDIpIHtcbiAgICAgICAgY29uc3QgdGVuT3JUd2VsdmVCaXQgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7XG4gICAgICAgIGJpdERlcHRoID0gdGVuT3JUd2VsdmVCaXQgPyAxMiA6IDEwO1xuICAgIH1cbiAgICAvLyBDb2xvciBzcGFjZVxuICAgIGNvbnN0IGNvbG9yU3BhY2UgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMyk7XG4gICAgbGV0IGNocm9tYVN1YnNhbXBsaW5nID0gMDtcbiAgICBsZXQgdmlkZW9GdWxsUmFuZ2VGbGFnID0gMDtcbiAgICBpZiAoY29sb3JTcGFjZSAhPT0gNykgeyAvLyA3IGlzIENTX1JHQlxuICAgICAgICBjb25zdCBjb2xvclJhbmdlID0gYml0c3RyZWFtLnJlYWRCaXRzKDEpO1xuICAgICAgICB2aWRlb0Z1bGxSYW5nZUZsYWcgPSBjb2xvclJhbmdlO1xuICAgICAgICBpZiAocHJvZmlsZSA9PT0gMSB8fCBwcm9maWxlID09PSAzKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzYW1wbGluZ1ggPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7XG4gICAgICAgICAgICBjb25zdCBzdWJzYW1wbGluZ1kgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7XG4gICAgICAgICAgICAvLyAwID0gNDoyOjAgdmVydGljYWxcbiAgICAgICAgICAgIC8vIDEgPSA0OjI6MCBjb2xvY2F0ZWRcbiAgICAgICAgICAgIC8vIDIgPSA0OjI6MlxuICAgICAgICAgICAgLy8gMyA9IDQ6NDo0XG4gICAgICAgICAgICBjaHJvbWFTdWJzYW1wbGluZyA9ICFzdWJzYW1wbGluZ1ggJiYgIXN1YnNhbXBsaW5nWVxuICAgICAgICAgICAgICAgID8gMyAvLyAwLDAgPSA0OjQ6NFxuICAgICAgICAgICAgICAgIDogc3Vic2FtcGxpbmdYICYmICFzdWJzYW1wbGluZ1lcbiAgICAgICAgICAgICAgICAgICAgPyAyIC8vIDEsMCA9IDQ6MjoyXG4gICAgICAgICAgICAgICAgICAgIDogMTsgLy8gMSwxID0gNDoyOjAgY29sb2NhdGVkIChkZWZhdWx0KVxuICAgICAgICAgICAgLy8gU2tpcCByZXNlcnZlZCBiaXRcbiAgICAgICAgICAgIGJpdHN0cmVhbS5za2lwQml0cygxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBwcm9maWxlIDAgYW5kIDIsIGFsd2F5cyA0OjI6MFxuICAgICAgICAgICAgY2hyb21hU3Vic2FtcGxpbmcgPSAxOyAvLyBVc2luZyBjb2xvY2F0ZWQgYXMgZGVmYXVsdFxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBSR0IgaXMgYWx3YXlzIDQ6NDo0XG4gICAgICAgIGNocm9tYVN1YnNhbXBsaW5nID0gMztcbiAgICAgICAgdmlkZW9GdWxsUmFuZ2VGbGFnID0gMTtcbiAgICB9XG4gICAgLy8gUGFyc2UgZnJhbWUgc2l6ZVxuICAgIGNvbnN0IHdpZHRoTWludXNPbmUgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMTYpO1xuICAgIGNvbnN0IGhlaWdodE1pbnVzT25lID0gYml0c3RyZWFtLnJlYWRCaXRzKDE2KTtcbiAgICBjb25zdCB3aWR0aCA9IHdpZHRoTWludXNPbmUgKyAxO1xuICAgIGNvbnN0IGhlaWdodCA9IGhlaWdodE1pbnVzT25lICsgMTtcbiAgICAvLyBDYWxjdWxhdGUgbGV2ZWwgYmFzZWQgb24gZGltZW5zaW9uc1xuICAgIGNvbnN0IHBpY3R1cmVTaXplID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgbGV0IGxldmVsID0gbGFzdChWUDlfTEVWRUxfVEFCTEUpLmxldmVsOyAvLyBEZWZhdWx0IHRvIGhpZ2hlc3QgbGV2ZWxcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIFZQOV9MRVZFTF9UQUJMRSkge1xuICAgICAgICBpZiAocGljdHVyZVNpemUgPD0gZW50cnkubWF4UGljdHVyZVNpemUpIHtcbiAgICAgICAgICAgIGxldmVsID0gZW50cnkubGV2ZWw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNYXAgY29sb3Jfc3BhY2UgdG8gc3RhbmRhcmQgdmFsdWVzXG4gICAgY29uc3QgbWF0cml4Q29lZmZpY2llbnRzID0gY29sb3JTcGFjZSA9PT0gN1xuICAgICAgICA/IDBcbiAgICAgICAgOiBjb2xvclNwYWNlID09PSAyXG4gICAgICAgICAgICA/IDFcbiAgICAgICAgICAgIDogY29sb3JTcGFjZSA9PT0gMVxuICAgICAgICAgICAgICAgID8gNlxuICAgICAgICAgICAgICAgIDogMjtcbiAgICBjb25zdCBjb2xvdXJQcmltYXJpZXMgPSBjb2xvclNwYWNlID09PSAyXG4gICAgICAgID8gMVxuICAgICAgICA6IGNvbG9yU3BhY2UgPT09IDFcbiAgICAgICAgICAgID8gNlxuICAgICAgICAgICAgOiAyO1xuICAgIGNvbnN0IHRyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzID0gY29sb3JTcGFjZSA9PT0gMlxuICAgICAgICA/IDFcbiAgICAgICAgOiBjb2xvclNwYWNlID09PSAxXG4gICAgICAgICAgICA/IDZcbiAgICAgICAgICAgIDogMjtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9maWxlLFxuICAgICAgICBsZXZlbCxcbiAgICAgICAgYml0RGVwdGgsXG4gICAgICAgIGNocm9tYVN1YnNhbXBsaW5nLFxuICAgICAgICB2aWRlb0Z1bGxSYW5nZUZsYWcsXG4gICAgICAgIGNvbG91clByaW1hcmllcyxcbiAgICAgICAgdHJhbnNmZXJDaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgIG1hdHJpeENvZWZmaWNpZW50cyxcbiAgICB9O1xufTtcbi8qKiBJdGVyYXRlcyBvdmVyIGFsbCBPQlVzIGluIGFuIEFWMSBwYWNrZXQgYmlzdHJlYW0uICovXG5leHBvcnQgY29uc3QgaXRlcmF0ZUF2MVBhY2tldE9idXMgPSBmdW5jdGlvbiogKHBhY2tldCkge1xuICAgIC8vIGh0dHBzOi8vYW9tZWRpYWNvZGVjLmdpdGh1Yi5pby9hdjEtc3BlYy9hdjEtc3BlYy5wZGZcbiAgICBjb25zdCBiaXRzdHJlYW0gPSBuZXcgQml0c3RyZWFtKHBhY2tldCk7XG4gICAgY29uc3QgcmVhZExlYjEyOCA9ICgpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUgPSBiaXRzdHJlYW0ucmVhZEFsaWduZWRCeXRlKCk7XG4gICAgICAgICAgICB2YWx1ZSB8PSAoKGJ5dGUgJiAweDdmKSA8PCAoaSAqIDcpKTtcbiAgICAgICAgICAgIGlmICghKGJ5dGUgJiAweDgwKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3BlYyByZXF1aXJlbWVudFxuICAgICAgICAgICAgaWYgKGkgPT09IDcgJiYgKGJ5dGUgJiAweDgwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNwZWMgcmVxdWlyZW1lbnRcbiAgICAgICAgaWYgKHZhbHVlID49IDIgKiogMzIgLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICB3aGlsZSAoYml0c3RyZWFtLmdldEJpdHNMZWZ0KCkgPj0gOCkge1xuICAgICAgICAvLyBQYXJzZSBPQlUgaGVhZGVyXG4gICAgICAgIGJpdHN0cmVhbS5za2lwQml0cygxKTtcbiAgICAgICAgY29uc3Qgb2J1VHlwZSA9IGJpdHN0cmVhbS5yZWFkQml0cyg0KTtcbiAgICAgICAgY29uc3Qgb2J1RXh0ZW5zaW9uID0gYml0c3RyZWFtLnJlYWRCaXRzKDEpO1xuICAgICAgICBjb25zdCBvYnVIYXNTaXplRmllbGQgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7XG4gICAgICAgIGJpdHN0cmVhbS5za2lwQml0cygxKTtcbiAgICAgICAgLy8gU2tpcCBleHRlbnNpb24gaGVhZGVyIGlmIHByZXNlbnRcbiAgICAgICAgaWYgKG9idUV4dGVuc2lvbikge1xuICAgICAgICAgICAgYml0c3RyZWFtLnNraXBCaXRzKDgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlYWQgT0JVIHNpemUgaWYgcHJlc2VudFxuICAgICAgICBsZXQgb2J1U2l6ZTtcbiAgICAgICAgaWYgKG9idUhhc1NpemVGaWVsZCkge1xuICAgICAgICAgICAgY29uc3Qgb2J1U2l6ZVZhbHVlID0gcmVhZExlYjEyOCgpO1xuICAgICAgICAgICAgaWYgKG9idVNpemVWYWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEl0IHdhcyBpbnZhbGlkXG4gICAgICAgICAgICBvYnVTaXplID0gb2J1U2l6ZVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHJlbWFpbmluZyBiaXRzIGFuZCBjb252ZXJ0IHRvIGJ5dGVzLCByb3VuZGluZyBkb3duXG4gICAgICAgICAgICBvYnVTaXplID0gTWF0aC5mbG9vcihiaXRzdHJlYW0uZ2V0Qml0c0xlZnQoKSAvIDgpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChiaXRzdHJlYW0ucG9zICUgOCA9PT0gMCk7XG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHR5cGU6IG9idVR5cGUsXG4gICAgICAgICAgICBkYXRhOiBwYWNrZXQuc3ViYXJyYXkoYml0c3RyZWFtLnBvcyAvIDgsIGJpdHN0cmVhbS5wb3MgLyA4ICsgb2J1U2l6ZSksXG4gICAgICAgIH07XG4gICAgICAgIC8vIE1vdmUgdG8gbmV4dCBPQlVcbiAgICAgICAgYml0c3RyZWFtLnNraXBCaXRzKG9idVNpemUgKiA4KTtcbiAgICB9XG59O1xuLyoqXG4gKiBXaGVuIEFWMSBjb2RlYyBpbmZvcm1hdGlvbiBpcyBub3QgcHJvdmlkZWQgYnkgdGhlIGNvbnRhaW5lciwgd2UgY2FuIHN0aWxsIHRyeSB0byBleHRyYWN0IHRoZSBpbmZvcm1hdGlvbiBieSBkaWdnaW5nXG4gKiBpbnRvIHRoZSBBVjEgYml0c3RyZWFtLlxuICovXG5leHBvcnQgY29uc3QgZXh0cmFjdEF2MUNvZGVjSW5mb0Zyb21QYWNrZXQgPSAocGFja2V0KSA9PiB7XG4gICAgLy8gaHR0cHM6Ly9hb21lZGlhY29kZWMuZ2l0aHViLmlvL2F2MS1zcGVjL2F2MS1zcGVjLnBkZlxuICAgIGZvciAoY29uc3QgeyB0eXBlLCBkYXRhIH0gb2YgaXRlcmF0ZUF2MVBhY2tldE9idXMocGFja2V0KSkge1xuICAgICAgICBpZiAodHlwZSAhPT0gMSkge1xuICAgICAgICAgICAgY29udGludWU7IC8vIDEgPT0gT0JVX1NFUVVFTkNFX0hFQURFUlxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJpdHN0cmVhbSA9IG5ldyBCaXRzdHJlYW0oZGF0YSk7XG4gICAgICAgIC8vIFJlYWQgc2VxdWVuY2UgaGVhZGVyIGZpZWxkc1xuICAgICAgICBjb25zdCBzZXFQcm9maWxlID0gYml0c3RyZWFtLnJlYWRCaXRzKDMpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIGNvbnN0IHN0aWxsUGljdHVyZSA9IGJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgY29uc3QgcmVkdWNlZFN0aWxsUGljdHVyZUhlYWRlciA9IGJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgbGV0IHNlcUxldmVsID0gMDtcbiAgICAgICAgbGV0IHNlcVRpZXIgPSAwO1xuICAgICAgICBsZXQgYnVmZmVyRGVsYXlMZW5ndGhNaW51czEgPSAwO1xuICAgICAgICBpZiAocmVkdWNlZFN0aWxsUGljdHVyZUhlYWRlcikge1xuICAgICAgICAgICAgc2VxTGV2ZWwgPSBiaXRzdHJlYW0ucmVhZEJpdHMoNSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBQYXJzZSB0aW1pbmdfaW5mb19wcmVzZW50X2ZsYWdcbiAgICAgICAgICAgIGNvbnN0IHRpbWluZ0luZm9QcmVzZW50RmxhZyA9IGJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgICAgIGlmICh0aW1pbmdJbmZvUHJlc2VudEZsYWcpIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHRpbWluZyBpbmZvIChudW1fdW5pdHNfaW5fZGlzcGxheV90aWNrLCB0aW1lX3NjYWxlLCBlcXVhbF9waWN0dXJlX2ludGVydmFsKVxuICAgICAgICAgICAgICAgIGJpdHN0cmVhbS5za2lwQml0cygzMik7IC8vIG51bV91bml0c19pbl9kaXNwbGF5X3RpY2tcbiAgICAgICAgICAgICAgICBiaXRzdHJlYW0uc2tpcEJpdHMoMzIpOyAvLyB0aW1lX3NjYWxlXG4gICAgICAgICAgICAgICAgY29uc3QgZXF1YWxQaWN0dXJlSW50ZXJ2YWwgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7XG4gICAgICAgICAgICAgICAgaWYgKGVxdWFsUGljdHVyZUludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgbnVtX3RpY2tzX3Blcl9waWN0dXJlX21pbnVzXzEgKHV2bGMpXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgdmFyaWFibGUgbGVuZ3RoLCB3ZSdkIG5lZWQgdG8gaW1wbGVtZW50IHV2bGMgcmVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCByZXR1cm4gbnVsbCBhcyB0aGlzIGlzIHJhcmVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2UgZGVjb2Rlcl9tb2RlbF9pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICAgICAgY29uc3QgZGVjb2Rlck1vZGVsSW5mb1ByZXNlbnRGbGFnID0gYml0c3RyZWFtLnJlYWRCaXRzKDEpO1xuICAgICAgICAgICAgaWYgKGRlY29kZXJNb2RlbEluZm9QcmVzZW50RmxhZykge1xuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGJ1ZmZlcl9kZWxheV9sZW5ndGhfbWludXNfMSBpbnN0ZWFkIG9mIGp1c3Qgc2tpcHBpbmdcbiAgICAgICAgICAgICAgICBidWZmZXJEZWxheUxlbmd0aE1pbnVzMSA9IGJpdHN0cmVhbS5yZWFkQml0cyg1KTtcbiAgICAgICAgICAgICAgICBiaXRzdHJlYW0uc2tpcEJpdHMoMzIpOyAvLyBudW1fdW5pdHNfaW5fZGVjb2RpbmdfdGlja1xuICAgICAgICAgICAgICAgIGJpdHN0cmVhbS5za2lwQml0cyg1KTsgLy8gYnVmZmVyX3JlbW92YWxfdGltZV9sZW5ndGhfbWludXNfMVxuICAgICAgICAgICAgICAgIGJpdHN0cmVhbS5za2lwQml0cyg1KTsgLy8gZnJhbWVfcHJlc2VudGF0aW9uX3RpbWVfbGVuZ3RoX21pbnVzXzFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIG9wZXJhdGluZ19wb2ludHNfY250X21pbnVzXzFcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdGluZ1BvaW50c0NudE1pbnVzMSA9IGJpdHN0cmVhbS5yZWFkQml0cyg1KTtcbiAgICAgICAgICAgIC8vIEZvciBlYWNoIG9wZXJhdGluZyBwb2ludFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gb3BlcmF0aW5nUG9pbnRzQ250TWludXMxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBvcGVyYXRpbmdfcG9pbnRfaWRjW2ldXG4gICAgICAgICAgICAgICAgYml0c3RyZWFtLnNraXBCaXRzKDEyKTtcbiAgICAgICAgICAgICAgICAvLyBzZXFfbGV2ZWxfaWR4W2ldXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VxTGV2ZWxJZHggPSBiaXRzdHJlYW0ucmVhZEJpdHMoNSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VxTGV2ZWwgPSBzZXFMZXZlbElkeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlcUxldmVsSWR4ID4gNykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXFfdGllcltpXVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXFUaWVyVGVtcCA9IGJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcVRpZXIgPSBzZXFUaWVyVGVtcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVjb2Rlck1vZGVsSW5mb1ByZXNlbnRGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlY29kZXJfbW9kZWxfcHJlc2VudF9mb3JfdGhpc19vcFtpXVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVyTW9kZWxQcmVzZW50Rm9yVGhpc09wID0gYml0c3RyZWFtLnJlYWRCaXRzKDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVjb2Rlck1vZGVsUHJlc2VudEZvclRoaXNPcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbiA9IGJ1ZmZlckRlbGF5TGVuZ3RoTWludXMxICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHN0cmVhbS5za2lwQml0cyhuKTsgLy8gZGVjb2Rlcl9idWZmZXJfZGVsYXlbb3BdXG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRzdHJlYW0uc2tpcEJpdHMobik7IC8vIGVuY29kZXJfYnVmZmVyX2RlbGF5W29wXVxuICAgICAgICAgICAgICAgICAgICAgICAgYml0c3RyZWFtLnNraXBCaXRzKDEpOyAvLyBsb3dfZGVsYXlfbW9kZV9mbGFnW29wXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxfZGlzcGxheV9kZWxheV9wcmVzZW50X2ZsYWdcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsRGlzcGxheURlbGF5UHJlc2VudEZsYWcgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxEaXNwbGF5RGVsYXlQcmVzZW50RmxhZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWFsX2Rpc3BsYXlfZGVsYXlfbWludXNfMVtpXVxuICAgICAgICAgICAgICAgICAgICBiaXRzdHJlYW0uc2tpcEJpdHMoNCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhpZ2hCaXRkZXB0aCA9IGJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgbGV0IGJpdERlcHRoID0gODtcbiAgICAgICAgaWYgKHNlcVByb2ZpbGUgPT09IDIgJiYgaGlnaEJpdGRlcHRoKSB7XG4gICAgICAgICAgICBjb25zdCB0d2VsdmVCaXQgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7XG4gICAgICAgICAgICBiaXREZXB0aCA9IHR3ZWx2ZUJpdCA/IDEyIDogMTA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VxUHJvZmlsZSA8PSAyKSB7XG4gICAgICAgICAgICBiaXREZXB0aCA9IGhpZ2hCaXRkZXB0aCA/IDEwIDogODtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbW9ub2Nocm9tZSA9IDA7XG4gICAgICAgIGlmIChzZXFQcm9maWxlICE9PSAxKSB7XG4gICAgICAgICAgICBtb25vY2hyb21lID0gYml0c3RyZWFtLnJlYWRCaXRzKDEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaHJvbWFTdWJzYW1wbGluZ1ggPSAxO1xuICAgICAgICBsZXQgY2hyb21hU3Vic2FtcGxpbmdZID0gMTtcbiAgICAgICAgbGV0IGNocm9tYVNhbXBsZVBvc2l0aW9uID0gMDtcbiAgICAgICAgaWYgKCFtb25vY2hyb21lKSB7XG4gICAgICAgICAgICBpZiAoc2VxUHJvZmlsZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNocm9tYVN1YnNhbXBsaW5nWCA9IDE7XG4gICAgICAgICAgICAgICAgY2hyb21hU3Vic2FtcGxpbmdZID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlcVByb2ZpbGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjaHJvbWFTdWJzYW1wbGluZ1ggPSAwO1xuICAgICAgICAgICAgICAgIGNocm9tYVN1YnNhbXBsaW5nWSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYml0RGVwdGggPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNocm9tYVN1YnNhbXBsaW5nWCA9IGJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNocm9tYVN1YnNhbXBsaW5nWCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21hU3Vic2FtcGxpbmdZID0gYml0c3RyZWFtLnJlYWRCaXRzKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNocm9tYVN1YnNhbXBsaW5nWCAmJiBjaHJvbWFTdWJzYW1wbGluZ1kpIHtcbiAgICAgICAgICAgICAgICBjaHJvbWFTYW1wbGVQb3NpdGlvbiA9IGJpdHN0cmVhbS5yZWFkQml0cygyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvZmlsZTogc2VxUHJvZmlsZSxcbiAgICAgICAgICAgIGxldmVsOiBzZXFMZXZlbCxcbiAgICAgICAgICAgIHRpZXI6IHNlcVRpZXIsXG4gICAgICAgICAgICBiaXREZXB0aCxcbiAgICAgICAgICAgIG1vbm9jaHJvbWUsXG4gICAgICAgICAgICBjaHJvbWFTdWJzYW1wbGluZ1gsXG4gICAgICAgICAgICBjaHJvbWFTdWJzYW1wbGluZ1ksXG4gICAgICAgICAgICBjaHJvbWFTYW1wbGVQb3NpdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuZXhwb3J0IGNvbnN0IHBhcnNlT3B1c0lkZW50aWZpY2F0aW9uSGVhZGVyID0gKGJ5dGVzKSA9PiB7XG4gICAgY29uc3QgdmlldyA9IHRvRGF0YVZpZXcoYnl0ZXMpO1xuICAgIGNvbnN0IG91dHB1dENoYW5uZWxDb3VudCA9IHZpZXcuZ2V0VWludDgoOSk7XG4gICAgY29uc3QgcHJlU2tpcCA9IHZpZXcuZ2V0VWludDE2KDEwLCB0cnVlKTtcbiAgICBjb25zdCBpbnB1dFNhbXBsZVJhdGUgPSB2aWV3LmdldFVpbnQzMigxMiwgdHJ1ZSk7XG4gICAgY29uc3Qgb3V0cHV0R2FpbiA9IHZpZXcuZ2V0SW50MTYoMTYsIHRydWUpO1xuICAgIGNvbnN0IGNoYW5uZWxNYXBwaW5nRmFtaWx5ID0gdmlldy5nZXRVaW50OCgxOCk7XG4gICAgbGV0IGNoYW5uZWxNYXBwaW5nVGFibGUgPSBudWxsO1xuICAgIGlmIChjaGFubmVsTWFwcGluZ0ZhbWlseSkge1xuICAgICAgICBjaGFubmVsTWFwcGluZ1RhYmxlID0gYnl0ZXMuc3ViYXJyYXkoMTksIDE5ICsgMiArIG91dHB1dENoYW5uZWxDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG91dHB1dENoYW5uZWxDb3VudCxcbiAgICAgICAgcHJlU2tpcCxcbiAgICAgICAgaW5wdXRTYW1wbGVSYXRlLFxuICAgICAgICBvdXRwdXRHYWluLFxuICAgICAgICBjaGFubmVsTWFwcGluZ0ZhbWlseSxcbiAgICAgICAgY2hhbm5lbE1hcHBpbmdUYWJsZSxcbiAgICB9O1xufTtcbi8vIEZyb20gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NzE2LCBpbiA0OCBrSHogc2FtcGxlc1xuY29uc3QgT1BVU19GUkFNRV9EVVJBVElPTl9UQUJMRSA9IFtcbiAgICA0ODAsIDk2MCwgMTkyMCwgMjg4MCxcbiAgICA0ODAsIDk2MCwgMTkyMCwgMjg4MCxcbiAgICA0ODAsIDk2MCwgMTkyMCwgMjg4MCxcbiAgICA0ODAsIDk2MCxcbiAgICA0ODAsIDk2MCxcbiAgICAxMjAsIDI0MCwgNDgwLCA5NjAsXG4gICAgMTIwLCAyNDAsIDQ4MCwgOTYwLFxuICAgIDEyMCwgMjQwLCA0ODAsIDk2MCxcbiAgICAxMjAsIDI0MCwgNDgwLCA5NjAsXG5dO1xuZXhwb3J0IGNvbnN0IHBhcnNlT3B1c1RvY0J5dGUgPSAocGFja2V0KSA9PiB7XG4gICAgY29uc3QgY29uZmlnID0gcGFja2V0WzBdID4+IDM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHVyYXRpb25JblNhbXBsZXM6IE9QVVNfRlJBTUVfRFVSQVRJT05fVEFCTEVbY29uZmlnXSxcbiAgICB9O1xufTtcbi8vIEJhc2VkIG9uIHZvcmJpc19wYXJzZXIuYyBmcm9tIEZGbXBlZy5cbmV4cG9ydCBjb25zdCBwYXJzZU1vZGVzRnJvbVZvcmJpc1NldHVwUGFja2V0ID0gKHNldHVwSGVhZGVyKSA9PiB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhpcyBpcyBhIFNldHVwIGhlYWRlci5cbiAgICBpZiAoc2V0dXBIZWFkZXIubGVuZ3RoIDwgNykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NldHVwIGhlYWRlciBpcyB0b28gc2hvcnQuJyk7XG4gICAgfVxuICAgIGlmIChzZXR1cEhlYWRlclswXSAhPT0gNSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIHBhY2tldCB0eXBlIGluIFNldHVwIGhlYWRlci4nKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5zZXR1cEhlYWRlci5zbGljZSgxLCA3KSk7XG4gICAgaWYgKHNpZ25hdHVyZSAhPT0gJ3ZvcmJpcycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhY2tldCBzaWduYXR1cmUgaW4gU2V0dXAgaGVhZGVyLicpO1xuICAgIH1cbiAgICAvLyBSZXZlcnNlIHRoZSBlbnRpcmUgYnVmZmVyLlxuICAgIGNvbnN0IGJ1ZlNpemUgPSBzZXR1cEhlYWRlci5sZW5ndGg7XG4gICAgY29uc3QgcmV2QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmU2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZTaXplOyBpKyspIHtcbiAgICAgICAgcmV2QnVmZmVyW2ldID0gc2V0dXBIZWFkZXJbYnVmU2l6ZSAtIDEgLSBpXTtcbiAgICB9XG4gICAgLy8gSW5pdGlhbGl6ZSBhIEJpdHN0cmVhbSBvbiB0aGUgcmV2ZXJzZWQgYnVmZmVyLlxuICAgIGNvbnN0IGJpdHN0cmVhbSA9IG5ldyBCaXRzdHJlYW0ocmV2QnVmZmVyKTtcbiAgICAvLyAtLS0gRmluZCB0aGUgZnJhbWluZyBiaXQuXG4gICAgLy8gSW4gRkZtcGVnIGNvZGUsIHdlIHNjYW4gdW50aWwgZ2V0X2JpdHMxKCkgcmV0dXJucyAxLlxuICAgIGxldCBnb3RGcmFtaW5nQml0ID0gMDtcbiAgICB3aGlsZSAoYml0c3RyZWFtLmdldEJpdHNMZWZ0KCkgPiA5Nykge1xuICAgICAgICBpZiAoYml0c3RyZWFtLnJlYWRCaXRzKDEpID09PSAxKSB7XG4gICAgICAgICAgICBnb3RGcmFtaW5nQml0ID0gYml0c3RyZWFtLnBvcztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChnb3RGcmFtaW5nQml0ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBTZXR1cCBoZWFkZXI6IGZyYW1pbmcgYml0IG5vdCBmb3VuZC4nKTtcbiAgICB9XG4gICAgLy8gLS0tIFNlYXJjaCBiYWNrd2FyZHMgZm9yIGEgdmFsaWQgbW9kZSBoZWFkZXIuXG4gICAgLy8gV2UgdHJ5IHRvIOKAnGd1ZXNz4oCdIHRoZSBudW1iZXIgb2YgbW9kZXMgYnkgcmVhZGluZyBhIGZpeGVkIHBhdHRlcm4uXG4gICAgbGV0IG1vZGVDb3VudCA9IDA7XG4gICAgbGV0IGdvdE1vZGVIZWFkZXIgPSBmYWxzZTtcbiAgICBsZXQgbGFzdE1vZGVDb3VudCA9IDA7XG4gICAgd2hpbGUgKGJpdHN0cmVhbS5nZXRCaXRzTGVmdCgpID49IDk3KSB7XG4gICAgICAgIGNvbnN0IHRlbXBQb3MgPSBiaXRzdHJlYW0ucG9zO1xuICAgICAgICBjb25zdCBhID0gYml0c3RyZWFtLnJlYWRCaXRzKDgpO1xuICAgICAgICBjb25zdCBiID0gYml0c3RyZWFtLnJlYWRCaXRzKDE2KTtcbiAgICAgICAgY29uc3QgYyA9IGJpdHN0cmVhbS5yZWFkQml0cygxNik7XG4gICAgICAgIC8vIElmIGEgPiA2MyBvciBiIG9yIGMgbm9uemVybywgYXNzdW1lIHdl4oCZdmUgZ29uZSB0b28gZmFyLlxuICAgICAgICBpZiAoYSA+IDYzIHx8IGIgIT09IDAgfHwgYyAhPT0gMCkge1xuICAgICAgICAgICAgYml0c3RyZWFtLnBvcyA9IHRlbXBQb3M7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBiaXRzdHJlYW0uc2tpcEJpdHMoMSk7XG4gICAgICAgIG1vZGVDb3VudCsrO1xuICAgICAgICBpZiAobW9kZUNvdW50ID4gNjQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJzQ2xvbmUgPSBiaXRzdHJlYW0uY2xvbmUoKTtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gYnNDbG9uZS5yZWFkQml0cyg2KSArIDE7XG4gICAgICAgIGlmIChjYW5kaWRhdGUgPT09IG1vZGVDb3VudCkge1xuICAgICAgICAgICAgZ290TW9kZUhlYWRlciA9IHRydWU7XG4gICAgICAgICAgICBsYXN0TW9kZUNvdW50ID0gbW9kZUNvdW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghZ290TW9kZUhlYWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgU2V0dXAgaGVhZGVyOiBtb2RlIGhlYWRlciBub3QgZm91bmQuJyk7XG4gICAgfVxuICAgIGlmIChsYXN0TW9kZUNvdW50ID4gNjMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtb2RlIGNvdW50OiAke2xhc3RNb2RlQ291bnR9LmApO1xuICAgIH1cbiAgICBjb25zdCBmaW5hbE1vZGVDb3VudCA9IGxhc3RNb2RlQ291bnQ7XG4gICAgLy8gLS0tIFJlaW5pdGlhbGl6ZSB0aGUgYml0c3RyZWFtLlxuICAgIGJpdHN0cmVhbS5wb3MgPSAwO1xuICAgIC8vIFNraXAgdGhlIGJpdHMgdXAgdG8gdGhlIGZvdW5kIGZyYW1pbmcgYml0LlxuICAgIGJpdHN0cmVhbS5za2lwQml0cyhnb3RGcmFtaW5nQml0KTtcbiAgICAvLyAtLS0gTm93IHJlYWQsIGZvciBlYWNoIG1vZGUgKGluIHJldmVyc2Ugb3JkZXIpLCA0MCBiaXRzIHRoZW4gb25lIGJpdC5cbiAgICAvLyBUaGF0IG9uZSBiaXQgaXMgdGhlIG1vZGUgYmxvY2tmbGFnLlxuICAgIGNvbnN0IG1vZGVCbG9ja2ZsYWdzID0gQXJyYXkoZmluYWxNb2RlQ291bnQpLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IGZpbmFsTW9kZUNvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYml0c3RyZWFtLnNraXBCaXRzKDQwKTtcbiAgICAgICAgbW9kZUJsb2NrZmxhZ3NbaV0gPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGVCbG9ja2ZsYWdzIH07XG59O1xuLyoqIERldGVybWluZXMgYSBwYWNrZXQncyB0eXBlIChrZXkgb3IgZGVsdGEpIGJ5IGRpZ2dpbmcgaW50byB0aGUgcGFja2V0IGJpdHN0cmVhbS4gKi9cbmV4cG9ydCBjb25zdCBkZXRlcm1pbmVWaWRlb1BhY2tldFR5cGUgPSBhc3luYyAodmlkZW9UcmFjaywgcGFja2V0KSA9PiB7XG4gICAgYXNzZXJ0KHZpZGVvVHJhY2suY29kZWMpO1xuICAgIHN3aXRjaCAodmlkZW9UcmFjay5jb2RlYykge1xuICAgICAgICBjYXNlICdhdmMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY29kZXJDb25maWcgPSBhd2FpdCB2aWRlb1RyYWNrLmdldERlY29kZXJDb25maWcoKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZGVjb2RlckNvbmZpZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFsVW5pdHMgPSBleHRyYWN0QXZjTmFsVW5pdHMocGFja2V0LmRhdGEsIGRlY29kZXJDb25maWcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzS2V5ZnJhbWUgPSBuYWxVbml0cy5zb21lKHggPT4gZXh0cmFjdE5hbFVuaXRUeXBlRm9yQXZjKHgpID09PSBBdmNOYWxVbml0VHlwZS5JRFIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0tleWZyYW1lID8gJ2tleScgOiAnZGVsdGEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICBjYXNlICdoZXZjJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVyQ29uZmlnID0gYXdhaXQgdmlkZW9UcmFjay5nZXREZWNvZGVyQ29uZmlnKCk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGRlY29kZXJDb25maWcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbFVuaXRzID0gZXh0cmFjdEhldmNOYWxVbml0cyhwYWNrZXQuZGF0YSwgZGVjb2RlckNvbmZpZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNLZXlmcmFtZSA9IG5hbFVuaXRzLnNvbWUoKHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGV4dHJhY3ROYWxVbml0VHlwZUZvckhldmMoeCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBIZXZjTmFsVW5pdFR5cGUuQkxBX1dfTFAgPD0gdHlwZSAmJiB0eXBlIDw9IEhldmNOYWxVbml0VHlwZS5SU1ZfSVJBUF9WQ0wyMztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNLZXlmcmFtZSA/ICdrZXknIDogJ2RlbHRhJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgY2FzZSAndnA4JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBWUDgsIG9uY2UgYWdhaW4sIGJ5IGZhciB0aGUgZWFzaWVzdCB0byBkZWFsIHdpdGguXG4gICAgICAgICAgICAgICAgY29uc3QgZnJhbWVUeXBlID0gcGFja2V0LmRhdGFbMF0gJiAwYjE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lVHlwZSA9PT0gMCA/ICdrZXknIDogJ2RlbHRhJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgY2FzZSAndnA5JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaXRzdHJlYW0gPSBuZXcgQml0c3RyZWFtKHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoYml0c3RyZWFtLnJlYWRCaXRzKDIpICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvZmlsZUxvd0JpdCA9IGJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9maWxlSGlnaEJpdCA9IGJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9maWxlID0gKHByb2ZpbGVIaWdoQml0IDw8IDEpICsgcHJvZmlsZUxvd0JpdDtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHJlc2VydmVkIGJpdCBmb3IgcHJvZmlsZSAzXG4gICAgICAgICAgICAgICAgaWYgKHByb2ZpbGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgYml0c3RyZWFtLnNraXBCaXRzKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzaG93RXhpc3RpbmdGcmFtZSA9IGJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvd0V4aXN0aW5nRnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lVHlwZSA9IGJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWVUeXBlID09PSAwID8gJ2tleScgOiAnZGVsdGEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICBjYXNlICdhdjEnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCByZWR1Y2VkU3RpbGxQaWN0dXJlSGVhZGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHR5cGUsIGRhdGEgfSBvZiBpdGVyYXRlQXYxUGFja2V0T2J1cyhwYWNrZXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IDEpIHsgLy8gT0JVX1NFUVVFTkNFX0hFQURFUlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYml0c3RyZWFtID0gbmV3IEJpdHN0cmVhbShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHN0cmVhbS5za2lwQml0cyg0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZHVjZWRTdGlsbFBpY3R1cmVIZWFkZXIgPSAhIWJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAzIC8vIE9CVV9GUkFNRV9IRUFERVJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IHR5cGUgPT09IDYgLy8gT0JVX0ZSQU1FXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCB0eXBlID09PSA3IC8vIE9CVV9SRURVTkRBTlRfRlJBTUVfSEVBREVSXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZHVjZWRTdGlsbFBpY3R1cmVIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2tleSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiaXRzdHJlYW0gPSBuZXcgQml0c3RyZWFtKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvd0V4aXN0aW5nRnJhbWUgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd0V4aXN0aW5nRnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lVHlwZSA9IGJpdHN0cmVhbS5yZWFkQml0cygyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZVR5cGUgPT09IDAgPyAna2V5JyA6ICdkZWx0YSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TmV2ZXIodmlkZW9UcmFjay5jb2RlYyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/codec-data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/codec.js":
/*!***********************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/codec.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AUDIO_CODECS: () => (/* binding */ AUDIO_CODECS),\n/* harmony export */   NON_PCM_AUDIO_CODECS: () => (/* binding */ NON_PCM_AUDIO_CODECS),\n/* harmony export */   OPUS_SAMPLE_RATE: () => (/* binding */ OPUS_SAMPLE_RATE),\n/* harmony export */   PCM_AUDIO_CODECS: () => (/* binding */ PCM_AUDIO_CODECS),\n/* harmony export */   SUBTITLE_CODECS: () => (/* binding */ SUBTITLE_CODECS),\n/* harmony export */   VIDEO_CODECS: () => (/* binding */ VIDEO_CODECS),\n/* harmony export */   VP9_LEVEL_TABLE: () => (/* binding */ VP9_LEVEL_TABLE),\n/* harmony export */   aacChannelMap: () => (/* binding */ aacChannelMap),\n/* harmony export */   aacFrequencyTable: () => (/* binding */ aacFrequencyTable),\n/* harmony export */   buildAudioCodecString: () => (/* binding */ buildAudioCodecString),\n/* harmony export */   buildVideoCodecString: () => (/* binding */ buildVideoCodecString),\n/* harmony export */   extractAudioCodecString: () => (/* binding */ extractAudioCodecString),\n/* harmony export */   extractVideoCodecString: () => (/* binding */ extractVideoCodecString),\n/* harmony export */   generateAv1CodecConfigurationFromCodecString: () => (/* binding */ generateAv1CodecConfigurationFromCodecString),\n/* harmony export */   generateVp9CodecConfigurationFromCodecString: () => (/* binding */ generateVp9CodecConfigurationFromCodecString),\n/* harmony export */   getAudioEncoderConfigExtension: () => (/* binding */ getAudioEncoderConfigExtension),\n/* harmony export */   getVideoEncoderConfigExtension: () => (/* binding */ getVideoEncoderConfigExtension),\n/* harmony export */   inferCodecFromCodecString: () => (/* binding */ inferCodecFromCodecString),\n/* harmony export */   parseAacAudioSpecificConfig: () => (/* binding */ parseAacAudioSpecificConfig),\n/* harmony export */   parsePcmCodec: () => (/* binding */ parsePcmCodec),\n/* harmony export */   validateAudioChunkMetadata: () => (/* binding */ validateAudioChunkMetadata),\n/* harmony export */   validateSubtitleMetadata: () => (/* binding */ validateSubtitleMetadata),\n/* harmony export */   validateVideoChunkMetadata: () => (/* binding */ validateVideoChunkMetadata)\n/* harmony export */ });\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n/**\n * List of known video codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nconst VIDEO_CODECS = [\n    'avc',\n    'hevc',\n    'vp9',\n    'av1',\n    'vp8',\n];\n/**\n * List of known PCM (uncompressed) audio codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nconst PCM_AUDIO_CODECS = [\n    'pcm-s16', // We don't prefix 'le' so we're compatible with the WebCodecs-registered PCM codec strings\n    'pcm-s16be',\n    'pcm-s24',\n    'pcm-s24be',\n    'pcm-s32',\n    'pcm-s32be',\n    'pcm-f32',\n    'pcm-f32be',\n    'pcm-f64',\n    'pcm-f64be',\n    'pcm-u8',\n    'pcm-s8',\n    'ulaw',\n    'alaw',\n];\n/**\n * List of known compressed audio codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nconst NON_PCM_AUDIO_CODECS = [\n    'aac',\n    'opus',\n    'mp3',\n    'vorbis',\n    'flac',\n];\n/**\n * List of known audio codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nconst AUDIO_CODECS = [\n    ...NON_PCM_AUDIO_CODECS,\n    ...PCM_AUDIO_CODECS,\n];\n/**\n * List of known subtitle codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nconst SUBTITLE_CODECS = [\n    'webvtt',\n]; // TODO add the rest\n// https://en.wikipedia.org/wiki/Advanced_Video_Coding\nconst AVC_LEVEL_TABLE = [\n    { maxMacroblocks: 99, maxBitrate: 64000, level: 0x0A }, // Level 1\n    { maxMacroblocks: 396, maxBitrate: 192000, level: 0x0B }, // Level 1.1\n    { maxMacroblocks: 396, maxBitrate: 384000, level: 0x0C }, // Level 1.2\n    { maxMacroblocks: 396, maxBitrate: 768000, level: 0x0D }, // Level 1.3\n    { maxMacroblocks: 396, maxBitrate: 2000000, level: 0x14 }, // Level 2\n    { maxMacroblocks: 792, maxBitrate: 4000000, level: 0x15 }, // Level 2.1\n    { maxMacroblocks: 1620, maxBitrate: 4000000, level: 0x16 }, // Level 2.2\n    { maxMacroblocks: 1620, maxBitrate: 10000000, level: 0x1E }, // Level 3\n    { maxMacroblocks: 3600, maxBitrate: 14000000, level: 0x1F }, // Level 3.1\n    { maxMacroblocks: 5120, maxBitrate: 20000000, level: 0x20 }, // Level 3.2\n    { maxMacroblocks: 8192, maxBitrate: 20000000, level: 0x28 }, // Level 4\n    { maxMacroblocks: 8192, maxBitrate: 50000000, level: 0x29 }, // Level 4.1\n    { maxMacroblocks: 8704, maxBitrate: 50000000, level: 0x2A }, // Level 4.2\n    { maxMacroblocks: 22080, maxBitrate: 135000000, level: 0x32 }, // Level 5\n    { maxMacroblocks: 36864, maxBitrate: 240000000, level: 0x33 }, // Level 5.1\n    { maxMacroblocks: 36864, maxBitrate: 240000000, level: 0x34 }, // Level 5.2\n    { maxMacroblocks: 139264, maxBitrate: 240000000, level: 0x3C }, // Level 6\n    { maxMacroblocks: 139264, maxBitrate: 480000000, level: 0x3D }, // Level 6.1\n    { maxMacroblocks: 139264, maxBitrate: 800000000, level: 0x3E }, // Level 6.2\n];\n// https://en.wikipedia.org/wiki/High_Efficiency_Video_Coding\nconst HEVC_LEVEL_TABLE = [\n    { maxPictureSize: 36864, maxBitrate: 128000, tier: 'L', level: 30 }, // Level 1 (Low Tier)\n    { maxPictureSize: 122880, maxBitrate: 1500000, tier: 'L', level: 60 }, // Level 2 (Low Tier)\n    { maxPictureSize: 245760, maxBitrate: 3000000, tier: 'L', level: 63 }, // Level 2.1 (Low Tier)\n    { maxPictureSize: 552960, maxBitrate: 6000000, tier: 'L', level: 90 }, // Level 3 (Low Tier)\n    { maxPictureSize: 983040, maxBitrate: 10000000, tier: 'L', level: 93 }, // Level 3.1 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 12000000, tier: 'L', level: 120 }, // Level 4 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 30000000, tier: 'H', level: 120 }, // Level 4 (High Tier)\n    { maxPictureSize: 2228224, maxBitrate: 20000000, tier: 'L', level: 123 }, // Level 4.1 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 50000000, tier: 'H', level: 123 }, // Level 4.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 25000000, tier: 'L', level: 150 }, // Level 5 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 100000000, tier: 'H', level: 150 }, // Level 5 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 40000000, tier: 'L', level: 153 }, // Level 5.1 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 160000000, tier: 'H', level: 153 }, // Level 5.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 60000000, tier: 'L', level: 156 }, // Level 5.2 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 240000000, tier: 'H', level: 156 }, // Level 5.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'L', level: 180 }, // Level 6 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 180 }, // Level 6 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 120000000, tier: 'L', level: 183 }, // Level 6.1 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 480000000, tier: 'H', level: 183 }, // Level 6.1 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'L', level: 186 }, // Level 6.2 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 186 }, // Level 6.2 (High Tier)\n];\n// https://en.wikipedia.org/wiki/VP9\nconst VP9_LEVEL_TABLE = [\n    { maxPictureSize: 36864, maxBitrate: 200000, level: 10 }, // Level 1\n    { maxPictureSize: 73728, maxBitrate: 800000, level: 11 }, // Level 1.1\n    { maxPictureSize: 122880, maxBitrate: 1800000, level: 20 }, // Level 2\n    { maxPictureSize: 245760, maxBitrate: 3600000, level: 21 }, // Level 2.1\n    { maxPictureSize: 552960, maxBitrate: 7200000, level: 30 }, // Level 3\n    { maxPictureSize: 983040, maxBitrate: 12000000, level: 31 }, // Level 3.1\n    { maxPictureSize: 2228224, maxBitrate: 18000000, level: 40 }, // Level 4\n    { maxPictureSize: 2228224, maxBitrate: 30000000, level: 41 }, // Level 4.1\n    { maxPictureSize: 8912896, maxBitrate: 60000000, level: 50 }, // Level 5\n    { maxPictureSize: 8912896, maxBitrate: 120000000, level: 51 }, // Level 5.1\n    { maxPictureSize: 8912896, maxBitrate: 180000000, level: 52 }, // Level 5.2\n    { maxPictureSize: 35651584, maxBitrate: 180000000, level: 60 }, // Level 6\n    { maxPictureSize: 35651584, maxBitrate: 240000000, level: 61 }, // Level 6.1\n    { maxPictureSize: 35651584, maxBitrate: 480000000, level: 62 }, // Level 6.2\n];\n// https://en.wikipedia.org/wiki/AV1\nconst AV1_LEVEL_TABLE = [\n    { maxPictureSize: 147456, maxBitrate: 1500000, tier: 'M', level: 0 }, // Level 2.0 (Main Tier)\n    { maxPictureSize: 278784, maxBitrate: 3000000, tier: 'M', level: 1 }, // Level 2.1 (Main Tier)\n    { maxPictureSize: 665856, maxBitrate: 6000000, tier: 'M', level: 4 }, // Level 3.0 (Main Tier)\n    { maxPictureSize: 1065024, maxBitrate: 10000000, tier: 'M', level: 5 }, // Level 3.1 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 12000000, tier: 'M', level: 8 }, // Level 4.0 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 30000000, tier: 'H', level: 8 }, // Level 4.0 (High Tier)\n    { maxPictureSize: 2359296, maxBitrate: 20000000, tier: 'M', level: 9 }, // Level 4.1 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 50000000, tier: 'H', level: 9 }, // Level 4.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 30000000, tier: 'M', level: 12 }, // Level 5.0 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 100000000, tier: 'H', level: 12 }, // Level 5.0 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 40000000, tier: 'M', level: 13 }, // Level 5.1 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 160000000, tier: 'H', level: 13 }, // Level 5.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 60000000, tier: 'M', level: 14 }, // Level 5.2 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 240000000, tier: 'H', level: 14 }, // Level 5.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'M', level: 15 }, // Level 5.3 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 15 }, // Level 5.3 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'M', level: 16 }, // Level 6.0 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 16 }, // Level 6.0 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 100000000, tier: 'M', level: 17 }, // Level 6.1 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 480000000, tier: 'H', level: 17 }, // Level 6.1 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 160000000, tier: 'M', level: 18 }, // Level 6.2 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 18 }, // Level 6.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 160000000, tier: 'M', level: 19 }, // Level 6.3 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 19 }, // Level 6.3 (High Tier)\n];\nconst VP9_DEFAULT_SUFFIX = '.01.01.01.01.00';\nconst AV1_DEFAULT_SUFFIX = '.0.110.01.01.01.0';\nconst buildVideoCodecString = (codec, width, height, bitrate) => {\n    if (codec === 'avc') {\n        const profileIndication = 0x64; // High Profile\n        const totalMacroblocks = Math.ceil(width / 16) * Math.ceil(height / 16);\n        // Determine the level based on the table\n        const levelInfo = AVC_LEVEL_TABLE.find(level => totalMacroblocks <= level.maxMacroblocks && bitrate <= level.maxBitrate) ?? (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.last)(AVC_LEVEL_TABLE);\n        const levelIndication = levelInfo ? levelInfo.level : 0;\n        const hexProfileIndication = profileIndication.toString(16).padStart(2, '0');\n        const hexProfileCompatibility = '00';\n        const hexLevelIndication = levelIndication.toString(16).padStart(2, '0');\n        return `avc1.${hexProfileIndication}${hexProfileCompatibility}${hexLevelIndication}`;\n    }\n    else if (codec === 'hevc') {\n        const profilePrefix = ''; // Profile space 0\n        const profileIdc = 1; // Main Profile\n        const compatibilityFlags = '6'; // Taken from the example in ISO 14496-15\n        const pictureSize = width * height;\n        const levelInfo = HEVC_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.last)(HEVC_LEVEL_TABLE);\n        const constraintFlags = 'B0'; // Progressive source flag\n        return 'hev1.'\n            + `${profilePrefix}${profileIdc}.`\n            + `${compatibilityFlags}.`\n            + `${levelInfo.tier}${levelInfo.level}.`\n            + `${constraintFlags}`;\n    }\n    else if (codec === 'vp8') {\n        return 'vp8'; // Easy, this one\n    }\n    else if (codec === 'vp9') {\n        const profile = '00'; // Profile 0\n        const pictureSize = width * height;\n        const levelInfo = VP9_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.last)(VP9_LEVEL_TABLE);\n        const bitDepth = '08'; // 8-bit\n        return `vp09.${profile}.${levelInfo.level.toString().padStart(2, '0')}.${bitDepth}`;\n    }\n    else if (codec === 'av1') {\n        const profile = 0; // Main Profile, single digit\n        const pictureSize = width * height;\n        const levelInfo = AV1_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.last)(AV1_LEVEL_TABLE);\n        const level = levelInfo.level.toString().padStart(2, '0');\n        const bitDepth = '08'; // 8-bit\n        return `av01.${profile}.${level}${levelInfo.tier}.${bitDepth}`;\n    }\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nconst generateVp9CodecConfigurationFromCodecString = (codecString) => {\n    // Reference: https://www.webmproject.org/docs/container/#vp9-codec-feature-metadata-codecprivate\n    const parts = codecString.split('.'); // We can derive the required values from the codec string\n    const profile = Number(parts[1]);\n    const level = Number(parts[2]);\n    const bitDepth = Number(parts[3]);\n    const chromaSubsampling = parts[4] ? Number(parts[4]) : 1;\n    return [\n        1, 1, profile,\n        2, 1, level,\n        3, 1, bitDepth,\n        4, 1, chromaSubsampling,\n    ];\n};\nconst generateAv1CodecConfigurationFromCodecString = (codecString) => {\n    // Reference: https://aomediacodec.github.io/av1-isobmff/\n    const parts = codecString.split('.'); // We can derive the required values from the codec string\n    const marker = 1;\n    const version = 1;\n    const firstByte = (marker << 7) + version;\n    const profile = Number(parts[1]);\n    const levelAndTier = parts[2];\n    const level = Number(levelAndTier.slice(0, -1));\n    const secondByte = (profile << 5) + level;\n    const tier = levelAndTier.slice(-1) === 'H' ? 1 : 0;\n    const bitDepth = Number(parts[3]);\n    const highBitDepth = bitDepth === 8 ? 0 : 1;\n    const twelveBit = 0;\n    const monochrome = parts[4] ? Number(parts[4]) : 0;\n    const chromaSubsamplingX = parts[5] ? Number(parts[5][0]) : 1;\n    const chromaSubsamplingY = parts[5] ? Number(parts[5][1]) : 1;\n    const chromaSamplePosition = parts[5] ? Number(parts[5][2]) : 0; // CSP_UNKNOWN\n    const thirdByte = (tier << 7)\n        + (highBitDepth << 6)\n        + (twelveBit << 5)\n        + (monochrome << 4)\n        + (chromaSubsamplingX << 3)\n        + (chromaSubsamplingY << 2)\n        + chromaSamplePosition;\n    const initialPresentationDelayPresent = 0; // Should be fine\n    const fourthByte = initialPresentationDelayPresent;\n    return [firstByte, secondByte, thirdByte, fourthByte];\n};\nconst extractVideoCodecString = (trackInfo) => {\n    const { codec, codecDescription, colorSpace, avcCodecInfo, hevcCodecInfo, vp9CodecInfo, av1CodecInfo } = trackInfo;\n    if (codec === 'avc') {\n        if (avcCodecInfo) {\n            const bytes = new Uint8Array([\n                avcCodecInfo.avcProfileIndication,\n                avcCodecInfo.profileCompatibility,\n                avcCodecInfo.avcLevelIndication,\n            ]);\n            return `avc1.${(0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHexString)(bytes)}`;\n        }\n        if (!codecDescription || codecDescription.byteLength < 4) {\n            throw new TypeError('AVC decoder description is not provided or is not at least 4 bytes long.');\n        }\n        return `avc1.${(0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHexString)(codecDescription.subarray(1, 4))}`;\n    }\n    else if (codec === 'hevc') {\n        let generalProfileSpace;\n        let generalProfileIdc;\n        let compatibilityFlags;\n        let generalTierFlag;\n        let generalLevelIdc;\n        let constraintFlags;\n        if (hevcCodecInfo) {\n            generalProfileSpace = hevcCodecInfo.generalProfileSpace;\n            generalProfileIdc = hevcCodecInfo.generalProfileIdc;\n            compatibilityFlags = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.reverseBitsU32)(hevcCodecInfo.generalProfileCompatibilityFlags);\n            generalTierFlag = hevcCodecInfo.generalTierFlag;\n            generalLevelIdc = hevcCodecInfo.generalLevelIdc;\n            constraintFlags = [...hevcCodecInfo.generalConstraintIndicatorFlags];\n        }\n        else {\n            if (!codecDescription || codecDescription.byteLength < 23) {\n                throw new TypeError('HEVC decoder description is not provided or is not at least 23 bytes long.');\n            }\n            const view = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.toDataView)(codecDescription);\n            const profileByte = view.getUint8(1);\n            generalProfileSpace = (profileByte >> 6) & 0x03;\n            generalProfileIdc = profileByte & 0x1F;\n            compatibilityFlags = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.reverseBitsU32)(view.getUint32(2));\n            generalTierFlag = (profileByte >> 5) & 0x01;\n            generalLevelIdc = view.getUint8(12);\n            constraintFlags = [];\n            for (let i = 0; i < 6; i++) {\n                constraintFlags.push(view.getUint8(6 + i));\n            }\n        }\n        let codecString = 'hev1.';\n        codecString += ['', 'A', 'B', 'C'][generalProfileSpace] + generalProfileIdc;\n        codecString += '.';\n        codecString += compatibilityFlags.toString(16).toUpperCase();\n        codecString += '.';\n        codecString += generalTierFlag === 0 ? 'L' : 'H';\n        codecString += generalLevelIdc;\n        while (constraintFlags.length > 0 && constraintFlags[constraintFlags.length - 1] === 0) {\n            constraintFlags.pop();\n        }\n        if (constraintFlags.length > 0) {\n            codecString += '.';\n            codecString += constraintFlags.map(x => x.toString(16).toUpperCase()).join('.');\n        }\n        return codecString;\n    }\n    else if (codec === 'vp8') {\n        return 'vp8'; // Easy, this one\n    }\n    else if (codec === 'vp9') {\n        if (!vp9CodecInfo) {\n            // Calculate level based on dimensions\n            const pictureSize = trackInfo.width * trackInfo.height;\n            let level = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.last)(VP9_LEVEL_TABLE).level; // Default to highest level\n            for (const entry of VP9_LEVEL_TABLE) {\n                if (pictureSize <= entry.maxPictureSize) {\n                    level = entry.level;\n                    break;\n                }\n            }\n            // We don't really know better, so let's return a general-purpose, common codec string and hope for the best\n            return `vp09.00.${level.toString().padStart(2, '0')}.08`;\n        }\n        const profile = vp9CodecInfo.profile.toString().padStart(2, '0');\n        const level = vp9CodecInfo.level.toString().padStart(2, '0');\n        const bitDepth = vp9CodecInfo.bitDepth.toString().padStart(2, '0');\n        const chromaSubsampling = vp9CodecInfo.chromaSubsampling.toString().padStart(2, '0');\n        const colourPrimaries = vp9CodecInfo.colourPrimaries.toString().padStart(2, '0');\n        const transferCharacteristics = vp9CodecInfo.transferCharacteristics.toString().padStart(2, '0');\n        const matrixCoefficients = vp9CodecInfo.matrixCoefficients.toString().padStart(2, '0');\n        const videoFullRangeFlag = vp9CodecInfo.videoFullRangeFlag.toString().padStart(2, '0');\n        let string = `vp09.${profile}.${level}.${bitDepth}.${chromaSubsampling}`;\n        string += `.${colourPrimaries}.${transferCharacteristics}.${matrixCoefficients}.${videoFullRangeFlag}`;\n        if (string.endsWith(VP9_DEFAULT_SUFFIX)) {\n            string = string.slice(0, -VP9_DEFAULT_SUFFIX.length);\n        }\n        return string;\n    }\n    else if (codec === 'av1') {\n        if (!av1CodecInfo) {\n            // Calculate level based on dimensions\n            const pictureSize = trackInfo.width * trackInfo.height;\n            let level = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.last)(VP9_LEVEL_TABLE).level; // Default to highest level\n            for (const entry of VP9_LEVEL_TABLE) {\n                if (pictureSize <= entry.maxPictureSize) {\n                    level = entry.level;\n                    break;\n                }\n            }\n            // We don't really know better, so let's return a general-purpose, common codec string and hope for the best\n            return `av01.0.${level.toString().padStart(2, '0')}M.08`;\n        }\n        // https://aomediacodec.github.io/av1-isobmff/#codecsparam\n        const profile = av1CodecInfo.profile; // Single digit\n        const level = av1CodecInfo.level.toString().padStart(2, '0');\n        const tier = av1CodecInfo.tier ? 'H' : 'M';\n        const bitDepth = av1CodecInfo.bitDepth.toString().padStart(2, '0');\n        const monochrome = av1CodecInfo.monochrome ? '1' : '0';\n        const chromaSubsampling = 100 * av1CodecInfo.chromaSubsamplingX\n            + 10 * av1CodecInfo.chromaSubsamplingY\n            + 1 * (av1CodecInfo.chromaSubsamplingX && av1CodecInfo.chromaSubsamplingY\n                ? av1CodecInfo.chromaSamplePosition\n                : 0);\n        // The defaults are 1 (ITU-R BT.709)\n        const colorPrimaries = colorSpace?.primaries ? _misc_js__WEBPACK_IMPORTED_MODULE_0__.COLOR_PRIMARIES_MAP[colorSpace.primaries] : 1;\n        const transferCharacteristics = colorSpace?.transfer ? _misc_js__WEBPACK_IMPORTED_MODULE_0__.TRANSFER_CHARACTERISTICS_MAP[colorSpace.transfer] : 1;\n        const matrixCoefficients = colorSpace?.matrix ? _misc_js__WEBPACK_IMPORTED_MODULE_0__.MATRIX_COEFFICIENTS_MAP[colorSpace.matrix] : 1;\n        const videoFullRangeFlag = colorSpace?.fullRange ? 1 : 0;\n        let string = `av01.${profile}.${level}${tier}.${bitDepth}`;\n        string += `.${monochrome}.${chromaSubsampling.toString().padStart(3, '0')}`;\n        string += `.${colorPrimaries.toString().padStart(2, '0')}`;\n        string += `.${transferCharacteristics.toString().padStart(2, '0')}`;\n        string += `.${matrixCoefficients.toString().padStart(2, '0')}`;\n        string += `.${videoFullRangeFlag}`;\n        if (string.endsWith(AV1_DEFAULT_SUFFIX)) {\n            string = string.slice(0, -AV1_DEFAULT_SUFFIX.length);\n        }\n        return string;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nconst buildAudioCodecString = (codec, numberOfChannels, sampleRate) => {\n    if (codec === 'aac') {\n        // If stereo or higher channels and lower sample rate, likely using HE-AAC v2 with PS\n        if (numberOfChannels >= 2 && sampleRate <= 24000) {\n            return 'mp4a.40.29'; // HE-AAC v2 (AAC LC + SBR + PS)\n        }\n        // If sample rate is low, likely using HE-AAC v1 with SBR\n        if (sampleRate <= 24000) {\n            return 'mp4a.40.5'; // HE-AAC v1 (AAC LC + SBR)\n        }\n        // Default to standard AAC-LC for higher sample rates\n        return 'mp4a.40.2'; // AAC-LC\n    }\n    else if (codec === 'mp3') {\n        return 'mp3';\n    }\n    else if (codec === 'opus') {\n        return 'opus';\n    }\n    else if (codec === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codec === 'flac') {\n        return 'flac';\n    }\n    else if (PCM_AUDIO_CODECS.includes(codec)) {\n        return codec;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nconst extractAudioCodecString = (trackInfo) => {\n    const { codec, codecDescription, aacCodecInfo } = trackInfo;\n    if (codec === 'aac') {\n        if (!aacCodecInfo) {\n            throw new TypeError('AAC codec info must be provided.');\n        }\n        if (aacCodecInfo.isMpeg2) {\n            return 'mp4a.67';\n        }\n        else {\n            const audioSpecificConfig = parseAacAudioSpecificConfig(codecDescription);\n            return `mp4a.40.${audioSpecificConfig.objectType}`;\n        }\n    }\n    else if (codec === 'mp3') {\n        return 'mp3';\n    }\n    else if (codec === 'opus') {\n        return 'opus';\n    }\n    else if (codec === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codec === 'flac') {\n        return 'flac';\n    }\n    else if (codec && PCM_AUDIO_CODECS.includes(codec)) {\n        return codec;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nconst aacFrequencyTable = [\n    96000, 88200, 64000, 48000, 44100, 32000,\n    24000, 22050, 16000, 12000, 11025, 8000, 7350,\n];\nconst aacChannelMap = [-1, 1, 2, 3, 4, 5, 6, 8];\nconst parseAacAudioSpecificConfig = (bytes) => {\n    if (!bytes || bytes.byteLength < 2) {\n        throw new TypeError('AAC description must be at least 2 bytes long.');\n    }\n    const bitstream = new _misc_js__WEBPACK_IMPORTED_MODULE_0__.Bitstream(bytes);\n    let objectType = bitstream.readBits(5);\n    if (objectType === 31) {\n        objectType = 32 + bitstream.readBits(6);\n    }\n    const frequencyIndex = bitstream.readBits(4);\n    let sampleRate = null;\n    if (frequencyIndex === 15) {\n        sampleRate = bitstream.readBits(24);\n    }\n    else {\n        if (frequencyIndex < aacFrequencyTable.length) {\n            sampleRate = aacFrequencyTable[frequencyIndex];\n        }\n    }\n    const channelConfiguration = bitstream.readBits(4);\n    let numberOfChannels = null;\n    if (channelConfiguration >= 1 && channelConfiguration <= 7) {\n        numberOfChannels = aacChannelMap[channelConfiguration];\n    }\n    return {\n        objectType,\n        frequencyIndex,\n        sampleRate,\n        channelConfiguration,\n        numberOfChannels,\n    };\n};\nconst OPUS_SAMPLE_RATE = 48_000;\nconst PCM_CODEC_REGEX = /^pcm-([usf])(\\d+)+(be)?$/;\nconst parsePcmCodec = (codec) => {\n    (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(PCM_AUDIO_CODECS.includes(codec));\n    if (codec === 'ulaw') {\n        return { dataType: 'ulaw', sampleSize: 1, littleEndian: true, silentValue: 255 };\n    }\n    else if (codec === 'alaw') {\n        return { dataType: 'alaw', sampleSize: 1, littleEndian: true, silentValue: 213 };\n    }\n    const match = PCM_CODEC_REGEX.exec(codec);\n    (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(match);\n    let dataType;\n    if (match[1] === 'u') {\n        dataType = 'unsigned';\n    }\n    else if (match[1] === 's') {\n        dataType = 'signed';\n    }\n    else {\n        dataType = 'float';\n    }\n    const sampleSize = (Number(match[2]) / 8);\n    const littleEndian = match[3] !== 'be';\n    const silentValue = codec === 'pcm-u8' ? 2 ** 7 : 0;\n    return { dataType, sampleSize, littleEndian, silentValue };\n};\nconst inferCodecFromCodecString = (codecString) => {\n    // Video codecs\n    if (codecString.startsWith('avc1') || codecString.startsWith('avc3')) {\n        return 'avc';\n    }\n    else if (codecString.startsWith('hev1') || codecString.startsWith('hvc1')) {\n        return 'hevc';\n    }\n    else if (codecString === 'vp8') {\n        return 'vp8';\n    }\n    else if (codecString.startsWith('vp09')) {\n        return 'vp9';\n    }\n    else if (codecString.startsWith('av01')) {\n        return 'av1';\n    }\n    // Audio codecs\n    if (codecString.startsWith('mp4a.40') || codecString === 'mp4a.67') {\n        return 'aac';\n    }\n    else if (codecString === 'mp3'\n        || codecString === 'mp4a.69'\n        || codecString === 'mp4a.6B'\n        || codecString === 'mp4a.6b') {\n        return 'mp3';\n    }\n    else if (codecString === 'opus') {\n        return 'opus';\n    }\n    else if (codecString === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codecString === 'flac') {\n        return 'flac';\n    }\n    else if (codecString === 'ulaw') {\n        return 'ulaw';\n    }\n    else if (codecString === 'alaw') {\n        return 'alaw';\n    }\n    else if (PCM_CODEC_REGEX.test(codecString)) {\n        return codecString;\n    }\n    // Subtitle codecs\n    if (codecString === 'webvtt') {\n        return 'webvtt';\n    }\n    return null;\n};\nconst getVideoEncoderConfigExtension = (codec) => {\n    if (codec === 'avc') {\n        return {\n            avc: {\n                format: 'avc', // Ensure the format is not Annex B\n            },\n        };\n    }\n    else if (codec === 'hevc') {\n        return {\n            hevc: {\n                format: 'hevc', // Ensure the format is not Annex B\n            },\n        };\n    }\n    return {};\n};\nconst getAudioEncoderConfigExtension = (codec) => {\n    if (codec === 'aac') {\n        return {\n            aac: {\n                format: 'aac', // Ensure the format is not ADTS\n            },\n        };\n    }\n    else if (codec === 'opus') {\n        return {\n            opus: {\n                format: 'opus',\n            },\n        };\n    }\n    return {};\n};\nconst VALID_VIDEO_CODEC_STRING_PREFIXES = ['avc1', 'avc3', 'hev1', 'hvc1', 'vp8', 'vp09', 'av01'];\nconst AVC_CODEC_STRING_REGEX = /^(avc1|avc3)\\.[0-9a-fA-F]{6}$/;\nconst HEVC_CODEC_STRING_REGEX = /^(hev1|hvc1)\\.(?:[ABC]?\\d+)\\.[0-9a-fA-F]{1,8}\\.[LH]\\d+(?:\\.[0-9a-fA-F]{1,2}){0,6}$/;\nconst VP9_CODEC_STRING_REGEX = /^vp09(?:\\.\\d{2}){3}(?:(?:\\.\\d{2}){5})?$/;\nconst AV1_CODEC_STRING_REGEX = /^av01\\.\\d\\.\\d{2}[MH]\\.\\d{2}(?:\\.\\d\\.\\d{3}\\.\\d{2}\\.\\d{2}\\.\\d{2}\\.\\d)?$/;\nconst validateVideoChunkMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Video chunk metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Video chunk metadata must be an object.');\n    }\n    if (!metadata.decoderConfig) {\n        throw new TypeError('Video chunk metadata must include a decoder configuration.');\n    }\n    if (typeof metadata.decoderConfig !== 'object') {\n        throw new TypeError('Video chunk metadata decoder configuration must be an object.');\n    }\n    if (typeof metadata.decoderConfig.codec !== 'string') {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a codec string.');\n    }\n    if (!VALID_VIDEO_CODEC_STRING_PREFIXES.some(prefix => metadata.decoderConfig.codec.startsWith(prefix))) {\n        throw new TypeError('Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in'\n            + ' the WebCodecs Codec Registry.');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.codedWidth) || metadata.decoderConfig.codedWidth <= 0) {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.codedHeight) || metadata.decoderConfig.codedHeight <= 0) {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).');\n    }\n    if (metadata.decoderConfig.description !== undefined) {\n        if (!(0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.isAllowSharedBufferSource)(metadata.decoderConfig.description)) {\n            throw new TypeError('Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an'\n                + ' ArrayBuffer view.');\n        }\n    }\n    if (metadata.decoderConfig.colorSpace !== undefined) {\n        const { colorSpace } = metadata.decoderConfig;\n        if (typeof colorSpace !== 'object') {\n            throw new TypeError('Video chunk metadata decoder configuration colorSpace, when provided, must be an object.');\n        }\n        const primariesValues = Object.keys(_misc_js__WEBPACK_IMPORTED_MODULE_0__.COLOR_PRIMARIES_MAP);\n        if (colorSpace.primaries != null && !primariesValues.includes(colorSpace.primaries)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of`\n                + ` ${primariesValues.join(', ')}.`);\n        }\n        const transferValues = Object.keys(_misc_js__WEBPACK_IMPORTED_MODULE_0__.TRANSFER_CHARACTERISTICS_MAP);\n        if (colorSpace.transfer != null && !transferValues.includes(colorSpace.transfer)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of`\n                + ` ${transferValues.join(', ')}.`);\n        }\n        const matrixValues = Object.keys(_misc_js__WEBPACK_IMPORTED_MODULE_0__.MATRIX_COEFFICIENTS_MAP);\n        if (colorSpace.matrix != null && !matrixValues.includes(colorSpace.matrix)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of`\n                + ` ${matrixValues.join(', ')}.`);\n        }\n        if (colorSpace.fullRange != null && typeof colorSpace.fullRange !== 'boolean') {\n            throw new TypeError('Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.');\n        }\n    }\n    if (metadata.decoderConfig.codec.startsWith('avc1') || metadata.decoderConfig.codec.startsWith('avc3')) {\n        // AVC-specific validation\n        if (!AVC_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as'\n                + ' specified in Section 3.4 of RFC 6381.');\n        }\n        // `description` may or may not be set, depending on if the format is AVCC or Annex B, so don't perform any\n        // validation for it.\n        // https://www.w3.org/TR/webcodecs-avc-codec-registration\n    }\n    else if (metadata.decoderConfig.codec.startsWith('hev1') || metadata.decoderConfig.codec.startsWith('hvc1')) {\n        // HEVC-specific validation\n        if (!HEVC_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as'\n                + ' specified in Section E.3 of ISO 14496-15.');\n        }\n        // `description` may or may not be set, depending on if the format is HEVC or Annex B, so don't perform any\n        // validation for it.\n        // https://www.w3.org/TR/webcodecs-hevc-codec-registration\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vp8')) {\n        // VP8-specific validation\n        if (metadata.decoderConfig.codec !== 'vp8') {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be \"vp8\".');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vp09')) {\n        // VP9-specific validation\n        if (!VP9_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as'\n                + ' specified in Section \"Codecs Parameter String\" of https://www.webmproject.org/vp9/mp4/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('av01')) {\n        // AV1-specific validation\n        if (!AV1_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as'\n                + ' specified in Section \"Codecs Parameter String\" of https://aomediacodec.github.io/av1-isobmff/.');\n        }\n    }\n};\nconst VALID_AUDIO_CODEC_STRING_PREFIXES = ['mp4a', 'mp3', 'opus', 'vorbis', 'flac', 'ulaw', 'alaw', 'pcm'];\nconst validateAudioChunkMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Audio chunk metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Audio chunk metadata must be an object.');\n    }\n    if (!metadata.decoderConfig) {\n        throw new TypeError('Audio chunk metadata must include a decoder configuration.');\n    }\n    if (typeof metadata.decoderConfig !== 'object') {\n        throw new TypeError('Audio chunk metadata decoder configuration must be an object.');\n    }\n    if (typeof metadata.decoderConfig.codec !== 'string') {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a codec string.');\n    }\n    if (!VALID_AUDIO_CODEC_STRING_PREFIXES.some(prefix => metadata.decoderConfig.codec.startsWith(prefix))) {\n        throw new TypeError('Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in'\n            + ' the WebCodecs Codec Registry.');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.sampleRate) || metadata.decoderConfig.sampleRate <= 0) {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.numberOfChannels) || metadata.decoderConfig.numberOfChannels <= 0) {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).');\n    }\n    if (metadata.decoderConfig.description !== undefined) {\n        if (!(0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.isAllowSharedBufferSource)(metadata.decoderConfig.description)) {\n            throw new TypeError('Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an'\n                + ' ArrayBuffer view.');\n        }\n    }\n    if (metadata.decoderConfig.codec.startsWith('mp4a')\n        // These three refer to MP3:\n        && metadata.decoderConfig.codec !== 'mp4a.69'\n        && metadata.decoderConfig.codec !== 'mp4a.6B'\n        && metadata.decoderConfig.codec !== 'mp4a.6b') {\n        // AAC-specific validation\n        const validStrings = ['mp4a.40.2', 'mp4a.40.02', 'mp4a.40.5', 'mp4a.40.05', 'mp4a.40.29', 'mp4a.67'];\n        if (!validStrings.includes(metadata.decoderConfig.codec)) {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as'\n                + ' specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/.');\n        }\n        if (!metadata.decoderConfig.description) {\n            throw new TypeError('Audio chunk metadata decoder configuration for AAC must include a description, which is expected to be'\n                + ' an AudioSpecificConfig as specified in ISO 14496-3.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('mp3') || metadata.decoderConfig.codec.startsWith('mp4a')) {\n        // MP3-specific validation\n        if (metadata.decoderConfig.codec !== 'mp3'\n            && metadata.decoderConfig.codec !== 'mp4a.69'\n            && metadata.decoderConfig.codec !== 'mp4a.6B'\n            && metadata.decoderConfig.codec !== 'mp4a.6b') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for MP3 must be \"mp3\", \"mp4a.69\" or'\n                + ' \"mp4a.6B\".');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('opus')) {\n        // Opus-specific validation\n        if (metadata.decoderConfig.codec !== 'opus') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be \"opus\".');\n        }\n        if (metadata.decoderConfig.description && metadata.decoderConfig.description.byteLength < 18) {\n            // Description is optional for Opus per-spec, so we shouldn't enforce it\n            throw new TypeError('Audio chunk metadata decoder configuration description, when specified, is expected to be an'\n                + ' Identification Header as specified in Section 5.1 of RFC 7845.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vorbis')) {\n        // Vorbis-specific validation\n        if (metadata.decoderConfig.codec !== 'vorbis') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for Vorbis must be \"vorbis\".');\n        }\n        if (!metadata.decoderConfig.description) {\n            throw new TypeError('Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to'\n                + ' adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('flac')) {\n        // FLAC-specific validation\n        if (metadata.decoderConfig.codec !== 'flac') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be \"flac\".');\n        }\n        const minDescriptionSize = 4 + 4 + 34; // 'fLaC' + metadata block header + STREAMINFO block\n        if (!metadata.decoderConfig.description || metadata.decoderConfig.description.byteLength < minDescriptionSize) {\n            throw new TypeError('Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to'\n                + ' adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('pcm')\n        || metadata.decoderConfig.codec.startsWith('ulaw')\n        || metadata.decoderConfig.codec.startsWith('alaw')) {\n        // PCM-specific validation\n        if (!PCM_AUDIO_CODECS.includes(metadata.decoderConfig.codec)) {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM'\n                + ` codecs (${PCM_AUDIO_CODECS.join(', ')}).`);\n        }\n    }\n};\nconst validateSubtitleMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Subtitle metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Subtitle metadata must be an object.');\n    }\n    if (!metadata.config) {\n        throw new TypeError('Subtitle metadata must include a config object.');\n    }\n    if (typeof metadata.config !== 'object') {\n        throw new TypeError('Subtitle metadata config must be an object.');\n    }\n    if (typeof metadata.config.description !== 'string') {\n        throw new TypeError('Subtitle metadata config description must be a string.');\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL2NvZGVjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBNO0FBQzFNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLG9EQUFvRDtBQUMxRCxNQUFNLHNEQUFzRDtBQUM1RCxNQUFNLHNEQUFzRDtBQUM1RCxNQUFNLHNEQUFzRDtBQUM1RCxNQUFNLHVEQUF1RDtBQUM3RCxNQUFNLHVEQUF1RDtBQUM3RCxNQUFNLHdEQUF3RDtBQUM5RCxNQUFNLHlEQUF5RDtBQUMvRCxNQUFNLHlEQUF5RDtBQUMvRCxNQUFNLHlEQUF5RDtBQUMvRCxNQUFNLHlEQUF5RDtBQUMvRCxNQUFNLHlEQUF5RDtBQUMvRCxNQUFNLHlEQUF5RDtBQUMvRCxNQUFNLDJEQUEyRDtBQUNqRSxNQUFNLDJEQUEyRDtBQUNqRSxNQUFNLDJEQUEyRDtBQUNqRSxNQUFNLDREQUE0RDtBQUNsRSxNQUFNLDREQUE0RDtBQUNsRSxNQUFNLDREQUE0RDtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlFQUFpRTtBQUN2RSxNQUFNLG1FQUFtRTtBQUN6RSxNQUFNLG1FQUFtRTtBQUN6RSxNQUFNLG1FQUFtRTtBQUN6RSxNQUFNLG9FQUFvRTtBQUMxRSxNQUFNLHNFQUFzRTtBQUM1RSxNQUFNLHNFQUFzRTtBQUM1RSxNQUFNLHNFQUFzRTtBQUM1RSxNQUFNLHNFQUFzRTtBQUM1RSxNQUFNLHNFQUFzRTtBQUM1RSxNQUFNLHVFQUF1RTtBQUM3RSxNQUFNLHNFQUFzRTtBQUM1RSxNQUFNLHVFQUF1RTtBQUM3RSxNQUFNLHNFQUFzRTtBQUM1RSxNQUFNLHVFQUF1RTtBQUM3RSxNQUFNLHVFQUF1RTtBQUM3RSxNQUFNLHdFQUF3RTtBQUM5RSxNQUFNLHdFQUF3RTtBQUM5RSxNQUFNLHdFQUF3RTtBQUM5RSxNQUFNLHdFQUF3RTtBQUM5RSxNQUFNLHdFQUF3RTtBQUM5RTtBQUNBO0FBQ087QUFDUCxNQUFNLHNEQUFzRDtBQUM1RCxNQUFNLHNEQUFzRDtBQUM1RCxNQUFNLHdEQUF3RDtBQUM5RCxNQUFNLHdEQUF3RDtBQUM5RCxNQUFNLHdEQUF3RDtBQUM5RCxNQUFNLHlEQUF5RDtBQUMvRCxNQUFNLDBEQUEwRDtBQUNoRSxNQUFNLDBEQUEwRDtBQUNoRSxNQUFNLDBEQUEwRDtBQUNoRSxNQUFNLDJEQUEyRDtBQUNqRSxNQUFNLDJEQUEyRDtBQUNqRSxNQUFNLDREQUE0RDtBQUNsRSxNQUFNLDREQUE0RDtBQUNsRSxNQUFNLDREQUE0RDtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtFQUFrRTtBQUN4RSxNQUFNLGtFQUFrRTtBQUN4RSxNQUFNLGtFQUFrRTtBQUN4RSxNQUFNLG9FQUFvRTtBQUMxRSxNQUFNLG9FQUFvRTtBQUMxRSxNQUFNLG9FQUFvRTtBQUMxRSxNQUFNLG9FQUFvRTtBQUMxRSxNQUFNLG9FQUFvRTtBQUMxRSxNQUFNLHFFQUFxRTtBQUMzRSxNQUFNLHNFQUFzRTtBQUM1RSxNQUFNLHFFQUFxRTtBQUMzRSxNQUFNLHNFQUFzRTtBQUM1RSxNQUFNLHFFQUFxRTtBQUMzRSxNQUFNLHNFQUFzRTtBQUM1RSxNQUFNLHNFQUFzRTtBQUM1RSxNQUFNLHVFQUF1RTtBQUM3RSxNQUFN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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRjaC1jdXQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL21lZGlhYnVubnkvZGlzdC9tb2R1bGVzL3NyYy9jb2RlYy5qcz81YTM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDI1LXByZXNlbnQsIFZhbmlsYWd5IGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgQml0c3RyZWFtLCBDT0xPUl9QUklNQVJJRVNfTUFQLCBNQVRSSVhfQ09FRkZJQ0lFTlRTX01BUCwgVFJBTlNGRVJfQ0hBUkFDVEVSSVNUSUNTX01BUCwgYXNzZXJ0LCBieXRlc1RvSGV4U3RyaW5nLCBpc0FsbG93U2hhcmVkQnVmZmVyU291cmNlLCBsYXN0LCByZXZlcnNlQml0c1UzMiwgdG9EYXRhVmlldywgfSBmcm9tICcuL21pc2MuanMnO1xuLyoqXG4gKiBMaXN0IG9mIGtub3duIHZpZGVvIGNvZGVjcywgb3JkZXJlZCBieSBlbmNvZGluZyBwcmVmZXJlbmNlLlxuICogQGdyb3VwIENvZGVjc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgVklERU9fQ09ERUNTID0gW1xuICAgICdhdmMnLFxuICAgICdoZXZjJyxcbiAgICAndnA5JyxcbiAgICAnYXYxJyxcbiAgICAndnA4Jyxcbl07XG4vKipcbiAqIExpc3Qgb2Yga25vd24gUENNICh1bmNvbXByZXNzZWQpIGF1ZGlvIGNvZGVjcywgb3JkZXJlZCBieSBlbmNvZGluZyBwcmVmZXJlbmNlLlxuICogQGdyb3VwIENvZGVjc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgUENNX0FVRElPX0NPREVDUyA9IFtcbiAgICAncGNtLXMxNicsIC8vIFdlIGRvbid0IHByZWZpeCAnbGUnIHNvIHdlJ3JlIGNvbXBhdGlibGUgd2l0aCB0aGUgV2ViQ29kZWNzLXJlZ2lzdGVyZWQgUENNIGNvZGVjIHN0cmluZ3NcbiAgICAncGNtLXMxNmJlJyxcbiAgICAncGNtLXMyNCcsXG4gICAgJ3BjbS1zMjRiZScsXG4gICAgJ3BjbS1zMzInLFxuICAgICdwY20tczMyYmUnLFxuICAgICdwY20tZjMyJyxcbiAgICAncGNtLWYzMmJlJyxcbiAgICAncGNtLWY2NCcsXG4gICAgJ3BjbS1mNjRiZScsXG4gICAgJ3BjbS11OCcsXG4gICAgJ3BjbS1zOCcsXG4gICAgJ3VsYXcnLFxuICAgICdhbGF3Jyxcbl07XG4vKipcbiAqIExpc3Qgb2Yga25vd24gY29tcHJlc3NlZCBhdWRpbyBjb2RlY3MsIG9yZGVyZWQgYnkgZW5jb2RpbmcgcHJlZmVyZW5jZS5cbiAqIEBncm91cCBDb2RlY3NcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IE5PTl9QQ01fQVVESU9fQ09ERUNTID0gW1xuICAgICdhYWMnLFxuICAgICdvcHVzJyxcbiAgICAnbXAzJyxcbiAgICAndm9yYmlzJyxcbiAgICAnZmxhYycsXG5dO1xuLyoqXG4gKiBMaXN0IG9mIGtub3duIGF1ZGlvIGNvZGVjcywgb3JkZXJlZCBieSBlbmNvZGluZyBwcmVmZXJlbmNlLlxuICogQGdyb3VwIENvZGVjc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgQVVESU9fQ09ERUNTID0gW1xuICAgIC4uLk5PTl9QQ01fQVVESU9fQ09ERUNTLFxuICAgIC4uLlBDTV9BVURJT19DT0RFQ1MsXG5dO1xuLyoqXG4gKiBMaXN0IG9mIGtub3duIHN1YnRpdGxlIGNvZGVjcywgb3JkZXJlZCBieSBlbmNvZGluZyBwcmVmZXJlbmNlLlxuICogQGdyb3VwIENvZGVjc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgU1VCVElUTEVfQ09ERUNTID0gW1xuICAgICd3ZWJ2dHQnLFxuXTsgLy8gVE9ETyBhZGQgdGhlIHJlc3Rcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FkdmFuY2VkX1ZpZGVvX0NvZGluZ1xuY29uc3QgQVZDX0xFVkVMX1RBQkxFID0gW1xuICAgIHsgbWF4TWFjcm9ibG9ja3M6IDk5LCBtYXhCaXRyYXRlOiA2NDAwMCwgbGV2ZWw6IDB4MEEgfSwgLy8gTGV2ZWwgMVxuICAgIHsgbWF4TWFjcm9ibG9ja3M6IDM5NiwgbWF4Qml0cmF0ZTogMTkyMDAwLCBsZXZlbDogMHgwQiB9LCAvLyBMZXZlbCAxLjFcbiAgICB7IG1heE1hY3JvYmxvY2tzOiAzOTYsIG1heEJpdHJhdGU6IDM4NDAwMCwgbGV2ZWw6IDB4MEMgfSwgLy8gTGV2ZWwgMS4yXG4gICAgeyBtYXhNYWNyb2Jsb2NrczogMzk2LCBtYXhCaXRyYXRlOiA3NjgwMDAsIGxldmVsOiAweDBEIH0sIC8vIExldmVsIDEuM1xuICAgIHsgbWF4TWFjcm9ibG9ja3M6IDM5NiwgbWF4Qml0cmF0ZTogMjAwMDAwMCwgbGV2ZWw6IDB4MTQgfSwgLy8gTGV2ZWwgMlxuICAgIHsgbWF4TWFjcm9ibG9ja3M6IDc5MiwgbWF4Qml0cmF0ZTogNDAwMDAwMCwgbGV2ZWw6IDB4MTUgfSwgLy8gTGV2ZWwgMi4xXG4gICAgeyBtYXhNYWNyb2Jsb2NrczogMTYyMCwgbWF4Qml0cmF0ZTogNDAwMDAwMCwgbGV2ZWw6IDB4MTYgfSwgLy8gTGV2ZWwgMi4yXG4gICAgeyBtYXhNYWNyb2Jsb2NrczogMTYyMCwgbWF4Qml0cmF0ZTogMTAwMDAwMDAsIGxldmVsOiAweDFFIH0sIC8vIExldmVsIDNcbiAgICB7IG1heE1hY3JvYmxvY2tzOiAzNjAwLCBtYXhCaXRyYXRlOiAxNDAwMDAwMCwgbGV2ZWw6IDB4MUYgfSwgLy8gTGV2ZWwgMy4xXG4gICAgeyBtYXhNYWNyb2Jsb2NrczogNTEyMCwgbWF4Qml0cmF0ZTogMjAwMDAwMDAsIGxldmVsOiAweDIwIH0sIC8vIExldmVsIDMuMlxuICAgIHsgbWF4TWFjcm9ibG9ja3M6IDgxOTIsIG1heEJpdHJhdGU6IDIwMDAwMDAwLCBsZXZlbDogMHgyOCB9LCAvLyBMZXZlbCA0XG4gICAgeyBtYXhNYWNyb2Jsb2NrczogODE5MiwgbWF4Qml0cmF0ZTogNTAwMDAwMDAsIGxldmVsOiAweDI5IH0sIC8vIExldmVsIDQuMVxuICAgIHsgbWF4TWFjcm9ibG9ja3M6IDg3MDQsIG1heEJpdHJhdGU6IDUwMDAwMDAwLCBsZXZlbDogMHgyQSB9LCAvLyBMZXZlbCA0LjJcbiAgICB7IG1heE1hY3JvYmxvY2tzOiAyMjA4MCwgbWF4Qml0cmF0ZTogMTM1MDAwMDAwLCBsZXZlbDogMHgzMiB9LCAvLyBMZXZlbCA1XG4gICAgeyBtYXhNYWNyb2Jsb2NrczogMzY4NjQsIG1heEJpdHJhdGU6IDI0MDAwMDAwMCwgbGV2ZWw6IDB4MzMgfSwgLy8gTGV2ZWwgNS4xXG4gICAgeyBtYXhNYWNyb2Jsb2NrczogMzY4NjQsIG1heEJpdHJhdGU6IDI0MDAwMDAwMCwgbGV2ZWw6IDB4MzQgfSwgLy8gTGV2ZWwgNS4yXG4gICAgeyBtYXhNYWNyb2Jsb2NrczogMTM5MjY0LCBtYXhCaXRyYXRlOiAyNDAwMDAwMDAsIGxldmVsOiAweDNDIH0sIC8vIExldmVsIDZcbiAgICB7IG1heE1hY3JvYmxvY2tzOiAxMzkyNjQsIG1heEJpdHJhdGU6IDQ4MDAwMDAwMCwgbGV2ZWw6IDB4M0QgfSwgLy8gTGV2ZWwgNi4xXG4gICAgeyBtYXhNYWNyb2Jsb2NrczogMTM5MjY0LCBtYXhCaXRyYXRlOiA4MDAwMDAwMDAsIGxldmVsOiAweDNFIH0sIC8vIExldmVsIDYuMlxuXTtcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hpZ2hfRWZmaWNpZW5jeV9WaWRlb19Db2RpbmdcbmNvbnN0IEhFVkNfTEVWRUxfVEFCTEUgPSBbXG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogMzY4NjQsIG1heEJpdHJhdGU6IDEyODAwMCwgdGllcjogJ0wnLCBsZXZlbDogMzAgfSwgLy8gTGV2ZWwgMSAoTG93IFRpZXIpXG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogMTIyODgwLCBtYXhCaXRyYXRlOiAxNTAwMDAwLCB0aWVyOiAnTCcsIGxldmVsOiA2MCB9LCAvLyBMZXZlbCAyIChMb3cgVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiAyNDU3NjAsIG1heEJpdHJhdGU6IDMwMDAwMDAsIHRpZXI6ICdMJywgbGV2ZWw6IDYzIH0sIC8vIExldmVsIDIuMSAoTG93IFRpZXIpXG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogNTUyOTYwLCBtYXhCaXRyYXRlOiA2MDAwMDAwLCB0aWVyOiAnTCcsIGxldmVsOiA5MCB9LCAvLyBMZXZlbCAzIChMb3cgVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiA5ODMwNDAsIG1heEJpdHJhdGU6IDEwMDAwMDAwLCB0aWVyOiAnTCcsIGxldmVsOiA5MyB9LCAvLyBMZXZlbCAzLjEgKExvdyBUaWVyKVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDIyMjgyMjQsIG1heEJpdHJhdGU6IDEyMDAwMDAwLCB0aWVyOiAnTCcsIGxldmVsOiAxMjAgfSwgLy8gTGV2ZWwgNCAoTG93IFRpZXIpXG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogMjIyODIyNCwgbWF4Qml0cmF0ZTogMzAwMDAwMDAsIHRpZXI6ICdIJywgbGV2ZWw6IDEyMCB9LCAvLyBMZXZlbCA0IChIaWdoIFRpZXIpXG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogMjIyODIyNCwgbWF4Qml0cmF0ZTogMjAwMDAwMDAsIHRpZXI6ICdMJywgbGV2ZWw6IDEyMyB9LCAvLyBMZXZlbCA0LjEgKExvdyBUaWVyKVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDIyMjgyMjQsIG1heEJpdHJhdGU6IDUwMDAwMDAwLCB0aWVyOiAnSCcsIGxldmVsOiAxMjMgfSwgLy8gTGV2ZWwgNC4xIChIaWdoIFRpZXIpXG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogODkxMjg5NiwgbWF4Qml0cmF0ZTogMjUwMDAwMDAsIHRpZXI6ICdMJywgbGV2ZWw6IDE1MCB9LCAvLyBMZXZlbCA1IChMb3cgVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiA4OTEyODk2LCBtYXhCaXRyYXRlOiAxMDAwMDAwMDAsIHRpZXI6ICdIJywgbGV2ZWw6IDE1MCB9LCAvLyBMZXZlbCA1IChIaWdoIFRpZXIpXG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogODkxMjg5NiwgbWF4Qml0cmF0ZTogNDAwMDAwMDAsIHRpZXI6ICdMJywgbGV2ZWw6IDE1MyB9LCAvLyBMZXZlbCA1LjEgKExvdyBUaWVyKVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDg5MTI4OTYsIG1heEJpdHJhdGU6IDE2MDAwMDAwMCwgdGllcjogJ0gnLCBsZXZlbDogMTUzIH0sIC8vIExldmVsIDUuMSAoSGlnaCBUaWVyKVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDg5MTI4OTYsIG1heEJpdHJhdGU6IDYwMDAwMDAwLCB0aWVyOiAnTCcsIGxldmVsOiAxNTYgfSwgLy8gTGV2ZWwgNS4yIChMb3cgVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiA4OTEyODk2LCBtYXhCaXRyYXRlOiAyNDAwMDAwMDAsIHRpZXI6ICdIJywgbGV2ZWw6IDE1NiB9LCAvLyBMZXZlbCA1LjIgKEhpZ2ggVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiAzNTY1MTU4NCwgbWF4Qml0cmF0ZTogNjAwMDAwMDAsIHRpZXI6ICdMJywgbGV2ZWw6IDE4MCB9LCAvLyBMZXZlbCA2IChMb3cgVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiAzNTY1MTU4NCwgbWF4Qml0cmF0ZTogMjQwMDAwMDAwLCB0aWVyOiAnSCcsIGxldmVsOiAxODAgfSwgLy8gTGV2ZWwgNiAoSGlnaCBUaWVyKVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDM1NjUxNTg0LCBtYXhCaXRyYXRlOiAxMjAwMDAwMDAsIHRpZXI6ICdMJywgbGV2ZWw6IDE4MyB9LCAvLyBMZXZlbCA2LjEgKExvdyBUaWVyKVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDM1NjUxNTg0LCBtYXhCaXRyYXRlOiA0ODAwMDAwMDAsIHRpZXI6ICdIJywgbGV2ZWw6IDE4MyB9LCAvLyBMZXZlbCA2LjEgKEhpZ2ggVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiAzNTY1MTU4NCwgbWF4Qml0cmF0ZTogMjQwMDAwMDAwLCB0aWVyOiAnTCcsIGxldmVsOiAxODYgfSwgLy8gTGV2ZWwgNi4yIChMb3cgVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiAzNTY1MTU4NCwgbWF4Qml0cmF0ZTogODAwMDAwMDAwLCB0aWVyOiAnSCcsIGxldmVsOiAxODYgfSwgLy8gTGV2ZWwgNi4yIChIaWdoIFRpZXIpXG5dO1xuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVlA5XG5leHBvcnQgY29uc3QgVlA5X0xFVkVMX1RBQkxFID0gW1xuICAgIHsgbWF4UGljdHVyZVNpemU6IDM2ODY0LCBtYXhCaXRyYXRlOiAyMDAwMDAsIGxldmVsOiAxMCB9LCAvLyBMZXZlbCAxXG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogNzM3MjgsIG1heEJpdHJhdGU6IDgwMDAwMCwgbGV2ZWw6IDExIH0sIC8vIExldmVsIDEuMVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDEyMjg4MCwgbWF4Qml0cmF0ZTogMTgwMDAwMCwgbGV2ZWw6IDIwIH0sIC8vIExldmVsIDJcbiAgICB7IG1heFBpY3R1cmVTaXplOiAyNDU3NjAsIG1heEJpdHJhdGU6IDM2MDAwMDAsIGxldmVsOiAyMSB9LCAvLyBMZXZlbCAyLjFcbiAgICB7IG1heFBpY3R1cmVTaXplOiA1NTI5NjAsIG1heEJpdHJhdGU6IDcyMDAwMDAsIGxldmVsOiAzMCB9LCAvLyBMZXZlbCAzXG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogOTgzMDQwLCBtYXhCaXRyYXRlOiAxMjAwMDAwMCwgbGV2ZWw6IDMxIH0sIC8vIExldmVsIDMuMVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDIyMjgyMjQsIG1heEJpdHJhdGU6IDE4MDAwMDAwLCBsZXZlbDogNDAgfSwgLy8gTGV2ZWwgNFxuICAgIHsgbWF4UGljdHVyZVNpemU6IDIyMjgyMjQsIG1heEJpdHJhdGU6IDMwMDAwMDAwLCBsZXZlbDogNDEgfSwgLy8gTGV2ZWwgNC4xXG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogODkxMjg5NiwgbWF4Qml0cmF0ZTogNjAwMDAwMDAsIGxldmVsOiA1MCB9LCAvLyBMZXZlbCA1XG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogODkxMjg5NiwgbWF4Qml0cmF0ZTogMTIwMDAwMDAwLCBsZXZlbDogNTEgfSwgLy8gTGV2ZWwgNS4xXG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogODkxMjg5NiwgbWF4Qml0cmF0ZTogMTgwMDAwMDAwLCBsZXZlbDogNTIgfSwgLy8gTGV2ZWwgNS4yXG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogMzU2NTE1ODQsIG1heEJpdHJhdGU6IDE4MDAwMDAwMCwgbGV2ZWw6IDYwIH0sIC8vIExldmVsIDZcbiAgICB7IG1heFBpY3R1cmVTaXplOiAzNTY1MTU4NCwgbWF4Qml0cmF0ZTogMjQwMDAwMDAwLCBsZXZlbDogNjEgfSwgLy8gTGV2ZWwgNi4xXG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogMzU2NTE1ODQsIG1heEJpdHJhdGU6IDQ4MDAwMDAwMCwgbGV2ZWw6IDYyIH0sIC8vIExldmVsIDYuMlxuXTtcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FWMVxuY29uc3QgQVYxX0xFVkVMX1RBQkxFID0gW1xuICAgIHsgbWF4UGljdHVyZVNpemU6IDE0NzQ1NiwgbWF4Qml0cmF0ZTogMTUwMDAwMCwgdGllcjogJ00nLCBsZXZlbDogMCB9LCAvLyBMZXZlbCAyLjAgKE1haW4gVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiAyNzg3ODQsIG1heEJpdHJhdGU6IDMwMDAwMDAsIHRpZXI6ICdNJywgbGV2ZWw6IDEgfSwgLy8gTGV2ZWwgMi4xIChNYWluIFRpZXIpXG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogNjY1ODU2LCBtYXhCaXRyYXRlOiA2MDAwMDAwLCB0aWVyOiAnTScsIGxldmVsOiA0IH0sIC8vIExldmVsIDMuMCAoTWFpbiBUaWVyKVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDEwNjUwMjQsIG1heEJpdHJhdGU6IDEwMDAwMDAwLCB0aWVyOiAnTScsIGxldmVsOiA1IH0sIC8vIExldmVsIDMuMSAoTWFpbiBUaWVyKVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDIzNTkyOTYsIG1heEJpdHJhdGU6IDEyMDAwMDAwLCB0aWVyOiAnTScsIGxldmVsOiA4IH0sIC8vIExldmVsIDQuMCAoTWFpbiBUaWVyKVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDIzNTkyOTYsIG1heEJpdHJhdGU6IDMwMDAwMDAwLCB0aWVyOiAnSCcsIGxldmVsOiA4IH0sIC8vIExldmVsIDQuMCAoSGlnaCBUaWVyKVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDIzNTkyOTYsIG1heEJpdHJhdGU6IDIwMDAwMDAwLCB0aWVyOiAnTScsIGxldmVsOiA5IH0sIC8vIExldmVsIDQuMSAoTWFpbiBUaWVyKVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDIzNTkyOTYsIG1heEJpdHJhdGU6IDUwMDAwMDAwLCB0aWVyOiAnSCcsIGxldmVsOiA5IH0sIC8vIExldmVsIDQuMSAoSGlnaCBUaWVyKVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDg5MTI4OTYsIG1heEJpdHJhdGU6IDMwMDAwMDAwLCB0aWVyOiAnTScsIGxldmVsOiAxMiB9LCAvLyBMZXZlbCA1LjAgKE1haW4gVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiA4OTEyODk2LCBtYXhCaXRyYXRlOiAxMDAwMDAwMDAsIHRpZXI6ICdIJywgbGV2ZWw6IDEyIH0sIC8vIExldmVsIDUuMCAoSGlnaCBUaWVyKVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDg5MTI4OTYsIG1heEJpdHJhdGU6IDQwMDAwMDAwLCB0aWVyOiAnTScsIGxldmVsOiAxMyB9LCAvLyBMZXZlbCA1LjEgKE1haW4gVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiA4OTEyODk2LCBtYXhCaXRyYXRlOiAxNjAwMDAwMDAsIHRpZXI6ICdIJywgbGV2ZWw6IDEzIH0sIC8vIExldmVsIDUuMSAoSGlnaCBUaWVyKVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDg5MTI4OTYsIG1heEJpdHJhdGU6IDYwMDAwMDAwLCB0aWVyOiAnTScsIGxldmVsOiAxNCB9LCAvLyBMZXZlbCA1LjIgKE1haW4gVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiA4OTEyODk2LCBtYXhCaXRyYXRlOiAyNDAwMDAwMDAsIHRpZXI6ICdIJywgbGV2ZWw6IDE0IH0sIC8vIExldmVsIDUuMiAoSGlnaCBUaWVyKVxuICAgIHsgbWF4UGljdHVyZVNpemU6IDM1NjUxNTg0LCBtYXhCaXRyYXRlOiA2MDAwMDAwMCwgdGllcjogJ00nLCBsZXZlbDogMTUgfSwgLy8gTGV2ZWwgNS4zIChNYWluIFRpZXIpXG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogMzU2NTE1ODQsIG1heEJpdHJhdGU6IDI0MDAwMDAwMCwgdGllcjogJ0gnLCBsZXZlbDogMTUgfSwgLy8gTGV2ZWwgNS4zIChIaWdoIFRpZXIpXG4gICAgeyBtYXhQaWN0dXJlU2l6ZTogMzU2NTE1ODQsIG1heEJpdHJhdGU6IDYwMDAwMDAwLCB0aWVyOiAnTScsIGxldmVsOiAxNiB9LCAvLyBMZXZlbCA2LjAgKE1haW4gVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiAzNTY1MTU4NCwgbWF4Qml0cmF0ZTogMjQwMDAwMDAwLCB0aWVyOiAnSCcsIGxldmVsOiAxNiB9LCAvLyBMZXZlbCA2LjAgKEhpZ2ggVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiAzNTY1MTU4NCwgbWF4Qml0cmF0ZTogMTAwMDAwMDAwLCB0aWVyOiAnTScsIGxldmVsOiAxNyB9LCAvLyBMZXZlbCA2LjEgKE1haW4gVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiAzNTY1MTU4NCwgbWF4Qml0cmF0ZTogNDgwMDAwMDAwLCB0aWVyOiAnSCcsIGxldmVsOiAxNyB9LCAvLyBMZXZlbCA2LjEgKEhpZ2ggVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiAzNTY1MTU4NCwgbWF4Qml0cmF0ZTogMTYwMDAwMDAwLCB0aWVyOiAnTScsIGxldmVsOiAxOCB9LCAvLyBMZXZlbCA2LjIgKE1haW4gVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiAzNTY1MTU4NCwgbWF4Qml0cmF0ZTogODAwMDAwMDAwLCB0aWVyOiAnSCcsIGxldmVsOiAxOCB9LCAvLyBMZXZlbCA2LjIgKEhpZ2ggVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiAzNTY1MTU4NCwgbWF4Qml0cmF0ZTogMTYwMDAwMDAwLCB0aWVyOiAnTScsIGxldmVsOiAxOSB9LCAvLyBMZXZlbCA2LjMgKE1haW4gVGllcilcbiAgICB7IG1heFBpY3R1cmVTaXplOiAzNTY1MTU4NCwgbWF4Qml0cmF0ZTogODAwMDAwMDAwLCB0aWVyOiAnSCcsIGxldmVsOiAxOSB9LCAvLyBMZXZlbCA2LjMgKEhpZ2ggVGllcilcbl07XG5jb25zdCBWUDlfREVGQVVMVF9TVUZGSVggPSAnLjAxLjAxLjAxLjAxLjAwJztcbmNvbnN0IEFWMV9ERUZBVUxUX1NVRkZJWCA9ICcuMC4xMTAuMDEuMDEuMDEuMCc7XG5leHBvcnQgY29uc3QgYnVpbGRWaWRlb0NvZGVjU3RyaW5nID0gKGNvZGVjLCB3aWR0aCwgaGVpZ2h0LCBiaXRyYXRlKSA9PiB7XG4gICAgaWYgKGNvZGVjID09PSAnYXZjJykge1xuICAgICAgICBjb25zdCBwcm9maWxlSW5kaWNhdGlvbiA9IDB4NjQ7IC8vIEhpZ2ggUHJvZmlsZVxuICAgICAgICBjb25zdCB0b3RhbE1hY3JvYmxvY2tzID0gTWF0aC5jZWlsKHdpZHRoIC8gMTYpICogTWF0aC5jZWlsKGhlaWdodCAvIDE2KTtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBsZXZlbCBiYXNlZCBvbiB0aGUgdGFibGVcbiAgICAgICAgY29uc3QgbGV2ZWxJbmZvID0gQVZDX0xFVkVMX1RBQkxFLmZpbmQobGV2ZWwgPT4gdG90YWxNYWNyb2Jsb2NrcyA8PSBsZXZlbC5tYXhNYWNyb2Jsb2NrcyAmJiBiaXRyYXRlIDw9IGxldmVsLm1heEJpdHJhdGUpID8/IGxhc3QoQVZDX0xFVkVMX1RBQkxFKTtcbiAgICAgICAgY29uc3QgbGV2ZWxJbmRpY2F0aW9uID0gbGV2ZWxJbmZvID8gbGV2ZWxJbmZvLmxldmVsIDogMDtcbiAgICAgICAgY29uc3QgaGV4UHJvZmlsZUluZGljYXRpb24gPSBwcm9maWxlSW5kaWNhdGlvbi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgY29uc3QgaGV4UHJvZmlsZUNvbXBhdGliaWxpdHkgPSAnMDAnO1xuICAgICAgICBjb25zdCBoZXhMZXZlbEluZGljYXRpb24gPSBsZXZlbEluZGljYXRpb24udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgIHJldHVybiBgYXZjMS4ke2hleFByb2ZpbGVJbmRpY2F0aW9ufSR7aGV4UHJvZmlsZUNvbXBhdGliaWxpdHl9JHtoZXhMZXZlbEluZGljYXRpb259YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZWMgPT09ICdoZXZjJykge1xuICAgICAgICBjb25zdCBwcm9maWxlUHJlZml4ID0gJyc7IC8vIFByb2ZpbGUgc3BhY2UgMFxuICAgICAgICBjb25zdCBwcm9maWxlSWRjID0gMTsgLy8gTWFpbiBQcm9maWxlXG4gICAgICAgIGNvbnN0IGNvbXBhdGliaWxpdHlGbGFncyA9ICc2JzsgLy8gVGFrZW4gZnJvbSB0aGUgZXhhbXBsZSBpbiBJU08gMTQ0OTYtMTVcbiAgICAgICAgY29uc3QgcGljdHVyZVNpemUgPSB3aWR0aCAqIGhlaWdodDtcbiAgICAgICAgY29uc3QgbGV2ZWxJbmZvID0gSEVWQ19MRVZFTF9UQUJMRS5maW5kKGxldmVsID0+IHBpY3R1cmVTaXplIDw9IGxldmVsLm1heFBpY3R1cmVTaXplICYmIGJpdHJhdGUgPD0gbGV2ZWwubWF4Qml0cmF0ZSkgPz8gbGFzdChIRVZDX0xFVkVMX1RBQkxFKTtcbiAgICAgICAgY29uc3QgY29uc3RyYWludEZsYWdzID0gJ0IwJzsgLy8gUHJvZ3Jlc3NpdmUgc291cmNlIGZsYWdcbiAgICAgICAgcmV0dXJuICdoZXYxLidcbiAgICAgICAgICAgICsgYCR7cHJvZmlsZVByZWZpeH0ke3Byb2ZpbGVJZGN9LmBcbiAgICAgICAgICAgICsgYCR7Y29tcGF0aWJpbGl0eUZsYWdzfS5gXG4gICAgICAgICAgICArIGAke2xldmVsSW5mby50aWVyfSR7bGV2ZWxJbmZvLmxldmVsfS5gXG4gICAgICAgICAgICArIGAke2NvbnN0cmFpbnRGbGFnc31gO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlYyA9PT0gJ3ZwOCcpIHtcbiAgICAgICAgcmV0dXJuICd2cDgnOyAvLyBFYXN5LCB0aGlzIG9uZVxuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlYyA9PT0gJ3ZwOScpIHtcbiAgICAgICAgY29uc3QgcHJvZmlsZSA9ICcwMCc7IC8vIFByb2ZpbGUgMFxuICAgICAgICBjb25zdCBwaWN0dXJlU2l6ZSA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICBjb25zdCBsZXZlbEluZm8gPSBWUDlfTEVWRUxfVEFCTEUuZmluZChsZXZlbCA9PiBwaWN0dXJlU2l6ZSA8PSBsZXZlbC5tYXhQaWN0dXJlU2l6ZSAmJiBiaXRyYXRlIDw9IGxldmVsLm1heEJpdHJhdGUpID8/IGxhc3QoVlA5X0xFVkVMX1RBQkxFKTtcbiAgICAgICAgY29uc3QgYml0RGVwdGggPSAnMDgnOyAvLyA4LWJpdFxuICAgICAgICByZXR1cm4gYHZwMDkuJHtwcm9maWxlfS4ke2xldmVsSW5mby5sZXZlbC50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9LiR7Yml0RGVwdGh9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZWMgPT09ICdhdjEnKSB7XG4gICAgICAgIGNvbnN0IHByb2ZpbGUgPSAwOyAvLyBNYWluIFByb2ZpbGUsIHNpbmdsZSBkaWdpdFxuICAgICAgICBjb25zdCBwaWN0dXJlU2l6ZSA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICBjb25zdCBsZXZlbEluZm8gPSBBVjFfTEVWRUxfVEFCTEUuZmluZChsZXZlbCA9PiBwaWN0dXJlU2l6ZSA8PSBsZXZlbC5tYXhQaWN0dXJlU2l6ZSAmJiBiaXRyYXRlIDw9IGxldmVsLm1heEJpdHJhdGUpID8/IGxhc3QoQVYxX0xFVkVMX1RBQkxFKTtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBsZXZlbEluZm8ubGV2ZWwudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICBjb25zdCBiaXREZXB0aCA9ICcwOCc7IC8vIDgtYml0XG4gICAgICAgIHJldHVybiBgYXYwMS4ke3Byb2ZpbGV9LiR7bGV2ZWx9JHtsZXZlbEluZm8udGllcn0uJHtiaXREZXB0aH1gO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5oYW5kbGVkIGNvZGVjICcke2NvZGVjfScuYCk7XG59O1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlVnA5Q29kZWNDb25maWd1cmF0aW9uRnJvbUNvZGVjU3RyaW5nID0gKGNvZGVjU3RyaW5nKSA9PiB7XG4gICAgLy8gUmVmZXJlbmNlOiBodHRwczovL3d3dy53ZWJtcHJvamVjdC5vcmcvZG9jcy9jb250YWluZXIvI3ZwOS1jb2RlYy1mZWF0dXJlLW1ldGFkYXRhLWNvZGVjcHJpdmF0ZVxuICAgIGNvbnN0IHBhcnRzID0gY29kZWNTdHJpbmcuc3BsaXQoJy4nKTsgLy8gV2UgY2FuIGRlcml2ZSB0aGUgcmVxdWlyZWQgdmFsdWVzIGZyb20gdGhlIGNvZGVjIHN0cmluZ1xuICAgIGNvbnN0IHByb2ZpbGUgPSBOdW1iZXIocGFydHNbMV0pO1xuICAgIGNvbnN0IGxldmVsID0gTnVtYmVyKHBhcnRzWzJdKTtcbiAgICBjb25zdCBiaXREZXB0aCA9IE51bWJlcihwYXJ0c1szXSk7XG4gICAgY29uc3QgY2hyb21hU3Vic2FtcGxpbmcgPSBwYXJ0c1s0XSA/IE51bWJlcihwYXJ0c1s0XSkgOiAxO1xuICAgIHJldHVybiBbXG4gICAgICAgIDEsIDEsIHByb2ZpbGUsXG4gICAgICAgIDIsIDEsIGxldmVsLFxuICAgICAgICAzLCAxLCBiaXREZXB0aCxcbiAgICAgICAgNCwgMSwgY2hyb21hU3Vic2FtcGxpbmcsXG4gICAgXTtcbn07XG5leHBvcnQgY29uc3QgZ2VuZXJhdGVBdjFDb2RlY0NvbmZpZ3VyYXRpb25Gcm9tQ29kZWNTdHJpbmcgPSAoY29kZWNTdHJpbmcpID0+IHtcbiAgICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYW9tZWRpYWNvZGVjLmdpdGh1Yi5pby9hdjEtaXNvYm1mZi9cbiAgICBjb25zdCBwYXJ0cyA9IGNvZGVjU3RyaW5nLnNwbGl0KCcuJyk7IC8vIFdlIGNhbiBkZXJpdmUgdGhlIHJlcXVpcmVkIHZhbHVlcyBmcm9tIHRoZSBjb2RlYyBzdHJpbmdcbiAgICBjb25zdCBtYXJrZXIgPSAxO1xuICAgIGNvbnN0IHZlcnNpb24gPSAxO1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IChtYXJrZXIgPDwgNykgKyB2ZXJzaW9uO1xuICAgIGNvbnN0IHByb2ZpbGUgPSBOdW1iZXIocGFydHNbMV0pO1xuICAgIGNvbnN0IGxldmVsQW5kVGllciA9IHBhcnRzWzJdO1xuICAgIGNvbnN0IGxldmVsID0gTnVtYmVyKGxldmVsQW5kVGllci5zbGljZSgwLCAtMSkpO1xuICAgIGNvbnN0IHNlY29uZEJ5dGUgPSAocHJvZmlsZSA8PCA1KSArIGxldmVsO1xuICAgIGNvbnN0IHRpZXIgPSBsZXZlbEFuZFRpZXIuc2xpY2UoLTEpID09PSAnSCcgPyAxIDogMDtcbiAgICBjb25zdCBiaXREZXB0aCA9IE51bWJlcihwYXJ0c1szXSk7XG4gICAgY29uc3QgaGlnaEJpdERlcHRoID0gYml0RGVwdGggPT09IDggPyAwIDogMTtcbiAgICBjb25zdCB0d2VsdmVCaXQgPSAwO1xuICAgIGNvbnN0IG1vbm9jaHJvbWUgPSBwYXJ0c1s0XSA/IE51bWJlcihwYXJ0c1s0XSkgOiAwO1xuICAgIGNvbnN0IGNocm9tYVN1YnNhbXBsaW5nWCA9IHBhcnRzWzVdID8gTnVtYmVyKHBhcnRzWzVdWzBdKSA6IDE7XG4gICAgY29uc3QgY2hyb21hU3Vic2FtcGxpbmdZID0gcGFydHNbNV0gPyBOdW1iZXIocGFydHNbNV1bMV0pIDogMTtcbiAgICBjb25zdCBjaHJvbWFTYW1wbGVQb3NpdGlvbiA9IHBhcnRzWzVdID8gTnVtYmVyKHBhcnRzWzVdWzJdKSA6IDA7IC8vIENTUF9VTktOT1dOXG4gICAgY29uc3QgdGhpcmRCeXRlID0gKHRpZXIgPDwgNylcbiAgICAgICAgKyAoaGlnaEJpdERlcHRoIDw8IDYpXG4gICAgICAgICsgKHR3ZWx2ZUJpdCA8PCA1KVxuICAgICAgICArIChtb25vY2hyb21lIDw8IDQpXG4gICAgICAgICsgKGNocm9tYVN1YnNhbXBsaW5nWCA8PCAzKVxuICAgICAgICArIChjaHJvbWFTdWJzYW1wbGluZ1kgPDwgMilcbiAgICAgICAgKyBjaHJvbWFTYW1wbGVQb3NpdGlvbjtcbiAgICBjb25zdCBpbml0aWFsUHJlc2VudGF0aW9uRGVsYXlQcmVzZW50ID0gMDsgLy8gU2hvdWxkIGJlIGZpbmVcbiAgICBjb25zdCBmb3VydGhCeXRlID0gaW5pdGlhbFByZXNlbnRhdGlvbkRlbGF5UHJlc2VudDtcbiAgICByZXR1cm4gW2ZpcnN0Qnl0ZSwgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlXTtcbn07XG5leHBvcnQgY29uc3QgZXh0cmFjdFZpZGVvQ29kZWNTdHJpbmcgPSAodHJhY2tJbmZvKSA9PiB7XG4gICAgY29uc3QgeyBjb2RlYywgY29kZWNEZXNjcmlwdGlvbiwgY29sb3JTcGFjZSwgYXZjQ29kZWNJbmZvLCBoZXZjQ29kZWNJbmZvLCB2cDlDb2RlY0luZm8sIGF2MUNvZGVjSW5mbyB9ID0gdHJhY2tJbmZvO1xuICAgIGlmIChjb2RlYyA9PT0gJ2F2YycpIHtcbiAgICAgICAgaWYgKGF2Y0NvZGVjSW5mbykge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAgICAgYXZjQ29kZWNJbmZvLmF2Y1Byb2ZpbGVJbmRpY2F0aW9uLFxuICAgICAgICAgICAgICAgIGF2Y0NvZGVjSW5mby5wcm9maWxlQ29tcGF0aWJpbGl0eSxcbiAgICAgICAgICAgICAgICBhdmNDb2RlY0luZm8uYXZjTGV2ZWxJbmRpY2F0aW9uLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gYGF2YzEuJHtieXRlc1RvSGV4U3RyaW5nKGJ5dGVzKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29kZWNEZXNjcmlwdGlvbiB8fCBjb2RlY0Rlc2NyaXB0aW9uLmJ5dGVMZW5ndGggPCA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBVkMgZGVjb2RlciBkZXNjcmlwdGlvbiBpcyBub3QgcHJvdmlkZWQgb3IgaXMgbm90IGF0IGxlYXN0IDQgYnl0ZXMgbG9uZy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYGF2YzEuJHtieXRlc1RvSGV4U3RyaW5nKGNvZGVjRGVzY3JpcHRpb24uc3ViYXJyYXkoMSwgNCkpfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVjID09PSAnaGV2YycpIHtcbiAgICAgICAgbGV0IGdlbmVyYWxQcm9maWxlU3BhY2U7XG4gICAgICAgIGxldCBnZW5lcmFsUHJvZmlsZUlkYztcbiAgICAgICAgbGV0IGNvbXBhdGliaWxpdHlGbGFncztcbiAgICAgICAgbGV0IGdlbmVyYWxUaWVyRmxhZztcbiAgICAgICAgbGV0IGdlbmVyYWxMZXZlbElkYztcbiAgICAgICAgbGV0IGNvbnN0cmFpbnRGbGFncztcbiAgICAgICAgaWYgKGhldmNDb2RlY0luZm8pIHtcbiAgICAgICAgICAgIGdlbmVyYWxQcm9maWxlU3BhY2UgPSBoZXZjQ29kZWNJbmZvLmdlbmVyYWxQcm9maWxlU3BhY2U7XG4gICAgICAgICAgICBnZW5lcmFsUHJvZmlsZUlkYyA9IGhldmNDb2RlY0luZm8uZ2VuZXJhbFByb2ZpbGVJZGM7XG4gICAgICAgICAgICBjb21wYXRpYmlsaXR5RmxhZ3MgPSByZXZlcnNlQml0c1UzMihoZXZjQ29kZWNJbmZvLmdlbmVyYWxQcm9maWxlQ29tcGF0aWJpbGl0eUZsYWdzKTtcbiAgICAgICAgICAgIGdlbmVyYWxUaWVyRmxhZyA9IGhldmNDb2RlY0luZm8uZ2VuZXJhbFRpZXJGbGFnO1xuICAgICAgICAgICAgZ2VuZXJhbExldmVsSWRjID0gaGV2Y0NvZGVjSW5mby5nZW5lcmFsTGV2ZWxJZGM7XG4gICAgICAgICAgICBjb25zdHJhaW50RmxhZ3MgPSBbLi4uaGV2Y0NvZGVjSW5mby5nZW5lcmFsQ29uc3RyYWludEluZGljYXRvckZsYWdzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghY29kZWNEZXNjcmlwdGlvbiB8fCBjb2RlY0Rlc2NyaXB0aW9uLmJ5dGVMZW5ndGggPCAyMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hFVkMgZGVjb2RlciBkZXNjcmlwdGlvbiBpcyBub3QgcHJvdmlkZWQgb3IgaXMgbm90IGF0IGxlYXN0IDIzIGJ5dGVzIGxvbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gdG9EYXRhVmlldyhjb2RlY0Rlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHByb2ZpbGVCeXRlID0gdmlldy5nZXRVaW50OCgxKTtcbiAgICAgICAgICAgIGdlbmVyYWxQcm9maWxlU3BhY2UgPSAocHJvZmlsZUJ5dGUgPj4gNikgJiAweDAzO1xuICAgICAgICAgICAgZ2VuZXJhbFByb2ZpbGVJZGMgPSBwcm9maWxlQnl0ZSAmIDB4MUY7XG4gICAgICAgICAgICBjb21wYXRpYmlsaXR5RmxhZ3MgPSByZXZlcnNlQml0c1UzMih2aWV3LmdldFVpbnQzMigyKSk7XG4gICAgICAgICAgICBnZW5lcmFsVGllckZsYWcgPSAocHJvZmlsZUJ5dGUgPj4gNSkgJiAweDAxO1xuICAgICAgICAgICAgZ2VuZXJhbExldmVsSWRjID0gdmlldy5nZXRVaW50OCgxMik7XG4gICAgICAgICAgICBjb25zdHJhaW50RmxhZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludEZsYWdzLnB1c2godmlldy5nZXRVaW50OCg2ICsgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb2RlY1N0cmluZyA9ICdoZXYxLic7XG4gICAgICAgIGNvZGVjU3RyaW5nICs9IFsnJywgJ0EnLCAnQicsICdDJ11bZ2VuZXJhbFByb2ZpbGVTcGFjZV0gKyBnZW5lcmFsUHJvZmlsZUlkYztcbiAgICAgICAgY29kZWNTdHJpbmcgKz0gJy4nO1xuICAgICAgICBjb2RlY1N0cmluZyArPSBjb21wYXRpYmlsaXR5RmxhZ3MudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGNvZGVjU3RyaW5nICs9ICcuJztcbiAgICAgICAgY29kZWNTdHJpbmcgKz0gZ2VuZXJhbFRpZXJGbGFnID09PSAwID8gJ0wnIDogJ0gnO1xuICAgICAgICBjb2RlY1N0cmluZyArPSBnZW5lcmFsTGV2ZWxJZGM7XG4gICAgICAgIHdoaWxlIChjb25zdHJhaW50RmxhZ3MubGVuZ3RoID4gMCAmJiBjb25zdHJhaW50RmxhZ3NbY29uc3RyYWludEZsYWdzLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdHJhaW50RmxhZ3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cmFpbnRGbGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb2RlY1N0cmluZyArPSAnLic7XG4gICAgICAgICAgICBjb2RlY1N0cmluZyArPSBjb25zdHJhaW50RmxhZ3MubWFwKHggPT4geC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuam9pbignLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlY1N0cmluZztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZWMgPT09ICd2cDgnKSB7XG4gICAgICAgIHJldHVybiAndnA4JzsgLy8gRWFzeSwgdGhpcyBvbmVcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZWMgPT09ICd2cDknKSB7XG4gICAgICAgIGlmICghdnA5Q29kZWNJbmZvKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgbGV2ZWwgYmFzZWQgb24gZGltZW5zaW9uc1xuICAgICAgICAgICAgY29uc3QgcGljdHVyZVNpemUgPSB0cmFja0luZm8ud2lkdGggKiB0cmFja0luZm8uaGVpZ2h0O1xuICAgICAgICAgICAgbGV0IGxldmVsID0gbGFzdChWUDlfTEVWRUxfVEFCTEUpLmxldmVsOyAvLyBEZWZhdWx0IHRvIGhpZ2hlc3QgbGV2ZWxcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgVlA5X0xFVkVMX1RBQkxFKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBpY3R1cmVTaXplIDw9IGVudHJ5Lm1heFBpY3R1cmVTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsID0gZW50cnkubGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHJlYWxseSBrbm93IGJldHRlciwgc28gbGV0J3MgcmV0dXJuIGEgZ2VuZXJhbC1wdXJwb3NlLCBjb21tb24gY29kZWMgc3RyaW5nIGFuZCBob3BlIGZvciB0aGUgYmVzdFxuICAgICAgICAgICAgcmV0dXJuIGB2cDA5LjAwLiR7bGV2ZWwudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfS4wOGA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvZmlsZSA9IHZwOUNvZGVjSW5mby5wcm9maWxlLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB2cDlDb2RlY0luZm8ubGV2ZWwudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICBjb25zdCBiaXREZXB0aCA9IHZwOUNvZGVjSW5mby5iaXREZXB0aC50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgIGNvbnN0IGNocm9tYVN1YnNhbXBsaW5nID0gdnA5Q29kZWNJbmZvLmNocm9tYVN1YnNhbXBsaW5nLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgY29uc3QgY29sb3VyUHJpbWFyaWVzID0gdnA5Q29kZWNJbmZvLmNvbG91clByaW1hcmllcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgIGNvbnN0IHRyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzID0gdnA5Q29kZWNJbmZvLnRyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgY29uc3QgbWF0cml4Q29lZmZpY2llbnRzID0gdnA5Q29kZWNJbmZvLm1hdHJpeENvZWZmaWNpZW50cy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgIGNvbnN0IHZpZGVvRnVsbFJhbmdlRmxhZyA9IHZwOUNvZGVjSW5mby52aWRlb0Z1bGxSYW5nZUZsYWcudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICBsZXQgc3RyaW5nID0gYHZwMDkuJHtwcm9maWxlfS4ke2xldmVsfS4ke2JpdERlcHRofS4ke2Nocm9tYVN1YnNhbXBsaW5nfWA7XG4gICAgICAgIHN0cmluZyArPSBgLiR7Y29sb3VyUHJpbWFyaWVzfS4ke3RyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzfS4ke21hdHJpeENvZWZmaWNpZW50c30uJHt2aWRlb0Z1bGxSYW5nZUZsYWd9YDtcbiAgICAgICAgaWYgKHN0cmluZy5lbmRzV2l0aChWUDlfREVGQVVMVF9TVUZGSVgpKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMCwgLVZQOV9ERUZBVUxUX1NVRkZJWC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVjID09PSAnYXYxJykge1xuICAgICAgICBpZiAoIWF2MUNvZGVjSW5mbykge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGxldmVsIGJhc2VkIG9uIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIGNvbnN0IHBpY3R1cmVTaXplID0gdHJhY2tJbmZvLndpZHRoICogdHJhY2tJbmZvLmhlaWdodDtcbiAgICAgICAgICAgIGxldCBsZXZlbCA9IGxhc3QoVlA5X0xFVkVMX1RBQkxFKS5sZXZlbDsgLy8gRGVmYXVsdCB0byBoaWdoZXN0IGxldmVsXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIFZQOV9MRVZFTF9UQUJMRSkge1xuICAgICAgICAgICAgICAgIGlmIChwaWN0dXJlU2l6ZSA8PSBlbnRyeS5tYXhQaWN0dXJlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXZlbCA9IGVudHJ5LmxldmVsO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBkb24ndCByZWFsbHkga25vdyBiZXR0ZXIsIHNvIGxldCdzIHJldHVybiBhIGdlbmVyYWwtcHVycG9zZSwgY29tbW9uIGNvZGVjIHN0cmluZyBhbmQgaG9wZSBmb3IgdGhlIGJlc3RcbiAgICAgICAgICAgIHJldHVybiBgYXYwMS4wLiR7bGV2ZWwudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfU0uMDhgO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vYW9tZWRpYWNvZGVjLmdpdGh1Yi5pby9hdjEtaXNvYm1mZi8jY29kZWNzcGFyYW1cbiAgICAgICAgY29uc3QgcHJvZmlsZSA9IGF2MUNvZGVjSW5mby5wcm9maWxlOyAvLyBTaW5nbGUgZGlnaXRcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBhdjFDb2RlY0luZm8ubGV2ZWwudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICBjb25zdCB0aWVyID0gYXYxQ29kZWNJbmZvLnRpZXIgPyAnSCcgOiAnTSc7XG4gICAgICAgIGNvbnN0IGJpdERlcHRoID0gYXYxQ29kZWNJbmZvLmJpdERlcHRoLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgY29uc3QgbW9ub2Nocm9tZSA9IGF2MUNvZGVjSW5mby5tb25vY2hyb21lID8gJzEnIDogJzAnO1xuICAgICAgICBjb25zdCBjaHJvbWFTdWJzYW1wbGluZyA9IDEwMCAqIGF2MUNvZGVjSW5mby5jaHJvbWFTdWJzYW1wbGluZ1hcbiAgICAgICAgICAgICsgMTAgKiBhdjFDb2RlY0luZm8uY2hyb21hU3Vic2FtcGxpbmdZXG4gICAgICAgICAgICArIDEgKiAoYXYxQ29kZWNJbmZvLmNocm9tYVN1YnNhbXBsaW5nWCAmJiBhdjFDb2RlY0luZm8uY2hyb21hU3Vic2FtcGxpbmdZXG4gICAgICAgICAgICAgICAgPyBhdjFDb2RlY0luZm8uY2hyb21hU2FtcGxlUG9zaXRpb25cbiAgICAgICAgICAgICAgICA6IDApO1xuICAgICAgICAvLyBUaGUgZGVmYXVsdHMgYXJlIDEgKElUVS1SIEJULjcwOSlcbiAgICAgICAgY29uc3QgY29sb3JQcmltYXJpZXMgPSBjb2xvclNwYWNlPy5wcmltYXJpZXMgPyBDT0xPUl9QUklNQVJJRVNfTUFQW2NvbG9yU3BhY2UucHJpbWFyaWVzXSA6IDE7XG4gICAgICAgIGNvbnN0IHRyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzID0gY29sb3JTcGFjZT8udHJhbnNmZXIgPyBUUkFOU0ZFUl9DSEFSQUNURVJJU1RJQ1NfTUFQW2NvbG9yU3BhY2UudHJhbnNmZXJdIDogMTtcbiAgICAgICAgY29uc3QgbWF0cml4Q29lZmZpY2llbnRzID0gY29sb3JTcGFjZT8ubWF0cml4ID8gTUFUUklYX0NPRUZGSUNJRU5UU19NQVBbY29sb3JTcGFjZS5tYXRyaXhdIDogMTtcbiAgICAgICAgY29uc3QgdmlkZW9GdWxsUmFuZ2VGbGFnID0gY29sb3JTcGFjZT8uZnVsbFJhbmdlID8gMSA6IDA7XG4gICAgICAgIGxldCBzdHJpbmcgPSBgYXYwMS4ke3Byb2ZpbGV9LiR7bGV2ZWx9JHt0aWVyfS4ke2JpdERlcHRofWA7XG4gICAgICAgIHN0cmluZyArPSBgLiR7bW9ub2Nocm9tZX0uJHtjaHJvbWFTdWJzYW1wbGluZy50b1N0cmluZygpLnBhZFN0YXJ0KDMsICcwJyl9YDtcbiAgICAgICAgc3RyaW5nICs9IGAuJHtjb2xvclByaW1hcmllcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDtcbiAgICAgICAgc3RyaW5nICs9IGAuJHt0cmFuc2ZlckNoYXJhY3RlcmlzdGljcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDtcbiAgICAgICAgc3RyaW5nICs9IGAuJHttYXRyaXhDb2VmZmljaWVudHMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWA7XG4gICAgICAgIHN0cmluZyArPSBgLiR7dmlkZW9GdWxsUmFuZ2VGbGFnfWA7XG4gICAgICAgIGlmIChzdHJpbmcuZW5kc1dpdGgoQVYxX0RFRkFVTFRfU1VGRklYKSkge1xuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKDAsIC1BVjFfREVGQVVMVF9TVUZGSVgubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmhhbmRsZWQgY29kZWMgJyR7Y29kZWN9Jy5gKTtcbn07XG5leHBvcnQgY29uc3QgYnVpbGRBdWRpb0NvZGVjU3RyaW5nID0gKGNvZGVjLCBudW1iZXJPZkNoYW5uZWxzLCBzYW1wbGVSYXRlKSA9PiB7XG4gICAgaWYgKGNvZGVjID09PSAnYWFjJykge1xuICAgICAgICAvLyBJZiBzdGVyZW8gb3IgaGlnaGVyIGNoYW5uZWxzIGFuZCBsb3dlciBzYW1wbGUgcmF0ZSwgbGlrZWx5IHVzaW5nIEhFLUFBQyB2MiB3aXRoIFBTXG4gICAgICAgIGlmIChudW1iZXJPZkNoYW5uZWxzID49IDIgJiYgc2FtcGxlUmF0ZSA8PSAyNDAwMCkge1xuICAgICAgICAgICAgcmV0dXJuICdtcDRhLjQwLjI5JzsgLy8gSEUtQUFDIHYyIChBQUMgTEMgKyBTQlIgKyBQUylcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBzYW1wbGUgcmF0ZSBpcyBsb3csIGxpa2VseSB1c2luZyBIRS1BQUMgdjEgd2l0aCBTQlJcbiAgICAgICAgaWYgKHNhbXBsZVJhdGUgPD0gMjQwMDApIHtcbiAgICAgICAgICAgIHJldHVybiAnbXA0YS40MC41JzsgLy8gSEUtQUFDIHYxIChBQUMgTEMgKyBTQlIpXG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVmYXVsdCB0byBzdGFuZGFyZCBBQUMtTEMgZm9yIGhpZ2hlciBzYW1wbGUgcmF0ZXNcbiAgICAgICAgcmV0dXJuICdtcDRhLjQwLjInOyAvLyBBQUMtTENcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZWMgPT09ICdtcDMnKSB7XG4gICAgICAgIHJldHVybiAnbXAzJztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZWMgPT09ICdvcHVzJykge1xuICAgICAgICByZXR1cm4gJ29wdXMnO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlYyA9PT0gJ3ZvcmJpcycpIHtcbiAgICAgICAgcmV0dXJuICd2b3JiaXMnO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlYyA9PT0gJ2ZsYWMnKSB7XG4gICAgICAgIHJldHVybiAnZmxhYyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKFBDTV9BVURJT19DT0RFQ1MuaW5jbHVkZXMoY29kZWMpKSB7XG4gICAgICAgIHJldHVybiBjb2RlYztcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5oYW5kbGVkIGNvZGVjICcke2NvZGVjfScuYCk7XG59O1xuZXhwb3J0IGNvbnN0IGV4dHJhY3RBdWRpb0NvZGVjU3RyaW5nID0gKHRyYWNrSW5mbykgPT4ge1xuICAgIGNvbnN0IHsgY29kZWMsIGNvZGVjRGVzY3JpcHRpb24sIGFhY0NvZGVjSW5mbyB9ID0gdHJhY2tJbmZvO1xuICAgIGlmIChjb2RlYyA9PT0gJ2FhYycpIHtcbiAgICAgICAgaWYgKCFhYWNDb2RlY0luZm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FBQyBjb2RlYyBpbmZvIG11c3QgYmUgcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFhY0NvZGVjSW5mby5pc01wZWcyKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21wNGEuNjcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYXVkaW9TcGVjaWZpY0NvbmZpZyA9IHBhcnNlQWFjQXVkaW9TcGVjaWZpY0NvbmZpZyhjb2RlY0Rlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBgbXA0YS40MC4ke2F1ZGlvU3BlY2lmaWNDb25maWcub2JqZWN0VHlwZX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVjID09PSAnbXAzJykge1xuICAgICAgICByZXR1cm4gJ21wMyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVjID09PSAnb3B1cycpIHtcbiAgICAgICAgcmV0dXJuICdvcHVzJztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZWMgPT09ICd2b3JiaXMnKSB7XG4gICAgICAgIHJldHVybiAndm9yYmlzJztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZWMgPT09ICdmbGFjJykge1xuICAgICAgICByZXR1cm4gJ2ZsYWMnO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlYyAmJiBQQ01fQVVESU9fQ09ERUNTLmluY2x1ZGVzKGNvZGVjKSkge1xuICAgICAgICByZXR1cm4gY29kZWM7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuaGFuZGxlZCBjb2RlYyAnJHtjb2RlY30nLmApO1xufTtcbmV4cG9ydCBjb25zdCBhYWNGcmVxdWVuY3lUYWJsZSA9IFtcbiAgICA5NjAwMCwgODgyMDAsIDY0MDAwLCA0ODAwMCwgNDQxMDAsIDMyMDAwLFxuICAgIDI0MDAwLCAyMjA1MCwgMTYwMDAsIDEyMDAwLCAxMTAyNSwgODAwMCwgNzM1MCxcbl07XG5leHBvcnQgY29uc3QgYWFjQ2hhbm5lbE1hcCA9IFstMSwgMSwgMiwgMywgNCwgNSwgNiwgOF07XG5leHBvcnQgY29uc3QgcGFyc2VBYWNBdWRpb1NwZWNpZmljQ29uZmlnID0gKGJ5dGVzKSA9PiB7XG4gICAgaWYgKCFieXRlcyB8fCBieXRlcy5ieXRlTGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBQUMgZGVzY3JpcHRpb24gbXVzdCBiZSBhdCBsZWFzdCAyIGJ5dGVzIGxvbmcuJyk7XG4gICAgfVxuICAgIGNvbnN0IGJpdHN0cmVhbSA9IG5ldyBCaXRzdHJlYW0oYnl0ZXMpO1xuICAgIGxldCBvYmplY3RUeXBlID0gYml0c3RyZWFtLnJlYWRCaXRzKDUpO1xuICAgIGlmIChvYmplY3RUeXBlID09PSAzMSkge1xuICAgICAgICBvYmplY3RUeXBlID0gMzIgKyBiaXRzdHJlYW0ucmVhZEJpdHMoNik7XG4gICAgfVxuICAgIGNvbnN0IGZyZXF1ZW5jeUluZGV4ID0gYml0c3RyZWFtLnJlYWRCaXRzKDQpO1xuICAgIGxldCBzYW1wbGVSYXRlID0gbnVsbDtcbiAgICBpZiAoZnJlcXVlbmN5SW5kZXggPT09IDE1KSB7XG4gICAgICAgIHNhbXBsZVJhdGUgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMjQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGZyZXF1ZW5jeUluZGV4IDwgYWFjRnJlcXVlbmN5VGFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBzYW1wbGVSYXRlID0gYWFjRnJlcXVlbmN5VGFibGVbZnJlcXVlbmN5SW5kZXhdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoYW5uZWxDb25maWd1cmF0aW9uID0gYml0c3RyZWFtLnJlYWRCaXRzKDQpO1xuICAgIGxldCBudW1iZXJPZkNoYW5uZWxzID0gbnVsbDtcbiAgICBpZiAoY2hhbm5lbENvbmZpZ3VyYXRpb24gPj0gMSAmJiBjaGFubmVsQ29uZmlndXJhdGlvbiA8PSA3KSB7XG4gICAgICAgIG51bWJlck9mQ2hhbm5lbHMgPSBhYWNDaGFubmVsTWFwW2NoYW5uZWxDb25maWd1cmF0aW9uXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb2JqZWN0VHlwZSxcbiAgICAgICAgZnJlcXVlbmN5SW5kZXgsXG4gICAgICAgIHNhbXBsZVJhdGUsXG4gICAgICAgIGNoYW5uZWxDb25maWd1cmF0aW9uLFxuICAgICAgICBudW1iZXJPZkNoYW5uZWxzLFxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IE9QVVNfU0FNUExFX1JBVEUgPSA0OF8wMDA7XG5jb25zdCBQQ01fQ09ERUNfUkVHRVggPSAvXnBjbS0oW3VzZl0pKFxcZCspKyhiZSk/JC87XG5leHBvcnQgY29uc3QgcGFyc2VQY21Db2RlYyA9IChjb2RlYykgPT4ge1xuICAgIGFzc2VydChQQ01fQVVESU9fQ09ERUNTLmluY2x1ZGVzKGNvZGVjKSk7XG4gICAgaWYgKGNvZGVjID09PSAndWxhdycpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YVR5cGU6ICd1bGF3Jywgc2FtcGxlU2l6ZTogMSwgbGl0dGxlRW5kaWFuOiB0cnVlLCBzaWxlbnRWYWx1ZTogMjU1IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVjID09PSAnYWxhdycpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YVR5cGU6ICdhbGF3Jywgc2FtcGxlU2l6ZTogMSwgbGl0dGxlRW5kaWFuOiB0cnVlLCBzaWxlbnRWYWx1ZTogMjEzIH07XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gUENNX0NPREVDX1JFR0VYLmV4ZWMoY29kZWMpO1xuICAgIGFzc2VydChtYXRjaCk7XG4gICAgbGV0IGRhdGFUeXBlO1xuICAgIGlmIChtYXRjaFsxXSA9PT0gJ3UnKSB7XG4gICAgICAgIGRhdGFUeXBlID0gJ3Vuc2lnbmVkJztcbiAgICB9XG4gICAgZWxzZSBpZiAobWF0Y2hbMV0gPT09ICdzJykge1xuICAgICAgICBkYXRhVHlwZSA9ICdzaWduZWQnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGF0YVR5cGUgPSAnZmxvYXQnO1xuICAgIH1cbiAgICBjb25zdCBzYW1wbGVTaXplID0gKE51bWJlcihtYXRjaFsyXSkgLyA4KTtcbiAgICBjb25zdCBsaXR0bGVFbmRpYW4gPSBtYXRjaFszXSAhPT0gJ2JlJztcbiAgICBjb25zdCBzaWxlbnRWYWx1ZSA9IGNvZGVjID09PSAncGNtLXU4JyA/IDIgKiogNyA6IDA7XG4gICAgcmV0dXJuIHsgZGF0YVR5cGUsIHNhbXBsZVNpemUsIGxpdHRsZUVuZGlhbiwgc2lsZW50VmFsdWUgfTtcbn07XG5leHBvcnQgY29uc3QgaW5mZXJDb2RlY0Zyb21Db2RlY1N0cmluZyA9IChjb2RlY1N0cmluZykgPT4ge1xuICAgIC8vIFZpZGVvIGNvZGVjc1xuICAgIGlmIChjb2RlY1N0cmluZy5zdGFydHNXaXRoKCdhdmMxJykgfHwgY29kZWNTdHJpbmcuc3RhcnRzV2l0aCgnYXZjMycpKSB7XG4gICAgICAgIHJldHVybiAnYXZjJztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZWNTdHJpbmcuc3RhcnRzV2l0aCgnaGV2MScpIHx8IGNvZGVjU3RyaW5nLnN0YXJ0c1dpdGgoJ2h2YzEnKSkge1xuICAgICAgICByZXR1cm4gJ2hldmMnO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlY1N0cmluZyA9PT0gJ3ZwOCcpIHtcbiAgICAgICAgcmV0dXJuICd2cDgnO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlY1N0cmluZy5zdGFydHNXaXRoKCd2cDA5JykpIHtcbiAgICAgICAgcmV0dXJuICd2cDknO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlY1N0cmluZy5zdGFydHNXaXRoKCdhdjAxJykpIHtcbiAgICAgICAgcmV0dXJuICdhdjEnO1xuICAgIH1cbiAgICAvLyBBdWRpbyBjb2RlY3NcbiAgICBpZiAoY29kZWNTdHJpbmcuc3RhcnRzV2l0aCgnbXA0YS40MCcpIHx8IGNvZGVjU3RyaW5nID09PSAnbXA0YS42NycpIHtcbiAgICAgICAgcmV0dXJuICdhYWMnO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlY1N0cmluZyA9PT0gJ21wMydcbiAgICAgICAgfHwgY29kZWNTdHJpbmcgPT09ICdtcDRhLjY5J1xuICAgICAgICB8fCBjb2RlY1N0cmluZyA9PT0gJ21wNGEuNkInXG4gICAgICAgIHx8IGNvZGVjU3RyaW5nID09PSAnbXA0YS42YicpIHtcbiAgICAgICAgcmV0dXJuICdtcDMnO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlY1N0cmluZyA9PT0gJ29wdXMnKSB7XG4gICAgICAgIHJldHVybiAnb3B1cyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVjU3RyaW5nID09PSAndm9yYmlzJykge1xuICAgICAgICByZXR1cm4gJ3ZvcmJpcyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVjU3RyaW5nID09PSAnZmxhYycpIHtcbiAgICAgICAgcmV0dXJuICdmbGFjJztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZWNTdHJpbmcgPT09ICd1bGF3Jykge1xuICAgICAgICByZXR1cm4gJ3VsYXcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlY1N0cmluZyA9PT0gJ2FsYXcnKSB7XG4gICAgICAgIHJldHVybiAnYWxhdyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKFBDTV9DT0RFQ19SRUdFWC50ZXN0KGNvZGVjU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gY29kZWNTdHJpbmc7XG4gICAgfVxuICAgIC8vIFN1YnRpdGxlIGNvZGVjc1xuICAgIGlmIChjb2RlY1N0cmluZyA9PT0gJ3dlYnZ0dCcpIHtcbiAgICAgICAgcmV0dXJuICd3ZWJ2dHQnO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5leHBvcnQgY29uc3QgZ2V0VmlkZW9FbmNvZGVyQ29uZmlnRXh0ZW5zaW9uID0gKGNvZGVjKSA9PiB7XG4gICAgaWYgKGNvZGVjID09PSAnYXZjJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXZjOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnYXZjJywgLy8gRW5zdXJlIHRoZSBmb3JtYXQgaXMgbm90IEFubmV4IEJcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVjID09PSAnaGV2YycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhldmM6IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdoZXZjJywgLy8gRW5zdXJlIHRoZSBmb3JtYXQgaXMgbm90IEFubmV4IEJcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn07XG5leHBvcnQgY29uc3QgZ2V0QXVkaW9FbmNvZGVyQ29uZmlnRXh0ZW5zaW9uID0gKGNvZGVjKSA9PiB7XG4gICAgaWYgKGNvZGVjID09PSAnYWFjJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWFjOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnYWFjJywgLy8gRW5zdXJlIHRoZSBmb3JtYXQgaXMgbm90IEFEVFNcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVjID09PSAnb3B1cycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdXM6IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdvcHVzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn07XG5jb25zdCBWQUxJRF9WSURFT19DT0RFQ19TVFJJTkdfUFJFRklYRVMgPSBbJ2F2YzEnLCAnYXZjMycsICdoZXYxJywgJ2h2YzEnLCAndnA4JywgJ3ZwMDknLCAnYXYwMSddO1xuY29uc3QgQVZDX0NPREVDX1NUUklOR19SRUdFWCA9IC9eKGF2YzF8YXZjMylcXC5bMC05YS1mQS1GXXs2fSQvO1xuY29uc3QgSEVWQ19DT0RFQ19TVFJJTkdfUkVHRVggPSAvXihoZXYxfGh2YzEpXFwuKD86W0FCQ10/XFxkKylcXC5bMC05YS1mQS1GXXsxLDh9XFwuW0xIXVxcZCsoPzpcXC5bMC05YS1mQS1GXXsxLDJ9KXswLDZ9JC87XG5jb25zdCBWUDlfQ09ERUNfU1RSSU5HX1JFR0VYID0gL152cDA5KD86XFwuXFxkezJ9KXszfSg/Oig/OlxcLlxcZHsyfSl7NX0pPyQvO1xuY29uc3QgQVYxX0NPREVDX1NUUklOR19SRUdFWCA9IC9eYXYwMVxcLlxcZFxcLlxcZHsyfVtNSF1cXC5cXGR7Mn0oPzpcXC5cXGRcXC5cXGR7M31cXC5cXGR7Mn1cXC5cXGR7Mn1cXC5cXGR7Mn1cXC5cXGQpPyQvO1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlVmlkZW9DaHVua01ldGFkYXRhID0gKG1ldGFkYXRhKSA9PiB7XG4gICAgaWYgKCFtZXRhZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWaWRlbyBjaHVuayBtZXRhZGF0YSBtdXN0IGJlIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1ldGFkYXRhICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWaWRlbyBjaHVuayBtZXRhZGF0YSBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICB9XG4gICAgaWYgKCFtZXRhZGF0YS5kZWNvZGVyQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZpZGVvIGNodW5rIG1ldGFkYXRhIG11c3QgaW5jbHVkZSBhIGRlY29kZXIgY29uZmlndXJhdGlvbi4nKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtZXRhZGF0YS5kZWNvZGVyQ29uZmlnICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWaWRlbyBjaHVuayBtZXRhZGF0YSBkZWNvZGVyIGNvbmZpZ3VyYXRpb24gbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEuZGVjb2RlckNvbmZpZy5jb2RlYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVmlkZW8gY2h1bmsgbWV0YWRhdGEgZGVjb2RlciBjb25maWd1cmF0aW9uIG11c3Qgc3BlY2lmeSBhIGNvZGVjIHN0cmluZy4nKTtcbiAgICB9XG4gICAgaWYgKCFWQUxJRF9WSURFT19DT0RFQ19TVFJJTkdfUFJFRklYRVMuc29tZShwcmVmaXggPT4gbWV0YWRhdGEuZGVjb2RlckNvbmZpZy5jb2RlYy5zdGFydHNXaXRoKHByZWZpeCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZpZGVvIGNodW5rIG1ldGFkYXRhIGRlY29kZXIgY29uZmlndXJhdGlvbiBjb2RlYyBzdHJpbmcgbXVzdCBiZSBhIHZhbGlkIHZpZGVvIGNvZGVjIHN0cmluZyBhcyBzcGVjaWZpZWQgaW4nXG4gICAgICAgICAgICArICcgdGhlIFdlYkNvZGVjcyBDb2RlYyBSZWdpc3RyeS4nKTtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWRXaWR0aCkgfHwgbWV0YWRhdGEuZGVjb2RlckNvbmZpZy5jb2RlZFdpZHRoIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVmlkZW8gY2h1bmsgbWV0YWRhdGEgZGVjb2RlciBjb25maWd1cmF0aW9uIG11c3Qgc3BlY2lmeSBhIHZhbGlkIGNvZGVkV2lkdGggKHBvc2l0aXZlIGludGVnZXIpLicpO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWV0YWRhdGEuZGVjb2RlckNvbmZpZy5jb2RlZEhlaWdodCkgfHwgbWV0YWRhdGEuZGVjb2RlckNvbmZpZy5jb2RlZEhlaWdodCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZpZGVvIGNodW5rIG1ldGFkYXRhIGRlY29kZXIgY29uZmlndXJhdGlvbiBtdXN0IHNwZWNpZnkgYSB2YWxpZCBjb2RlZEhlaWdodCAocG9zaXRpdmUgaW50ZWdlcikuJyk7XG4gICAgfVxuICAgIGlmIChtZXRhZGF0YS5kZWNvZGVyQ29uZmlnLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFpc0FsbG93U2hhcmVkQnVmZmVyU291cmNlKG1ldGFkYXRhLmRlY29kZXJDb25maWcuZGVzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWaWRlbyBjaHVuayBtZXRhZGF0YSBkZWNvZGVyIGNvbmZpZ3VyYXRpb24gZGVzY3JpcHRpb24sIHdoZW4gZGVmaW5lZCwgbXVzdCBiZSBhbiBBcnJheUJ1ZmZlciBvciBhbidcbiAgICAgICAgICAgICAgICArICcgQXJyYXlCdWZmZXIgdmlldy4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobWV0YWRhdGEuZGVjb2RlckNvbmZpZy5jb2xvclNwYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgeyBjb2xvclNwYWNlIH0gPSBtZXRhZGF0YS5kZWNvZGVyQ29uZmlnO1xuICAgICAgICBpZiAodHlwZW9mIGNvbG9yU3BhY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWaWRlbyBjaHVuayBtZXRhZGF0YSBkZWNvZGVyIGNvbmZpZ3VyYXRpb24gY29sb3JTcGFjZSwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpbWFyaWVzVmFsdWVzID0gT2JqZWN0LmtleXMoQ09MT1JfUFJJTUFSSUVTX01BUCk7XG4gICAgICAgIGlmIChjb2xvclNwYWNlLnByaW1hcmllcyAhPSBudWxsICYmICFwcmltYXJpZXNWYWx1ZXMuaW5jbHVkZXMoY29sb3JTcGFjZS5wcmltYXJpZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBWaWRlbyBjaHVuayBtZXRhZGF0YSBkZWNvZGVyIGNvbmZpZ3VyYXRpb24gY29sb3JTcGFjZSBwcmltYXJpZXMsIHdoZW4gZGVmaW5lZCwgbXVzdCBiZSBvbmUgb2ZgXG4gICAgICAgICAgICAgICAgKyBgICR7cHJpbWFyaWVzVmFsdWVzLmpvaW4oJywgJyl9LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zZmVyVmFsdWVzID0gT2JqZWN0LmtleXMoVFJBTlNGRVJfQ0hBUkFDVEVSSVNUSUNTX01BUCk7XG4gICAgICAgIGlmIChjb2xvclNwYWNlLnRyYW5zZmVyICE9IG51bGwgJiYgIXRyYW5zZmVyVmFsdWVzLmluY2x1ZGVzKGNvbG9yU3BhY2UudHJhbnNmZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBWaWRlbyBjaHVuayBtZXRhZGF0YSBkZWNvZGVyIGNvbmZpZ3VyYXRpb24gY29sb3JTcGFjZSB0cmFuc2Zlciwgd2hlbiBkZWZpbmVkLCBtdXN0IGJlIG9uZSBvZmBcbiAgICAgICAgICAgICAgICArIGAgJHt0cmFuc2ZlclZhbHVlcy5qb2luKCcsICcpfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRyaXhWYWx1ZXMgPSBPYmplY3Qua2V5cyhNQVRSSVhfQ09FRkZJQ0lFTlRTX01BUCk7XG4gICAgICAgIGlmIChjb2xvclNwYWNlLm1hdHJpeCAhPSBudWxsICYmICFtYXRyaXhWYWx1ZXMuaW5jbHVkZXMoY29sb3JTcGFjZS5tYXRyaXgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBWaWRlbyBjaHVuayBtZXRhZGF0YSBkZWNvZGVyIGNvbmZpZ3VyYXRpb24gY29sb3JTcGFjZSBtYXRyaXgsIHdoZW4gZGVmaW5lZCwgbXVzdCBiZSBvbmUgb2ZgXG4gICAgICAgICAgICAgICAgKyBgICR7bWF0cml4VmFsdWVzLmpvaW4oJywgJyl9LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xvclNwYWNlLmZ1bGxSYW5nZSAhPSBudWxsICYmIHR5cGVvZiBjb2xvclNwYWNlLmZ1bGxSYW5nZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWaWRlbyBjaHVuayBtZXRhZGF0YSBkZWNvZGVyIGNvbmZpZ3VyYXRpb24gY29sb3JTcGFjZSBmdWxsUmFuZ2UsIHdoZW4gZGVmaW5lZCwgbXVzdCBiZSBhIGJvb2xlYW4uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMuc3RhcnRzV2l0aCgnYXZjMScpIHx8IG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMuc3RhcnRzV2l0aCgnYXZjMycpKSB7XG4gICAgICAgIC8vIEFWQy1zcGVjaWZpYyB2YWxpZGF0aW9uXG4gICAgICAgIGlmICghQVZDX0NPREVDX1NUUklOR19SRUdFWC50ZXN0KG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWaWRlbyBjaHVuayBtZXRhZGF0YSBkZWNvZGVyIGNvbmZpZ3VyYXRpb24gY29kZWMgc3RyaW5nIGZvciBBVkMgbXVzdCBiZSBhIHZhbGlkIEFWQyBjb2RlYyBzdHJpbmcgYXMnXG4gICAgICAgICAgICAgICAgKyAnIHNwZWNpZmllZCBpbiBTZWN0aW9uIDMuNCBvZiBSRkMgNjM4MS4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBgZGVzY3JpcHRpb25gIG1heSBvciBtYXkgbm90IGJlIHNldCwgZGVwZW5kaW5nIG9uIGlmIHRoZSBmb3JtYXQgaXMgQVZDQyBvciBBbm5leCBCLCBzbyBkb24ndCBwZXJmb3JtIGFueVxuICAgICAgICAvLyB2YWxpZGF0aW9uIGZvciBpdC5cbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmNvZGVjcy1hdmMtY29kZWMtcmVnaXN0cmF0aW9uXG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMuc3RhcnRzV2l0aCgnaGV2MScpIHx8IG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMuc3RhcnRzV2l0aCgnaHZjMScpKSB7XG4gICAgICAgIC8vIEhFVkMtc3BlY2lmaWMgdmFsaWRhdGlvblxuICAgICAgICBpZiAoIUhFVkNfQ09ERUNfU1RSSU5HX1JFR0VYLnRlc3QobWV0YWRhdGEuZGVjb2RlckNvbmZpZy5jb2RlYykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZpZGVvIGNodW5rIG1ldGFkYXRhIGRlY29kZXIgY29uZmlndXJhdGlvbiBjb2RlYyBzdHJpbmcgZm9yIEhFVkMgbXVzdCBiZSBhIHZhbGlkIEhFVkMgY29kZWMgc3RyaW5nIGFzJ1xuICAgICAgICAgICAgICAgICsgJyBzcGVjaWZpZWQgaW4gU2VjdGlvbiBFLjMgb2YgSVNPIDE0NDk2LTE1LicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBkZXNjcmlwdGlvbmAgbWF5IG9yIG1heSBub3QgYmUgc2V0LCBkZXBlbmRpbmcgb24gaWYgdGhlIGZvcm1hdCBpcyBIRVZDIG9yIEFubmV4IEIsIHNvIGRvbid0IHBlcmZvcm0gYW55XG4gICAgICAgIC8vIHZhbGlkYXRpb24gZm9yIGl0LlxuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViY29kZWNzLWhldmMtY29kZWMtcmVnaXN0cmF0aW9uXG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMuc3RhcnRzV2l0aCgndnA4JykpIHtcbiAgICAgICAgLy8gVlA4LXNwZWNpZmljIHZhbGlkYXRpb25cbiAgICAgICAgaWYgKG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMgIT09ICd2cDgnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWaWRlbyBjaHVuayBtZXRhZGF0YSBkZWNvZGVyIGNvbmZpZ3VyYXRpb24gY29kZWMgc3RyaW5nIGZvciBWUDggbXVzdCBiZSBcInZwOFwiLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMuc3RhcnRzV2l0aCgndnAwOScpKSB7XG4gICAgICAgIC8vIFZQOS1zcGVjaWZpYyB2YWxpZGF0aW9uXG4gICAgICAgIGlmICghVlA5X0NPREVDX1NUUklOR19SRUdFWC50ZXN0KG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWaWRlbyBjaHVuayBtZXRhZGF0YSBkZWNvZGVyIGNvbmZpZ3VyYXRpb24gY29kZWMgc3RyaW5nIGZvciBWUDkgbXVzdCBiZSBhIHZhbGlkIFZQOSBjb2RlYyBzdHJpbmcgYXMnXG4gICAgICAgICAgICAgICAgKyAnIHNwZWNpZmllZCBpbiBTZWN0aW9uIFwiQ29kZWNzIFBhcmFtZXRlciBTdHJpbmdcIiBvZiBodHRwczovL3d3dy53ZWJtcHJvamVjdC5vcmcvdnA5L21wNC8uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobWV0YWRhdGEuZGVjb2RlckNvbmZpZy5jb2RlYy5zdGFydHNXaXRoKCdhdjAxJykpIHtcbiAgICAgICAgLy8gQVYxLXNwZWNpZmljIHZhbGlkYXRpb25cbiAgICAgICAgaWYgKCFBVjFfQ09ERUNfU1RSSU5HX1JFR0VYLnRlc3QobWV0YWRhdGEuZGVjb2RlckNvbmZpZy5jb2RlYykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZpZGVvIGNodW5rIG1ldGFkYXRhIGRlY29kZXIgY29uZmlndXJhdGlvbiBjb2RlYyBzdHJpbmcgZm9yIEFWMSBtdXN0IGJlIGEgdmFsaWQgQVYxIGNvZGVjIHN0cmluZyBhcydcbiAgICAgICAgICAgICAgICArICcgc3BlY2lmaWVkIGluIFNlY3Rpb24gXCJDb2RlY3MgUGFyYW1ldGVyIFN0cmluZ1wiIG9mIGh0dHBzOi8vYW9tZWRpYWNvZGVjLmdpdGh1Yi5pby9hdjEtaXNvYm1mZi8uJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgVkFMSURfQVVESU9fQ09ERUNfU1RSSU5HX1BSRUZJWEVTID0gWydtcDRhJywgJ21wMycsICdvcHVzJywgJ3ZvcmJpcycsICdmbGFjJywgJ3VsYXcnLCAnYWxhdycsICdwY20nXTtcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUF1ZGlvQ2h1bmtNZXRhZGF0YSA9IChtZXRhZGF0YSkgPT4ge1xuICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXVkaW8gY2h1bmsgbWV0YWRhdGEgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtZXRhZGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXVkaW8gY2h1bmsgbWV0YWRhdGEgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuICAgIGlmICghbWV0YWRhdGEuZGVjb2RlckNvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBdWRpbyBjaHVuayBtZXRhZGF0YSBtdXN0IGluY2x1ZGUgYSBkZWNvZGVyIGNvbmZpZ3VyYXRpb24uJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEuZGVjb2RlckNvbmZpZyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXVkaW8gY2h1bmsgbWV0YWRhdGEgZGVjb2RlciBjb25maWd1cmF0aW9uIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0F1ZGlvIGNodW5rIG1ldGFkYXRhIGRlY29kZXIgY29uZmlndXJhdGlvbiBtdXN0IHNwZWNpZnkgYSBjb2RlYyBzdHJpbmcuJyk7XG4gICAgfVxuICAgIGlmICghVkFMSURfQVVESU9fQ09ERUNfU1RSSU5HX1BSRUZJWEVTLnNvbWUocHJlZml4ID0+IG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMuc3RhcnRzV2l0aChwcmVmaXgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBdWRpbyBjaHVuayBtZXRhZGF0YSBkZWNvZGVyIGNvbmZpZ3VyYXRpb24gY29kZWMgc3RyaW5nIG11c3QgYmUgYSB2YWxpZCBhdWRpbyBjb2RlYyBzdHJpbmcgYXMgc3BlY2lmaWVkIGluJ1xuICAgICAgICAgICAgKyAnIHRoZSBXZWJDb2RlY3MgQ29kZWMgUmVnaXN0cnkuJyk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtZXRhZGF0YS5kZWNvZGVyQ29uZmlnLnNhbXBsZVJhdGUpIHx8IG1ldGFkYXRhLmRlY29kZXJDb25maWcuc2FtcGxlUmF0ZSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0F1ZGlvIGNodW5rIG1ldGFkYXRhIGRlY29kZXIgY29uZmlndXJhdGlvbiBtdXN0IHNwZWNpZnkgYSB2YWxpZCBzYW1wbGVSYXRlIChwb3NpdGl2ZSBpbnRlZ2VyKS4nKTtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1ldGFkYXRhLmRlY29kZXJDb25maWcubnVtYmVyT2ZDaGFubmVscykgfHwgbWV0YWRhdGEuZGVjb2RlckNvbmZpZy5udW1iZXJPZkNoYW5uZWxzIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXVkaW8gY2h1bmsgbWV0YWRhdGEgZGVjb2RlciBjb25maWd1cmF0aW9uIG11c3Qgc3BlY2lmeSBhIHZhbGlkIG51bWJlck9mQ2hhbm5lbHMgKHBvc2l0aXZlIGludGVnZXIpLicpO1xuICAgIH1cbiAgICBpZiAobWV0YWRhdGEuZGVjb2RlckNvbmZpZy5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghaXNBbGxvd1NoYXJlZEJ1ZmZlclNvdXJjZShtZXRhZGF0YS5kZWNvZGVyQ29uZmlnLmRlc2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXVkaW8gY2h1bmsgbWV0YWRhdGEgZGVjb2RlciBjb25maWd1cmF0aW9uIGRlc2NyaXB0aW9uLCB3aGVuIGRlZmluZWQsIG11c3QgYmUgYW4gQXJyYXlCdWZmZXIgb3IgYW4nXG4gICAgICAgICAgICAgICAgKyAnIEFycmF5QnVmZmVyIHZpZXcuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMuc3RhcnRzV2l0aCgnbXA0YScpXG4gICAgICAgIC8vIFRoZXNlIHRocmVlIHJlZmVyIHRvIE1QMzpcbiAgICAgICAgJiYgbWV0YWRhdGEuZGVjb2RlckNvbmZpZy5jb2RlYyAhPT0gJ21wNGEuNjknXG4gICAgICAgICYmIG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMgIT09ICdtcDRhLjZCJ1xuICAgICAgICAmJiBtZXRhZGF0YS5kZWNvZGVyQ29uZmlnLmNvZGVjICE9PSAnbXA0YS42YicpIHtcbiAgICAgICAgLy8gQUFDLXNwZWNpZmljIHZhbGlkYXRpb25cbiAgICAgICAgY29uc3QgdmFsaWRTdHJpbmdzID0gWydtcDRhLjQwLjInLCAnbXA0YS40MC4wMicsICdtcDRhLjQwLjUnLCAnbXA0YS40MC4wNScsICdtcDRhLjQwLjI5JywgJ21wNGEuNjcnXTtcbiAgICAgICAgaWYgKCF2YWxpZFN0cmluZ3MuaW5jbHVkZXMobWV0YWRhdGEuZGVjb2RlckNvbmZpZy5jb2RlYykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0F1ZGlvIGNodW5rIG1ldGFkYXRhIGRlY29kZXIgY29uZmlndXJhdGlvbiBjb2RlYyBzdHJpbmcgZm9yIEFBQyBtdXN0IGJlIGEgdmFsaWQgQUFDIGNvZGVjIHN0cmluZyBhcydcbiAgICAgICAgICAgICAgICArICcgc3BlY2lmaWVkIGluIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJjb2RlY3MtYWFjLWNvZGVjLXJlZ2lzdHJhdGlvbi8uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXRhZGF0YS5kZWNvZGVyQ29uZmlnLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBdWRpbyBjaHVuayBtZXRhZGF0YSBkZWNvZGVyIGNvbmZpZ3VyYXRpb24gZm9yIEFBQyBtdXN0IGluY2x1ZGUgYSBkZXNjcmlwdGlvbiwgd2hpY2ggaXMgZXhwZWN0ZWQgdG8gYmUnXG4gICAgICAgICAgICAgICAgKyAnIGFuIEF1ZGlvU3BlY2lmaWNDb25maWcgYXMgc3BlY2lmaWVkIGluIElTTyAxNDQ5Ni0zLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMuc3RhcnRzV2l0aCgnbXAzJykgfHwgbWV0YWRhdGEuZGVjb2RlckNvbmZpZy5jb2RlYy5zdGFydHNXaXRoKCdtcDRhJykpIHtcbiAgICAgICAgLy8gTVAzLXNwZWNpZmljIHZhbGlkYXRpb25cbiAgICAgICAgaWYgKG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMgIT09ICdtcDMnXG4gICAgICAgICAgICAmJiBtZXRhZGF0YS5kZWNvZGVyQ29uZmlnLmNvZGVjICE9PSAnbXA0YS42OSdcbiAgICAgICAgICAgICYmIG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMgIT09ICdtcDRhLjZCJ1xuICAgICAgICAgICAgJiYgbWV0YWRhdGEuZGVjb2RlckNvbmZpZy5jb2RlYyAhPT0gJ21wNGEuNmInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBdWRpbyBjaHVuayBtZXRhZGF0YSBkZWNvZGVyIGNvbmZpZ3VyYXRpb24gY29kZWMgc3RyaW5nIGZvciBNUDMgbXVzdCBiZSBcIm1wM1wiLCBcIm1wNGEuNjlcIiBvcidcbiAgICAgICAgICAgICAgICArICcgXCJtcDRhLjZCXCIuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobWV0YWRhdGEuZGVjb2RlckNvbmZpZy5jb2RlYy5zdGFydHNXaXRoKCdvcHVzJykpIHtcbiAgICAgICAgLy8gT3B1cy1zcGVjaWZpYyB2YWxpZGF0aW9uXG4gICAgICAgIGlmIChtZXRhZGF0YS5kZWNvZGVyQ29uZmlnLmNvZGVjICE9PSAnb3B1cycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0F1ZGlvIGNodW5rIG1ldGFkYXRhIGRlY29kZXIgY29uZmlndXJhdGlvbiBjb2RlYyBzdHJpbmcgZm9yIE9wdXMgbXVzdCBiZSBcIm9wdXNcIi4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEuZGVjb2RlckNvbmZpZy5kZXNjcmlwdGlvbiAmJiBtZXRhZGF0YS5kZWNvZGVyQ29uZmlnLmRlc2NyaXB0aW9uLmJ5dGVMZW5ndGggPCAxOCkge1xuICAgICAgICAgICAgLy8gRGVzY3JpcHRpb24gaXMgb3B0aW9uYWwgZm9yIE9wdXMgcGVyLXNwZWMsIHNvIHdlIHNob3VsZG4ndCBlbmZvcmNlIGl0XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBdWRpbyBjaHVuayBtZXRhZGF0YSBkZWNvZGVyIGNvbmZpZ3VyYXRpb24gZGVzY3JpcHRpb24sIHdoZW4gc3BlY2lmaWVkLCBpcyBleHBlY3RlZCB0byBiZSBhbidcbiAgICAgICAgICAgICAgICArICcgSWRlbnRpZmljYXRpb24gSGVhZGVyIGFzIHNwZWNpZmllZCBpbiBTZWN0aW9uIDUuMSBvZiBSRkMgNzg0NS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChtZXRhZGF0YS5kZWNvZGVyQ29uZmlnLmNvZGVjLnN0YXJ0c1dpdGgoJ3ZvcmJpcycpKSB7XG4gICAgICAgIC8vIFZvcmJpcy1zcGVjaWZpYyB2YWxpZGF0aW9uXG4gICAgICAgIGlmIChtZXRhZGF0YS5kZWNvZGVyQ29uZmlnLmNvZGVjICE9PSAndm9yYmlzJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXVkaW8gY2h1bmsgbWV0YWRhdGEgZGVjb2RlciBjb25maWd1cmF0aW9uIGNvZGVjIHN0cmluZyBmb3IgVm9yYmlzIG11c3QgYmUgXCJ2b3JiaXNcIi4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1ldGFkYXRhLmRlY29kZXJDb25maWcuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0F1ZGlvIGNodW5rIG1ldGFkYXRhIGRlY29kZXIgY29uZmlndXJhdGlvbiBmb3IgVm9yYmlzIG11c3QgaW5jbHVkZSBhIGRlc2NyaXB0aW9uLCB3aGljaCBpcyBleHBlY3RlZCB0bydcbiAgICAgICAgICAgICAgICArICcgYWRoZXJlIHRvIHRoZSBmb3JtYXQgZGVzY3JpYmVkIGluIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJjb2RlY3Mtdm9yYmlzLWNvZGVjLXJlZ2lzdHJhdGlvbi8uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobWV0YWRhdGEuZGVjb2RlckNvbmZpZy5jb2RlYy5zdGFydHNXaXRoKCdmbGFjJykpIHtcbiAgICAgICAgLy8gRkxBQy1zcGVjaWZpYyB2YWxpZGF0aW9uXG4gICAgICAgIGlmIChtZXRhZGF0YS5kZWNvZGVyQ29uZmlnLmNvZGVjICE9PSAnZmxhYycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0F1ZGlvIGNodW5rIG1ldGFkYXRhIGRlY29kZXIgY29uZmlndXJhdGlvbiBjb2RlYyBzdHJpbmcgZm9yIEZMQUMgbXVzdCBiZSBcImZsYWNcIi4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW5EZXNjcmlwdGlvblNpemUgPSA0ICsgNCArIDM0OyAvLyAnZkxhQycgKyBtZXRhZGF0YSBibG9jayBoZWFkZXIgKyBTVFJFQU1JTkZPIGJsb2NrXG4gICAgICAgIGlmICghbWV0YWRhdGEuZGVjb2RlckNvbmZpZy5kZXNjcmlwdGlvbiB8fCBtZXRhZGF0YS5kZWNvZGVyQ29uZmlnLmRlc2NyaXB0aW9uLmJ5dGVMZW5ndGggPCBtaW5EZXNjcmlwdGlvblNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0F1ZGlvIGNodW5rIG1ldGFkYXRhIGRlY29kZXIgY29uZmlndXJhdGlvbiBmb3IgRkxBQyBtdXN0IGluY2x1ZGUgYSBkZXNjcmlwdGlvbiwgd2hpY2ggaXMgZXhwZWN0ZWQgdG8nXG4gICAgICAgICAgICAgICAgKyAnIGFkaGVyZSB0byB0aGUgZm9ybWF0IGRlc2NyaWJlZCBpbiBodHRwczovL3d3dy53My5vcmcvVFIvd2ViY29kZWNzLWZsYWMtY29kZWMtcmVnaXN0cmF0aW9uLy4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChtZXRhZGF0YS5kZWNvZGVyQ29uZmlnLmNvZGVjLnN0YXJ0c1dpdGgoJ3BjbScpXG4gICAgICAgIHx8IG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMuc3RhcnRzV2l0aCgndWxhdycpXG4gICAgICAgIHx8IG1ldGFkYXRhLmRlY29kZXJDb25maWcuY29kZWMuc3RhcnRzV2l0aCgnYWxhdycpKSB7XG4gICAgICAgIC8vIFBDTS1zcGVjaWZpYyB2YWxpZGF0aW9uXG4gICAgICAgIGlmICghUENNX0FVRElPX0NPREVDUy5pbmNsdWRlcyhtZXRhZGF0YS5kZWNvZGVyQ29uZmlnLmNvZGVjKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXVkaW8gY2h1bmsgbWV0YWRhdGEgZGVjb2RlciBjb25maWd1cmF0aW9uIGNvZGVjIHN0cmluZyBmb3IgUENNIG11c3QgYmUgb25lIG9mIHRoZSBzdXBwb3J0ZWQgUENNJ1xuICAgICAgICAgICAgICAgICsgYCBjb2RlY3MgKCR7UENNX0FVRElPX0NPREVDUy5qb2luKCcsICcpfSkuYCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlU3VidGl0bGVNZXRhZGF0YSA9IChtZXRhZGF0YSkgPT4ge1xuICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VidGl0bGUgbWV0YWRhdGEgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtZXRhZGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VidGl0bGUgbWV0YWRhdGEgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuICAgIGlmICghbWV0YWRhdGEuY29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1YnRpdGxlIG1ldGFkYXRhIG11c3QgaW5jbHVkZSBhIGNvbmZpZyBvYmplY3QuJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEuY29uZmlnICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdWJ0aXRsZSBtZXRhZGF0YSBjb25maWcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEuY29uZmlnLmRlc2NyaXB0aW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdWJ0aXRsZSBtZXRhZGF0YSBjb25maWcgZGVzY3JpcHRpb24gbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/codec.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/custom-coder.js":
/*!******************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/custom-coder.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomAudioDecoder: () => (/* binding */ CustomAudioDecoder),\n/* harmony export */   CustomAudioEncoder: () => (/* binding */ CustomAudioEncoder),\n/* harmony export */   CustomVideoDecoder: () => (/* binding */ CustomVideoDecoder),\n/* harmony export */   CustomVideoEncoder: () => (/* binding */ CustomVideoEncoder),\n/* harmony export */   customAudioDecoders: () => (/* binding */ customAudioDecoders),\n/* harmony export */   customAudioEncoders: () => (/* binding */ customAudioEncoders),\n/* harmony export */   customVideoDecoders: () => (/* binding */ customVideoDecoders),\n/* harmony export */   customVideoEncoders: () => (/* binding */ customVideoEncoders),\n/* harmony export */   registerDecoder: () => (/* binding */ registerDecoder),\n/* harmony export */   registerEncoder: () => (/* binding */ registerEncoder)\n/* harmony export */ });\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/**\n * Base class for custom video decoders. To add your own custom video decoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the decoder using {@link registerDecoder}.\n * @group Custom coders\n * @public\n */\nclass CustomVideoDecoder {\n    /** Returns true if and only if the decoder can decode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom audio decoders. To add your own custom audio decoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the decoder using {@link registerDecoder}.\n * @group Custom coders\n * @public\n */\nclass CustomAudioDecoder {\n    /** Returns true if and only if the decoder can decode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom video encoders. To add your own custom video encoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the encoder using {@link registerEncoder}.\n * @group Custom coders\n * @public\n */\nclass CustomVideoEncoder {\n    /** Returns true if and only if the encoder can encode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom audio encoders. To add your own custom audio encoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the encoder using {@link registerEncoder}.\n * @group Custom coders\n * @public\n */\nclass CustomAudioEncoder {\n    /** Returns true if and only if the encoder can encode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\nconst customVideoDecoders = [];\nconst customAudioDecoders = [];\nconst customVideoEncoders = [];\nconst customAudioEncoders = [];\n/**\n * Registers a custom video or audio decoder. Registered decoders will automatically be used for decoding whenever\n * possible.\n * @group Custom coders\n * @public\n */\nconst registerDecoder = (decoder) => {\n    if (decoder.prototype instanceof CustomVideoDecoder) {\n        const casted = decoder;\n        if (customVideoDecoders.includes(casted)) {\n            console.warn('Video decoder already registered.');\n            return;\n        }\n        customVideoDecoders.push(casted);\n    }\n    else if (decoder.prototype instanceof CustomAudioDecoder) {\n        const casted = decoder;\n        if (customAudioDecoders.includes(casted)) {\n            console.warn('Audio decoder already registered.');\n            return;\n        }\n        customAudioDecoders.push(casted);\n    }\n    else {\n        throw new TypeError('Decoder must be a CustomVideoDecoder or CustomAudioDecoder.');\n    }\n};\n/**\n * Registers a custom video or audio encoder. Registered encoders will automatically be used for encoding whenever\n * possible.\n * @group Custom coders\n * @public\n */\nconst registerEncoder = (encoder) => {\n    if (encoder.prototype instanceof CustomVideoEncoder) {\n        const casted = encoder;\n        if (customVideoEncoders.includes(casted)) {\n            console.warn('Video encoder already registered.');\n            return;\n        }\n        customVideoEncoders.push(casted);\n    }\n    else if (encoder.prototype instanceof CustomAudioEncoder) {\n        const casted = encoder;\n        if (customAudioEncoders.includes(casted)) {\n            console.warn('Audio encoder already registered.');\n            return;\n        }\n        customAudioEncoders.push(casted);\n    }\n    else {\n        throw new TypeError('Encoder must be a CustomVideoEncoder or CustomAudioEncoder.');\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL2N1c3RvbS1jb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLHNCQUFzQjtBQUN4RztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Ysc0JBQXNCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixzQkFBc0I7QUFDeEc7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLHNCQUFzQjtBQUN4RztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWF0Y2gtY3V0LWdlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9tZWRpYWJ1bm55L2Rpc3QvbW9kdWxlcy9zcmMvY3VzdG9tLWNvZGVyLmpzPzU3ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjUtcHJlc2VudCwgVmFuaWxhZ3kgYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGN1c3RvbSB2aWRlbyBkZWNvZGVycy4gVG8gYWRkIHlvdXIgb3duIGN1c3RvbSB2aWRlbyBkZWNvZGVyLCBleHRlbmQgdGhpcyBjbGFzcywgaW1wbGVtZW50IHRoZVxuICogYWJzdHJhY3QgbWV0aG9kcyBhbmQgc3RhdGljIGBzdXBwb3J0c2AgbWV0aG9kLCBhbmQgcmVnaXN0ZXIgdGhlIGRlY29kZXIgdXNpbmcge0BsaW5rIHJlZ2lzdGVyRGVjb2Rlcn0uXG4gKiBAZ3JvdXAgQ3VzdG9tIGNvZGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQ3VzdG9tVmlkZW9EZWNvZGVyIHtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBkZWNvZGVyIGNhbiBkZWNvZGUgdGhlIGdpdmVuIGNvZGVjIGNvbmZpZ3VyYXRpb24uICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHN0YXRpYyBzdXBwb3J0cyhjb2RlYywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGN1c3RvbSBhdWRpbyBkZWNvZGVycy4gVG8gYWRkIHlvdXIgb3duIGN1c3RvbSBhdWRpbyBkZWNvZGVyLCBleHRlbmQgdGhpcyBjbGFzcywgaW1wbGVtZW50IHRoZVxuICogYWJzdHJhY3QgbWV0aG9kcyBhbmQgc3RhdGljIGBzdXBwb3J0c2AgbWV0aG9kLCBhbmQgcmVnaXN0ZXIgdGhlIGRlY29kZXIgdXNpbmcge0BsaW5rIHJlZ2lzdGVyRGVjb2Rlcn0uXG4gKiBAZ3JvdXAgQ3VzdG9tIGNvZGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQ3VzdG9tQXVkaW9EZWNvZGVyIHtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBkZWNvZGVyIGNhbiBkZWNvZGUgdGhlIGdpdmVuIGNvZGVjIGNvbmZpZ3VyYXRpb24uICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHN0YXRpYyBzdXBwb3J0cyhjb2RlYywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGN1c3RvbSB2aWRlbyBlbmNvZGVycy4gVG8gYWRkIHlvdXIgb3duIGN1c3RvbSB2aWRlbyBlbmNvZGVyLCBleHRlbmQgdGhpcyBjbGFzcywgaW1wbGVtZW50IHRoZVxuICogYWJzdHJhY3QgbWV0aG9kcyBhbmQgc3RhdGljIGBzdXBwb3J0c2AgbWV0aG9kLCBhbmQgcmVnaXN0ZXIgdGhlIGVuY29kZXIgdXNpbmcge0BsaW5rIHJlZ2lzdGVyRW5jb2Rlcn0uXG4gKiBAZ3JvdXAgQ3VzdG9tIGNvZGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQ3VzdG9tVmlkZW9FbmNvZGVyIHtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBlbmNvZGVyIGNhbiBlbmNvZGUgdGhlIGdpdmVuIGNvZGVjIGNvbmZpZ3VyYXRpb24uICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHN0YXRpYyBzdXBwb3J0cyhjb2RlYywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGN1c3RvbSBhdWRpbyBlbmNvZGVycy4gVG8gYWRkIHlvdXIgb3duIGN1c3RvbSBhdWRpbyBlbmNvZGVyLCBleHRlbmQgdGhpcyBjbGFzcywgaW1wbGVtZW50IHRoZVxuICogYWJzdHJhY3QgbWV0aG9kcyBhbmQgc3RhdGljIGBzdXBwb3J0c2AgbWV0aG9kLCBhbmQgcmVnaXN0ZXIgdGhlIGVuY29kZXIgdXNpbmcge0BsaW5rIHJlZ2lzdGVyRW5jb2Rlcn0uXG4gKiBAZ3JvdXAgQ3VzdG9tIGNvZGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQ3VzdG9tQXVkaW9FbmNvZGVyIHtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBlbmNvZGVyIGNhbiBlbmNvZGUgdGhlIGdpdmVuIGNvZGVjIGNvbmZpZ3VyYXRpb24uICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHN0YXRpYyBzdXBwb3J0cyhjb2RlYywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgY3VzdG9tVmlkZW9EZWNvZGVycyA9IFtdO1xuZXhwb3J0IGNvbnN0IGN1c3RvbUF1ZGlvRGVjb2RlcnMgPSBbXTtcbmV4cG9ydCBjb25zdCBjdXN0b21WaWRlb0VuY29kZXJzID0gW107XG5leHBvcnQgY29uc3QgY3VzdG9tQXVkaW9FbmNvZGVycyA9IFtdO1xuLyoqXG4gKiBSZWdpc3RlcnMgYSBjdXN0b20gdmlkZW8gb3IgYXVkaW8gZGVjb2Rlci4gUmVnaXN0ZXJlZCBkZWNvZGVycyB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgdXNlZCBmb3IgZGVjb2Rpbmcgd2hlbmV2ZXJcbiAqIHBvc3NpYmxlLlxuICogQGdyb3VwIEN1c3RvbSBjb2RlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyRGVjb2RlciA9IChkZWNvZGVyKSA9PiB7XG4gICAgaWYgKGRlY29kZXIucHJvdG90eXBlIGluc3RhbmNlb2YgQ3VzdG9tVmlkZW9EZWNvZGVyKSB7XG4gICAgICAgIGNvbnN0IGNhc3RlZCA9IGRlY29kZXI7XG4gICAgICAgIGlmIChjdXN0b21WaWRlb0RlY29kZXJzLmluY2x1ZGVzKGNhc3RlZCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVmlkZW8gZGVjb2RlciBhbHJlYWR5IHJlZ2lzdGVyZWQuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3VzdG9tVmlkZW9EZWNvZGVycy5wdXNoKGNhc3RlZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlY29kZXIucHJvdG90eXBlIGluc3RhbmNlb2YgQ3VzdG9tQXVkaW9EZWNvZGVyKSB7XG4gICAgICAgIGNvbnN0IGNhc3RlZCA9IGRlY29kZXI7XG4gICAgICAgIGlmIChjdXN0b21BdWRpb0RlY29kZXJzLmluY2x1ZGVzKGNhc3RlZCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQXVkaW8gZGVjb2RlciBhbHJlYWR5IHJlZ2lzdGVyZWQuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3VzdG9tQXVkaW9EZWNvZGVycy5wdXNoKGNhc3RlZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEZWNvZGVyIG11c3QgYmUgYSBDdXN0b21WaWRlb0RlY29kZXIgb3IgQ3VzdG9tQXVkaW9EZWNvZGVyLicpO1xuICAgIH1cbn07XG4vKipcbiAqIFJlZ2lzdGVycyBhIGN1c3RvbSB2aWRlbyBvciBhdWRpbyBlbmNvZGVyLiBSZWdpc3RlcmVkIGVuY29kZXJzIHdpbGwgYXV0b21hdGljYWxseSBiZSB1c2VkIGZvciBlbmNvZGluZyB3aGVuZXZlclxuICogcG9zc2libGUuXG4gKiBAZ3JvdXAgQ3VzdG9tIGNvZGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJFbmNvZGVyID0gKGVuY29kZXIpID0+IHtcbiAgICBpZiAoZW5jb2Rlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBDdXN0b21WaWRlb0VuY29kZXIpIHtcbiAgICAgICAgY29uc3QgY2FzdGVkID0gZW5jb2RlcjtcbiAgICAgICAgaWYgKGN1c3RvbVZpZGVvRW5jb2RlcnMuaW5jbHVkZXMoY2FzdGVkKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdWaWRlbyBlbmNvZGVyIGFscmVhZHkgcmVnaXN0ZXJlZC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdXN0b21WaWRlb0VuY29kZXJzLnB1c2goY2FzdGVkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZW5jb2Rlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBDdXN0b21BdWRpb0VuY29kZXIpIHtcbiAgICAgICAgY29uc3QgY2FzdGVkID0gZW5jb2RlcjtcbiAgICAgICAgaWYgKGN1c3RvbUF1ZGlvRW5jb2RlcnMuaW5jbHVkZXMoY2FzdGVkKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdBdWRpbyBlbmNvZGVyIGFscmVhZHkgcmVnaXN0ZXJlZC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdXN0b21BdWRpb0VuY29kZXJzLnB1c2goY2FzdGVkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuY29kZXIgbXVzdCBiZSBhIEN1c3RvbVZpZGVvRW5jb2RlciBvciBDdXN0b21BdWRpb0VuY29kZXIuJyk7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/custom-coder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/demuxer.js":
/*!*************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/demuxer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Demuxer: () => (/* binding */ Demuxer)\n/* harmony export */ });\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nclass Demuxer {\n    constructor(input) {\n        this.input = input;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL2RlbXV4ZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGNoLWN1dC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL2RlbXV4ZXIuanM/MTRlYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAyNS1wcmVzZW50LCBWYW5pbGFneSBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmV4cG9ydCBjbGFzcyBEZW11eGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/demuxer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/encode.js":
/*!************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/encode.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QUALITY_HIGH: () => (/* binding */ QUALITY_HIGH),\n/* harmony export */   QUALITY_LOW: () => (/* binding */ QUALITY_LOW),\n/* harmony export */   QUALITY_MEDIUM: () => (/* binding */ QUALITY_MEDIUM),\n/* harmony export */   QUALITY_VERY_HIGH: () => (/* binding */ QUALITY_VERY_HIGH),\n/* harmony export */   QUALITY_VERY_LOW: () => (/* binding */ QUALITY_VERY_LOW),\n/* harmony export */   Quality: () => (/* binding */ Quality),\n/* harmony export */   buildAudioEncoderConfig: () => (/* binding */ buildAudioEncoderConfig),\n/* harmony export */   buildVideoEncoderConfig: () => (/* binding */ buildVideoEncoderConfig),\n/* harmony export */   canEncode: () => (/* binding */ canEncode),\n/* harmony export */   canEncodeAudio: () => (/* binding */ canEncodeAudio),\n/* harmony export */   canEncodeSubtitles: () => (/* binding */ canEncodeSubtitles),\n/* harmony export */   canEncodeVideo: () => (/* binding */ canEncodeVideo),\n/* harmony export */   getEncodableAudioCodecs: () => (/* binding */ getEncodableAudioCodecs),\n/* harmony export */   getEncodableCodecs: () => (/* binding */ getEncodableCodecs),\n/* harmony export */   getEncodableSubtitleCodecs: () => (/* binding */ getEncodableSubtitleCodecs),\n/* harmony export */   getEncodableVideoCodecs: () => (/* binding */ getEncodableVideoCodecs),\n/* harmony export */   getFirstEncodableAudioCodec: () => (/* binding */ getFirstEncodableAudioCodec),\n/* harmony export */   getFirstEncodableSubtitleCodec: () => (/* binding */ getFirstEncodableSubtitleCodec),\n/* harmony export */   getFirstEncodableVideoCodec: () => (/* binding */ getFirstEncodableVideoCodec),\n/* harmony export */   validateAudioEncodingAdditionalOptions: () => (/* binding */ validateAudioEncodingAdditionalOptions),\n/* harmony export */   validateAudioEncodingConfig: () => (/* binding */ validateAudioEncodingConfig),\n/* harmony export */   validateVideoEncodingAdditionalOptions: () => (/* binding */ validateVideoEncodingAdditionalOptions),\n/* harmony export */   validateVideoEncodingConfig: () => (/* binding */ validateVideoEncodingConfig)\n/* harmony export */ });\n/* harmony import */ var _codec_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./codec.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec.js\");\n/* harmony import */ var _custom_coder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./custom-coder.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/custom-coder.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\nconst validateVideoEncodingConfig = (config) => {\n    if (!config || typeof config !== 'object') {\n        throw new TypeError('Encoding config must be an object.');\n    }\n    if (!_codec_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO_CODECS.includes(config.codec)) {\n        throw new TypeError(`Invalid video codec '${config.codec}'. Must be one of: ${_codec_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO_CODECS.join(', ')}.`);\n    }\n    if (!(config.bitrate instanceof Quality) && (!Number.isInteger(config.bitrate) || config.bitrate <= 0)) {\n        throw new TypeError('config.bitrate must be a positive integer or a quality.');\n    }\n    if (config.keyFrameInterval !== undefined\n        && (!Number.isFinite(config.keyFrameInterval) || config.keyFrameInterval < 0)) {\n        throw new TypeError('config.keyFrameInterval, when provided, must be a non-negative number.');\n    }\n    if (config.sizeChangeBehavior !== undefined\n        && !['deny', 'passThrough', 'fill', 'contain', 'cover'].includes(config.sizeChangeBehavior)) {\n        throw new TypeError('config.sizeChangeBehavior, when provided, must be \\'deny\\', \\'passThrough\\', \\'fill\\', \\'contain\\''\n            + ' or \\'cover\\'.');\n    }\n    if (config.onEncodedPacket !== undefined && typeof config.onEncodedPacket !== 'function') {\n        throw new TypeError('config.onEncodedChunk, when provided, must be a function.');\n    }\n    if (config.onEncoderConfig !== undefined && typeof config.onEncoderConfig !== 'function') {\n        throw new TypeError('config.onEncoderConfig, when provided, must be a function.');\n    }\n    validateVideoEncodingAdditionalOptions(config.codec, config);\n};\nconst validateVideoEncodingAdditionalOptions = (codec, options) => {\n    if (!options || typeof options !== 'object') {\n        throw new TypeError('Encoding options must be an object.');\n    }\n    if (options.bitrateMode !== undefined && !['constant', 'variable'].includes(options.bitrateMode)) {\n        throw new TypeError('bitrateMode, when provided, must be \\'constant\\' or \\'variable\\'.');\n    }\n    if (options.latencyMode !== undefined && !['quality', 'realtime'].includes(options.latencyMode)) {\n        throw new TypeError('latencyMode, when provided, must be \\'quality\\' or \\'realtime\\'.');\n    }\n    if (options.fullCodecString !== undefined && typeof options.fullCodecString !== 'string') {\n        throw new TypeError('fullCodecString, when provided, must be a string.');\n    }\n    if (options.fullCodecString !== undefined && (0,_codec_js__WEBPACK_IMPORTED_MODULE_0__.inferCodecFromCodecString)(options.fullCodecString) !== codec) {\n        throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${codec}).`);\n    }\n    if (options.hardwareAcceleration !== undefined\n        && !['no-preference', 'prefer-hardware', 'prefer-software'].includes(options.hardwareAcceleration)) {\n        throw new TypeError('hardwareAcceleration, when provided, must be \\'no-preference\\', \\'prefer-hardware\\' or'\n            + ' \\'prefer-software\\'.');\n    }\n    if (options.scalabilityMode !== undefined && typeof options.scalabilityMode !== 'string') {\n        throw new TypeError('scalabilityMode, when provided, must be a string.');\n    }\n    if (options.contentHint !== undefined && typeof options.contentHint !== 'string') {\n        throw new TypeError('contentHint, when provided, must be a string.');\n    }\n};\nconst buildVideoEncoderConfig = (options) => {\n    const resolvedBitrate = options.bitrate instanceof Quality\n        ? options.bitrate._toVideoBitrate(options.codec, options.width, options.height)\n        : options.bitrate;\n    return {\n        codec: options.fullCodecString ?? (0,_codec_js__WEBPACK_IMPORTED_MODULE_0__.buildVideoCodecString)(options.codec, options.width, options.height, resolvedBitrate),\n        width: options.width,\n        height: options.height,\n        bitrate: resolvedBitrate,\n        bitrateMode: options.bitrateMode,\n        framerate: options.framerate, // this.source._connectedTrack?.metadata.frameRate,\n        latencyMode: options.latencyMode,\n        hardwareAcceleration: options.hardwareAcceleration,\n        scalabilityMode: options.scalabilityMode,\n        contentHint: options.contentHint,\n        ...(0,_codec_js__WEBPACK_IMPORTED_MODULE_0__.getVideoEncoderConfigExtension)(options.codec),\n    };\n};\nconst validateAudioEncodingConfig = (config) => {\n    if (!config || typeof config !== 'object') {\n        throw new TypeError('Encoding config must be an object.');\n    }\n    if (!_codec_js__WEBPACK_IMPORTED_MODULE_0__.AUDIO_CODECS.includes(config.codec)) {\n        throw new TypeError(`Invalid audio codec '${config.codec}'. Must be one of: ${_codec_js__WEBPACK_IMPORTED_MODULE_0__.AUDIO_CODECS.join(', ')}.`);\n    }\n    if (config.bitrate === undefined\n        && (!_codec_js__WEBPACK_IMPORTED_MODULE_0__.PCM_AUDIO_CODECS.includes(config.codec) || config.codec === 'flac')) {\n        throw new TypeError('config.bitrate must be provided for compressed audio codecs.');\n    }\n    if (config.bitrate !== undefined\n        && !(config.bitrate instanceof Quality)\n        && (!Number.isInteger(config.bitrate) || config.bitrate <= 0)) {\n        throw new TypeError('config.bitrate, when provided, must be a positive integer or a quality.');\n    }\n    if (config.onEncodedPacket !== undefined && typeof config.onEncodedPacket !== 'function') {\n        throw new TypeError('config.onEncodedChunk, when provided, must be a function.');\n    }\n    if (config.onEncoderConfig !== undefined && typeof config.onEncoderConfig !== 'function') {\n        throw new TypeError('config.onEncoderConfig, when provided, must be a function.');\n    }\n    validateAudioEncodingAdditionalOptions(config.codec, config);\n};\nconst validateAudioEncodingAdditionalOptions = (codec, options) => {\n    if (!options || typeof options !== 'object') {\n        throw new TypeError('Encoding options must be an object.');\n    }\n    if (options.bitrateMode !== undefined && !['constant', 'variable'].includes(options.bitrateMode)) {\n        throw new TypeError('bitrateMode, when provided, must be \\'constant\\' or \\'variable\\'.');\n    }\n    if (options.fullCodecString !== undefined && typeof options.fullCodecString !== 'string') {\n        throw new TypeError('fullCodecString, when provided, must be a string.');\n    }\n    if (options.fullCodecString !== undefined && (0,_codec_js__WEBPACK_IMPORTED_MODULE_0__.inferCodecFromCodecString)(options.fullCodecString) !== codec) {\n        throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${codec}).`);\n    }\n};\nconst buildAudioEncoderConfig = (options) => {\n    const resolvedBitrate = options.bitrate instanceof Quality\n        ? options.bitrate._toAudioBitrate(options.codec)\n        : options.bitrate;\n    return {\n        codec: options.fullCodecString ?? (0,_codec_js__WEBPACK_IMPORTED_MODULE_0__.buildAudioCodecString)(options.codec, options.numberOfChannels, options.sampleRate),\n        numberOfChannels: options.numberOfChannels,\n        sampleRate: options.sampleRate,\n        bitrate: resolvedBitrate,\n        bitrateMode: options.bitrateMode,\n        ...(0,_codec_js__WEBPACK_IMPORTED_MODULE_0__.getAudioEncoderConfigExtension)(options.codec),\n    };\n};\n/**\n * Represents a subjective media quality level.\n * @group Encoding\n * @public\n */\nclass Quality {\n    /** @internal */\n    constructor(factor) {\n        this._factor = factor;\n    }\n    /** @internal */\n    _toVideoBitrate(codec, width, height) {\n        const pixels = width * height;\n        const codecEfficiencyFactors = {\n            avc: 1.0, // H.264/AVC (baseline)\n            hevc: 0.6, // H.265/HEVC (~40% more efficient than AVC)\n            vp9: 0.6, // Similar to HEVC\n            av1: 0.4, // ~60% more efficient than AVC\n            vp8: 1.2, // Slightly less efficient than AVC\n        };\n        const referencePixels = 1920 * 1080;\n        const referenceBitrate = 3000000;\n        const scaleFactor = Math.pow(pixels / referencePixels, 0.95); // Slight non-linear scaling\n        const baseBitrate = referenceBitrate * scaleFactor;\n        const codecAdjustedBitrate = baseBitrate * codecEfficiencyFactors[codec];\n        const finalBitrate = codecAdjustedBitrate * this._factor;\n        return Math.ceil(finalBitrate / 1000) * 1000;\n    }\n    /** @internal */\n    _toAudioBitrate(codec) {\n        if (_codec_js__WEBPACK_IMPORTED_MODULE_0__.PCM_AUDIO_CODECS.includes(codec) || codec === 'flac') {\n            return undefined;\n        }\n        const baseRates = {\n            aac: 128000, // 128kbps base for AAC\n            opus: 64000, // 64kbps base for Opus\n            mp3: 160000, // 160kbps base for MP3\n            vorbis: 64000, // 64kbps base for Vorbis\n        };\n        const baseBitrate = baseRates[codec];\n        if (!baseBitrate) {\n            throw new Error(`Unhandled codec: ${codec}`);\n        }\n        let finalBitrate = baseBitrate * this._factor;\n        if (codec === 'aac') {\n            // AAC only works with specific bitrates, let's find the closest\n            const validRates = [96000, 128000, 160000, 192000];\n            finalBitrate = validRates.reduce((prev, curr) => Math.abs(curr - finalBitrate) < Math.abs(prev - finalBitrate) ? curr : prev);\n        }\n        else if (codec === 'opus' || codec === 'vorbis') {\n            finalBitrate = Math.max(6000, finalBitrate);\n        }\n        else if (codec === 'mp3') {\n            const validRates = [\n                8000, 16000, 24000, 32000, 40000, 48000, 64000, 80000,\n                96000, 112000, 128000, 160000, 192000, 224000, 256000, 320000,\n            ];\n            finalBitrate = validRates.reduce((prev, curr) => Math.abs(curr - finalBitrate) < Math.abs(prev - finalBitrate) ? curr : prev);\n        }\n        return Math.round(finalBitrate / 1000) * 1000;\n    }\n}\n/**\n * Represents a very low media quality.\n * @group Encoding\n * @public\n */\nconst QUALITY_VERY_LOW = new Quality(0.3);\n/**\n * Represents a low media quality.\n * @group Encoding\n * @public\n */\nconst QUALITY_LOW = new Quality(0.6);\n/**\n * Represents a medium media quality.\n * @group Encoding\n * @public\n */\nconst QUALITY_MEDIUM = new Quality(1);\n/**\n * Represents a high media quality.\n * @group Encoding\n * @public\n */\nconst QUALITY_HIGH = new Quality(2);\n/**\n * Represents a very high media quality.\n * @group Encoding\n * @public\n */\nconst QUALITY_VERY_HIGH = new Quality(4);\n/**\n * Checks if the browser is able to encode the given codec.\n * @group Encoding\n * @public\n */\nconst canEncode = (codec) => {\n    if (_codec_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO_CODECS.includes(codec)) {\n        return canEncodeVideo(codec);\n    }\n    else if (_codec_js__WEBPACK_IMPORTED_MODULE_0__.AUDIO_CODECS.includes(codec)) {\n        return canEncodeAudio(codec);\n    }\n    else if (_codec_js__WEBPACK_IMPORTED_MODULE_0__.SUBTITLE_CODECS.includes(codec)) {\n        return canEncodeSubtitles(codec);\n    }\n    throw new TypeError(`Unknown codec '${codec}'.`);\n};\n/**\n * Checks if the browser is able to encode the given video codec with the given parameters.\n * @group Encoding\n * @public\n */\nconst canEncodeVideo = async (codec, options = {}) => {\n    const { width = 1280, height = 720, bitrate = 1e6, ...restOptions } = options;\n    if (!_codec_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO_CODECS.includes(codec)) {\n        return false;\n    }\n    if (!Number.isInteger(width) || width <= 0) {\n        throw new TypeError('width must be a positive integer.');\n    }\n    if (!Number.isInteger(height) || height <= 0) {\n        throw new TypeError('height must be a positive integer.');\n    }\n    if (!(bitrate instanceof Quality) && (!Number.isInteger(bitrate) || bitrate <= 0)) {\n        throw new TypeError('bitrate must be a positive integer or a quality.');\n    }\n    validateVideoEncodingAdditionalOptions(codec, restOptions);\n    let encoderConfig = null;\n    if (_custom_coder_js__WEBPACK_IMPORTED_MODULE_1__.customVideoEncoders.length > 0) {\n        encoderConfig ??= buildVideoEncoderConfig({\n            codec,\n            width,\n            height,\n            bitrate,\n            framerate: undefined,\n            ...restOptions,\n        });\n        if (_custom_coder_js__WEBPACK_IMPORTED_MODULE_1__.customVideoEncoders.some(x => x.supports(codec, encoderConfig))) {\n            // There's a custom encoder\n            return true;\n        }\n    }\n    if (typeof VideoEncoder === 'undefined') {\n        return false;\n    }\n    encoderConfig ??= buildVideoEncoderConfig({\n        codec,\n        width,\n        height,\n        bitrate,\n        framerate: undefined,\n        ...restOptions,\n    });\n    const support = await VideoEncoder.isConfigSupported(encoderConfig);\n    return support.supported === true;\n};\n/**\n * Checks if the browser is able to encode the given audio codec with the given parameters.\n * @group Encoding\n * @public\n */\nconst canEncodeAudio = async (codec, options = {}) => {\n    const { numberOfChannels = 2, sampleRate = 48000, bitrate = 128e3, ...restOptions } = options;\n    if (!_codec_js__WEBPACK_IMPORTED_MODULE_0__.AUDIO_CODECS.includes(codec)) {\n        return false;\n    }\n    if (!Number.isInteger(numberOfChannels) || numberOfChannels <= 0) {\n        throw new TypeError('numberOfChannels must be a positive integer.');\n    }\n    if (!Number.isInteger(sampleRate) || sampleRate <= 0) {\n        throw new TypeError('sampleRate must be a positive integer.');\n    }\n    if (!(bitrate instanceof Quality) && (!Number.isInteger(bitrate) || bitrate <= 0)) {\n        throw new TypeError('bitrate must be a positive integer.');\n    }\n    validateAudioEncodingAdditionalOptions(codec, restOptions);\n    let encoderConfig = null;\n    if (_custom_coder_js__WEBPACK_IMPORTED_MODULE_1__.customAudioEncoders.length > 0) {\n        encoderConfig ??= buildAudioEncoderConfig({\n            codec,\n            numberOfChannels,\n            sampleRate,\n            bitrate,\n            ...restOptions,\n        });\n        if (_custom_coder_js__WEBPACK_IMPORTED_MODULE_1__.customAudioEncoders.some(x => x.supports(codec, encoderConfig))) {\n            // There's a custom encoder\n            return true;\n        }\n    }\n    if (_codec_js__WEBPACK_IMPORTED_MODULE_0__.PCM_AUDIO_CODECS.includes(codec)) {\n        return true; // Because we encode these ourselves\n    }\n    if (typeof AudioEncoder === 'undefined') {\n        return false;\n    }\n    encoderConfig ??= buildAudioEncoderConfig({\n        codec,\n        numberOfChannels,\n        sampleRate,\n        bitrate,\n        ...restOptions,\n    });\n    const support = await AudioEncoder.isConfigSupported(encoderConfig);\n    return support.supported === true;\n};\n/**\n * Checks if the browser is able to encode the given subtitle codec.\n * @group Encoding\n * @public\n */\nconst canEncodeSubtitles = async (codec) => {\n    if (!_codec_js__WEBPACK_IMPORTED_MODULE_0__.SUBTITLE_CODECS.includes(codec)) {\n        return false;\n    }\n    return true;\n};\n/**\n * Returns the list of all media codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nconst getEncodableCodecs = async () => {\n    const [videoCodecs, audioCodecs, subtitleCodecs] = await Promise.all([\n        getEncodableVideoCodecs(),\n        getEncodableAudioCodecs(),\n        getEncodableSubtitleCodecs(),\n    ]);\n    return [...videoCodecs, ...audioCodecs, ...subtitleCodecs];\n};\n/**\n * Returns the list of all video codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nconst getEncodableVideoCodecs = async (checkedCodecs = _codec_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO_CODECS, options) => {\n    const bools = await Promise.all(checkedCodecs.map(codec => canEncodeVideo(codec, options)));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the list of all audio codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nconst getEncodableAudioCodecs = async (checkedCodecs = _codec_js__WEBPACK_IMPORTED_MODULE_0__.AUDIO_CODECS, options) => {\n    const bools = await Promise.all(checkedCodecs.map(codec => canEncodeAudio(codec, options)));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the list of all subtitle codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nconst getEncodableSubtitleCodecs = async (checkedCodecs = _codec_js__WEBPACK_IMPORTED_MODULE_0__.SUBTITLE_CODECS) => {\n    const bools = await Promise.all(checkedCodecs.map(canEncodeSubtitles));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the first video codec from the given list that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nconst getFirstEncodableVideoCodec = async (checkedCodecs, options) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeVideo(codec, options)) {\n            return codec;\n        }\n    }\n    return null;\n};\n/**\n * Returns the first audio codec from the given list that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nconst getFirstEncodableAudioCodec = async (checkedCodecs, options) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeAudio(codec, options)) {\n            return codec;\n        }\n    }\n    return null;\n};\n/**\n * Returns the first subtitle codec from the given list that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nconst getFirstEncodableSubtitleCodec = async (checkedCodecs) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeSubtitles(codec)) {\n            return codec;\n        }\n    }\n    return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL2VuY29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcU87QUFDeEo7QUFDdEU7QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1EQUFZO0FBQ3JCLG9EQUFvRCxhQUFhLHFCQUFxQixtREFBWSxZQUFZO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG9FQUF5QjtBQUMxRSxrSEFBa0gsTUFBTTtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZ0VBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUVBQThCO0FBQ3pDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbURBQVk7QUFDckIsb0RBQW9ELGFBQWEscUJBQXFCLG1EQUFZLFlBQVk7QUFDOUc7QUFDQTtBQUNBLGFBQWEsdURBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG9FQUF5QjtBQUMxRSxrSEFBa0gsTUFBTTtBQUN4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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGNoLWN1dC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL2VuY29kZS5qcz9mOTBiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDI1LXByZXNlbnQsIFZhbmlsYWd5IGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgQVVESU9fQ09ERUNTLCBidWlsZEF1ZGlvQ29kZWNTdHJpbmcsIGJ1aWxkVmlkZW9Db2RlY1N0cmluZywgZ2V0QXVkaW9FbmNvZGVyQ29uZmlnRXh0ZW5zaW9uLCBnZXRWaWRlb0VuY29kZXJDb25maWdFeHRlbnNpb24sIGluZmVyQ29kZWNGcm9tQ29kZWNTdHJpbmcsIFBDTV9BVURJT19DT0RFQ1MsIFNVQlRJVExFX0NPREVDUywgVklERU9fQ09ERUNTLCB9IGZyb20gJy4vY29kZWMuanMnO1xuaW1wb3J0IHsgY3VzdG9tQXVkaW9FbmNvZGVycywgY3VzdG9tVmlkZW9FbmNvZGVycyB9IGZyb20gJy4vY3VzdG9tLWNvZGVyLmpzJztcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVZpZGVvRW5jb2RpbmdDb25maWcgPSAoY29uZmlnKSA9PiB7XG4gICAgaWYgKCFjb25maWcgfHwgdHlwZW9mIGNvbmZpZyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5jb2RpbmcgY29uZmlnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgIH1cbiAgICBpZiAoIVZJREVPX0NPREVDUy5pbmNsdWRlcyhjb25maWcuY29kZWMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgdmlkZW8gY29kZWMgJyR7Y29uZmlnLmNvZGVjfScuIE11c3QgYmUgb25lIG9mOiAke1ZJREVPX0NPREVDUy5qb2luKCcsICcpfS5gKTtcbiAgICB9XG4gICAgaWYgKCEoY29uZmlnLmJpdHJhdGUgaW5zdGFuY2VvZiBRdWFsaXR5KSAmJiAoIU51bWJlci5pc0ludGVnZXIoY29uZmlnLmJpdHJhdGUpIHx8IGNvbmZpZy5iaXRyYXRlIDw9IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvbmZpZy5iaXRyYXRlIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIGEgcXVhbGl0eS4nKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5rZXlGcmFtZUludGVydmFsICE9PSB1bmRlZmluZWRcbiAgICAgICAgJiYgKCFOdW1iZXIuaXNGaW5pdGUoY29uZmlnLmtleUZyYW1lSW50ZXJ2YWwpIHx8IGNvbmZpZy5rZXlGcmFtZUludGVydmFsIDwgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29uZmlnLmtleUZyYW1lSW50ZXJ2YWwsIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLnNpemVDaGFuZ2VCZWhhdmlvciAhPT0gdW5kZWZpbmVkXG4gICAgICAgICYmICFbJ2RlbnknLCAncGFzc1Rocm91Z2gnLCAnZmlsbCcsICdjb250YWluJywgJ2NvdmVyJ10uaW5jbHVkZXMoY29uZmlnLnNpemVDaGFuZ2VCZWhhdmlvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29uZmlnLnNpemVDaGFuZ2VCZWhhdmlvciwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBcXCdkZW55XFwnLCBcXCdwYXNzVGhyb3VnaFxcJywgXFwnZmlsbFxcJywgXFwnY29udGFpblxcJydcbiAgICAgICAgICAgICsgJyBvciBcXCdjb3ZlclxcJy4nKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5vbkVuY29kZWRQYWNrZXQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgY29uZmlnLm9uRW5jb2RlZFBhY2tldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb25maWcub25FbmNvZGVkQ2h1bmssIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5vbkVuY29kZXJDb25maWcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgY29uZmlnLm9uRW5jb2RlckNvbmZpZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb25maWcub25FbmNvZGVyQ29uZmlnLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuICAgIHZhbGlkYXRlVmlkZW9FbmNvZGluZ0FkZGl0aW9uYWxPcHRpb25zKGNvbmZpZy5jb2RlYywgY29uZmlnKTtcbn07XG5leHBvcnQgY29uc3QgdmFsaWRhdGVWaWRlb0VuY29kaW5nQWRkaXRpb25hbE9wdGlvbnMgPSAoY29kZWMsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuY29kaW5nIG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmJpdHJhdGVNb2RlICE9PSB1bmRlZmluZWQgJiYgIVsnY29uc3RhbnQnLCAndmFyaWFibGUnXS5pbmNsdWRlcyhvcHRpb25zLmJpdHJhdGVNb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiaXRyYXRlTW9kZSwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBcXCdjb25zdGFudFxcJyBvciBcXCd2YXJpYWJsZVxcJy4nKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGF0ZW5jeU1vZGUgIT09IHVuZGVmaW5lZCAmJiAhWydxdWFsaXR5JywgJ3JlYWx0aW1lJ10uaW5jbHVkZXMob3B0aW9ucy5sYXRlbmN5TW9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF0ZW5jeU1vZGUsIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgXFwncXVhbGl0eVxcJyBvciBcXCdyZWFsdGltZVxcJy4nKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZnVsbENvZGVjU3RyaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMuZnVsbENvZGVjU3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmdWxsQ29kZWNTdHJpbmcsIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZ1bGxDb2RlY1N0cmluZyAhPT0gdW5kZWZpbmVkICYmIGluZmVyQ29kZWNGcm9tQ29kZWNTdHJpbmcob3B0aW9ucy5mdWxsQ29kZWNTdHJpbmcpICE9PSBjb2RlYykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBmdWxsQ29kZWNTdHJpbmcsIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgYSBzdHJpbmcgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgY29kZWMgKCR7Y29kZWN9KS5gKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaGFyZHdhcmVBY2NlbGVyYXRpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICAmJiAhWyduby1wcmVmZXJlbmNlJywgJ3ByZWZlci1oYXJkd2FyZScsICdwcmVmZXItc29mdHdhcmUnXS5pbmNsdWRlcyhvcHRpb25zLmhhcmR3YXJlQWNjZWxlcmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoYXJkd2FyZUFjY2VsZXJhdGlvbiwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBcXCduby1wcmVmZXJlbmNlXFwnLCBcXCdwcmVmZXItaGFyZHdhcmVcXCcgb3InXG4gICAgICAgICAgICArICcgXFwncHJlZmVyLXNvZnR3YXJlXFwnLicpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zY2FsYWJpbGl0eU1vZGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5zY2FsYWJpbGl0eU1vZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NjYWxhYmlsaXR5TW9kZSwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY29udGVudEhpbnQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5jb250ZW50SGludCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29udGVudEhpbnQsIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBidWlsZFZpZGVvRW5jb2RlckNvbmZpZyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWRCaXRyYXRlID0gb3B0aW9ucy5iaXRyYXRlIGluc3RhbmNlb2YgUXVhbGl0eVxuICAgICAgICA/IG9wdGlvbnMuYml0cmF0ZS5fdG9WaWRlb0JpdHJhdGUob3B0aW9ucy5jb2RlYywgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQpXG4gICAgICAgIDogb3B0aW9ucy5iaXRyYXRlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGVjOiBvcHRpb25zLmZ1bGxDb2RlY1N0cmluZyA/PyBidWlsZFZpZGVvQ29kZWNTdHJpbmcob3B0aW9ucy5jb2RlYywgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQsIHJlc29sdmVkQml0cmF0ZSksXG4gICAgICAgIHdpZHRoOiBvcHRpb25zLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IG9wdGlvbnMuaGVpZ2h0LFxuICAgICAgICBiaXRyYXRlOiByZXNvbHZlZEJpdHJhdGUsXG4gICAgICAgIGJpdHJhdGVNb2RlOiBvcHRpb25zLmJpdHJhdGVNb2RlLFxuICAgICAgICBmcmFtZXJhdGU6IG9wdGlvbnMuZnJhbWVyYXRlLCAvLyB0aGlzLnNvdXJjZS5fY29ubmVjdGVkVHJhY2s/Lm1ldGFkYXRhLmZyYW1lUmF0ZSxcbiAgICAgICAgbGF0ZW5jeU1vZGU6IG9wdGlvbnMubGF0ZW5jeU1vZGUsXG4gICAgICAgIGhhcmR3YXJlQWNjZWxlcmF0aW9uOiBvcHRpb25zLmhhcmR3YXJlQWNjZWxlcmF0aW9uLFxuICAgICAgICBzY2FsYWJpbGl0eU1vZGU6IG9wdGlvbnMuc2NhbGFiaWxpdHlNb2RlLFxuICAgICAgICBjb250ZW50SGludDogb3B0aW9ucy5jb250ZW50SGludCxcbiAgICAgICAgLi4uZ2V0VmlkZW9FbmNvZGVyQ29uZmlnRXh0ZW5zaW9uKG9wdGlvbnMuY29kZWMpLFxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlQXVkaW9FbmNvZGluZ0NvbmZpZyA9IChjb25maWcpID0+IHtcbiAgICBpZiAoIWNvbmZpZyB8fCB0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmNvZGluZyBjb25maWcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuICAgIGlmICghQVVESU9fQ09ERUNTLmluY2x1ZGVzKGNvbmZpZy5jb2RlYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBhdWRpbyBjb2RlYyAnJHtjb25maWcuY29kZWN9Jy4gTXVzdCBiZSBvbmUgb2Y6ICR7QVVESU9fQ09ERUNTLmpvaW4oJywgJyl9LmApO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmJpdHJhdGUgPT09IHVuZGVmaW5lZFxuICAgICAgICAmJiAoIVBDTV9BVURJT19DT0RFQ1MuaW5jbHVkZXMoY29uZmlnLmNvZGVjKSB8fCBjb25maWcuY29kZWMgPT09ICdmbGFjJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29uZmlnLmJpdHJhdGUgbXVzdCBiZSBwcm92aWRlZCBmb3IgY29tcHJlc3NlZCBhdWRpbyBjb2RlY3MuJyk7XG4gICAgfVxuICAgIGlmIChjb25maWcuYml0cmF0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICYmICEoY29uZmlnLmJpdHJhdGUgaW5zdGFuY2VvZiBRdWFsaXR5KVxuICAgICAgICAmJiAoIU51bWJlci5pc0ludGVnZXIoY29uZmlnLmJpdHJhdGUpIHx8IGNvbmZpZy5iaXRyYXRlIDw9IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvbmZpZy5iaXRyYXRlLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciBhIHF1YWxpdHkuJyk7XG4gICAgfVxuICAgIGlmIChjb25maWcub25FbmNvZGVkUGFja2V0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGNvbmZpZy5vbkVuY29kZWRQYWNrZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29uZmlnLm9uRW5jb2RlZENodW5rLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuICAgIGlmIChjb25maWcub25FbmNvZGVyQ29uZmlnICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGNvbmZpZy5vbkVuY29kZXJDb25maWcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29uZmlnLm9uRW5jb2RlckNvbmZpZywgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cbiAgICB2YWxpZGF0ZUF1ZGlvRW5jb2RpbmdBZGRpdGlvbmFsT3B0aW9ucyhjb25maWcuY29kZWMsIGNvbmZpZyk7XG59O1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlQXVkaW9FbmNvZGluZ0FkZGl0aW9uYWxPcHRpb25zID0gKGNvZGVjLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmNvZGluZyBvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5iaXRyYXRlTW9kZSAhPT0gdW5kZWZpbmVkICYmICFbJ2NvbnN0YW50JywgJ3ZhcmlhYmxlJ10uaW5jbHVkZXMob3B0aW9ucy5iaXRyYXRlTW9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYml0cmF0ZU1vZGUsIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgXFwnY29uc3RhbnRcXCcgb3IgXFwndmFyaWFibGVcXCcuJyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZ1bGxDb2RlY1N0cmluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLmZ1bGxDb2RlY1N0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZnVsbENvZGVjU3RyaW5nLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5mdWxsQ29kZWNTdHJpbmcgIT09IHVuZGVmaW5lZCAmJiBpbmZlckNvZGVjRnJvbUNvZGVjU3RyaW5nKG9wdGlvbnMuZnVsbENvZGVjU3RyaW5nKSAhPT0gY29kZWMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZnVsbENvZGVjU3RyaW5nLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgc3RyaW5nIHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGNvZGVjICgke2NvZGVjfSkuYCk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBidWlsZEF1ZGlvRW5jb2RlckNvbmZpZyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWRCaXRyYXRlID0gb3B0aW9ucy5iaXRyYXRlIGluc3RhbmNlb2YgUXVhbGl0eVxuICAgICAgICA/IG9wdGlvbnMuYml0cmF0ZS5fdG9BdWRpb0JpdHJhdGUob3B0aW9ucy5jb2RlYylcbiAgICAgICAgOiBvcHRpb25zLmJpdHJhdGU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZWM6IG9wdGlvbnMuZnVsbENvZGVjU3RyaW5nID8/IGJ1aWxkQXVkaW9Db2RlY1N0cmluZyhvcHRpb25zLmNvZGVjLCBvcHRpb25zLm51bWJlck9mQ2hhbm5lbHMsIG9wdGlvbnMuc2FtcGxlUmF0ZSksXG4gICAgICAgIG51bWJlck9mQ2hhbm5lbHM6IG9wdGlvbnMubnVtYmVyT2ZDaGFubmVscyxcbiAgICAgICAgc2FtcGxlUmF0ZTogb3B0aW9ucy5zYW1wbGVSYXRlLFxuICAgICAgICBiaXRyYXRlOiByZXNvbHZlZEJpdHJhdGUsXG4gICAgICAgIGJpdHJhdGVNb2RlOiBvcHRpb25zLmJpdHJhdGVNb2RlLFxuICAgICAgICAuLi5nZXRBdWRpb0VuY29kZXJDb25maWdFeHRlbnNpb24ob3B0aW9ucy5jb2RlYyksXG4gICAgfTtcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdWJqZWN0aXZlIG1lZGlhIHF1YWxpdHkgbGV2ZWwuXG4gKiBAZ3JvdXAgRW5jb2RpbmdcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFF1YWxpdHkge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjb25zdHJ1Y3RvcihmYWN0b3IpIHtcbiAgICAgICAgdGhpcy5fZmFjdG9yID0gZmFjdG9yO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3RvVmlkZW9CaXRyYXRlKGNvZGVjLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHBpeGVscyA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICBjb25zdCBjb2RlY0VmZmljaWVuY3lGYWN0b3JzID0ge1xuICAgICAgICAgICAgYXZjOiAxLjAsIC8vIEguMjY0L0FWQyAoYmFzZWxpbmUpXG4gICAgICAgICAgICBoZXZjOiAwLjYsIC8vIEguMjY1L0hFVkMgKH40MCUgbW9yZSBlZmZpY2llbnQgdGhhbiBBVkMpXG4gICAgICAgICAgICB2cDk6IDAuNiwgLy8gU2ltaWxhciB0byBIRVZDXG4gICAgICAgICAgICBhdjE6IDAuNCwgLy8gfjYwJSBtb3JlIGVmZmljaWVudCB0aGFuIEFWQ1xuICAgICAgICAgICAgdnA4OiAxLjIsIC8vIFNsaWdodGx5IGxlc3MgZWZmaWNpZW50IHRoYW4gQVZDXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZVBpeGVscyA9IDE5MjAgKiAxMDgwO1xuICAgICAgICBjb25zdCByZWZlcmVuY2VCaXRyYXRlID0gMzAwMDAwMDtcbiAgICAgICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBNYXRoLnBvdyhwaXhlbHMgLyByZWZlcmVuY2VQaXhlbHMsIDAuOTUpOyAvLyBTbGlnaHQgbm9uLWxpbmVhciBzY2FsaW5nXG4gICAgICAgIGNvbnN0IGJhc2VCaXRyYXRlID0gcmVmZXJlbmNlQml0cmF0ZSAqIHNjYWxlRmFjdG9yO1xuICAgICAgICBjb25zdCBjb2RlY0FkanVzdGVkQml0cmF0ZSA9IGJhc2VCaXRyYXRlICogY29kZWNFZmZpY2llbmN5RmFjdG9yc1tjb2RlY107XG4gICAgICAgIGNvbnN0IGZpbmFsQml0cmF0ZSA9IGNvZGVjQWRqdXN0ZWRCaXRyYXRlICogdGhpcy5fZmFjdG9yO1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGZpbmFsQml0cmF0ZSAvIDEwMDApICogMTAwMDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90b0F1ZGlvQml0cmF0ZShjb2RlYykge1xuICAgICAgICBpZiAoUENNX0FVRElPX0NPREVDUy5pbmNsdWRlcyhjb2RlYykgfHwgY29kZWMgPT09ICdmbGFjJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXNlUmF0ZXMgPSB7XG4gICAgICAgICAgICBhYWM6IDEyODAwMCwgLy8gMTI4a2JwcyBiYXNlIGZvciBBQUNcbiAgICAgICAgICAgIG9wdXM6IDY0MDAwLCAvLyA2NGticHMgYmFzZSBmb3IgT3B1c1xuICAgICAgICAgICAgbXAzOiAxNjAwMDAsIC8vIDE2MGticHMgYmFzZSBmb3IgTVAzXG4gICAgICAgICAgICB2b3JiaXM6IDY0MDAwLCAvLyA2NGticHMgYmFzZSBmb3IgVm9yYmlzXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJhc2VCaXRyYXRlID0gYmFzZVJhdGVzW2NvZGVjXTtcbiAgICAgICAgaWYgKCFiYXNlQml0cmF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmhhbmRsZWQgY29kZWM6ICR7Y29kZWN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpbmFsQml0cmF0ZSA9IGJhc2VCaXRyYXRlICogdGhpcy5fZmFjdG9yO1xuICAgICAgICBpZiAoY29kZWMgPT09ICdhYWMnKSB7XG4gICAgICAgICAgICAvLyBBQUMgb25seSB3b3JrcyB3aXRoIHNwZWNpZmljIGJpdHJhdGVzLCBsZXQncyBmaW5kIHRoZSBjbG9zZXN0XG4gICAgICAgICAgICBjb25zdCB2YWxpZFJhdGVzID0gWzk2MDAwLCAxMjgwMDAsIDE2MDAwMCwgMTkyMDAwXTtcbiAgICAgICAgICAgIGZpbmFsQml0cmF0ZSA9IHZhbGlkUmF0ZXMucmVkdWNlKChwcmV2LCBjdXJyKSA9PiBNYXRoLmFicyhjdXJyIC0gZmluYWxCaXRyYXRlKSA8IE1hdGguYWJzKHByZXYgLSBmaW5hbEJpdHJhdGUpID8gY3VyciA6IHByZXYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVjID09PSAnb3B1cycgfHwgY29kZWMgPT09ICd2b3JiaXMnKSB7XG4gICAgICAgICAgICBmaW5hbEJpdHJhdGUgPSBNYXRoLm1heCg2MDAwLCBmaW5hbEJpdHJhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVjID09PSAnbXAzJykge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRSYXRlcyA9IFtcbiAgICAgICAgICAgICAgICA4MDAwLCAxNjAwMCwgMjQwMDAsIDMyMDAwLCA0MDAwMCwgNDgwMDAsIDY0MDAwLCA4MDAwMCxcbiAgICAgICAgICAgICAgICA5NjAwMCwgMTEyMDAwLCAxMjgwMDAsIDE2MDAwMCwgMTkyMDAwLCAyMjQwMDAsIDI1NjAwMCwgMzIwMDAwLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGZpbmFsQml0cmF0ZSA9IHZhbGlkUmF0ZXMucmVkdWNlKChwcmV2LCBjdXJyKSA9PiBNYXRoLmFicyhjdXJyIC0gZmluYWxCaXRyYXRlKSA8IE1hdGguYWJzKHByZXYgLSBmaW5hbEJpdHJhdGUpID8gY3VyciA6IHByZXYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGZpbmFsQml0cmF0ZSAvIDEwMDApICogMTAwMDtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSB2ZXJ5IGxvdyBtZWRpYSBxdWFsaXR5LlxuICogQGdyb3VwIEVuY29kaW5nXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBRVUFMSVRZX1ZFUllfTE9XID0gbmV3IFF1YWxpdHkoMC4zKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGxvdyBtZWRpYSBxdWFsaXR5LlxuICogQGdyb3VwIEVuY29kaW5nXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBRVUFMSVRZX0xPVyA9IG5ldyBRdWFsaXR5KDAuNik7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBtZWRpdW0gbWVkaWEgcXVhbGl0eS5cbiAqIEBncm91cCBFbmNvZGluZ1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgUVVBTElUWV9NRURJVU0gPSBuZXcgUXVhbGl0eSgxKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGhpZ2ggbWVkaWEgcXVhbGl0eS5cbiAqIEBncm91cCBFbmNvZGluZ1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgUVVBTElUWV9ISUdIID0gbmV3IFF1YWxpdHkoMik7XG4vKipcbiAqIFJlcHJlc2VudHMgYSB2ZXJ5IGhpZ2ggbWVkaWEgcXVhbGl0eS5cbiAqIEBncm91cCBFbmNvZGluZ1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgUVVBTElUWV9WRVJZX0hJR0ggPSBuZXcgUXVhbGl0eSg0KTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBicm93c2VyIGlzIGFibGUgdG8gZW5jb2RlIHRoZSBnaXZlbiBjb2RlYy5cbiAqIEBncm91cCBFbmNvZGluZ1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgY2FuRW5jb2RlID0gKGNvZGVjKSA9PiB7XG4gICAgaWYgKFZJREVPX0NPREVDUy5pbmNsdWRlcyhjb2RlYykpIHtcbiAgICAgICAgcmV0dXJuIGNhbkVuY29kZVZpZGVvKGNvZGVjKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQVVESU9fQ09ERUNTLmluY2x1ZGVzKGNvZGVjKSkge1xuICAgICAgICByZXR1cm4gY2FuRW5jb2RlQXVkaW8oY29kZWMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChTVUJUSVRMRV9DT0RFQ1MuaW5jbHVkZXMoY29kZWMpKSB7XG4gICAgICAgIHJldHVybiBjYW5FbmNvZGVTdWJ0aXRsZXMoY29kZWMpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmtub3duIGNvZGVjICcke2NvZGVjfScuYCk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGJyb3dzZXIgaXMgYWJsZSB0byBlbmNvZGUgdGhlIGdpdmVuIHZpZGVvIGNvZGVjIHdpdGggdGhlIGdpdmVuIHBhcmFtZXRlcnMuXG4gKiBAZ3JvdXAgRW5jb2RpbmdcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGNhbkVuY29kZVZpZGVvID0gYXN5bmMgKGNvZGVjLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB7IHdpZHRoID0gMTI4MCwgaGVpZ2h0ID0gNzIwLCBiaXRyYXRlID0gMWU2LCAuLi5yZXN0T3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICBpZiAoIVZJREVPX0NPREVDUy5pbmNsdWRlcyhjb2RlYykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIod2lkdGgpIHx8IHdpZHRoIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignd2lkdGggbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuJyk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihoZWlnaHQpIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hlaWdodCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4nKTtcbiAgICB9XG4gICAgaWYgKCEoYml0cmF0ZSBpbnN0YW5jZW9mIFF1YWxpdHkpICYmICghTnVtYmVyLmlzSW50ZWdlcihiaXRyYXRlKSB8fCBiaXRyYXRlIDw9IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2JpdHJhdGUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgYSBxdWFsaXR5LicpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVZpZGVvRW5jb2RpbmdBZGRpdGlvbmFsT3B0aW9ucyhjb2RlYywgcmVzdE9wdGlvbnMpO1xuICAgIGxldCBlbmNvZGVyQ29uZmlnID0gbnVsbDtcbiAgICBpZiAoY3VzdG9tVmlkZW9FbmNvZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVuY29kZXJDb25maWcgPz89IGJ1aWxkVmlkZW9FbmNvZGVyQ29uZmlnKHtcbiAgICAgICAgICAgIGNvZGVjLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBiaXRyYXRlLFxuICAgICAgICAgICAgZnJhbWVyYXRlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAuLi5yZXN0T3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdXN0b21WaWRlb0VuY29kZXJzLnNvbWUoeCA9PiB4LnN1cHBvcnRzKGNvZGVjLCBlbmNvZGVyQ29uZmlnKSkpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlJ3MgYSBjdXN0b20gZW5jb2RlclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBWaWRlb0VuY29kZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZW5jb2RlckNvbmZpZyA/Pz0gYnVpbGRWaWRlb0VuY29kZXJDb25maWcoe1xuICAgICAgICBjb2RlYyxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgYml0cmF0ZSxcbiAgICAgICAgZnJhbWVyYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIC4uLnJlc3RPcHRpb25zLFxuICAgIH0pO1xuICAgIGNvbnN0IHN1cHBvcnQgPSBhd2FpdCBWaWRlb0VuY29kZXIuaXNDb25maWdTdXBwb3J0ZWQoZW5jb2RlckNvbmZpZyk7XG4gICAgcmV0dXJuIHN1cHBvcnQuc3VwcG9ydGVkID09PSB0cnVlO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBicm93c2VyIGlzIGFibGUgdG8gZW5jb2RlIHRoZSBnaXZlbiBhdWRpbyBjb2RlYyB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuICogQGdyb3VwIEVuY29kaW5nXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBjYW5FbmNvZGVBdWRpbyA9IGFzeW5jIChjb2RlYywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgeyBudW1iZXJPZkNoYW5uZWxzID0gMiwgc2FtcGxlUmF0ZSA9IDQ4MDAwLCBiaXRyYXRlID0gMTI4ZTMsIC4uLnJlc3RPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgIGlmICghQVVESU9fQ09ERUNTLmluY2x1ZGVzKGNvZGVjKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW1iZXJPZkNoYW5uZWxzKSB8fCBudW1iZXJPZkNoYW5uZWxzIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbnVtYmVyT2ZDaGFubmVscyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4nKTtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNhbXBsZVJhdGUpIHx8IHNhbXBsZVJhdGUgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzYW1wbGVSYXRlIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLicpO1xuICAgIH1cbiAgICBpZiAoIShiaXRyYXRlIGluc3RhbmNlb2YgUXVhbGl0eSkgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKGJpdHJhdGUpIHx8IGJpdHJhdGUgPD0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYml0cmF0ZSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4nKTtcbiAgICB9XG4gICAgdmFsaWRhdGVBdWRpb0VuY29kaW5nQWRkaXRpb25hbE9wdGlvbnMoY29kZWMsIHJlc3RPcHRpb25zKTtcbiAgICBsZXQgZW5jb2RlckNvbmZpZyA9IG51bGw7XG4gICAgaWYgKGN1c3RvbUF1ZGlvRW5jb2RlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBlbmNvZGVyQ29uZmlnID8/PSBidWlsZEF1ZGlvRW5jb2RlckNvbmZpZyh7XG4gICAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICAgIG51bWJlck9mQ2hhbm5lbHMsXG4gICAgICAgICAgICBzYW1wbGVSYXRlLFxuICAgICAgICAgICAgYml0cmF0ZSxcbiAgICAgICAgICAgIC4uLnJlc3RPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN1c3RvbUF1ZGlvRW5jb2RlcnMuc29tZSh4ID0+IHguc3VwcG9ydHMoY29kZWMsIGVuY29kZXJDb25maWcpKSkge1xuICAgICAgICAgICAgLy8gVGhlcmUncyBhIGN1c3RvbSBlbmNvZGVyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoUENNX0FVRElPX0NPREVDUy5pbmNsdWRlcyhjb2RlYykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEJlY2F1c2Ugd2UgZW5jb2RlIHRoZXNlIG91cnNlbHZlc1xuICAgIH1cbiAgICBpZiAodHlwZW9mIEF1ZGlvRW5jb2RlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbmNvZGVyQ29uZmlnID8/PSBidWlsZEF1ZGlvRW5jb2RlckNvbmZpZyh7XG4gICAgICAgIGNvZGVjLFxuICAgICAgICBudW1iZXJPZkNoYW5uZWxzLFxuICAgICAgICBzYW1wbGVSYXRlLFxuICAgICAgICBiaXRyYXRlLFxuICAgICAgICAuLi5yZXN0T3B0aW9ucyxcbiAgICB9KTtcbiAgICBjb25zdCBzdXBwb3J0ID0gYXdhaXQgQXVkaW9FbmNvZGVyLmlzQ29uZmlnU3VwcG9ydGVkKGVuY29kZXJDb25maWcpO1xuICAgIHJldHVybiBzdXBwb3J0LnN1cHBvcnRlZCA9PT0gdHJ1ZTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYnJvd3NlciBpcyBhYmxlIHRvIGVuY29kZSB0aGUgZ2l2ZW4gc3VidGl0bGUgY29kZWMuXG4gKiBAZ3JvdXAgRW5jb2RpbmdcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGNhbkVuY29kZVN1YnRpdGxlcyA9IGFzeW5jIChjb2RlYykgPT4ge1xuICAgIGlmICghU1VCVElUTEVfQ09ERUNTLmluY2x1ZGVzKGNvZGVjKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgbGlzdCBvZiBhbGwgbWVkaWEgY29kZWNzIHRoYXQgY2FuIGJlIGVuY29kZWQgYnkgdGhlIGJyb3dzZXIuXG4gKiBAZ3JvdXAgRW5jb2RpbmdcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEVuY29kYWJsZUNvZGVjcyA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBbdmlkZW9Db2RlY3MsIGF1ZGlvQ29kZWNzLCBzdWJ0aXRsZUNvZGVjc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGdldEVuY29kYWJsZVZpZGVvQ29kZWNzKCksXG4gICAgICAgIGdldEVuY29kYWJsZUF1ZGlvQ29kZWNzKCksXG4gICAgICAgIGdldEVuY29kYWJsZVN1YnRpdGxlQ29kZWNzKCksXG4gICAgXSk7XG4gICAgcmV0dXJuIFsuLi52aWRlb0NvZGVjcywgLi4uYXVkaW9Db2RlY3MsIC4uLnN1YnRpdGxlQ29kZWNzXTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIHZpZGVvIGNvZGVjcyB0aGF0IGNhbiBiZSBlbmNvZGVkIGJ5IHRoZSBicm93c2VyLlxuICogQGdyb3VwIEVuY29kaW5nXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRFbmNvZGFibGVWaWRlb0NvZGVjcyA9IGFzeW5jIChjaGVja2VkQ29kZWNzID0gVklERU9fQ09ERUNTLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgYm9vbHMgPSBhd2FpdCBQcm9taXNlLmFsbChjaGVja2VkQ29kZWNzLm1hcChjb2RlYyA9PiBjYW5FbmNvZGVWaWRlbyhjb2RlYywgb3B0aW9ucykpKTtcbiAgICByZXR1cm4gY2hlY2tlZENvZGVjcy5maWx0ZXIoKF8sIGkpID0+IGJvb2xzW2ldKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIGF1ZGlvIGNvZGVjcyB0aGF0IGNhbiBiZSBlbmNvZGVkIGJ5IHRoZSBicm93c2VyLlxuICogQGdyb3VwIEVuY29kaW5nXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRFbmNvZGFibGVBdWRpb0NvZGVjcyA9IGFzeW5jIChjaGVja2VkQ29kZWNzID0gQVVESU9fQ09ERUNTLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgYm9vbHMgPSBhd2FpdCBQcm9taXNlLmFsbChjaGVja2VkQ29kZWNzLm1hcChjb2RlYyA9PiBjYW5FbmNvZGVBdWRpbyhjb2RlYywgb3B0aW9ucykpKTtcbiAgICByZXR1cm4gY2hlY2tlZENvZGVjcy5maWx0ZXIoKF8sIGkpID0+IGJvb2xzW2ldKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIHN1YnRpdGxlIGNvZGVjcyB0aGF0IGNhbiBiZSBlbmNvZGVkIGJ5IHRoZSBicm93c2VyLlxuICogQGdyb3VwIEVuY29kaW5nXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRFbmNvZGFibGVTdWJ0aXRsZUNvZGVjcyA9IGFzeW5jIChjaGVja2VkQ29kZWNzID0gU1VCVElUTEVfQ09ERUNTKSA9PiB7XG4gICAgY29uc3QgYm9vbHMgPSBhd2FpdCBQcm9taXNlLmFsbChjaGVja2VkQ29kZWNzLm1hcChjYW5FbmNvZGVTdWJ0aXRsZXMpKTtcbiAgICByZXR1cm4gY2hlY2tlZENvZGVjcy5maWx0ZXIoKF8sIGkpID0+IGJvb2xzW2ldKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IHZpZGVvIGNvZGVjIGZyb20gdGhlIGdpdmVuIGxpc3QgdGhhdCBjYW4gYmUgZW5jb2RlZCBieSB0aGUgYnJvd3Nlci5cbiAqIEBncm91cCBFbmNvZGluZ1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgZ2V0Rmlyc3RFbmNvZGFibGVWaWRlb0NvZGVjID0gYXN5bmMgKGNoZWNrZWRDb2RlY3MsIG9wdGlvbnMpID0+IHtcbiAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIGNoZWNrZWRDb2RlY3MpIHtcbiAgICAgICAgaWYgKGF3YWl0IGNhbkVuY29kZVZpZGVvKGNvZGVjLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVjO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgYXVkaW8gY29kZWMgZnJvbSB0aGUgZ2l2ZW4gbGlzdCB0aGF0IGNhbiBiZSBlbmNvZGVkIGJ5IHRoZSBicm93c2VyLlxuICogQGdyb3VwIEVuY29kaW5nXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRGaXJzdEVuY29kYWJsZUF1ZGlvQ29kZWMgPSBhc3luYyAoY2hlY2tlZENvZGVjcywgb3B0aW9ucykgPT4ge1xuICAgIGZvciAoY29uc3QgY29kZWMgb2YgY2hlY2tlZENvZGVjcykge1xuICAgICAgICBpZiAoYXdhaXQgY2FuRW5jb2RlQXVkaW8oY29kZWMsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29kZWM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBzdWJ0aXRsZSBjb2RlYyBmcm9tIHRoZSBnaXZlbiBsaXN0IHRoYXQgY2FuIGJlIGVuY29kZWQgYnkgdGhlIGJyb3dzZXIuXG4gKiBAZ3JvdXAgRW5jb2RpbmdcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEZpcnN0RW5jb2RhYmxlU3VidGl0bGVDb2RlYyA9IGFzeW5jIChjaGVja2VkQ29kZWNzKSA9PiB7XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBjaGVja2VkQ29kZWNzKSB7XG4gICAgICAgIGlmIChhd2FpdCBjYW5FbmNvZGVTdWJ0aXRsZXMoY29kZWMpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29kZWM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/encode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/input-track.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/input-track.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputAudioTrack: () => (/* binding */ InputAudioTrack),\n/* harmony export */   InputTrack: () => (/* binding */ InputTrack),\n/* harmony export */   InputVideoTrack: () => (/* binding */ InputVideoTrack)\n/* harmony export */ });\n/* harmony import */ var _codec_data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./codec-data.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec-data.js\");\n/* harmony import */ var _custom_coder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./custom-coder.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/custom-coder.js\");\n/* harmony import */ var _media_sink_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-sink.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/media-sink.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/* harmony import */ var _packet_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./packet.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/packet.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n/**\n * Represents a media track in an input file.\n * @group Input files & tracks\n * @public\n */\nclass InputTrack {\n    /** @internal */\n    constructor(backing) {\n        this._backing = backing;\n    }\n    /** Returns true if and only if this track is a video track. */\n    isVideoTrack() {\n        return this instanceof InputVideoTrack;\n    }\n    /** Returns true if and only if this track is an audio track. */\n    isAudioTrack() {\n        return this instanceof InputAudioTrack;\n    }\n    /** The unique ID of this track in the input file. */\n    get id() {\n        return this._backing.getId();\n    }\n    /**\n     * The identifier of the codec used internally by the container. It is not homogenized by Mediabunny\n     * and depends entirely on the container format.\n     *\n     * This field can be used to determine the codec of a track in case Mediabunny doesn't know that codec.\n     *\n     * - For ISOBMFF files, this field returns the name of the Sample Description Box (e.g. `'avc1'`).\n     * - For Matroska files, this field returns the value of the `CodecID` element.\n     * - For WAVE files, this field returns the value of the format tag in the `'fmt '` chunk.\n     * - For ADTS files, this field contains the `MPEG-4 Audio Object Type`.\n     * - In all other cases, this field is `null`.\n     */\n    get internalCodecId() {\n        return this._backing.getInternalCodecId();\n    }\n    /**\n     * The ISO 639-2/T language code for this track. If the language is unknown, this field is `'und'` (undetermined).\n     */\n    get languageCode() {\n        return this._backing.getLanguageCode();\n    }\n    /** A user-defined name for this track. */\n    get name() {\n        return this._backing.getName();\n    }\n    /**\n     * A positive number x such that all timestamps and durations of all packets of this track are\n     * integer multiples of 1/x.\n     */\n    get timeResolution() {\n        return this._backing.getTimeResolution();\n    }\n    /**\n     * Returns the start timestamp of the first packet of this track, in seconds. While often near zero, this value\n     * may be positive or even negative. A negative starting timestamp means the track's timing has been offset. Samples\n     * with a negative timestamp should not be presented.\n     */\n    getFirstTimestamp() {\n        return this._backing.getFirstTimestamp();\n    }\n    /** Returns the end timestamp of the last packet of this track, in seconds. */\n    computeDuration() {\n        return this._backing.computeDuration();\n    }\n    /**\n     * Computes aggregate packet statistics for this track, such as average packet rate or bitrate.\n     *\n     * @param targetPacketCount - This optional parameter sets a target for how many packets this method must have\n     * looked at before it can return early; this means, you can use it to aggregate only a subset (prefix) of all\n     * packets. This is very useful for getting a great estimate of video frame rate without having to scan through the\n     * entire file.\n     */\n    async computePacketStats(targetPacketCount = Infinity) {\n        const sink = new _media_sink_js__WEBPACK_IMPORTED_MODULE_0__.EncodedPacketSink(this);\n        let startTimestamp = Infinity;\n        let endTimestamp = -Infinity;\n        let packetCount = 0;\n        let totalPacketBytes = 0;\n        for await (const packet of sink.packets(undefined, undefined, { metadataOnly: true })) {\n            if (packetCount >= targetPacketCount\n                // This additional condition is needed to produce correct results with out-of-presentation-order packets\n                && packet.timestamp >= endTimestamp) {\n                break;\n            }\n            startTimestamp = Math.min(startTimestamp, packet.timestamp);\n            endTimestamp = Math.max(endTimestamp, packet.timestamp + packet.duration);\n            packetCount++;\n            totalPacketBytes += packet.byteLength;\n        }\n        return {\n            packetCount,\n            averagePacketRate: packetCount\n                ? Number((packetCount / (endTimestamp - startTimestamp)).toPrecision(16))\n                : 0,\n            averageBitrate: packetCount\n                ? Number((8 * totalPacketBytes / (endTimestamp - startTimestamp)).toPrecision(16))\n                : 0,\n        };\n    }\n}\n/**\n * Represents a video track in an input file.\n * @group Input files & tracks\n * @public\n */\nclass InputVideoTrack extends InputTrack {\n    /** @internal */\n    constructor(backing) {\n        super(backing);\n        this._backing = backing;\n    }\n    get type() {\n        return 'video';\n    }\n    get codec() {\n        return this._backing.getCodec();\n    }\n    /** The width in pixels of the track's coded samples, before any transformations or rotations. */\n    get codedWidth() {\n        return this._backing.getCodedWidth();\n    }\n    /** The height in pixels of the track's coded samples, before any transformations or rotations. */\n    get codedHeight() {\n        return this._backing.getCodedHeight();\n    }\n    /** The angle in degrees by which the track's frames should be rotated (clockwise). */\n    get rotation() {\n        return this._backing.getRotation();\n    }\n    /** The width in pixels of the track's frames after rotation. */\n    get displayWidth() {\n        const rotation = this._backing.getRotation();\n        return rotation % 180 === 0 ? this._backing.getCodedWidth() : this._backing.getCodedHeight();\n    }\n    /** The height in pixels of the track's frames after rotation. */\n    get displayHeight() {\n        const rotation = this._backing.getRotation();\n        return rotation % 180 === 0 ? this._backing.getCodedHeight() : this._backing.getCodedWidth();\n    }\n    /** Returns the color space of the track's samples. */\n    getColorSpace() {\n        return this._backing.getColorSpace();\n    }\n    /** If this method returns true, the track's samples use a high dynamic range (HDR). */\n    async hasHighDynamicRange() {\n        const colorSpace = await this._backing.getColorSpace();\n        return colorSpace.primaries === 'bt2020' || colorSpace.primaries === 'smpte432'\n            || colorSpace.transfer === 'pg' || colorSpace.transfer === 'hlg'\n            || colorSpace.matrix === 'bt2020-ncl';\n    }\n    /**\n     * Returns the [decoder configuration](https://www.w3.org/TR/webcodecs/#video-decoder-config) for decoding the\n     * track's packets using a [`VideoDecoder`](https://developer.mozilla.org/en-US/docs/Web/API/VideoDecoder). Returns\n     * null if the track's codec is unknown.\n     */\n    getDecoderConfig() {\n        return this._backing.getDecoderConfig();\n    }\n    async getCodecParameterString() {\n        const decoderConfig = await this._backing.getDecoderConfig();\n        return decoderConfig?.codec ?? null;\n    }\n    async canDecode() {\n        try {\n            const decoderConfig = await this._backing.getDecoderConfig();\n            if (!decoderConfig) {\n                return false;\n            }\n            const codec = this._backing.getCodec();\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(codec !== null);\n            if (_custom_coder_js__WEBPACK_IMPORTED_MODULE_2__.customVideoDecoders.some(x => x.supports(codec, decoderConfig))) {\n                return true;\n            }\n            if (typeof VideoDecoder === 'undefined') {\n                return false;\n            }\n            const support = await VideoDecoder.isConfigSupported(decoderConfig);\n            return support.supported === true;\n        }\n        catch (error) {\n            console.error('Error during decodability check:', error);\n            return false;\n        }\n    }\n    async determinePacketType(packet) {\n        if (!(packet instanceof _packet_js__WEBPACK_IMPORTED_MODULE_3__.EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (packet.isMetadataOnly) {\n            throw new TypeError('packet must not be metadata-only to determine its type.');\n        }\n        if (this.codec === null) {\n            return null;\n        }\n        return (0,_codec_data_js__WEBPACK_IMPORTED_MODULE_4__.determineVideoPacketType)(this, packet);\n    }\n}\n/**\n * Represents an audio track in an input file.\n * @group Input files & tracks\n * @public\n */\nclass InputAudioTrack extends InputTrack {\n    /** @internal */\n    constructor(backing) {\n        super(backing);\n        this._backing = backing;\n    }\n    get type() {\n        return 'audio';\n    }\n    get codec() {\n        return this._backing.getCodec();\n    }\n    /** The number of audio channels in the track. */\n    get numberOfChannels() {\n        return this._backing.getNumberOfChannels();\n    }\n    /** The track's audio sample rate in hertz. */\n    get sampleRate() {\n        return this._backing.getSampleRate();\n    }\n    /**\n     * Returns the [decoder configuration](https://www.w3.org/TR/webcodecs/#audio-decoder-config) for decoding the\n     * track's packets using an [`AudioDecoder`](https://developer.mozilla.org/en-US/docs/Web/API/AudioDecoder). Returns\n     * null if the track's codec is unknown.\n     */\n    getDecoderConfig() {\n        return this._backing.getDecoderConfig();\n    }\n    async getCodecParameterString() {\n        const decoderConfig = await this._backing.getDecoderConfig();\n        return decoderConfig?.codec ?? null;\n    }\n    async canDecode() {\n        try {\n            const decoderConfig = await this._backing.getDecoderConfig();\n            if (!decoderConfig) {\n                return false;\n            }\n            const codec = this._backing.getCodec();\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(codec !== null);\n            if (_custom_coder_js__WEBPACK_IMPORTED_MODULE_2__.customAudioDecoders.some(x => x.supports(codec, decoderConfig))) {\n                return true;\n            }\n            if (decoderConfig.codec.startsWith('pcm-')) {\n                return true; // Since we decode it ourselves\n            }\n            else {\n                if (typeof AudioDecoder === 'undefined') {\n                    return false;\n                }\n                const support = await AudioDecoder.isConfigSupported(decoderConfig);\n                return support.supported === true;\n            }\n        }\n        catch (error) {\n            console.error('Error during decodability check:', error);\n            return false;\n        }\n    }\n    async determinePacketType(packet) {\n        if (!(packet instanceof _packet_js__WEBPACK_IMPORTED_MODULE_3__.EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (this.codec === null) {\n            return null;\n        }\n        return 'key'; // No audio codec with delta packets\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL2lucHV0LXRyYWNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkQ7QUFDa0I7QUFDekI7QUFDakI7QUFDUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2REFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0Usb0JBQW9CO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQU07QUFDbEIsZ0JBQWdCLGlFQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFEQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdFQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQU07QUFDbEIsZ0JBQWdCLGlFQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFEQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGNoLWN1dC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL2lucHV0LXRyYWNrLmpzPzk2ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjUtcHJlc2VudCwgVmFuaWxhZ3kgYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgeyBkZXRlcm1pbmVWaWRlb1BhY2tldFR5cGUgfSBmcm9tICcuL2NvZGVjLWRhdGEuanMnO1xuaW1wb3J0IHsgY3VzdG9tQXVkaW9EZWNvZGVycywgY3VzdG9tVmlkZW9EZWNvZGVycyB9IGZyb20gJy4vY3VzdG9tLWNvZGVyLmpzJztcbmltcG9ydCB7IEVuY29kZWRQYWNrZXRTaW5rIH0gZnJvbSAnLi9tZWRpYS1zaW5rLmpzJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4vbWlzYy5qcyc7XG5pbXBvcnQgeyBFbmNvZGVkUGFja2V0IH0gZnJvbSAnLi9wYWNrZXQuanMnO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgbWVkaWEgdHJhY2sgaW4gYW4gaW5wdXQgZmlsZS5cbiAqIEBncm91cCBJbnB1dCBmaWxlcyAmIHRyYWNrc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgSW5wdXRUcmFjayB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNvbnN0cnVjdG9yKGJhY2tpbmcpIHtcbiAgICAgICAgdGhpcy5fYmFja2luZyA9IGJhY2tpbmc7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhpcyB0cmFjayBpcyBhIHZpZGVvIHRyYWNrLiAqL1xuICAgIGlzVmlkZW9UcmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBJbnB1dFZpZGVvVHJhY2s7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhpcyB0cmFjayBpcyBhbiBhdWRpbyB0cmFjay4gKi9cbiAgICBpc0F1ZGlvVHJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgSW5wdXRBdWRpb1RyYWNrO1xuICAgIH1cbiAgICAvKiogVGhlIHVuaXF1ZSBJRCBvZiB0aGlzIHRyYWNrIGluIHRoZSBpbnB1dCBmaWxlLiAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhY2tpbmcuZ2V0SWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGlkZW50aWZpZXIgb2YgdGhlIGNvZGVjIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgY29udGFpbmVyLiBJdCBpcyBub3QgaG9tb2dlbml6ZWQgYnkgTWVkaWFidW5ueVxuICAgICAqIGFuZCBkZXBlbmRzIGVudGlyZWx5IG9uIHRoZSBjb250YWluZXIgZm9ybWF0LlxuICAgICAqXG4gICAgICogVGhpcyBmaWVsZCBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGNvZGVjIG9mIGEgdHJhY2sgaW4gY2FzZSBNZWRpYWJ1bm55IGRvZXNuJ3Qga25vdyB0aGF0IGNvZGVjLlxuICAgICAqXG4gICAgICogLSBGb3IgSVNPQk1GRiBmaWxlcywgdGhpcyBmaWVsZCByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBTYW1wbGUgRGVzY3JpcHRpb24gQm94IChlLmcuIGAnYXZjMSdgKS5cbiAgICAgKiAtIEZvciBNYXRyb3NrYSBmaWxlcywgdGhpcyBmaWVsZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgYENvZGVjSURgIGVsZW1lbnQuXG4gICAgICogLSBGb3IgV0FWRSBmaWxlcywgdGhpcyBmaWVsZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZm9ybWF0IHRhZyBpbiB0aGUgYCdmbXQgJ2AgY2h1bmsuXG4gICAgICogLSBGb3IgQURUUyBmaWxlcywgdGhpcyBmaWVsZCBjb250YWlucyB0aGUgYE1QRUctNCBBdWRpbyBPYmplY3QgVHlwZWAuXG4gICAgICogLSBJbiBhbGwgb3RoZXIgY2FzZXMsIHRoaXMgZmllbGQgaXMgYG51bGxgLlxuICAgICAqL1xuICAgIGdldCBpbnRlcm5hbENvZGVjSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYWNraW5nLmdldEludGVybmFsQ29kZWNJZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgSVNPIDYzOS0yL1QgbGFuZ3VhZ2UgY29kZSBmb3IgdGhpcyB0cmFjay4gSWYgdGhlIGxhbmd1YWdlIGlzIHVua25vd24sIHRoaXMgZmllbGQgaXMgYCd1bmQnYCAodW5kZXRlcm1pbmVkKS5cbiAgICAgKi9cbiAgICBnZXQgbGFuZ3VhZ2VDb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFja2luZy5nZXRMYW5ndWFnZUNvZGUoKTtcbiAgICB9XG4gICAgLyoqIEEgdXNlci1kZWZpbmVkIG5hbWUgZm9yIHRoaXMgdHJhY2suICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYWNraW5nLmdldE5hbWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBwb3NpdGl2ZSBudW1iZXIgeCBzdWNoIHRoYXQgYWxsIHRpbWVzdGFtcHMgYW5kIGR1cmF0aW9ucyBvZiBhbGwgcGFja2V0cyBvZiB0aGlzIHRyYWNrIGFyZVxuICAgICAqIGludGVnZXIgbXVsdGlwbGVzIG9mIDEveC5cbiAgICAgKi9cbiAgICBnZXQgdGltZVJlc29sdXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYWNraW5nLmdldFRpbWVSZXNvbHV0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0YXJ0IHRpbWVzdGFtcCBvZiB0aGUgZmlyc3QgcGFja2V0IG9mIHRoaXMgdHJhY2ssIGluIHNlY29uZHMuIFdoaWxlIG9mdGVuIG5lYXIgemVybywgdGhpcyB2YWx1ZVxuICAgICAqIG1heSBiZSBwb3NpdGl2ZSBvciBldmVuIG5lZ2F0aXZlLiBBIG5lZ2F0aXZlIHN0YXJ0aW5nIHRpbWVzdGFtcCBtZWFucyB0aGUgdHJhY2sncyB0aW1pbmcgaGFzIGJlZW4gb2Zmc2V0LiBTYW1wbGVzXG4gICAgICogd2l0aCBhIG5lZ2F0aXZlIHRpbWVzdGFtcCBzaG91bGQgbm90IGJlIHByZXNlbnRlZC5cbiAgICAgKi9cbiAgICBnZXRGaXJzdFRpbWVzdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhY2tpbmcuZ2V0Rmlyc3RUaW1lc3RhbXAoKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIGVuZCB0aW1lc3RhbXAgb2YgdGhlIGxhc3QgcGFja2V0IG9mIHRoaXMgdHJhY2ssIGluIHNlY29uZHMuICovXG4gICAgY29tcHV0ZUR1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFja2luZy5jb21wdXRlRHVyYXRpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYWdncmVnYXRlIHBhY2tldCBzdGF0aXN0aWNzIGZvciB0aGlzIHRyYWNrLCBzdWNoIGFzIGF2ZXJhZ2UgcGFja2V0IHJhdGUgb3IgYml0cmF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXRQYWNrZXRDb3VudCAtIFRoaXMgb3B0aW9uYWwgcGFyYW1ldGVyIHNldHMgYSB0YXJnZXQgZm9yIGhvdyBtYW55IHBhY2tldHMgdGhpcyBtZXRob2QgbXVzdCBoYXZlXG4gICAgICogbG9va2VkIGF0IGJlZm9yZSBpdCBjYW4gcmV0dXJuIGVhcmx5OyB0aGlzIG1lYW5zLCB5b3UgY2FuIHVzZSBpdCB0byBhZ2dyZWdhdGUgb25seSBhIHN1YnNldCAocHJlZml4KSBvZiBhbGxcbiAgICAgKiBwYWNrZXRzLiBUaGlzIGlzIHZlcnkgdXNlZnVsIGZvciBnZXR0aW5nIGEgZ3JlYXQgZXN0aW1hdGUgb2YgdmlkZW8gZnJhbWUgcmF0ZSB3aXRob3V0IGhhdmluZyB0byBzY2FuIHRocm91Z2ggdGhlXG4gICAgICogZW50aXJlIGZpbGUuXG4gICAgICovXG4gICAgYXN5bmMgY29tcHV0ZVBhY2tldFN0YXRzKHRhcmdldFBhY2tldENvdW50ID0gSW5maW5pdHkpIHtcbiAgICAgICAgY29uc3Qgc2luayA9IG5ldyBFbmNvZGVkUGFja2V0U2luayh0aGlzKTtcbiAgICAgICAgbGV0IHN0YXJ0VGltZXN0YW1wID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBlbmRUaW1lc3RhbXAgPSAtSW5maW5pdHk7XG4gICAgICAgIGxldCBwYWNrZXRDb3VudCA9IDA7XG4gICAgICAgIGxldCB0b3RhbFBhY2tldEJ5dGVzID0gMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwYWNrZXQgb2Ygc2luay5wYWNrZXRzKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IG1ldGFkYXRhT25seTogdHJ1ZSB9KSkge1xuICAgICAgICAgICAgaWYgKHBhY2tldENvdW50ID49IHRhcmdldFBhY2tldENvdW50XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhZGRpdGlvbmFsIGNvbmRpdGlvbiBpcyBuZWVkZWQgdG8gcHJvZHVjZSBjb3JyZWN0IHJlc3VsdHMgd2l0aCBvdXQtb2YtcHJlc2VudGF0aW9uLW9yZGVyIHBhY2tldHNcbiAgICAgICAgICAgICAgICAmJiBwYWNrZXQudGltZXN0YW1wID49IGVuZFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXAgPSBNYXRoLm1pbihzdGFydFRpbWVzdGFtcCwgcGFja2V0LnRpbWVzdGFtcCk7XG4gICAgICAgICAgICBlbmRUaW1lc3RhbXAgPSBNYXRoLm1heChlbmRUaW1lc3RhbXAsIHBhY2tldC50aW1lc3RhbXAgKyBwYWNrZXQuZHVyYXRpb24pO1xuICAgICAgICAgICAgcGFja2V0Q291bnQrKztcbiAgICAgICAgICAgIHRvdGFsUGFja2V0Qnl0ZXMgKz0gcGFja2V0LmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhY2tldENvdW50LFxuICAgICAgICAgICAgYXZlcmFnZVBhY2tldFJhdGU6IHBhY2tldENvdW50XG4gICAgICAgICAgICAgICAgPyBOdW1iZXIoKHBhY2tldENvdW50IC8gKGVuZFRpbWVzdGFtcCAtIHN0YXJ0VGltZXN0YW1wKSkudG9QcmVjaXNpb24oMTYpKVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIGF2ZXJhZ2VCaXRyYXRlOiBwYWNrZXRDb3VudFxuICAgICAgICAgICAgICAgID8gTnVtYmVyKCg4ICogdG90YWxQYWNrZXRCeXRlcyAvIChlbmRUaW1lc3RhbXAgLSBzdGFydFRpbWVzdGFtcCkpLnRvUHJlY2lzaW9uKDE2KSlcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdmlkZW8gdHJhY2sgaW4gYW4gaW5wdXQgZmlsZS5cbiAqIEBncm91cCBJbnB1dCBmaWxlcyAmIHRyYWNrc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgSW5wdXRWaWRlb1RyYWNrIGV4dGVuZHMgSW5wdXRUcmFjayB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNvbnN0cnVjdG9yKGJhY2tpbmcpIHtcbiAgICAgICAgc3VwZXIoYmFja2luZyk7XG4gICAgICAgIHRoaXMuX2JhY2tpbmcgPSBiYWNraW5nO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICd2aWRlbyc7XG4gICAgfVxuICAgIGdldCBjb2RlYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhY2tpbmcuZ2V0Q29kZWMoKTtcbiAgICB9XG4gICAgLyoqIFRoZSB3aWR0aCBpbiBwaXhlbHMgb2YgdGhlIHRyYWNrJ3MgY29kZWQgc2FtcGxlcywgYmVmb3JlIGFueSB0cmFuc2Zvcm1hdGlvbnMgb3Igcm90YXRpb25zLiAqL1xuICAgIGdldCBjb2RlZFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFja2luZy5nZXRDb2RlZFdpZHRoKCk7XG4gICAgfVxuICAgIC8qKiBUaGUgaGVpZ2h0IGluIHBpeGVscyBvZiB0aGUgdHJhY2sncyBjb2RlZCBzYW1wbGVzLCBiZWZvcmUgYW55IHRyYW5zZm9ybWF0aW9ucyBvciByb3RhdGlvbnMuICovXG4gICAgZ2V0IGNvZGVkSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFja2luZy5nZXRDb2RlZEhlaWdodCgpO1xuICAgIH1cbiAgICAvKiogVGhlIGFuZ2xlIGluIGRlZ3JlZXMgYnkgd2hpY2ggdGhlIHRyYWNrJ3MgZnJhbWVzIHNob3VsZCBiZSByb3RhdGVkIChjbG9ja3dpc2UpLiAqL1xuICAgIGdldCByb3RhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhY2tpbmcuZ2V0Um90YXRpb24oKTtcbiAgICB9XG4gICAgLyoqIFRoZSB3aWR0aCBpbiBwaXhlbHMgb2YgdGhlIHRyYWNrJ3MgZnJhbWVzIGFmdGVyIHJvdGF0aW9uLiAqL1xuICAgIGdldCBkaXNwbGF5V2lkdGgoKSB7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gdGhpcy5fYmFja2luZy5nZXRSb3RhdGlvbigpO1xuICAgICAgICByZXR1cm4gcm90YXRpb24gJSAxODAgPT09IDAgPyB0aGlzLl9iYWNraW5nLmdldENvZGVkV2lkdGgoKSA6IHRoaXMuX2JhY2tpbmcuZ2V0Q29kZWRIZWlnaHQoKTtcbiAgICB9XG4gICAgLyoqIFRoZSBoZWlnaHQgaW4gcGl4ZWxzIG9mIHRoZSB0cmFjaydzIGZyYW1lcyBhZnRlciByb3RhdGlvbi4gKi9cbiAgICBnZXQgZGlzcGxheUhlaWdodCgpIHtcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLl9iYWNraW5nLmdldFJvdGF0aW9uKCk7XG4gICAgICAgIHJldHVybiByb3RhdGlvbiAlIDE4MCA9PT0gMCA/IHRoaXMuX2JhY2tpbmcuZ2V0Q29kZWRIZWlnaHQoKSA6IHRoaXMuX2JhY2tpbmcuZ2V0Q29kZWRXaWR0aCgpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgY29sb3Igc3BhY2Ugb2YgdGhlIHRyYWNrJ3Mgc2FtcGxlcy4gKi9cbiAgICBnZXRDb2xvclNwYWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFja2luZy5nZXRDb2xvclNwYWNlKCk7XG4gICAgfVxuICAgIC8qKiBJZiB0aGlzIG1ldGhvZCByZXR1cm5zIHRydWUsIHRoZSB0cmFjaydzIHNhbXBsZXMgdXNlIGEgaGlnaCBkeW5hbWljIHJhbmdlIChIRFIpLiAqL1xuICAgIGFzeW5jIGhhc0hpZ2hEeW5hbWljUmFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IGNvbG9yU3BhY2UgPSBhd2FpdCB0aGlzLl9iYWNraW5nLmdldENvbG9yU3BhY2UoKTtcbiAgICAgICAgcmV0dXJuIGNvbG9yU3BhY2UucHJpbWFyaWVzID09PSAnYnQyMDIwJyB8fCBjb2xvclNwYWNlLnByaW1hcmllcyA9PT0gJ3NtcHRlNDMyJ1xuICAgICAgICAgICAgfHwgY29sb3JTcGFjZS50cmFuc2ZlciA9PT0gJ3BnJyB8fCBjb2xvclNwYWNlLnRyYW5zZmVyID09PSAnaGxnJ1xuICAgICAgICAgICAgfHwgY29sb3JTcGFjZS5tYXRyaXggPT09ICdidDIwMjAtbmNsJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgW2RlY29kZXIgY29uZmlndXJhdGlvbl0oaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmNvZGVjcy8jdmlkZW8tZGVjb2Rlci1jb25maWcpIGZvciBkZWNvZGluZyB0aGVcbiAgICAgKiB0cmFjaydzIHBhY2tldHMgdXNpbmcgYSBbYFZpZGVvRGVjb2RlcmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9WaWRlb0RlY29kZXIpLiBSZXR1cm5zXG4gICAgICogbnVsbCBpZiB0aGUgdHJhY2sncyBjb2RlYyBpcyB1bmtub3duLlxuICAgICAqL1xuICAgIGdldERlY29kZXJDb25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYWNraW5nLmdldERlY29kZXJDb25maWcoKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q29kZWNQYXJhbWV0ZXJTdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXJDb25maWcgPSBhd2FpdCB0aGlzLl9iYWNraW5nLmdldERlY29kZXJDb25maWcoKTtcbiAgICAgICAgcmV0dXJuIGRlY29kZXJDb25maWc/LmNvZGVjID8/IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGNhbkRlY29kZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXJDb25maWcgPSBhd2FpdCB0aGlzLl9iYWNraW5nLmdldERlY29kZXJDb25maWcoKTtcbiAgICAgICAgICAgIGlmICghZGVjb2RlckNvbmZpZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0gdGhpcy5fYmFja2luZy5nZXRDb2RlYygpO1xuICAgICAgICAgICAgYXNzZXJ0KGNvZGVjICE9PSBudWxsKTtcbiAgICAgICAgICAgIGlmIChjdXN0b21WaWRlb0RlY29kZXJzLnNvbWUoeCA9PiB4LnN1cHBvcnRzKGNvZGVjLCBkZWNvZGVyQ29uZmlnKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgVmlkZW9EZWNvZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN1cHBvcnQgPSBhd2FpdCBWaWRlb0RlY29kZXIuaXNDb25maWdTdXBwb3J0ZWQoZGVjb2RlckNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm4gc3VwcG9ydC5zdXBwb3J0ZWQgPT09IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgZGVjb2RhYmlsaXR5IGNoZWNrOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkZXRlcm1pbmVQYWNrZXRUeXBlKHBhY2tldCkge1xuICAgICAgICBpZiAoIShwYWNrZXQgaW5zdGFuY2VvZiBFbmNvZGVkUGFja2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFja2V0IG11c3QgYmUgYW4gRW5jb2RlZFBhY2tldC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFja2V0LmlzTWV0YWRhdGFPbmx5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYWNrZXQgbXVzdCBub3QgYmUgbWV0YWRhdGEtb25seSB0byBkZXRlcm1pbmUgaXRzIHR5cGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29kZWMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXRlcm1pbmVWaWRlb1BhY2tldFR5cGUodGhpcywgcGFja2V0KTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYXVkaW8gdHJhY2sgaW4gYW4gaW5wdXQgZmlsZS5cbiAqIEBncm91cCBJbnB1dCBmaWxlcyAmIHRyYWNrc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgSW5wdXRBdWRpb1RyYWNrIGV4dGVuZHMgSW5wdXRUcmFjayB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNvbnN0cnVjdG9yKGJhY2tpbmcpIHtcbiAgICAgICAgc3VwZXIoYmFja2luZyk7XG4gICAgICAgIHRoaXMuX2JhY2tpbmcgPSBiYWNraW5nO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdhdWRpbyc7XG4gICAgfVxuICAgIGdldCBjb2RlYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhY2tpbmcuZ2V0Q29kZWMoKTtcbiAgICB9XG4gICAgLyoqIFRoZSBudW1iZXIgb2YgYXVkaW8gY2hhbm5lbHMgaW4gdGhlIHRyYWNrLiAqL1xuICAgIGdldCBudW1iZXJPZkNoYW5uZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFja2luZy5nZXROdW1iZXJPZkNoYW5uZWxzKCk7XG4gICAgfVxuICAgIC8qKiBUaGUgdHJhY2sncyBhdWRpbyBzYW1wbGUgcmF0ZSBpbiBoZXJ0ei4gKi9cbiAgICBnZXQgc2FtcGxlUmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhY2tpbmcuZ2V0U2FtcGxlUmF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBbZGVjb2RlciBjb25maWd1cmF0aW9uXShodHRwczovL3d3dy53My5vcmcvVFIvd2ViY29kZWNzLyNhdWRpby1kZWNvZGVyLWNvbmZpZykgZm9yIGRlY29kaW5nIHRoZVxuICAgICAqIHRyYWNrJ3MgcGFja2V0cyB1c2luZyBhbiBbYEF1ZGlvRGVjb2RlcmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb0RlY29kZXIpLiBSZXR1cm5zXG4gICAgICogbnVsbCBpZiB0aGUgdHJhY2sncyBjb2RlYyBpcyB1bmtub3duLlxuICAgICAqL1xuICAgIGdldERlY29kZXJDb25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYWNraW5nLmdldERlY29kZXJDb25maWcoKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q29kZWNQYXJhbWV0ZXJTdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXJDb25maWcgPSBhd2FpdCB0aGlzLl9iYWNraW5nLmdldERlY29kZXJDb25maWcoKTtcbiAgICAgICAgcmV0dXJuIGRlY29kZXJDb25maWc/LmNvZGVjID8/IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGNhbkRlY29kZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXJDb25maWcgPSBhd2FpdCB0aGlzLl9iYWNraW5nLmdldERlY29kZXJDb25maWcoKTtcbiAgICAgICAgICAgIGlmICghZGVjb2RlckNvbmZpZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0gdGhpcy5fYmFja2luZy5nZXRDb2RlYygpO1xuICAgICAgICAgICAgYXNzZXJ0KGNvZGVjICE9PSBudWxsKTtcbiAgICAgICAgICAgIGlmIChjdXN0b21BdWRpb0RlY29kZXJzLnNvbWUoeCA9PiB4LnN1cHBvcnRzKGNvZGVjLCBkZWNvZGVyQ29uZmlnKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWNvZGVyQ29uZmlnLmNvZGVjLnN0YXJ0c1dpdGgoJ3BjbS0nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBTaW5jZSB3ZSBkZWNvZGUgaXQgb3Vyc2VsdmVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEF1ZGlvRGVjb2RlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzdXBwb3J0ID0gYXdhaXQgQXVkaW9EZWNvZGVyLmlzQ29uZmlnU3VwcG9ydGVkKGRlY29kZXJDb25maWcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBwb3J0LnN1cHBvcnRlZCA9PT0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBkZWNvZGFiaWxpdHkgY2hlY2s6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRldGVybWluZVBhY2tldFR5cGUocGFja2V0KSB7XG4gICAgICAgIGlmICghKHBhY2tldCBpbnN0YW5jZW9mIEVuY29kZWRQYWNrZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYWNrZXQgbXVzdCBiZSBhbiBFbmNvZGVkUGFja2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvZGVjID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2tleSc7IC8vIE5vIGF1ZGlvIGNvZGVjIHdpdGggZGVsdGEgcGFja2V0c1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/input-track.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-boxes.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-boxes.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IsobmffBoxWriter: () => (/* binding */ IsobmffBoxWriter),\n/* harmony export */   av1C: () => (/* binding */ av1C),\n/* harmony export */   avcC: () => (/* binding */ avcC),\n/* harmony export */   box: () => (/* binding */ box),\n/* harmony export */   colr: () => (/* binding */ colr),\n/* harmony export */   cslg: () => (/* binding */ cslg),\n/* harmony export */   ctts: () => (/* binding */ ctts),\n/* harmony export */   dOps: () => (/* binding */ dOps),\n/* harmony export */   dfLa: () => (/* binding */ dfLa),\n/* harmony export */   dinf: () => (/* binding */ dinf),\n/* harmony export */   dref: () => (/* binding */ dref),\n/* harmony export */   enda: () => (/* binding */ enda),\n/* harmony export */   esds: () => (/* binding */ esds),\n/* harmony export */   frma: () => (/* binding */ frma),\n/* harmony export */   ftyp: () => (/* binding */ ftyp),\n/* harmony export */   fullBox: () => (/* binding */ fullBox),\n/* harmony export */   hdlr: () => (/* binding */ hdlr),\n/* harmony export */   hvcC: () => (/* binding */ hvcC),\n/* harmony export */   mdat: () => (/* binding */ mdat),\n/* harmony export */   mdhd: () => (/* binding */ mdhd),\n/* harmony export */   mdia: () => (/* binding */ mdia),\n/* harmony export */   mfhd: () => (/* binding */ mfhd),\n/* harmony export */   mfra: () => (/* binding */ mfra),\n/* harmony export */   mfro: () => (/* binding */ mfro),\n/* harmony export */   minf: () => (/* binding */ minf),\n/* harmony export */   moof: () => (/* binding */ moof),\n/* harmony export */   moov: () => (/* binding */ moov),\n/* harmony export */   mvex: () => (/* binding */ mvex),\n/* harmony export */   mvhd: () => (/* binding */ mvhd),\n/* harmony export */   nmhd: () => (/* binding */ nmhd),\n/* harmony export */   smhd: () => (/* binding */ smhd),\n/* harmony export */   soundSampleDescription: () => (/* binding */ soundSampleDescription),\n/* harmony export */   stbl: () => (/* binding */ stbl),\n/* harmony export */   stco: () => (/* binding */ stco),\n/* harmony export */   stsc: () => (/* binding */ stsc),\n/* harmony export */   stsd: () => (/* binding */ stsd),\n/* harmony export */   stss: () => (/* binding */ stss),\n/* harmony export */   stsz: () => (/* binding */ stsz),\n/* harmony export */   stts: () => (/* binding */ stts),\n/* harmony export */   subtitleSampleDescription: () => (/* binding */ subtitleSampleDescription),\n/* harmony export */   tfdt: () => (/* binding */ tfdt),\n/* harmony export */   tfhd: () => (/* binding */ tfhd),\n/* harmony export */   tfra: () => (/* binding */ tfra),\n/* harmony export */   tkhd: () => (/* binding */ tkhd),\n/* harmony export */   traf: () => (/* binding */ traf),\n/* harmony export */   trak: () => (/* binding */ trak),\n/* harmony export */   trex: () => (/* binding */ trex),\n/* harmony export */   trun: () => (/* binding */ trun),\n/* harmony export */   txtC: () => (/* binding */ txtC),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   videoSampleDescription: () => (/* binding */ videoSampleDescription),\n/* harmony export */   vmhd: () => (/* binding */ vmhd),\n/* harmony export */   vpcC: () => (/* binding */ vpcC),\n/* harmony export */   vttC: () => (/* binding */ vttC),\n/* harmony export */   vtta: () => (/* binding */ vtta),\n/* harmony export */   vttc: () => (/* binding */ vttc),\n/* harmony export */   vtte: () => (/* binding */ vtte),\n/* harmony export */   wave: () => (/* binding */ wave)\n/* harmony export */ });\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/* harmony import */ var _codec_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../codec.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec.js\");\n/* harmony import */ var _subtitles_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../subtitles.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/subtitles.js\");\n/* harmony import */ var _isobmff_muxer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isobmff-muxer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-muxer.js\");\n/* harmony import */ var _codec_data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../codec-data.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec-data.js\");\n/* harmony import */ var _tags_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tags.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/tags.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n\nclass IsobmffBoxWriter {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n        /**\n         * Stores the position from the start of the file to where boxes elements have been written. This is used to\n         * rewrite/edit elements that were already added before, and to measure sizes of things.\n         */\n        this.offsets = new WeakMap();\n    }\n    writeU32(value) {\n        this.helperView.setUint32(0, value, false);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeU64(value) {\n        this.helperView.setUint32(0, Math.floor(value / 2 ** 32), false);\n        this.helperView.setUint32(4, value, false);\n        this.writer.write(this.helper.subarray(0, 8));\n    }\n    writeAscii(text) {\n        for (let i = 0; i < text.length; i++) {\n            this.helperView.setUint8(i % 8, text.charCodeAt(i));\n            if (i % 8 === 7)\n                this.writer.write(this.helper);\n        }\n        if (text.length % 8 !== 0) {\n            this.writer.write(this.helper.subarray(0, text.length % 8));\n        }\n    }\n    writeBox(box) {\n        this.offsets.set(box, this.writer.getPos());\n        if (box.contents && !box.children) {\n            this.writeBoxHeader(box, box.size ?? box.contents.byteLength + 8);\n            this.writer.write(box.contents);\n        }\n        else {\n            const startPos = this.writer.getPos();\n            this.writeBoxHeader(box, 0);\n            if (box.contents)\n                this.writer.write(box.contents);\n            if (box.children)\n                for (const child of box.children)\n                    if (child)\n                        this.writeBox(child);\n            const endPos = this.writer.getPos();\n            const size = box.size ?? endPos - startPos;\n            this.writer.seek(startPos);\n            this.writeBoxHeader(box, size);\n            this.writer.seek(endPos);\n        }\n    }\n    writeBoxHeader(box, size) {\n        this.writeU32(box.largeSize ? 1 : size);\n        this.writeAscii(box.type);\n        if (box.largeSize)\n            this.writeU64(size);\n    }\n    measureBoxHeader(box) {\n        return 8 + (box.largeSize ? 8 : 0);\n    }\n    patchBox(box) {\n        const boxOffset = this.offsets.get(box);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(boxOffset !== undefined);\n        const endPos = this.writer.getPos();\n        this.writer.seek(boxOffset);\n        this.writeBox(box);\n        this.writer.seek(endPos);\n    }\n    measureBox(box) {\n        if (box.contents && !box.children) {\n            const headerSize = this.measureBoxHeader(box);\n            return headerSize + box.contents.byteLength;\n        }\n        else {\n            let result = this.measureBoxHeader(box);\n            if (box.contents)\n                result += box.contents.byteLength;\n            if (box.children)\n                for (const child of box.children)\n                    if (child)\n                        result += this.measureBox(child);\n            return result;\n        }\n    }\n}\nconst bytes = new Uint8Array(8);\nconst view = new DataView(bytes.buffer);\nconst u8 = (value) => {\n    return [(value % 0x100 + 0x100) % 0x100];\n};\nconst u16 = (value) => {\n    view.setUint16(0, value, false);\n    return [bytes[0], bytes[1]];\n};\nconst i16 = (value) => {\n    view.setInt16(0, value, false);\n    return [bytes[0], bytes[1]];\n};\nconst u24 = (value) => {\n    view.setUint32(0, value, false);\n    return [bytes[1], bytes[2], bytes[3]];\n};\nconst u32 = (value) => {\n    view.setUint32(0, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst i32 = (value) => {\n    view.setInt32(0, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst u64 = (value) => {\n    view.setUint32(0, Math.floor(value / 2 ** 32), false);\n    view.setUint32(4, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]];\n};\nconst fixed_8_8 = (value) => {\n    view.setInt16(0, 2 ** 8 * value, false);\n    return [bytes[0], bytes[1]];\n};\nconst fixed_16_16 = (value) => {\n    view.setInt32(0, 2 ** 16 * value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst fixed_2_30 = (value) => {\n    view.setInt32(0, 2 ** 30 * value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst variableUnsignedInt = (value, byteLength) => {\n    const bytes = [];\n    let remaining = value;\n    do {\n        let byte = remaining & 0x7f;\n        remaining >>= 7;\n        // If this isn't the first byte we're adding (meaning there will be more bytes after it\n        // when we reverse the array), set the continuation bit\n        if (bytes.length > 0) {\n            byte |= 0x80;\n        }\n        bytes.push(byte);\n        if (byteLength !== undefined) {\n            byteLength--;\n        }\n    } while (remaining > 0 || byteLength);\n    // Reverse the array since we built it backwards\n    return bytes.reverse();\n};\nconst ascii = (text, nullTerminated = false) => {\n    const bytes = Array(text.length).fill(null).map((_, i) => text.charCodeAt(i));\n    if (nullTerminated)\n        bytes.push(0x00);\n    return bytes;\n};\nconst lastPresentedSample = (samples) => {\n    let result = null;\n    for (const sample of samples) {\n        if (!result || sample.timestamp > result.timestamp) {\n            result = sample;\n        }\n    }\n    return result;\n};\nconst rotationMatrix = (rotationInDegrees) => {\n    const theta = rotationInDegrees * (Math.PI / 180);\n    const cosTheta = Math.round(Math.cos(theta));\n    const sinTheta = Math.round(Math.sin(theta));\n    // Matrices are post-multiplied in ISOBMFF, meaning this is the transpose of your typical rotation matrix\n    return [\n        cosTheta, sinTheta, 0,\n        -sinTheta, cosTheta, 0,\n        0, 0, 1,\n    ];\n};\nconst IDENTITY_MATRIX = rotationMatrix(0);\nconst matrixToBytes = (matrix) => {\n    return [\n        fixed_16_16(matrix[0]), fixed_16_16(matrix[1]), fixed_2_30(matrix[2]),\n        fixed_16_16(matrix[3]), fixed_16_16(matrix[4]), fixed_2_30(matrix[5]),\n        fixed_16_16(matrix[6]), fixed_16_16(matrix[7]), fixed_2_30(matrix[8]),\n    ];\n};\nconst box = (type, contents, children) => ({\n    type,\n    contents: contents && new Uint8Array(contents.flat(10)),\n    children,\n});\n/** A FullBox always starts with a version byte, followed by three flag bytes. */\nconst fullBox = (type, version, flags, contents, children) => box(type, [u8(version), u24(flags), contents ?? []], children);\n/**\n * File Type Compatibility Box: Allows the reader to determine whether this is a type of file that the\n * reader understands.\n */\nconst ftyp = (details) => {\n    // You can find the full logic for this at\n    // https://github.com/FFmpeg/FFmpeg/blob/de2fb43e785773738c660cdafb9309b1ef1bc80d/libavformat/movenc.c#L5518\n    // Obviously, this lib only needs a small subset of that logic.\n    const minorVersion = 0x200;\n    if (details.isQuickTime) {\n        return box('ftyp', [\n            ascii('qt  '), // Major brand\n            u32(minorVersion), // Minor version\n            // Compatible brands\n            ascii('qt  '),\n        ]);\n    }\n    if (details.fragmented) {\n        return box('ftyp', [\n            ascii('iso5'), // Major brand\n            u32(minorVersion), // Minor version\n            // Compatible brands\n            ascii('iso5'),\n            ascii('iso6'),\n            ascii('mp41'),\n        ]);\n    }\n    return box('ftyp', [\n        ascii('isom'), // Major brand\n        u32(minorVersion), // Minor version\n        // Compatible brands\n        ascii('isom'),\n        details.holdsAvc ? ascii('avc1') : [],\n        ascii('mp41'),\n    ]);\n};\n/** Movie Sample Data Box. Contains the actual frames/samples of the media. */\nconst mdat = (reserveLargeSize) => ({ type: 'mdat', largeSize: reserveLargeSize });\n/**\n * Movie Box: Used to specify the information that defines a movie - that is, the information that allows\n * an application to interpret the sample data that is stored elsewhere.\n */\nconst moov = (muxer, fragmented = false) => box('moov', undefined, [\n    mvhd(muxer.creationTime, muxer.trackDatas),\n    ...muxer.trackDatas.map(x => trak(x, muxer.creationTime)),\n    fragmented ? mvex(muxer.trackDatas) : null,\n    udta(muxer),\n]);\n/** Movie Header Box: Used to specify the characteristics of the entire movie, such as timescale and duration. */\nconst mvhd = (creationTime, trackDatas) => {\n    const duration = (0,_isobmff_muxer_js__WEBPACK_IMPORTED_MODULE_1__.intoTimescale)(Math.max(0, ...trackDatas\n        .filter(x => x.samples.length > 0)\n        .map((x) => {\n        const lastSample = lastPresentedSample(x.samples);\n        return lastSample.timestamp + lastSample.duration;\n    })), _isobmff_muxer_js__WEBPACK_IMPORTED_MODULE_1__.GLOBAL_TIMESCALE);\n    const nextTrackId = Math.max(0, ...trackDatas.map(x => x.track.id)) + 1;\n    // Conditionally use u64 if u32 isn't enough\n    const needsU64 = !(0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.isU32)(creationTime) || !(0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.isU32)(duration);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    return fullBox('mvhd', +needsU64, 0, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(_isobmff_muxer_js__WEBPACK_IMPORTED_MODULE_1__.GLOBAL_TIMESCALE), // Timescale\n        u32OrU64(duration), // Duration\n        fixed_16_16(1), // Preferred rate\n        fixed_8_8(1), // Preferred volume\n        Array(10).fill(0), // Reserved\n        matrixToBytes(IDENTITY_MATRIX), // Matrix\n        Array(24).fill(0), // Pre-defined\n        u32(nextTrackId), // Next track ID\n    ]);\n};\n/**\n * Track Box: Defines a single track of a movie. A movie may consist of one or more tracks. Each track is\n * independent of the other tracks in the movie and carries its own temporal and spatial information. Each Track Box\n * contains its associated Media Box.\n */\nconst trak = (trackData, creationTime) => {\n    const trackMetadata = (0,_isobmff_muxer_js__WEBPACK_IMPORTED_MODULE_1__.getTrackMetadata)(trackData);\n    return box('trak', undefined, [\n        tkhd(trackData, creationTime),\n        mdia(trackData, creationTime),\n        trackMetadata.name !== undefined\n            ? box('udta', undefined, [\n                box('name', [\n                    ..._misc_js__WEBPACK_IMPORTED_MODULE_0__.textEncoder.encode(trackMetadata.name),\n                ]),\n            ])\n            : null,\n    ]);\n};\n/** Track Header Box: Specifies the characteristics of a single track within a movie. */\nconst tkhd = (trackData, creationTime) => {\n    const lastSample = lastPresentedSample(trackData.samples);\n    const durationInGlobalTimescale = (0,_isobmff_muxer_js__WEBPACK_IMPORTED_MODULE_1__.intoTimescale)(lastSample ? lastSample.timestamp + lastSample.duration : 0, _isobmff_muxer_js__WEBPACK_IMPORTED_MODULE_1__.GLOBAL_TIMESCALE);\n    const needsU64 = !(0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.isU32)(creationTime) || !(0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.isU32)(durationInGlobalTimescale);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    let matrix;\n    if (trackData.type === 'video') {\n        const rotation = trackData.track.metadata.rotation;\n        matrix = rotationMatrix(rotation ?? 0);\n    }\n    else {\n        matrix = IDENTITY_MATRIX;\n    }\n    return fullBox('tkhd', +needsU64, 3, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(trackData.track.id), // Track ID\n        u32(0), // Reserved\n        u32OrU64(durationInGlobalTimescale), // Duration\n        Array(8).fill(0), // Reserved\n        u16(0), // Layer\n        u16(trackData.track.id), // Alternate group\n        fixed_8_8(trackData.type === 'audio' ? 1 : 0), // Volume\n        u16(0), // Reserved\n        matrixToBytes(matrix), // Matrix\n        fixed_16_16(trackData.type === 'video' ? trackData.info.width : 0), // Track width\n        fixed_16_16(trackData.type === 'video' ? trackData.info.height : 0), // Track height\n    ]);\n};\n/** Media Box: Describes and define a track's media type and sample data. */\nconst mdia = (trackData, creationTime) => box('mdia', undefined, [\n    mdhd(trackData, creationTime),\n    hdlr(true, TRACK_TYPE_TO_COMPONENT_SUBTYPE[trackData.type], TRACK_TYPE_TO_HANDLER_NAME[trackData.type]),\n    minf(trackData),\n]);\n/** Media Header Box: Specifies the characteristics of a media, including timescale and duration. */\nconst mdhd = (trackData, creationTime) => {\n    const lastSample = lastPresentedSample(trackData.samples);\n    const localDuration = (0,_isobmff_muxer_js__WEBPACK_IMPORTED_MODULE_1__.intoTimescale)(lastSample ? lastSample.timestamp + lastSample.duration : 0, trackData.timescale);\n    const needsU64 = !(0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.isU32)(creationTime) || !(0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.isU32)(localDuration);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    return fullBox('mdhd', +needsU64, 0, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(trackData.timescale), // Timescale\n        u32OrU64(localDuration), // Duration\n        u16(getLanguageCodeInt(trackData.track.metadata.languageCode ?? _misc_js__WEBPACK_IMPORTED_MODULE_0__.UNDETERMINED_LANGUAGE)), // Language\n        u16(0), // Quality\n    ]);\n};\nconst TRACK_TYPE_TO_COMPONENT_SUBTYPE = {\n    video: 'vide',\n    audio: 'soun',\n    subtitle: 'text',\n};\nconst TRACK_TYPE_TO_HANDLER_NAME = {\n    video: 'MediabunnyVideoHandler',\n    audio: 'MediabunnySoundHandler',\n    subtitle: 'MediabunnyTextHandler',\n};\n/** Handler Reference Box. */\nconst hdlr = (hasComponentType, handlerType, name, manufacturer = '\\0\\0\\0\\0') => fullBox('hdlr', 0, 0, [\n    hasComponentType ? ascii('mhlr') : u32(0), // Component type\n    ascii(handlerType), // Component subtype\n    ascii(manufacturer), // Component manufacturer\n    u32(0), // Component flags\n    u32(0), // Component flags mask\n    ascii(name, true), // Component name\n]);\n/**\n * Media Information Box: Stores handler-specific information for a track's media data. The media handler uses this\n * information to map from media time to media data and to process the media data.\n */\nconst minf = (trackData) => box('minf', undefined, [\n    TRACK_TYPE_TO_HEADER_BOX[trackData.type](),\n    dinf(),\n    stbl(trackData),\n]);\n/** Video Media Information Header Box: Defines specific color and graphics mode information. */\nconst vmhd = () => fullBox('vmhd', 0, 1, [\n    u16(0), // Graphics mode\n    u16(0), // Opcolor R\n    u16(0), // Opcolor G\n    u16(0), // Opcolor B\n]);\n/** Sound Media Information Header Box: Stores the sound media's control information, such as balance. */\nconst smhd = () => fullBox('smhd', 0, 0, [\n    u16(0), // Balance\n    u16(0), // Reserved\n]);\n/** Null Media Header Box. */\nconst nmhd = () => fullBox('nmhd', 0, 0);\nconst TRACK_TYPE_TO_HEADER_BOX = {\n    video: vmhd,\n    audio: smhd,\n    subtitle: nmhd,\n};\n/**\n * Data Information Box: Contains information specifying the data handler component that provides access to the\n * media data. The data handler component uses the Data Information Box to interpret the media's data.\n */\nconst dinf = () => box('dinf', undefined, [\n    dref(),\n]);\n/**\n * Data Reference Box: Contains tabular data that instructs the data handler component how to access the media's data.\n */\nconst dref = () => fullBox('dref', 0, 0, [\n    u32(1), // Entry count\n], [\n    url(),\n]);\nconst url = () => fullBox('url ', 0, 1); // Self-reference flag enabled\n/**\n * Sample Table Box: Contains information for converting from media time to sample number to sample location. This box\n * also indicates how to interpret the sample (for example, whether to decompress the video data and, if so, how).\n */\nconst stbl = (trackData) => {\n    const needsCtts = trackData.compositionTimeOffsetTable.length > 1\n        || trackData.compositionTimeOffsetTable.some(x => x.sampleCompositionTimeOffset !== 0);\n    return box('stbl', undefined, [\n        stsd(trackData),\n        stts(trackData),\n        needsCtts ? ctts(trackData) : null,\n        needsCtts ? cslg(trackData) : null,\n        stsc(trackData),\n        stsz(trackData),\n        stco(trackData),\n        stss(trackData),\n    ]);\n};\n/**\n * Sample Description Box: Stores information that allows you to decode samples in the media. The data stored in the\n * sample description varies, depending on the media type.\n */\nconst stsd = (trackData) => {\n    let sampleDescription;\n    if (trackData.type === 'video') {\n        sampleDescription = videoSampleDescription(VIDEO_CODEC_TO_BOX_NAME[trackData.track.source._codec], trackData);\n    }\n    else if (trackData.type === 'audio') {\n        const boxName = audioCodecToBoxName(trackData.track.source._codec, trackData.muxer.isQuickTime);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(boxName);\n        sampleDescription = soundSampleDescription(boxName, trackData);\n    }\n    else if (trackData.type === 'subtitle') {\n        sampleDescription = subtitleSampleDescription(SUBTITLE_CODEC_TO_BOX_NAME[trackData.track.source._codec], trackData);\n    }\n    (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(sampleDescription);\n    return fullBox('stsd', 0, 0, [\n        u32(1), // Entry count\n    ], [\n        sampleDescription,\n    ]);\n};\n/** Video Sample Description Box: Contains information that defines how to interpret video media data. */\nconst videoSampleDescription = (compressionType, trackData) => box(compressionType, [\n    Array(6).fill(0), // Reserved\n    u16(1), // Data reference index\n    u16(0), // Pre-defined\n    u16(0), // Reserved\n    Array(12).fill(0), // Pre-defined\n    u16(trackData.info.width), // Width\n    u16(trackData.info.height), // Height\n    u32(0x00480000), // Horizontal resolution\n    u32(0x00480000), // Vertical resolution\n    u32(0), // Reserved\n    u16(1), // Frame count\n    Array(32).fill(0), // Compressor name\n    u16(0x0018), // Depth\n    i16(0xffff), // Pre-defined\n], [\n    VIDEO_CODEC_TO_CONFIGURATION_BOX[trackData.track.source._codec](trackData),\n    (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.colorSpaceIsComplete)(trackData.info.decoderConfig.colorSpace) ? colr(trackData) : null,\n]);\n/** Colour Information Box: Specifies the color space of the video. */\nconst colr = (trackData) => box('colr', [\n    ascii('nclx'), // Colour type\n    u16(_misc_js__WEBPACK_IMPORTED_MODULE_0__.COLOR_PRIMARIES_MAP[trackData.info.decoderConfig.colorSpace.primaries]), // Colour primaries\n    u16(_misc_js__WEBPACK_IMPORTED_MODULE_0__.TRANSFER_CHARACTERISTICS_MAP[trackData.info.decoderConfig.colorSpace.transfer]), // Transfer characteristics\n    u16(_misc_js__WEBPACK_IMPORTED_MODULE_0__.MATRIX_COEFFICIENTS_MAP[trackData.info.decoderConfig.colorSpace.matrix]), // Matrix coefficients\n    u8((trackData.info.decoderConfig.colorSpace.fullRange ? 1 : 0) << 7), // Full range flag\n]);\n/** AVC Configuration Box: Provides additional information to the decoder. */\nconst avcC = (trackData) => trackData.info.decoderConfig && box('avcC', [\n    // For AVC, description is an AVCDecoderConfigurationRecord, so nothing else to do here\n    ...(0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.toUint8Array)(trackData.info.decoderConfig.description),\n]);\n/** HEVC Configuration Box: Provides additional information to the decoder. */\nconst hvcC = (trackData) => trackData.info.decoderConfig && box('hvcC', [\n    // For HEVC, description is an HEVCDecoderConfigurationRecord, so nothing else to do here\n    ...(0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.toUint8Array)(trackData.info.decoderConfig.description),\n]);\n/** VP Configuration Box: Provides additional information to the decoder. */\nconst vpcC = (trackData) => {\n    // Reference: https://www.webmproject.org/vp9/mp4/\n    if (!trackData.info.decoderConfig) {\n        return null;\n    }\n    const decoderConfig = trackData.info.decoderConfig;\n    const parts = decoderConfig.codec.split('.'); // We can derive the required values from the codec string\n    const profile = Number(parts[1]);\n    const level = Number(parts[2]);\n    const bitDepth = Number(parts[3]);\n    const chromaSubsampling = parts[4] ? Number(parts[4]) : 1; // 4:2:0 colocated with luma (0,0)\n    const videoFullRangeFlag = parts[8] ? Number(parts[8]) : Number(decoderConfig.colorSpace?.fullRange ?? 0);\n    const thirdByte = (bitDepth << 4) + (chromaSubsampling << 1) + videoFullRangeFlag;\n    const colourPrimaries = parts[5]\n        ? Number(parts[5])\n        : decoderConfig.colorSpace?.primaries\n            ? _misc_js__WEBPACK_IMPORTED_MODULE_0__.COLOR_PRIMARIES_MAP[decoderConfig.colorSpace.primaries]\n            : 2; // Default to undetermined\n    const transferCharacteristics = parts[6]\n        ? Number(parts[6])\n        : decoderConfig.colorSpace?.transfer\n            ? _misc_js__WEBPACK_IMPORTED_MODULE_0__.TRANSFER_CHARACTERISTICS_MAP[decoderConfig.colorSpace.transfer]\n            : 2;\n    const matrixCoefficients = parts[7]\n        ? Number(parts[7])\n        : decoderConfig.colorSpace?.matrix\n            ? _misc_js__WEBPACK_IMPORTED_MODULE_0__.MATRIX_COEFFICIENTS_MAP[decoderConfig.colorSpace.matrix]\n            : 2;\n    return fullBox('vpcC', 1, 0, [\n        u8(profile), // Profile\n        u8(level), // Level\n        u8(thirdByte), // Bit depth, chroma subsampling, full range\n        u8(colourPrimaries), // Colour primaries\n        u8(transferCharacteristics), // Transfer characteristics\n        u8(matrixCoefficients), // Matrix coefficients\n        u16(0), // Codec initialization data size\n    ]);\n};\n/** AV1 Configuration Box: Provides additional information to the decoder. */\nconst av1C = (trackData) => {\n    return box('av1C', (0,_codec_js__WEBPACK_IMPORTED_MODULE_2__.generateAv1CodecConfigurationFromCodecString)(trackData.info.decoderConfig.codec));\n};\n/** Sound Sample Description Box: Contains information that defines how to interpret sound media data. */\nconst soundSampleDescription = (compressionType, trackData) => {\n    let version = 0;\n    let contents;\n    let sampleSizeInBits = 16;\n    if (_codec_js__WEBPACK_IMPORTED_MODULE_2__.PCM_AUDIO_CODECS.includes(trackData.track.source._codec)) {\n        const codec = trackData.track.source._codec;\n        const { sampleSize } = (0,_codec_js__WEBPACK_IMPORTED_MODULE_2__.parsePcmCodec)(codec);\n        sampleSizeInBits = 8 * sampleSize;\n        if (sampleSizeInBits > 16) {\n            version = 1;\n        }\n    }\n    if (version === 0) {\n        contents = [\n            Array(6).fill(0), // Reserved\n            u16(1), // Data reference index\n            u16(version), // Version\n            u16(0), // Revision level\n            u32(0), // Vendor\n            u16(trackData.info.numberOfChannels), // Number of channels\n            u16(sampleSizeInBits), // Sample size (bits)\n            u16(0), // Compression ID\n            u16(0), // Packet size\n            u16(trackData.info.sampleRate < 2 ** 16 ? trackData.info.sampleRate : 0), // Sample rate (upper)\n            u16(0), // Sample rate (lower)\n        ];\n    }\n    else {\n        contents = [\n            Array(6).fill(0), // Reserved\n            u16(1), // Data reference index\n            u16(version), // Version\n            u16(0), // Revision level\n            u32(0), // Vendor\n            u16(trackData.info.numberOfChannels), // Number of channels\n            u16(Math.min(sampleSizeInBits, 16)), // Sample size (bits)\n            u16(0), // Compression ID\n            u16(0), // Packet size\n            u16(trackData.info.sampleRate < 2 ** 16 ? trackData.info.sampleRate : 0), // Sample rate (upper)\n            u16(0), // Sample rate (lower)\n            u32(1), // Samples per packet (must be 1 for uncompressed formats)\n            u32(sampleSizeInBits / 8), // Bytes per packet\n            u32(trackData.info.numberOfChannels * sampleSizeInBits / 8), // Bytes per frame\n            u32(2), // Bytes per sample (constant in FFmpeg)\n        ];\n    }\n    return box(compressionType, contents, [\n        audioCodecToConfigurationBox(trackData.track.source._codec, trackData.muxer.isQuickTime)?.(trackData) ?? null,\n    ]);\n};\n/** MPEG-4 Elementary Stream Descriptor Box. */\nconst esds = (trackData) => {\n    // We build up the bytes in a layered way which reflects the nested structure\n    let objectTypeIndication;\n    switch (trackData.track.source._codec) {\n        case 'aac':\n            {\n                objectTypeIndication = 0x40;\n            }\n            ;\n            break;\n        case 'mp3':\n            {\n                objectTypeIndication = 0x6b;\n            }\n            ;\n            break;\n        case 'vorbis':\n            {\n                objectTypeIndication = 0xdd;\n            }\n            ;\n            break;\n        default: throw new Error(`Unhandled audio codec: ${trackData.track.source._codec}`);\n    }\n    let bytes = [\n        ...u8(objectTypeIndication), // Object type indication\n        ...u8(0x15), // stream type(6bits)=5 audio, flags(2bits)=1\n        ...u24(0), // 24bit buffer size\n        ...u32(0), // max bitrate\n        ...u32(0), // avg bitrate\n    ];\n    if (trackData.info.decoderConfig.description) {\n        const description = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.toUint8Array)(trackData.info.decoderConfig.description);\n        // Add the decoder description to the end\n        bytes = [\n            ...bytes,\n            ...u8(0x05), // TAG(5) = DecoderSpecificInfo\n            ...variableUnsignedInt(description.byteLength),\n            ...description,\n        ];\n    }\n    bytes = [\n        ...u16(1), // ES_ID = 1\n        ...u8(0x00), // flags etc = 0\n        ...u8(0x04), // TAG(4) = ES Descriptor\n        ...variableUnsignedInt(bytes.length),\n        ...bytes,\n        ...u8(0x06), // TAG(6)\n        ...u8(0x01), // length\n        ...u8(0x02), // data\n    ];\n    bytes = [\n        ...u8(0x03), // TAG(3) = Object Descriptor\n        ...variableUnsignedInt(bytes.length),\n        ...bytes,\n    ];\n    return fullBox('esds', 0, 0, bytes);\n};\nconst wave = (trackData) => {\n    return box('wave', undefined, [\n        frma(trackData),\n        enda(trackData),\n        box('\\x00\\x00\\x00\\x00'), // NULL tag at the end\n    ]);\n};\nconst frma = (trackData) => {\n    return box('frma', [\n        ascii(audioCodecToBoxName(trackData.track.source._codec, trackData.muxer.isQuickTime)),\n    ]);\n};\n// This box specifies PCM endianness\nconst enda = (trackData) => {\n    const { littleEndian } = (0,_codec_js__WEBPACK_IMPORTED_MODULE_2__.parsePcmCodec)(trackData.track.source._codec);\n    return box('enda', [\n        u16(+littleEndian),\n    ]);\n};\n/** Opus Specific Box. */\nconst dOps = (trackData) => {\n    let outputChannelCount = trackData.info.numberOfChannels;\n    // Default PreSkip, should be at least 80 milliseconds worth of playback, measured in 48000 Hz samples\n    let preSkip = 3840;\n    let inputSampleRate = trackData.info.sampleRate;\n    let outputGain = 0;\n    let channelMappingFamily = 0;\n    let channelMappingTable = new Uint8Array(0);\n    // Read preskip and from codec private data from the encoder\n    // https://www.rfc-editor.org/rfc/rfc7845#section-5\n    const description = trackData.info.decoderConfig?.description;\n    if (description) {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(description.byteLength >= 18);\n        const bytes = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.toUint8Array)(description);\n        const header = (0,_codec_data_js__WEBPACK_IMPORTED_MODULE_3__.parseOpusIdentificationHeader)(bytes);\n        outputChannelCount = header.outputChannelCount;\n        preSkip = header.preSkip;\n        inputSampleRate = header.inputSampleRate;\n        outputGain = header.outputGain;\n        channelMappingFamily = header.channelMappingFamily;\n        if (header.channelMappingTable) {\n            channelMappingTable = header.channelMappingTable;\n        }\n    }\n    // https://www.opus-codec.org/docs/opus_in_isobmff.html\n    return box('dOps', [\n        u8(0), // Version\n        u8(outputChannelCount), // OutputChannelCount\n        u16(preSkip), // PreSkip\n        u32(inputSampleRate), // InputSampleRate\n        i16(outputGain), // OutputGain\n        u8(channelMappingFamily), // ChannelMappingFamily\n        ...channelMappingTable,\n    ]);\n};\n/** FLAC specific box. */\nconst dfLa = (trackData) => {\n    const description = trackData.info.decoderConfig?.description;\n    (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(description);\n    const bytes = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.toUint8Array)(description);\n    return fullBox('dfLa', 0, 0, [\n        ...bytes.subarray(4),\n    ]);\n};\n/** PCM Configuration Box, ISO/IEC 23003-5. */\nconst pcmC = (trackData) => {\n    const { littleEndian, sampleSize } = (0,_codec_js__WEBPACK_IMPORTED_MODULE_2__.parsePcmCodec)(trackData.track.source._codec);\n    const formatFlags = +littleEndian;\n    return fullBox('pcmC', 0, 0, [\n        u8(formatFlags),\n        u8(8 * sampleSize),\n    ]);\n};\nconst subtitleSampleDescription = (compressionType, trackData) => box(compressionType, [\n    Array(6).fill(0), // Reserved\n    u16(1), // Data reference index\n], [\n    SUBTITLE_CODEC_TO_CONFIGURATION_BOX[trackData.track.source._codec](trackData),\n]);\nconst vttC = (trackData) => box('vttC', [\n    ..._misc_js__WEBPACK_IMPORTED_MODULE_0__.textEncoder.encode(trackData.info.config.description),\n]);\nconst txtC = (textConfig) => fullBox('txtC', 0, 0, [\n    ...textConfig, 0, // Text config (null-terminated)\n]);\n/**\n * Time-To-Sample Box: Stores duration information for a media's samples, providing a mapping from a time in a media\n * to the corresponding data sample. The table is compact, meaning that consecutive samples with the same time delta\n * will be grouped.\n */\nconst stts = (trackData) => {\n    return fullBox('stts', 0, 0, [\n        u32(trackData.timeToSampleTable.length), // Number of entries\n        trackData.timeToSampleTable.map(x => [\n            u32(x.sampleCount), // Sample count\n            u32(x.sampleDelta), // Sample duration\n        ]),\n    ]);\n};\n/** Sync Sample Box: Identifies the key frames in the media, marking the random access points within a stream. */\nconst stss = (trackData) => {\n    if (trackData.samples.every(x => x.type === 'key'))\n        return null; // No stss box -> every frame is a key frame\n    const keySamples = [...trackData.samples.entries()].filter(([, sample]) => sample.type === 'key');\n    return fullBox('stss', 0, 0, [\n        u32(keySamples.length), // Number of entries\n        keySamples.map(([index]) => u32(index + 1)), // Sync sample table\n    ]);\n};\n/**\n * Sample-To-Chunk Box: As samples are added to a media, they are collected into chunks that allow optimized data\n * access. A chunk contains one or more samples. Chunks in a media may have different sizes, and the samples within a\n * chunk may have different sizes. The Sample-To-Chunk Box stores chunk information for the samples in a media, stored\n * in a compactly-coded fashion.\n */\nconst stsc = (trackData) => {\n    return fullBox('stsc', 0, 0, [\n        u32(trackData.compactlyCodedChunkTable.length), // Number of entries\n        trackData.compactlyCodedChunkTable.map(x => [\n            u32(x.firstChunk), // First chunk\n            u32(x.samplesPerChunk), // Samples per chunk\n            u32(1), // Sample description index\n        ]),\n    ]);\n};\n/** Sample Size Box: Specifies the byte size of each sample in the media. */\nconst stsz = (trackData) => {\n    if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n        const { sampleSize } = (0,_codec_js__WEBPACK_IMPORTED_MODULE_2__.parsePcmCodec)(trackData.track.source._codec);\n        // With PCM, every sample has the same size\n        return fullBox('stsz', 0, 0, [\n            u32(sampleSize * trackData.info.numberOfChannels), // Sample size\n            u32(trackData.samples.reduce((acc, x) => acc + (0,_isobmff_muxer_js__WEBPACK_IMPORTED_MODULE_1__.intoTimescale)(x.duration, trackData.timescale), 0)),\n        ]);\n    }\n    return fullBox('stsz', 0, 0, [\n        u32(0), // Sample size (0 means non-constant size)\n        u32(trackData.samples.length), // Number of entries\n        trackData.samples.map(x => u32(x.size)), // Sample size table\n    ]);\n};\n/** Chunk Offset Box: Identifies the location of each chunk of data in the media's data stream, relative to the file. */\nconst stco = (trackData) => {\n    if (trackData.finalizedChunks.length > 0 && (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.last)(trackData.finalizedChunks).offset >= 2 ** 32) {\n        // If the file is large, use the co64 box\n        return fullBox('co64', 0, 0, [\n            u32(trackData.finalizedChunks.length), // Number of entries\n            trackData.finalizedChunks.map(x => u64(x.offset)), // Chunk offset table\n        ]);\n    }\n    return fullBox('stco', 0, 0, [\n        u32(trackData.finalizedChunks.length), // Number of entries\n        trackData.finalizedChunks.map(x => u32(x.offset)), // Chunk offset table\n    ]);\n};\n/**\n * Composition Time to Sample Box: Stores composition time offset information (PTS-DTS) for a\n * media's samples. The table is compact, meaning that consecutive samples with the same time\n * composition time offset will be grouped.\n */\nconst ctts = (trackData) => {\n    return fullBox('ctts', 1, 0, [\n        u32(trackData.compositionTimeOffsetTable.length), // Number of entries\n        trackData.compositionTimeOffsetTable.map(x => [\n            u32(x.sampleCount), // Sample count\n            i32(x.sampleCompositionTimeOffset), // Sample offset\n        ]),\n    ]);\n};\n/**\n * Composition to Decode Box: Stores information about the composition and display times of the media samples.\n */\nconst cslg = (trackData) => {\n    let leastDecodeToDisplayDelta = Infinity;\n    let greatestDecodeToDisplayDelta = -Infinity;\n    let compositionStartTime = Infinity;\n    let compositionEndTime = -Infinity;\n    (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(trackData.compositionTimeOffsetTable.length > 0);\n    (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(trackData.samples.length > 0);\n    for (let i = 0; i < trackData.compositionTimeOffsetTable.length; i++) {\n        const entry = trackData.compositionTimeOffsetTable[i];\n        leastDecodeToDisplayDelta = Math.min(leastDecodeToDisplayDelta, entry.sampleCompositionTimeOffset);\n        greatestDecodeToDisplayDelta = Math.max(greatestDecodeToDisplayDelta, entry.sampleCompositionTimeOffset);\n    }\n    for (let i = 0; i < trackData.samples.length; i++) {\n        const sample = trackData.samples[i];\n        compositionStartTime = Math.min(compositionStartTime, (0,_isobmff_muxer_js__WEBPACK_IMPORTED_MODULE_1__.intoTimescale)(sample.timestamp, trackData.timescale));\n        compositionEndTime = Math.max(compositionEndTime, (0,_isobmff_muxer_js__WEBPACK_IMPORTED_MODULE_1__.intoTimescale)(sample.timestamp + sample.duration, trackData.timescale));\n    }\n    const compositionToDtsShift = Math.max(-leastDecodeToDisplayDelta, 0);\n    if (compositionEndTime >= 2 ** 31) {\n        // For very large files, the composition end time can't be represented in i32, so let's just scrap the box in\n        // that case. QuickTime fails to read the file if there's a cslg box with version 1, so that's sadly not an\n        // option.\n        return null;\n    }\n    return fullBox('cslg', 0, 0, [\n        i32(compositionToDtsShift), // Composition to DTS shift\n        i32(leastDecodeToDisplayDelta), // Least decode to display delta\n        i32(greatestDecodeToDisplayDelta), // Greatest decode to display delta\n        i32(compositionStartTime), // Composition start time\n        i32(compositionEndTime), // Composition end time\n    ]);\n};\n/**\n * Movie Extends Box: This box signals to readers that the file is fragmented. Contains a single Track Extends Box\n * for each track in the movie.\n */\nconst mvex = (trackDatas) => {\n    return box('mvex', undefined, trackDatas.map(trex));\n};\n/** Track Extends Box: Contains the default values used by the movie fragments. */\nconst trex = (trackData) => {\n    return fullBox('trex', 0, 0, [\n        u32(trackData.track.id), // Track ID\n        u32(1), // Default sample description index\n        u32(0), // Default sample duration\n        u32(0), // Default sample size\n        u32(0), // Default sample flags\n    ]);\n};\n/**\n * Movie Fragment Box: The movie fragments extend the presentation in time. They provide the information that would\n * previously have been\tin the Movie Box.\n */\nconst moof = (sequenceNumber, trackDatas) => {\n    return box('moof', undefined, [\n        mfhd(sequenceNumber),\n        ...trackDatas.map(traf),\n    ]);\n};\n/** Movie Fragment Header Box: Contains a sequence number as a safety check. */\nconst mfhd = (sequenceNumber) => {\n    return fullBox('mfhd', 0, 0, [\n        u32(sequenceNumber), // Sequence number\n    ]);\n};\nconst fragmentSampleFlags = (sample) => {\n    let byte1 = 0;\n    let byte2 = 0;\n    const byte3 = 0;\n    const byte4 = 0;\n    const sampleIsDifferenceSample = sample.type === 'delta';\n    byte2 |= +sampleIsDifferenceSample;\n    if (sampleIsDifferenceSample) {\n        byte1 |= 1; // There is redundant coding in this sample\n    }\n    else {\n        byte1 |= 2; // There is no redundant coding in this sample\n    }\n    // Note that there are a lot of other flags to potentially set here, but most are irrelevant / non-necessary\n    return byte1 << 24 | byte2 << 16 | byte3 << 8 | byte4;\n};\n/** Track Fragment Box */\nconst traf = (trackData) => {\n    return box('traf', undefined, [\n        tfhd(trackData),\n        tfdt(trackData),\n        trun(trackData),\n    ]);\n};\n/** Track Fragment Header Box: Provides a reference to the extended track, and flags. */\nconst tfhd = (trackData) => {\n    (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(trackData.currentChunk);\n    let tfFlags = 0;\n    tfFlags |= 0x00008; // Default sample duration present\n    tfFlags |= 0x00010; // Default sample size present\n    tfFlags |= 0x00020; // Default sample flags present\n    tfFlags |= 0x20000; // Default base is moof\n    // Prefer the second sample over the first one, as the first one is a sync sample and therefore the \"odd one out\"\n    const referenceSample = trackData.currentChunk.samples[1] ?? trackData.currentChunk.samples[0];\n    const referenceSampleInfo = {\n        duration: referenceSample.timescaleUnitsToNextSample,\n        size: referenceSample.size,\n        flags: fragmentSampleFlags(referenceSample),\n    };\n    return fullBox('tfhd', 0, tfFlags, [\n        u32(trackData.track.id), // Track ID\n        u32(referenceSampleInfo.duration), // Default sample duration\n        u32(referenceSampleInfo.size), // Default sample size\n        u32(referenceSampleInfo.flags), // Default sample flags\n    ]);\n};\n/**\n * Track Fragment Decode Time Box: Provides the absolute decode time of the first sample of the fragment. This is\n * useful for performing random access on the media file.\n */\nconst tfdt = (trackData) => {\n    (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(trackData.currentChunk);\n    return fullBox('tfdt', 1, 0, [\n        u64((0,_isobmff_muxer_js__WEBPACK_IMPORTED_MODULE_1__.intoTimescale)(trackData.currentChunk.startTimestamp, trackData.timescale)), // Base Media Decode Time\n    ]);\n};\n/** Track Run Box: Specifies a run of contiguous samples for a given track. */\nconst trun = (trackData) => {\n    (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(trackData.currentChunk);\n    const allSampleDurations = trackData.currentChunk.samples.map(x => x.timescaleUnitsToNextSample);\n    const allSampleSizes = trackData.currentChunk.samples.map(x => x.size);\n    const allSampleFlags = trackData.currentChunk.samples.map(fragmentSampleFlags);\n    const allSampleCompositionTimeOffsets = trackData.currentChunk.samples\n        .map(x => (0,_isobmff_muxer_js__WEBPACK_IMPORTED_MODULE_1__.intoTimescale)(x.timestamp - x.decodeTimestamp, trackData.timescale));\n    const uniqueSampleDurations = new Set(allSampleDurations);\n    const uniqueSampleSizes = new Set(allSampleSizes);\n    const uniqueSampleFlags = new Set(allSampleFlags);\n    const uniqueSampleCompositionTimeOffsets = new Set(allSampleCompositionTimeOffsets);\n    const firstSampleFlagsPresent = uniqueSampleFlags.size === 2 && allSampleFlags[0] !== allSampleFlags[1];\n    const sampleDurationPresent = uniqueSampleDurations.size > 1;\n    const sampleSizePresent = uniqueSampleSizes.size > 1;\n    const sampleFlagsPresent = !firstSampleFlagsPresent && uniqueSampleFlags.size > 1;\n    const sampleCompositionTimeOffsetsPresent = uniqueSampleCompositionTimeOffsets.size > 1 || [...uniqueSampleCompositionTimeOffsets].some(x => x !== 0);\n    let flags = 0;\n    flags |= 0x0001; // Data offset present\n    flags |= 0x0004 * +firstSampleFlagsPresent; // First sample flags present\n    flags |= 0x0100 * +sampleDurationPresent; // Sample duration present\n    flags |= 0x0200 * +sampleSizePresent; // Sample size present\n    flags |= 0x0400 * +sampleFlagsPresent; // Sample flags present\n    flags |= 0x0800 * +sampleCompositionTimeOffsetsPresent; // Sample composition time offsets present\n    return fullBox('trun', 1, flags, [\n        u32(trackData.currentChunk.samples.length), // Sample count\n        u32(trackData.currentChunk.offset - trackData.currentChunk.moofOffset || 0), // Data offset\n        firstSampleFlagsPresent ? u32(allSampleFlags[0]) : [],\n        trackData.currentChunk.samples.map((_, i) => [\n            sampleDurationPresent ? u32(allSampleDurations[i]) : [], // Sample duration\n            sampleSizePresent ? u32(allSampleSizes[i]) : [], // Sample size\n            sampleFlagsPresent ? u32(allSampleFlags[i]) : [], // Sample flags\n            // Sample composition time offsets\n            sampleCompositionTimeOffsetsPresent ? i32(allSampleCompositionTimeOffsets[i]) : [],\n        ]),\n    ]);\n};\n/**\n * Movie Fragment Random Access Box: For each track, provides pointers to sync samples within the file\n * for random access.\n */\nconst mfra = (trackDatas) => {\n    return box('mfra', undefined, [\n        ...trackDatas.map(tfra),\n        mfro(),\n    ]);\n};\n/** Track Fragment Random Access Box: Provides pointers to sync samples within the file for random access. */\nconst tfra = (trackData, trackIndex) => {\n    const version = 1; // Using this version allows us to use 64-bit time and offset values\n    return fullBox('tfra', version, 0, [\n        u32(trackData.track.id), // Track ID\n        u32(0b111111), // This specifies that traf number, trun number and sample number are 32-bit ints\n        u32(trackData.finalizedChunks.length), // Number of entries\n        trackData.finalizedChunks.map(chunk => [\n            u64((0,_isobmff_muxer_js__WEBPACK_IMPORTED_MODULE_1__.intoTimescale)(chunk.samples[0].timestamp, trackData.timescale)), // Time (in presentation time)\n            u64(chunk.moofOffset), // moof offset\n            u32(trackIndex + 1), // traf number\n            u32(1), // trun number\n            u32(1), // Sample number\n        ]),\n    ]);\n};\n/**\n * Movie Fragment Random Access Offset Box: Provides the size of the enclosing mfra box. This box can be used by readers\n * to quickly locate the mfra box by searching from the end of the file.\n */\nconst mfro = () => {\n    return fullBox('mfro', 0, 0, [\n        // This value needs to be overwritten manually from the outside, where the actual size of the enclosing mfra box\n        // is known\n        u32(0), // Size\n    ]);\n};\n/** VTT Empty Cue Box */\nconst vtte = () => box('vtte');\n/** VTT Cue Box */\nconst vttc = (payload, timestamp, identifier, settings, sourceId) => box('vttc', undefined, [\n    sourceId !== null ? box('vsid', [i32(sourceId)]) : null,\n    identifier !== null ? box('iden', [..._misc_js__WEBPACK_IMPORTED_MODULE_0__.textEncoder.encode(identifier)]) : null,\n    timestamp !== null ? box('ctim', [..._misc_js__WEBPACK_IMPORTED_MODULE_0__.textEncoder.encode((0,_subtitles_js__WEBPACK_IMPORTED_MODULE_4__.formatSubtitleTimestamp)(timestamp))]) : null,\n    settings !== null ? box('sttg', [..._misc_js__WEBPACK_IMPORTED_MODULE_0__.textEncoder.encode(settings)]) : null,\n    box('payl', [..._misc_js__WEBPACK_IMPORTED_MODULE_0__.textEncoder.encode(payload)]),\n]);\n/** VTT Additional Text Box */\nconst vtta = (notes) => box('vtta', [..._misc_js__WEBPACK_IMPORTED_MODULE_0__.textEncoder.encode(notes)]);\n/** User Data Box */\nconst udta = (muxer) => {\n    const boxes = [];\n    // Depending on the format, metadata tags are written differently\n    if (muxer.isQuickTime) {\n        addQuickTimeMetadataTagBoxes(boxes, muxer.output._metadataTags);\n    }\n    else {\n        const metaBox = meta(muxer.output._metadataTags);\n        if (metaBox) {\n            boxes.push(metaBox);\n        }\n    }\n    if (boxes.length === 0) {\n        return null;\n    }\n    return box('udta', undefined, boxes);\n};\nconst addQuickTimeMetadataTagBoxes = (boxes, tags) => {\n    // https://exiftool.org/TagNames/QuickTime.html (QuickTime UserData Tags)\n    // For QuickTime files, metadata tags are dumped into the udta box\n    for (const { key, value } of (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.keyValueIterator)(tags)) {\n        switch (key) {\n            case 'title':\n                {\n                    boxes.push(metadataTagStringBoxShort('©nam', value));\n                }\n                ;\n                break;\n            case 'description':\n                {\n                    boxes.push(metadataTagStringBoxShort('©des', value));\n                }\n                ;\n                break;\n            case 'artist':\n                {\n                    boxes.push(metadataTagStringBoxShort('©ART', value));\n                }\n                ;\n                break;\n            case 'album':\n                {\n                    boxes.push(metadataTagStringBoxShort('©alb', value));\n                }\n                ;\n                break;\n            case 'albumArtist':\n                {\n                    boxes.push(metadataTagStringBoxShort('albr', value));\n                }\n                ;\n                break;\n            case 'genre':\n                {\n                    boxes.push(metadataTagStringBoxShort('©gen', value));\n                }\n                ;\n                break;\n            case 'date':\n                {\n                    boxes.push(metadataTagStringBoxShort('©day', value.toISOString().slice(0, 10)));\n                }\n                ;\n                break;\n            case 'comment':\n                {\n                    boxes.push(metadataTagStringBoxShort('©cmt', value));\n                }\n                ;\n                break;\n            case 'lyrics':\n                {\n                    boxes.push(metadataTagStringBoxShort('©lyr', value));\n                }\n                ;\n                break;\n            case 'raw':\n                {\n                    // Handled later\n                }\n                ;\n                break;\n            case 'discNumber':\n            case 'discsTotal':\n            case 'trackNumber':\n            case 'tracksTotal':\n            case 'images':\n                {\n                    // Not written for QuickTime (common Apple L)\n                }\n                ;\n                break;\n            default: (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assertNever)(key);\n        }\n    }\n    if (tags.raw) {\n        for (const key in tags.raw) {\n            const value = tags.raw[key];\n            if (value == null || key.length !== 4 || boxes.some(x => x.type === key)) {\n                continue;\n            }\n            if (typeof value === 'string') {\n                boxes.push(metadataTagStringBoxShort(key, value));\n            }\n            else if (value instanceof Uint8Array) {\n                boxes.push(box(key, Array.from(value)));\n            }\n        }\n    }\n};\nconst metadataTagStringBoxShort = (name, value) => {\n    const encoded = _misc_js__WEBPACK_IMPORTED_MODULE_0__.textEncoder.encode(value);\n    return box(name, [\n        u16(encoded.length),\n        u16(getLanguageCodeInt('und')),\n        Array.from(encoded),\n    ]);\n};\nconst DATA_BOX_MIME_TYPE_MAP = {\n    'image/jpeg': 13,\n    'image/png': 14,\n    'image/bmp': 27,\n};\n/** Metadata Box */\nconst meta = (tags) => {\n    const boxes = [];\n    // https://exiftool.org/TagNames/QuickTime.html (QuickTime ItemList Tags)\n    // This is the metadata format used for MP4 files\n    for (const { key, value } of (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.keyValueIterator)(tags)) {\n        switch (key) {\n            case 'title':\n                {\n                    boxes.push(metadataTagStringBoxLong('©nam', value));\n                }\n                ;\n                break;\n            case 'description':\n                {\n                    boxes.push(metadataTagStringBoxLong('©des', value));\n                }\n                ;\n                break;\n            case 'artist':\n                {\n                    boxes.push(metadataTagStringBoxLong('©ART', value));\n                }\n                ;\n                break;\n            case 'album':\n                {\n                    boxes.push(metadataTagStringBoxLong('©alb', value));\n                }\n                ;\n                break;\n            case 'albumArtist':\n                {\n                    boxes.push(metadataTagStringBoxLong('aART', value));\n                }\n                ;\n                break;\n            case 'comment':\n                {\n                    boxes.push(metadataTagStringBoxLong('©cmt', value));\n                }\n                ;\n                break;\n            case 'genre':\n                {\n                    boxes.push(metadataTagStringBoxLong('©gen', value));\n                }\n                ;\n                break;\n            case 'lyrics':\n                {\n                    boxes.push(metadataTagStringBoxLong('©lyr', value));\n                }\n                ;\n                break;\n            case 'date':\n                {\n                    boxes.push(metadataTagStringBoxLong('©day', value.toISOString().slice(0, 10)));\n                }\n                ;\n                break;\n            case 'images':\n                {\n                    for (const image of value) {\n                        if (image.kind !== 'coverFront') {\n                            continue;\n                        }\n                        boxes.push(box('covr', undefined, [\n                            box('data', [\n                                u32(DATA_BOX_MIME_TYPE_MAP[image.mimeType] ?? 0), // Type indicator\n                                u32(0), // Locale indicator\n                                Array.from(image.data), // Kinda slow, hopefully temp\n                            ]),\n                        ]));\n                    }\n                }\n                ;\n                break;\n            case 'trackNumber':\n                {\n                    boxes.push(box('trkn', undefined, [\n                        box('data', [\n                            u32(0), // 8 bytes empty\n                            u32(0),\n                            u16(0), // Empty\n                            u16(value),\n                            u16(tags.tracksTotal ?? 0),\n                            u16(0), // Empty\n                        ]),\n                    ]));\n                }\n                ;\n                break;\n            case 'discNumber':\n                {\n                    boxes.push(box('disc', undefined, [\n                        box('data', [\n                            u32(0), // 8 bytes empty\n                            u32(0),\n                            u16(0), // Empty\n                            u16(value),\n                            u16(tags.discsTotal ?? 0),\n                            u16(0), // Empty\n                        ]),\n                    ]));\n                }\n                ;\n                break;\n            case 'tracksTotal':\n            case 'discsTotal':\n                {\n                    // These are included with 'trackNumber' and 'discNumber' respectively\n                }\n                ;\n                break;\n            case 'raw':\n                {\n                    // Handled later\n                }\n                ;\n                break;\n            default: (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assertNever)(key);\n        }\n    }\n    if (tags.raw) {\n        for (const key in tags.raw) {\n            const value = tags.raw[key];\n            if (value == null || key.length !== 4 || boxes.some(x => x.type === key)) {\n                continue;\n            }\n            if (typeof value === 'string') {\n                boxes.push(metadataTagStringBoxLong(key, value));\n            }\n            else if (value instanceof Uint8Array) {\n                boxes.push(box(key, undefined, [\n                    box('data', [\n                        u32(0), // Type indicator\n                        u32(0), // Locale indicator\n                        Array.from(value),\n                    ]),\n                ]));\n            }\n            else if (value instanceof _tags_js__WEBPACK_IMPORTED_MODULE_5__.RichImageData) {\n                boxes.push(box(key, undefined, [\n                    box('data', [\n                        u32(DATA_BOX_MIME_TYPE_MAP[value.mimeType] ?? 0), // Type indicator\n                        u32(0), // Locale indicator\n                        Array.from(value.data), // Kinda slow, hopefully temp\n                    ]),\n                ]));\n            }\n        }\n    }\n    if (boxes.length === 0) {\n        return null;\n    }\n    return fullBox('meta', 0, 0, undefined, [\n        hdlr(false, 'mdir', '', 'appl'),\n        box('ilst', undefined, boxes),\n    ]);\n};\nconst metadataTagStringBoxLong = (name, value) => {\n    return box(name, undefined, [\n        box('data', [\n            u32(1), // Type indicator (UTF-8)\n            u32(0), // Locale indicator\n            ..._misc_js__WEBPACK_IMPORTED_MODULE_0__.textEncoder.encode(value),\n        ]),\n    ]);\n};\nconst VIDEO_CODEC_TO_BOX_NAME = {\n    avc: 'avc1',\n    hevc: 'hvc1',\n    vp8: 'vp08',\n    vp9: 'vp09',\n    av1: 'av01',\n};\nconst VIDEO_CODEC_TO_CONFIGURATION_BOX = {\n    avc: avcC,\n    hevc: hvcC,\n    vp8: vpcC,\n    vp9: vpcC,\n    av1: av1C,\n};\nconst audioCodecToBoxName = (codec, isQuickTime) => {\n    switch (codec) {\n        case 'aac': return 'mp4a';\n        case 'mp3': return 'mp4a';\n        case 'opus': return 'Opus';\n        case 'vorbis': return 'mp4a';\n        case 'flac': return 'fLaC';\n        case 'ulaw': return 'ulaw';\n        case 'alaw': return 'alaw';\n        case 'pcm-u8': return 'raw ';\n        case 'pcm-s8': return 'sowt';\n    }\n    // Logic diverges here\n    if (isQuickTime) {\n        switch (codec) {\n            case 'pcm-s16': return 'sowt';\n            case 'pcm-s16be': return 'twos';\n            case 'pcm-s24': return 'in24';\n            case 'pcm-s24be': return 'in24';\n            case 'pcm-s32': return 'in32';\n            case 'pcm-s32be': return 'in32';\n            case 'pcm-f32': return 'fl32';\n            case 'pcm-f32be': return 'fl32';\n            case 'pcm-f64': return 'fl64';\n            case 'pcm-f64be': return 'fl64';\n        }\n    }\n    else {\n        switch (codec) {\n            case 'pcm-s16': return 'ipcm';\n            case 'pcm-s16be': return 'ipcm';\n            case 'pcm-s24': return 'ipcm';\n            case 'pcm-s24be': return 'ipcm';\n            case 'pcm-s32': return 'ipcm';\n            case 'pcm-s32be': return 'ipcm';\n            case 'pcm-f32': return 'fpcm';\n            case 'pcm-f32be': return 'fpcm';\n            case 'pcm-f64': return 'fpcm';\n            case 'pcm-f64be': return 'fpcm';\n        }\n    }\n};\nconst audioCodecToConfigurationBox = (codec, isQuickTime) => {\n    switch (codec) {\n        case 'aac': return esds;\n        case 'mp3': return esds;\n        case 'opus': return dOps;\n        case 'vorbis': return esds;\n        case 'flac': return dfLa;\n    }\n    // Logic diverges here\n    if (isQuickTime) {\n        switch (codec) {\n            case 'pcm-s24': return wave;\n            case 'pcm-s24be': return wave;\n            case 'pcm-s32': return wave;\n            case 'pcm-s32be': return wave;\n            case 'pcm-f32': return wave;\n            case 'pcm-f32be': return wave;\n            case 'pcm-f64': return wave;\n            case 'pcm-f64be': return wave;\n        }\n    }\n    else {\n        switch (codec) {\n            case 'pcm-s16': return pcmC;\n            case 'pcm-s16be': return pcmC;\n            case 'pcm-s24': return pcmC;\n            case 'pcm-s24be': return pcmC;\n            case 'pcm-s32': return pcmC;\n            case 'pcm-s32be': return pcmC;\n            case 'pcm-f32': return pcmC;\n            case 'pcm-f32be': return pcmC;\n            case 'pcm-f64': return pcmC;\n            case 'pcm-f64be': return pcmC;\n        }\n    }\n    return null;\n};\nconst SUBTITLE_CODEC_TO_BOX_NAME = {\n    webvtt: 'wvtt',\n};\nconst SUBTITLE_CODEC_TO_CONFIGURATION_BOX = {\n    webvtt: vttC,\n};\nconst getLanguageCodeInt = (code) => {\n    (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(code.length === 3);\n    ;\n    let language = 0;\n    for (let i = 0; i < 3; i++) {\n        language <<= 5;\n        language += code.charCodeAt(i) - 0x60;\n    }\n    return language;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL2lzb2JtZmYvaXNvYm1mZi1ib3hlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcU87QUFDeEg7QUFDbkQ7QUFDOEI7QUFDdkI7QUFDdEI7QUFDcEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFEQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbURBQWE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFNO0FBQ1Y7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRjaC1jdXQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL21lZGlhYnVubnkvZGlzdC9tb2R1bGVzL3NyYy9pc29ibWZmL2lzb2JtZmYtYm94ZXMuanM/MDUzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAyNS1wcmVzZW50LCBWYW5pbGFneSBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmltcG9ydCB7IHRvVWludDhBcnJheSwgYXNzZXJ0LCBpc1UzMiwgbGFzdCwgdGV4dEVuY29kZXIsIENPTE9SX1BSSU1BUklFU19NQVAsIFRSQU5TRkVSX0NIQVJBQ1RFUklTVElDU19NQVAsIE1BVFJJWF9DT0VGRklDSUVOVFNfTUFQLCBjb2xvclNwYWNlSXNDb21wbGV0ZSwgVU5ERVRFUk1JTkVEX0xBTkdVQUdFLCBhc3NlcnROZXZlciwga2V5VmFsdWVJdGVyYXRvciwgfSBmcm9tICcuLi9taXNjLmpzJztcbmltcG9ydCB7IGdlbmVyYXRlQXYxQ29kZWNDb25maWd1cmF0aW9uRnJvbUNvZGVjU3RyaW5nLCBwYXJzZVBjbUNvZGVjLCBQQ01fQVVESU9fQ09ERUNTLCB9IGZyb20gJy4uL2NvZGVjLmpzJztcbmltcG9ydCB7IGZvcm1hdFN1YnRpdGxlVGltZXN0YW1wIH0gZnJvbSAnLi4vc3VidGl0bGVzLmpzJztcbmltcG9ydCB7IGdldFRyYWNrTWV0YWRhdGEsIEdMT0JBTF9USU1FU0NBTEUsIGludG9UaW1lc2NhbGUsIH0gZnJvbSAnLi9pc29ibWZmLW11eGVyLmpzJztcbmltcG9ydCB7IHBhcnNlT3B1c0lkZW50aWZpY2F0aW9uSGVhZGVyIH0gZnJvbSAnLi4vY29kZWMtZGF0YS5qcyc7XG5pbXBvcnQgeyBSaWNoSW1hZ2VEYXRhIH0gZnJvbSAnLi4vdGFncy5qcyc7XG5leHBvcnQgY2xhc3MgSXNvYm1mZkJveFdyaXRlciB7XG4gICAgY29uc3RydWN0b3Iod3JpdGVyKSB7XG4gICAgICAgIHRoaXMud3JpdGVyID0gd3JpdGVyO1xuICAgICAgICB0aGlzLmhlbHBlciA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICB0aGlzLmhlbHBlclZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5oZWxwZXIuYnVmZmVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlcyB0aGUgcG9zaXRpb24gZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGZpbGUgdG8gd2hlcmUgYm94ZXMgZWxlbWVudHMgaGF2ZSBiZWVuIHdyaXR0ZW4uIFRoaXMgaXMgdXNlZCB0b1xuICAgICAgICAgKiByZXdyaXRlL2VkaXQgZWxlbWVudHMgdGhhdCB3ZXJlIGFscmVhZHkgYWRkZWQgYmVmb3JlLCBhbmQgdG8gbWVhc3VyZSBzaXplcyBvZiB0aGluZ3MuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9mZnNldHMgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICB3cml0ZVUzMih2YWx1ZSkge1xuICAgICAgICB0aGlzLmhlbHBlclZpZXcuc2V0VWludDMyKDAsIHZhbHVlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMud3JpdGVyLndyaXRlKHRoaXMuaGVscGVyLnN1YmFycmF5KDAsIDQpKTtcbiAgICB9XG4gICAgd3JpdGVVNjQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWxwZXJWaWV3LnNldFVpbnQzMigwLCBNYXRoLmZsb29yKHZhbHVlIC8gMiAqKiAzMiksIGZhbHNlKTtcbiAgICAgICAgdGhpcy5oZWxwZXJWaWV3LnNldFVpbnQzMig0LCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLndyaXRlci53cml0ZSh0aGlzLmhlbHBlci5zdWJhcnJheSgwLCA4KSk7XG4gICAgfVxuICAgIHdyaXRlQXNjaWkodGV4dCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaGVscGVyVmlldy5zZXRVaW50OChpICUgOCwgdGV4dC5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICAgIGlmIChpICUgOCA9PT0gNylcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlci53cml0ZSh0aGlzLmhlbHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHQubGVuZ3RoICUgOCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy53cml0ZXIud3JpdGUodGhpcy5oZWxwZXIuc3ViYXJyYXkoMCwgdGV4dC5sZW5ndGggJSA4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVCb3goYm94KSB7XG4gICAgICAgIHRoaXMub2Zmc2V0cy5zZXQoYm94LCB0aGlzLndyaXRlci5nZXRQb3MoKSk7XG4gICAgICAgIGlmIChib3guY29udGVudHMgJiYgIWJveC5jaGlsZHJlbikge1xuICAgICAgICAgICAgdGhpcy53cml0ZUJveEhlYWRlcihib3gsIGJveC5zaXplID8/IGJveC5jb250ZW50cy5ieXRlTGVuZ3RoICsgOCk7XG4gICAgICAgICAgICB0aGlzLndyaXRlci53cml0ZShib3guY29udGVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSB0aGlzLndyaXRlci5nZXRQb3MoKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCb3hIZWFkZXIoYm94LCAwKTtcbiAgICAgICAgICAgIGlmIChib3guY29udGVudHMpXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZXIud3JpdGUoYm94LmNvbnRlbnRzKTtcbiAgICAgICAgICAgIGlmIChib3guY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBib3guY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCb3goY2hpbGQpO1xuICAgICAgICAgICAgY29uc3QgZW5kUG9zID0gdGhpcy53cml0ZXIuZ2V0UG9zKCk7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gYm94LnNpemUgPz8gZW5kUG9zIC0gc3RhcnRQb3M7XG4gICAgICAgICAgICB0aGlzLndyaXRlci5zZWVrKHN0YXJ0UG9zKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCb3hIZWFkZXIoYm94LCBzaXplKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVyLnNlZWsoZW5kUG9zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUJveEhlYWRlcihib3gsIHNpemUpIHtcbiAgICAgICAgdGhpcy53cml0ZVUzMihib3gubGFyZ2VTaXplID8gMSA6IHNpemUpO1xuICAgICAgICB0aGlzLndyaXRlQXNjaWkoYm94LnR5cGUpO1xuICAgICAgICBpZiAoYm94LmxhcmdlU2l6ZSlcbiAgICAgICAgICAgIHRoaXMud3JpdGVVNjQoc2l6ZSk7XG4gICAgfVxuICAgIG1lYXN1cmVCb3hIZWFkZXIoYm94KSB7XG4gICAgICAgIHJldHVybiA4ICsgKGJveC5sYXJnZVNpemUgPyA4IDogMCk7XG4gICAgfVxuICAgIHBhdGNoQm94KGJveCkge1xuICAgICAgICBjb25zdCBib3hPZmZzZXQgPSB0aGlzLm9mZnNldHMuZ2V0KGJveCk7XG4gICAgICAgIGFzc2VydChib3hPZmZzZXQgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IGVuZFBvcyA9IHRoaXMud3JpdGVyLmdldFBvcygpO1xuICAgICAgICB0aGlzLndyaXRlci5zZWVrKGJveE9mZnNldCk7XG4gICAgICAgIHRoaXMud3JpdGVCb3goYm94KTtcbiAgICAgICAgdGhpcy53cml0ZXIuc2VlayhlbmRQb3MpO1xuICAgIH1cbiAgICBtZWFzdXJlQm94KGJveCkge1xuICAgICAgICBpZiAoYm94LmNvbnRlbnRzICYmICFib3guY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclNpemUgPSB0aGlzLm1lYXN1cmVCb3hIZWFkZXIoYm94KTtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJTaXplICsgYm94LmNvbnRlbnRzLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5tZWFzdXJlQm94SGVhZGVyKGJveCk7XG4gICAgICAgICAgICBpZiAoYm94LmNvbnRlbnRzKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBib3guY29udGVudHMuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGlmIChib3guY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBib3guY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLm1lYXN1cmVCb3goY2hpbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG5jb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlcik7XG5jb25zdCB1OCA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBbKHZhbHVlICUgMHgxMDAgKyAweDEwMCkgJSAweDEwMF07XG59O1xuY29uc3QgdTE2ID0gKHZhbHVlKSA9PiB7XG4gICAgdmlldy5zZXRVaW50MTYoMCwgdmFsdWUsIGZhbHNlKTtcbiAgICByZXR1cm4gW2J5dGVzWzBdLCBieXRlc1sxXV07XG59O1xuY29uc3QgaTE2ID0gKHZhbHVlKSA9PiB7XG4gICAgdmlldy5zZXRJbnQxNigwLCB2YWx1ZSwgZmFsc2UpO1xuICAgIHJldHVybiBbYnl0ZXNbMF0sIGJ5dGVzWzFdXTtcbn07XG5jb25zdCB1MjQgPSAodmFsdWUpID0+IHtcbiAgICB2aWV3LnNldFVpbnQzMigwLCB2YWx1ZSwgZmFsc2UpO1xuICAgIHJldHVybiBbYnl0ZXNbMV0sIGJ5dGVzWzJdLCBieXRlc1szXV07XG59O1xuY29uc3QgdTMyID0gKHZhbHVlKSA9PiB7XG4gICAgdmlldy5zZXRVaW50MzIoMCwgdmFsdWUsIGZhbHNlKTtcbiAgICByZXR1cm4gW2J5dGVzWzBdLCBieXRlc1sxXSwgYnl0ZXNbMl0sIGJ5dGVzWzNdXTtcbn07XG5jb25zdCBpMzIgPSAodmFsdWUpID0+IHtcbiAgICB2aWV3LnNldEludDMyKDAsIHZhbHVlLCBmYWxzZSk7XG4gICAgcmV0dXJuIFtieXRlc1swXSwgYnl0ZXNbMV0sIGJ5dGVzWzJdLCBieXRlc1szXV07XG59O1xuY29uc3QgdTY0ID0gKHZhbHVlKSA9PiB7XG4gICAgdmlldy5zZXRVaW50MzIoMCwgTWF0aC5mbG9vcih2YWx1ZSAvIDIgKiogMzIpLCBmYWxzZSk7XG4gICAgdmlldy5zZXRVaW50MzIoNCwgdmFsdWUsIGZhbHNlKTtcbiAgICByZXR1cm4gW2J5dGVzWzBdLCBieXRlc1sxXSwgYnl0ZXNbMl0sIGJ5dGVzWzNdLCBieXRlc1s0XSwgYnl0ZXNbNV0sIGJ5dGVzWzZdLCBieXRlc1s3XV07XG59O1xuY29uc3QgZml4ZWRfOF84ID0gKHZhbHVlKSA9PiB7XG4gICAgdmlldy5zZXRJbnQxNigwLCAyICoqIDggKiB2YWx1ZSwgZmFsc2UpO1xuICAgIHJldHVybiBbYnl0ZXNbMF0sIGJ5dGVzWzFdXTtcbn07XG5jb25zdCBmaXhlZF8xNl8xNiA9ICh2YWx1ZSkgPT4ge1xuICAgIHZpZXcuc2V0SW50MzIoMCwgMiAqKiAxNiAqIHZhbHVlLCBmYWxzZSk7XG4gICAgcmV0dXJuIFtieXRlc1swXSwgYnl0ZXNbMV0sIGJ5dGVzWzJdLCBieXRlc1szXV07XG59O1xuY29uc3QgZml4ZWRfMl8zMCA9ICh2YWx1ZSkgPT4ge1xuICAgIHZpZXcuc2V0SW50MzIoMCwgMiAqKiAzMCAqIHZhbHVlLCBmYWxzZSk7XG4gICAgcmV0dXJuIFtieXRlc1swXSwgYnl0ZXNbMV0sIGJ5dGVzWzJdLCBieXRlc1szXV07XG59O1xuY29uc3QgdmFyaWFibGVVbnNpZ25lZEludCA9ICh2YWx1ZSwgYnl0ZUxlbmd0aCkgPT4ge1xuICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgbGV0IHJlbWFpbmluZyA9IHZhbHVlO1xuICAgIGRvIHtcbiAgICAgICAgbGV0IGJ5dGUgPSByZW1haW5pbmcgJiAweDdmO1xuICAgICAgICByZW1haW5pbmcgPj49IDc7XG4gICAgICAgIC8vIElmIHRoaXMgaXNuJ3QgdGhlIGZpcnN0IGJ5dGUgd2UncmUgYWRkaW5nIChtZWFuaW5nIHRoZXJlIHdpbGwgYmUgbW9yZSBieXRlcyBhZnRlciBpdFxuICAgICAgICAvLyB3aGVuIHdlIHJldmVyc2UgdGhlIGFycmF5KSwgc2V0IHRoZSBjb250aW51YXRpb24gYml0XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBieXRlIHw9IDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXMucHVzaChieXRlKTtcbiAgICAgICAgaWYgKGJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAocmVtYWluaW5nID4gMCB8fCBieXRlTGVuZ3RoKTtcbiAgICAvLyBSZXZlcnNlIHRoZSBhcnJheSBzaW5jZSB3ZSBidWlsdCBpdCBiYWNrd2FyZHNcbiAgICByZXR1cm4gYnl0ZXMucmV2ZXJzZSgpO1xufTtcbmNvbnN0IGFzY2lpID0gKHRleHQsIG51bGxUZXJtaW5hdGVkID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBieXRlcyA9IEFycmF5KHRleHQubGVuZ3RoKS5maWxsKG51bGwpLm1hcCgoXywgaSkgPT4gdGV4dC5jaGFyQ29kZUF0KGkpKTtcbiAgICBpZiAobnVsbFRlcm1pbmF0ZWQpXG4gICAgICAgIGJ5dGVzLnB1c2goMHgwMCk7XG4gICAgcmV0dXJuIGJ5dGVzO1xufTtcbmNvbnN0IGxhc3RQcmVzZW50ZWRTYW1wbGUgPSAoc2FtcGxlcykgPT4ge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGZvciAoY29uc3Qgc2FtcGxlIG9mIHNhbXBsZXMpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQgfHwgc2FtcGxlLnRpbWVzdGFtcCA+IHJlc3VsdC50aW1lc3RhbXApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNhbXBsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IHJvdGF0aW9uTWF0cml4ID0gKHJvdGF0aW9uSW5EZWdyZWVzKSA9PiB7XG4gICAgY29uc3QgdGhldGEgPSByb3RhdGlvbkluRGVncmVlcyAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICBjb25zdCBjb3NUaGV0YSA9IE1hdGgucm91bmQoTWF0aC5jb3ModGhldGEpKTtcbiAgICBjb25zdCBzaW5UaGV0YSA9IE1hdGgucm91bmQoTWF0aC5zaW4odGhldGEpKTtcbiAgICAvLyBNYXRyaWNlcyBhcmUgcG9zdC1tdWx0aXBsaWVkIGluIElTT0JNRkYsIG1lYW5pbmcgdGhpcyBpcyB0aGUgdHJhbnNwb3NlIG9mIHlvdXIgdHlwaWNhbCByb3RhdGlvbiBtYXRyaXhcbiAgICByZXR1cm4gW1xuICAgICAgICBjb3NUaGV0YSwgc2luVGhldGEsIDAsXG4gICAgICAgIC1zaW5UaGV0YSwgY29zVGhldGEsIDAsXG4gICAgICAgIDAsIDAsIDEsXG4gICAgXTtcbn07XG5jb25zdCBJREVOVElUWV9NQVRSSVggPSByb3RhdGlvbk1hdHJpeCgwKTtcbmNvbnN0IG1hdHJpeFRvQnl0ZXMgPSAobWF0cml4KSA9PiB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZml4ZWRfMTZfMTYobWF0cml4WzBdKSwgZml4ZWRfMTZfMTYobWF0cml4WzFdKSwgZml4ZWRfMl8zMChtYXRyaXhbMl0pLFxuICAgICAgICBmaXhlZF8xNl8xNihtYXRyaXhbM10pLCBmaXhlZF8xNl8xNihtYXRyaXhbNF0pLCBmaXhlZF8yXzMwKG1hdHJpeFs1XSksXG4gICAgICAgIGZpeGVkXzE2XzE2KG1hdHJpeFs2XSksIGZpeGVkXzE2XzE2KG1hdHJpeFs3XSksIGZpeGVkXzJfMzAobWF0cml4WzhdKSxcbiAgICBdO1xufTtcbmV4cG9ydCBjb25zdCBib3ggPSAodHlwZSwgY29udGVudHMsIGNoaWxkcmVuKSA9PiAoe1xuICAgIHR5cGUsXG4gICAgY29udGVudHM6IGNvbnRlbnRzICYmIG5ldyBVaW50OEFycmF5KGNvbnRlbnRzLmZsYXQoMTApKSxcbiAgICBjaGlsZHJlbixcbn0pO1xuLyoqIEEgRnVsbEJveCBhbHdheXMgc3RhcnRzIHdpdGggYSB2ZXJzaW9uIGJ5dGUsIGZvbGxvd2VkIGJ5IHRocmVlIGZsYWcgYnl0ZXMuICovXG5leHBvcnQgY29uc3QgZnVsbEJveCA9ICh0eXBlLCB2ZXJzaW9uLCBmbGFncywgY29udGVudHMsIGNoaWxkcmVuKSA9PiBib3godHlwZSwgW3U4KHZlcnNpb24pLCB1MjQoZmxhZ3MpLCBjb250ZW50cyA/PyBbXV0sIGNoaWxkcmVuKTtcbi8qKlxuICogRmlsZSBUeXBlIENvbXBhdGliaWxpdHkgQm94OiBBbGxvd3MgdGhlIHJlYWRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgdHlwZSBvZiBmaWxlIHRoYXQgdGhlXG4gKiByZWFkZXIgdW5kZXJzdGFuZHMuXG4gKi9cbmV4cG9ydCBjb25zdCBmdHlwID0gKGRldGFpbHMpID0+IHtcbiAgICAvLyBZb3UgY2FuIGZpbmQgdGhlIGZ1bGwgbG9naWMgZm9yIHRoaXMgYXRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vRkZtcGVnL0ZGbXBlZy9ibG9iL2RlMmZiNDNlNzg1NzczNzM4YzY2MGNkYWZiOTMwOWIxZWYxYmM4MGQvbGliYXZmb3JtYXQvbW92ZW5jLmMjTDU1MThcbiAgICAvLyBPYnZpb3VzbHksIHRoaXMgbGliIG9ubHkgbmVlZHMgYSBzbWFsbCBzdWJzZXQgb2YgdGhhdCBsb2dpYy5cbiAgICBjb25zdCBtaW5vclZlcnNpb24gPSAweDIwMDtcbiAgICBpZiAoZGV0YWlscy5pc1F1aWNrVGltZSkge1xuICAgICAgICByZXR1cm4gYm94KCdmdHlwJywgW1xuICAgICAgICAgICAgYXNjaWkoJ3F0ICAnKSwgLy8gTWFqb3IgYnJhbmRcbiAgICAgICAgICAgIHUzMihtaW5vclZlcnNpb24pLCAvLyBNaW5vciB2ZXJzaW9uXG4gICAgICAgICAgICAvLyBDb21wYXRpYmxlIGJyYW5kc1xuICAgICAgICAgICAgYXNjaWkoJ3F0ICAnKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGlmIChkZXRhaWxzLmZyYWdtZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuIGJveCgnZnR5cCcsIFtcbiAgICAgICAgICAgIGFzY2lpKCdpc281JyksIC8vIE1ham9yIGJyYW5kXG4gICAgICAgICAgICB1MzIobWlub3JWZXJzaW9uKSwgLy8gTWlub3IgdmVyc2lvblxuICAgICAgICAgICAgLy8gQ29tcGF0aWJsZSBicmFuZHNcbiAgICAgICAgICAgIGFzY2lpKCdpc281JyksXG4gICAgICAgICAgICBhc2NpaSgnaXNvNicpLFxuICAgICAgICAgICAgYXNjaWkoJ21wNDEnKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiBib3goJ2Z0eXAnLCBbXG4gICAgICAgIGFzY2lpKCdpc29tJyksIC8vIE1ham9yIGJyYW5kXG4gICAgICAgIHUzMihtaW5vclZlcnNpb24pLCAvLyBNaW5vciB2ZXJzaW9uXG4gICAgICAgIC8vIENvbXBhdGlibGUgYnJhbmRzXG4gICAgICAgIGFzY2lpKCdpc29tJyksXG4gICAgICAgIGRldGFpbHMuaG9sZHNBdmMgPyBhc2NpaSgnYXZjMScpIDogW10sXG4gICAgICAgIGFzY2lpKCdtcDQxJyksXG4gICAgXSk7XG59O1xuLyoqIE1vdmllIFNhbXBsZSBEYXRhIEJveC4gQ29udGFpbnMgdGhlIGFjdHVhbCBmcmFtZXMvc2FtcGxlcyBvZiB0aGUgbWVkaWEuICovXG5leHBvcnQgY29uc3QgbWRhdCA9IChyZXNlcnZlTGFyZ2VTaXplKSA9PiAoeyB0eXBlOiAnbWRhdCcsIGxhcmdlU2l6ZTogcmVzZXJ2ZUxhcmdlU2l6ZSB9KTtcbi8qKlxuICogTW92aWUgQm94OiBVc2VkIHRvIHNwZWNpZnkgdGhlIGluZm9ybWF0aW9uIHRoYXQgZGVmaW5lcyBhIG1vdmllIC0gdGhhdCBpcywgdGhlIGluZm9ybWF0aW9uIHRoYXQgYWxsb3dzXG4gKiBhbiBhcHBsaWNhdGlvbiB0byBpbnRlcnByZXQgdGhlIHNhbXBsZSBkYXRhIHRoYXQgaXMgc3RvcmVkIGVsc2V3aGVyZS5cbiAqL1xuZXhwb3J0IGNvbnN0IG1vb3YgPSAobXV4ZXIsIGZyYWdtZW50ZWQgPSBmYWxzZSkgPT4gYm94KCdtb292JywgdW5kZWZpbmVkLCBbXG4gICAgbXZoZChtdXhlci5jcmVhdGlvblRpbWUsIG11eGVyLnRyYWNrRGF0YXMpLFxuICAgIC4uLm11eGVyLnRyYWNrRGF0YXMubWFwKHggPT4gdHJhayh4LCBtdXhlci5jcmVhdGlvblRpbWUpKSxcbiAgICBmcmFnbWVudGVkID8gbXZleChtdXhlci50cmFja0RhdGFzKSA6IG51bGwsXG4gICAgdWR0YShtdXhlciksXG5dKTtcbi8qKiBNb3ZpZSBIZWFkZXIgQm94OiBVc2VkIHRvIHNwZWNpZnkgdGhlIGNoYXJhY3RlcmlzdGljcyBvZiB0aGUgZW50aXJlIG1vdmllLCBzdWNoIGFzIHRpbWVzY2FsZSBhbmQgZHVyYXRpb24uICovXG5leHBvcnQgY29uc3QgbXZoZCA9IChjcmVhdGlvblRpbWUsIHRyYWNrRGF0YXMpID0+IHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IGludG9UaW1lc2NhbGUoTWF0aC5tYXgoMCwgLi4udHJhY2tEYXRhc1xuICAgICAgICAuZmlsdGVyKHggPT4geC5zYW1wbGVzLmxlbmd0aCA+IDApXG4gICAgICAgIC5tYXAoKHgpID0+IHtcbiAgICAgICAgY29uc3QgbGFzdFNhbXBsZSA9IGxhc3RQcmVzZW50ZWRTYW1wbGUoeC5zYW1wbGVzKTtcbiAgICAgICAgcmV0dXJuIGxhc3RTYW1wbGUudGltZXN0YW1wICsgbGFzdFNhbXBsZS5kdXJhdGlvbjtcbiAgICB9KSksIEdMT0JBTF9USU1FU0NBTEUpO1xuICAgIGNvbnN0IG5leHRUcmFja0lkID0gTWF0aC5tYXgoMCwgLi4udHJhY2tEYXRhcy5tYXAoeCA9PiB4LnRyYWNrLmlkKSkgKyAxO1xuICAgIC8vIENvbmRpdGlvbmFsbHkgdXNlIHU2NCBpZiB1MzIgaXNuJ3QgZW5vdWdoXG4gICAgY29uc3QgbmVlZHNVNjQgPSAhaXNVMzIoY3JlYXRpb25UaW1lKSB8fCAhaXNVMzIoZHVyYXRpb24pO1xuICAgIGNvbnN0IHUzMk9yVTY0ID0gbmVlZHNVNjQgPyB1NjQgOiB1MzI7XG4gICAgcmV0dXJuIGZ1bGxCb3goJ212aGQnLCArbmVlZHNVNjQsIDAsIFtcbiAgICAgICAgdTMyT3JVNjQoY3JlYXRpb25UaW1lKSwgLy8gQ3JlYXRpb24gdGltZVxuICAgICAgICB1MzJPclU2NChjcmVhdGlvblRpbWUpLCAvLyBNb2RpZmljYXRpb24gdGltZVxuICAgICAgICB1MzIoR0xPQkFMX1RJTUVTQ0FMRSksIC8vIFRpbWVzY2FsZVxuICAgICAgICB1MzJPclU2NChkdXJhdGlvbiksIC8vIER1cmF0aW9uXG4gICAgICAgIGZpeGVkXzE2XzE2KDEpLCAvLyBQcmVmZXJyZWQgcmF0ZVxuICAgICAgICBmaXhlZF84XzgoMSksIC8vIFByZWZlcnJlZCB2b2x1bWVcbiAgICAgICAgQXJyYXkoMTApLmZpbGwoMCksIC8vIFJlc2VydmVkXG4gICAgICAgIG1hdHJpeFRvQnl0ZXMoSURFTlRJVFlfTUFUUklYKSwgLy8gTWF0cml4XG4gICAgICAgIEFycmF5KDI0KS5maWxsKDApLCAvLyBQcmUtZGVmaW5lZFxuICAgICAgICB1MzIobmV4dFRyYWNrSWQpLCAvLyBOZXh0IHRyYWNrIElEXG4gICAgXSk7XG59O1xuLyoqXG4gKiBUcmFjayBCb3g6IERlZmluZXMgYSBzaW5nbGUgdHJhY2sgb2YgYSBtb3ZpZS4gQSBtb3ZpZSBtYXkgY29uc2lzdCBvZiBvbmUgb3IgbW9yZSB0cmFja3MuIEVhY2ggdHJhY2sgaXNcbiAqIGluZGVwZW5kZW50IG9mIHRoZSBvdGhlciB0cmFja3MgaW4gdGhlIG1vdmllIGFuZCBjYXJyaWVzIGl0cyBvd24gdGVtcG9yYWwgYW5kIHNwYXRpYWwgaW5mb3JtYXRpb24uIEVhY2ggVHJhY2sgQm94XG4gKiBjb250YWlucyBpdHMgYXNzb2NpYXRlZCBNZWRpYSBCb3guXG4gKi9cbmV4cG9ydCBjb25zdCB0cmFrID0gKHRyYWNrRGF0YSwgY3JlYXRpb25UaW1lKSA9PiB7XG4gICAgY29uc3QgdHJhY2tNZXRhZGF0YSA9IGdldFRyYWNrTWV0YWRhdGEodHJhY2tEYXRhKTtcbiAgICByZXR1cm4gYm94KCd0cmFrJywgdW5kZWZpbmVkLCBbXG4gICAgICAgIHRraGQodHJhY2tEYXRhLCBjcmVhdGlvblRpbWUpLFxuICAgICAgICBtZGlhKHRyYWNrRGF0YSwgY3JlYXRpb25UaW1lKSxcbiAgICAgICAgdHJhY2tNZXRhZGF0YS5uYW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYm94KCd1ZHRhJywgdW5kZWZpbmVkLCBbXG4gICAgICAgICAgICAgICAgYm94KCduYW1lJywgW1xuICAgICAgICAgICAgICAgICAgICAuLi50ZXh0RW5jb2Rlci5lbmNvZGUodHJhY2tNZXRhZGF0YS5uYW1lKSxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICA6IG51bGwsXG4gICAgXSk7XG59O1xuLyoqIFRyYWNrIEhlYWRlciBCb3g6IFNwZWNpZmllcyB0aGUgY2hhcmFjdGVyaXN0aWNzIG9mIGEgc2luZ2xlIHRyYWNrIHdpdGhpbiBhIG1vdmllLiAqL1xuZXhwb3J0IGNvbnN0IHRraGQgPSAodHJhY2tEYXRhLCBjcmVhdGlvblRpbWUpID0+IHtcbiAgICBjb25zdCBsYXN0U2FtcGxlID0gbGFzdFByZXNlbnRlZFNhbXBsZSh0cmFja0RhdGEuc2FtcGxlcyk7XG4gICAgY29uc3QgZHVyYXRpb25Jbkdsb2JhbFRpbWVzY2FsZSA9IGludG9UaW1lc2NhbGUobGFzdFNhbXBsZSA/IGxhc3RTYW1wbGUudGltZXN0YW1wICsgbGFzdFNhbXBsZS5kdXJhdGlvbiA6IDAsIEdMT0JBTF9USU1FU0NBTEUpO1xuICAgIGNvbnN0IG5lZWRzVTY0ID0gIWlzVTMyKGNyZWF0aW9uVGltZSkgfHwgIWlzVTMyKGR1cmF0aW9uSW5HbG9iYWxUaW1lc2NhbGUpO1xuICAgIGNvbnN0IHUzMk9yVTY0ID0gbmVlZHNVNjQgPyB1NjQgOiB1MzI7XG4gICAgbGV0IG1hdHJpeDtcbiAgICBpZiAodHJhY2tEYXRhLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSB0cmFja0RhdGEudHJhY2subWV0YWRhdGEucm90YXRpb247XG4gICAgICAgIG1hdHJpeCA9IHJvdGF0aW9uTWF0cml4KHJvdGF0aW9uID8/IDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWF0cml4ID0gSURFTlRJVFlfTUFUUklYO1xuICAgIH1cbiAgICByZXR1cm4gZnVsbEJveCgndGtoZCcsICtuZWVkc1U2NCwgMywgW1xuICAgICAgICB1MzJPclU2NChjcmVhdGlvblRpbWUpLCAvLyBDcmVhdGlvbiB0aW1lXG4gICAgICAgIHUzMk9yVTY0KGNyZWF0aW9uVGltZSksIC8vIE1vZGlmaWNhdGlvbiB0aW1lXG4gICAgICAgIHUzMih0cmFja0RhdGEudHJhY2suaWQpLCAvLyBUcmFjayBJRFxuICAgICAgICB1MzIoMCksIC8vIFJlc2VydmVkXG4gICAgICAgIHUzMk9yVTY0KGR1cmF0aW9uSW5HbG9iYWxUaW1lc2NhbGUpLCAvLyBEdXJhdGlvblxuICAgICAgICBBcnJheSg4KS5maWxsKDApLCAvLyBSZXNlcnZlZFxuICAgICAgICB1MTYoMCksIC8vIExheWVyXG4gICAgICAgIHUxNih0cmFja0RhdGEudHJhY2suaWQpLCAvLyBBbHRlcm5hdGUgZ3JvdXBcbiAgICAgICAgZml4ZWRfOF84KHRyYWNrRGF0YS50eXBlID09PSAnYXVkaW8nID8gMSA6IDApLCAvLyBWb2x1bWVcbiAgICAgICAgdTE2KDApLCAvLyBSZXNlcnZlZFxuICAgICAgICBtYXRyaXhUb0J5dGVzKG1hdHJpeCksIC8vIE1hdHJpeFxuICAgICAgICBmaXhlZF8xNl8xNih0cmFja0RhdGEudHlwZSA9PT0gJ3ZpZGVvJyA/IHRyYWNrRGF0YS5pbmZvLndpZHRoIDogMCksIC8vIFRyYWNrIHdpZHRoXG4gICAgICAgIGZpeGVkXzE2XzE2KHRyYWNrRGF0YS50eXBlID09PSAndmlkZW8nID8gdHJhY2tEYXRhLmluZm8uaGVpZ2h0IDogMCksIC8vIFRyYWNrIGhlaWdodFxuICAgIF0pO1xufTtcbi8qKiBNZWRpYSBCb3g6IERlc2NyaWJlcyBhbmQgZGVmaW5lIGEgdHJhY2sncyBtZWRpYSB0eXBlIGFuZCBzYW1wbGUgZGF0YS4gKi9cbmV4cG9ydCBjb25zdCBtZGlhID0gKHRyYWNrRGF0YSwgY3JlYXRpb25UaW1lKSA9PiBib3goJ21kaWEnLCB1bmRlZmluZWQsIFtcbiAgICBtZGhkKHRyYWNrRGF0YSwgY3JlYXRpb25UaW1lKSxcbiAgICBoZGxyKHRydWUsIFRSQUNLX1RZUEVfVE9fQ09NUE9ORU5UX1NVQlRZUEVbdHJhY2tEYXRhLnR5cGVdLCBUUkFDS19UWVBFX1RPX0hBTkRMRVJfTkFNRVt0cmFja0RhdGEudHlwZV0pLFxuICAgIG1pbmYodHJhY2tEYXRhKSxcbl0pO1xuLyoqIE1lZGlhIEhlYWRlciBCb3g6IFNwZWNpZmllcyB0aGUgY2hhcmFjdGVyaXN0aWNzIG9mIGEgbWVkaWEsIGluY2x1ZGluZyB0aW1lc2NhbGUgYW5kIGR1cmF0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IG1kaGQgPSAodHJhY2tEYXRhLCBjcmVhdGlvblRpbWUpID0+IHtcbiAgICBjb25zdCBsYXN0U2FtcGxlID0gbGFzdFByZXNlbnRlZFNhbXBsZSh0cmFja0RhdGEuc2FtcGxlcyk7XG4gICAgY29uc3QgbG9jYWxEdXJhdGlvbiA9IGludG9UaW1lc2NhbGUobGFzdFNhbXBsZSA/IGxhc3RTYW1wbGUudGltZXN0YW1wICsgbGFzdFNhbXBsZS5kdXJhdGlvbiA6IDAsIHRyYWNrRGF0YS50aW1lc2NhbGUpO1xuICAgIGNvbnN0IG5lZWRzVTY0ID0gIWlzVTMyKGNyZWF0aW9uVGltZSkgfHwgIWlzVTMyKGxvY2FsRHVyYXRpb24pO1xuICAgIGNvbnN0IHUzMk9yVTY0ID0gbmVlZHNVNjQgPyB1NjQgOiB1MzI7XG4gICAgcmV0dXJuIGZ1bGxCb3goJ21kaGQnLCArbmVlZHNVNjQsIDAsIFtcbiAgICAgICAgdTMyT3JVNjQoY3JlYXRpb25UaW1lKSwgLy8gQ3JlYXRpb24gdGltZVxuICAgICAgICB1MzJPclU2NChjcmVhdGlvblRpbWUpLCAvLyBNb2RpZmljYXRpb24gdGltZVxuICAgICAgICB1MzIodHJhY2tEYXRhLnRpbWVzY2FsZSksIC8vIFRpbWVzY2FsZVxuICAgICAgICB1MzJPclU2NChsb2NhbER1cmF0aW9uKSwgLy8gRHVyYXRpb25cbiAgICAgICAgdTE2KGdldExhbmd1YWdlQ29kZUludCh0cmFja0RhdGEudHJhY2subWV0YWRhdGEubGFuZ3VhZ2VDb2RlID8/IFVOREVURVJNSU5FRF9MQU5HVUFHRSkpLCAvLyBMYW5ndWFnZVxuICAgICAgICB1MTYoMCksIC8vIFF1YWxpdHlcbiAgICBdKTtcbn07XG5jb25zdCBUUkFDS19UWVBFX1RPX0NPTVBPTkVOVF9TVUJUWVBFID0ge1xuICAgIHZpZGVvOiAndmlkZScsXG4gICAgYXVkaW86ICdzb3VuJyxcbiAgICBzdWJ0aXRsZTogJ3RleHQnLFxufTtcbmNvbnN0IFRSQUNLX1RZUEVfVE9fSEFORExFUl9OQU1FID0ge1xuICAgIHZpZGVvOiAnTWVkaWFidW5ueVZpZGVvSGFuZGxlcicsXG4gICAgYXVkaW86ICdNZWRpYWJ1bm55U291bmRIYW5kbGVyJyxcbiAgICBzdWJ0aXRsZTogJ01lZGlhYnVubnlUZXh0SGFuZGxlcicsXG59O1xuLyoqIEhhbmRsZXIgUmVmZXJlbmNlIEJveC4gKi9cbmV4cG9ydCBjb25zdCBoZGxyID0gKGhhc0NvbXBvbmVudFR5cGUsIGhhbmRsZXJUeXBlLCBuYW1lLCBtYW51ZmFjdHVyZXIgPSAnXFwwXFwwXFwwXFwwJykgPT4gZnVsbEJveCgnaGRscicsIDAsIDAsIFtcbiAgICBoYXNDb21wb25lbnRUeXBlID8gYXNjaWkoJ21obHInKSA6IHUzMigwKSwgLy8gQ29tcG9uZW50IHR5cGVcbiAgICBhc2NpaShoYW5kbGVyVHlwZSksIC8vIENvbXBvbmVudCBzdWJ0eXBlXG4gICAgYXNjaWkobWFudWZhY3R1cmVyKSwgLy8gQ29tcG9uZW50IG1hbnVmYWN0dXJlclxuICAgIHUzMigwKSwgLy8gQ29tcG9uZW50IGZsYWdzXG4gICAgdTMyKDApLCAvLyBDb21wb25lbnQgZmxhZ3MgbWFza1xuICAgIGFzY2lpKG5hbWUsIHRydWUpLCAvLyBDb21wb25lbnQgbmFtZVxuXSk7XG4vKipcbiAqIE1lZGlhIEluZm9ybWF0aW9uIEJveDogU3RvcmVzIGhhbmRsZXItc3BlY2lmaWMgaW5mb3JtYXRpb24gZm9yIGEgdHJhY2sncyBtZWRpYSBkYXRhLiBUaGUgbWVkaWEgaGFuZGxlciB1c2VzIHRoaXNcbiAqIGluZm9ybWF0aW9uIHRvIG1hcCBmcm9tIG1lZGlhIHRpbWUgdG8gbWVkaWEgZGF0YSBhbmQgdG8gcHJvY2VzcyB0aGUgbWVkaWEgZGF0YS5cbiAqL1xuZXhwb3J0IGNvbnN0IG1pbmYgPSAodHJhY2tEYXRhKSA9PiBib3goJ21pbmYnLCB1bmRlZmluZWQsIFtcbiAgICBUUkFDS19UWVBFX1RPX0hFQURFUl9CT1hbdHJhY2tEYXRhLnR5cGVdKCksXG4gICAgZGluZigpLFxuICAgIHN0YmwodHJhY2tEYXRhKSxcbl0pO1xuLyoqIFZpZGVvIE1lZGlhIEluZm9ybWF0aW9uIEhlYWRlciBCb3g6IERlZmluZXMgc3BlY2lmaWMgY29sb3IgYW5kIGdyYXBoaWNzIG1vZGUgaW5mb3JtYXRpb24uICovXG5leHBvcnQgY29uc3Qgdm1oZCA9ICgpID0+IGZ1bGxCb3goJ3ZtaGQnLCAwLCAxLCBbXG4gICAgdTE2KDApLCAvLyBHcmFwaGljcyBtb2RlXG4gICAgdTE2KDApLCAvLyBPcGNvbG9yIFJcbiAgICB1MTYoMCksIC8vIE9wY29sb3IgR1xuICAgIHUxNigwKSwgLy8gT3Bjb2xvciBCXG5dKTtcbi8qKiBTb3VuZCBNZWRpYSBJbmZvcm1hdGlvbiBIZWFkZXIgQm94OiBTdG9yZXMgdGhlIHNvdW5kIG1lZGlhJ3MgY29udHJvbCBpbmZvcm1hdGlvbiwgc3VjaCBhcyBiYWxhbmNlLiAqL1xuZXhwb3J0IGNvbnN0IHNtaGQgPSAoKSA9PiBmdWxsQm94KCdzbWhkJywgMCwgMCwgW1xuICAgIHUxNigwKSwgLy8gQmFsYW5jZVxuICAgIHUxNigwKSwgLy8gUmVzZXJ2ZWRcbl0pO1xuLyoqIE51bGwgTWVkaWEgSGVhZGVyIEJveC4gKi9cbmV4cG9ydCBjb25zdCBubWhkID0gKCkgPT4gZnVsbEJveCgnbm1oZCcsIDAsIDApO1xuY29uc3QgVFJBQ0tfVFlQRV9UT19IRUFERVJfQk9YID0ge1xuICAgIHZpZGVvOiB2bWhkLFxuICAgIGF1ZGlvOiBzbWhkLFxuICAgIHN1YnRpdGxlOiBubWhkLFxufTtcbi8qKlxuICogRGF0YSBJbmZvcm1hdGlvbiBCb3g6IENvbnRhaW5zIGluZm9ybWF0aW9uIHNwZWNpZnlpbmcgdGhlIGRhdGEgaGFuZGxlciBjb21wb25lbnQgdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlXG4gKiBtZWRpYSBkYXRhLiBUaGUgZGF0YSBoYW5kbGVyIGNvbXBvbmVudCB1c2VzIHRoZSBEYXRhIEluZm9ybWF0aW9uIEJveCB0byBpbnRlcnByZXQgdGhlIG1lZGlhJ3MgZGF0YS5cbiAqL1xuZXhwb3J0IGNvbnN0IGRpbmYgPSAoKSA9PiBib3goJ2RpbmYnLCB1bmRlZmluZWQsIFtcbiAgICBkcmVmKCksXG5dKTtcbi8qKlxuICogRGF0YSBSZWZlcmVuY2UgQm94OiBDb250YWlucyB0YWJ1bGFyIGRhdGEgdGhhdCBpbnN0cnVjdHMgdGhlIGRhdGEgaGFuZGxlciBjb21wb25lbnQgaG93IHRvIGFjY2VzcyB0aGUgbWVkaWEncyBkYXRhLlxuICovXG5leHBvcnQgY29uc3QgZHJlZiA9ICgpID0+IGZ1bGxCb3goJ2RyZWYnLCAwLCAwLCBbXG4gICAgdTMyKDEpLCAvLyBFbnRyeSBjb3VudFxuXSwgW1xuICAgIHVybCgpLFxuXSk7XG5leHBvcnQgY29uc3QgdXJsID0gKCkgPT4gZnVsbEJveCgndXJsICcsIDAsIDEpOyAvLyBTZWxmLXJlZmVyZW5jZSBmbGFnIGVuYWJsZWRcbi8qKlxuICogU2FtcGxlIFRhYmxlIEJveDogQ29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGNvbnZlcnRpbmcgZnJvbSBtZWRpYSB0aW1lIHRvIHNhbXBsZSBudW1iZXIgdG8gc2FtcGxlIGxvY2F0aW9uLiBUaGlzIGJveFxuICogYWxzbyBpbmRpY2F0ZXMgaG93IHRvIGludGVycHJldCB0aGUgc2FtcGxlIChmb3IgZXhhbXBsZSwgd2hldGhlciB0byBkZWNvbXByZXNzIHRoZSB2aWRlbyBkYXRhIGFuZCwgaWYgc28sIGhvdykuXG4gKi9cbmV4cG9ydCBjb25zdCBzdGJsID0gKHRyYWNrRGF0YSkgPT4ge1xuICAgIGNvbnN0IG5lZWRzQ3R0cyA9IHRyYWNrRGF0YS5jb21wb3NpdGlvblRpbWVPZmZzZXRUYWJsZS5sZW5ndGggPiAxXG4gICAgICAgIHx8IHRyYWNrRGF0YS5jb21wb3NpdGlvblRpbWVPZmZzZXRUYWJsZS5zb21lKHggPT4geC5zYW1wbGVDb21wb3NpdGlvblRpbWVPZmZzZXQgIT09IDApO1xuICAgIHJldHVybiBib3goJ3N0YmwnLCB1bmRlZmluZWQsIFtcbiAgICAgICAgc3RzZCh0cmFja0RhdGEpLFxuICAgICAgICBzdHRzKHRyYWNrRGF0YSksXG4gICAgICAgIG5lZWRzQ3R0cyA/IGN0dHModHJhY2tEYXRhKSA6IG51bGwsXG4gICAgICAgIG5lZWRzQ3R0cyA/IGNzbGcodHJhY2tEYXRhKSA6IG51bGwsXG4gICAgICAgIHN0c2ModHJhY2tEYXRhKSxcbiAgICAgICAgc3Rzeih0cmFja0RhdGEpLFxuICAgICAgICBzdGNvKHRyYWNrRGF0YSksXG4gICAgICAgIHN0c3ModHJhY2tEYXRhKSxcbiAgICBdKTtcbn07XG4vKipcbiAqIFNhbXBsZSBEZXNjcmlwdGlvbiBCb3g6IFN0b3JlcyBpbmZvcm1hdGlvbiB0aGF0IGFsbG93cyB5b3UgdG8gZGVjb2RlIHNhbXBsZXMgaW4gdGhlIG1lZGlhLiBUaGUgZGF0YSBzdG9yZWQgaW4gdGhlXG4gKiBzYW1wbGUgZGVzY3JpcHRpb24gdmFyaWVzLCBkZXBlbmRpbmcgb24gdGhlIG1lZGlhIHR5cGUuXG4gKi9cbmV4cG9ydCBjb25zdCBzdHNkID0gKHRyYWNrRGF0YSkgPT4ge1xuICAgIGxldCBzYW1wbGVEZXNjcmlwdGlvbjtcbiAgICBpZiAodHJhY2tEYXRhLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgc2FtcGxlRGVzY3JpcHRpb24gPSB2aWRlb1NhbXBsZURlc2NyaXB0aW9uKFZJREVPX0NPREVDX1RPX0JPWF9OQU1FW3RyYWNrRGF0YS50cmFjay5zb3VyY2UuX2NvZGVjXSwgdHJhY2tEYXRhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhY2tEYXRhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgY29uc3QgYm94TmFtZSA9IGF1ZGlvQ29kZWNUb0JveE5hbWUodHJhY2tEYXRhLnRyYWNrLnNvdXJjZS5fY29kZWMsIHRyYWNrRGF0YS5tdXhlci5pc1F1aWNrVGltZSk7XG4gICAgICAgIGFzc2VydChib3hOYW1lKTtcbiAgICAgICAgc2FtcGxlRGVzY3JpcHRpb24gPSBzb3VuZFNhbXBsZURlc2NyaXB0aW9uKGJveE5hbWUsIHRyYWNrRGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYWNrRGF0YS50eXBlID09PSAnc3VidGl0bGUnKSB7XG4gICAgICAgIHNhbXBsZURlc2NyaXB0aW9uID0gc3VidGl0bGVTYW1wbGVEZXNjcmlwdGlvbihTVUJUSVRMRV9DT0RFQ19UT19CT1hfTkFNRVt0cmFja0RhdGEudHJhY2suc291cmNlLl9jb2RlY10sIHRyYWNrRGF0YSk7XG4gICAgfVxuICAgIGFzc2VydChzYW1wbGVEZXNjcmlwdGlvbik7XG4gICAgcmV0dXJuIGZ1bGxCb3goJ3N0c2QnLCAwLCAwLCBbXG4gICAgICAgIHUzMigxKSwgLy8gRW50cnkgY291bnRcbiAgICBdLCBbXG4gICAgICAgIHNhbXBsZURlc2NyaXB0aW9uLFxuICAgIF0pO1xufTtcbi8qKiBWaWRlbyBTYW1wbGUgRGVzY3JpcHRpb24gQm94OiBDb250YWlucyBpbmZvcm1hdGlvbiB0aGF0IGRlZmluZXMgaG93IHRvIGludGVycHJldCB2aWRlbyBtZWRpYSBkYXRhLiAqL1xuZXhwb3J0IGNvbnN0IHZpZGVvU2FtcGxlRGVzY3JpcHRpb24gPSAoY29tcHJlc3Npb25UeXBlLCB0cmFja0RhdGEpID0+IGJveChjb21wcmVzc2lvblR5cGUsIFtcbiAgICBBcnJheSg2KS5maWxsKDApLCAvLyBSZXNlcnZlZFxuICAgIHUxNigxKSwgLy8gRGF0YSByZWZlcmVuY2UgaW5kZXhcbiAgICB1MTYoMCksIC8vIFByZS1kZWZpbmVkXG4gICAgdTE2KDApLCAvLyBSZXNlcnZlZFxuICAgIEFycmF5KDEyKS5maWxsKDApLCAvLyBQcmUtZGVmaW5lZFxuICAgIHUxNih0cmFja0RhdGEuaW5mby53aWR0aCksIC8vIFdpZHRoXG4gICAgdTE2KHRyYWNrRGF0YS5pbmZvLmhlaWdodCksIC8vIEhlaWdodFxuICAgIHUzMigweDAwNDgwMDAwKSwgLy8gSG9yaXpvbnRhbCByZXNvbHV0aW9uXG4gICAgdTMyKDB4MDA0ODAwMDApLCAvLyBWZXJ0aWNhbCByZXNvbHV0aW9uXG4gICAgdTMyKDApLCAvLyBSZXNlcnZlZFxuICAgIHUxNigxKSwgLy8gRnJhbWUgY291bnRcbiAgICBBcnJheSgzMikuZmlsbCgwKSwgLy8gQ29tcHJlc3NvciBuYW1lXG4gICAgdTE2KDB4MDAxOCksIC8vIERlcHRoXG4gICAgaTE2KDB4ZmZmZiksIC8vIFByZS1kZWZpbmVkXG5dLCBbXG4gICAgVklERU9fQ09ERUNfVE9fQ09ORklHVVJBVElPTl9CT1hbdHJhY2tEYXRhLnRyYWNrLnNvdXJjZS5fY29kZWNdKHRyYWNrRGF0YSksXG4gICAgY29sb3JTcGFjZUlzQ29tcGxldGUodHJhY2tEYXRhLmluZm8uZGVjb2RlckNvbmZpZy5jb2xvclNwYWNlKSA/IGNvbHIodHJhY2tEYXRhKSA6IG51bGwsXG5dKTtcbi8qKiBDb2xvdXIgSW5mb3JtYXRpb24gQm94OiBTcGVjaWZpZXMgdGhlIGNvbG9yIHNwYWNlIG9mIHRoZSB2aWRlby4gKi9cbmV4cG9ydCBjb25zdCBjb2xyID0gKHRyYWNrRGF0YSkgPT4gYm94KCdjb2xyJywgW1xuICAgIGFzY2lpKCduY2x4JyksIC8vIENvbG91ciB0eXBlXG4gICAgdTE2KENPTE9SX1BSSU1BUklFU19NQVBbdHJhY2tEYXRhLmluZm8uZGVjb2RlckNvbmZpZy5jb2xvclNwYWNlLnByaW1hcmllc10pLCAvLyBDb2xvdXIgcHJpbWFyaWVzXG4gICAgdTE2KFRSQU5TRkVSX0NIQVJBQ1RFUklTVElDU19NQVBbdHJhY2tEYXRhLmluZm8uZGVjb2RlckNvbmZpZy5jb2xvclNwYWNlLnRyYW5zZmVyXSksIC8vIFRyYW5zZmVyIGNoYXJhY3RlcmlzdGljc1xuICAgIHUxNihNQVRSSVhfQ09FRkZJQ0lFTlRTX01BUFt0cmFja0RhdGEuaW5mby5kZWNvZGVyQ29uZmlnLmNvbG9yU3BhY2UubWF0cml4XSksIC8vIE1hdHJpeCBjb2VmZmljaWVudHNcbiAgICB1OCgodHJhY2tEYXRhLmluZm8uZGVjb2RlckNvbmZpZy5jb2xvclNwYWNlLmZ1bGxSYW5nZSA/IDEgOiAwKSA8PCA3KSwgLy8gRnVsbCByYW5nZSBmbGFnXG5dKTtcbi8qKiBBVkMgQ29uZmlndXJhdGlvbiBCb3g6IFByb3ZpZGVzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIGRlY29kZXIuICovXG5leHBvcnQgY29uc3QgYXZjQyA9ICh0cmFja0RhdGEpID0+IHRyYWNrRGF0YS5pbmZvLmRlY29kZXJDb25maWcgJiYgYm94KCdhdmNDJywgW1xuICAgIC8vIEZvciBBVkMsIGRlc2NyaXB0aW9uIGlzIGFuIEFWQ0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkLCBzbyBub3RoaW5nIGVsc2UgdG8gZG8gaGVyZVxuICAgIC4uLnRvVWludDhBcnJheSh0cmFja0RhdGEuaW5mby5kZWNvZGVyQ29uZmlnLmRlc2NyaXB0aW9uKSxcbl0pO1xuLyoqIEhFVkMgQ29uZmlndXJhdGlvbiBCb3g6IFByb3ZpZGVzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIGRlY29kZXIuICovXG5leHBvcnQgY29uc3QgaHZjQyA9ICh0cmFja0RhdGEpID0+IHRyYWNrRGF0YS5pbmZvLmRlY29kZXJDb25maWcgJiYgYm94KCdodmNDJywgW1xuICAgIC8vIEZvciBIRVZDLCBkZXNjcmlwdGlvbiBpcyBhbiBIRVZDRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmQsIHNvIG5vdGhpbmcgZWxzZSB0byBkbyBoZXJlXG4gICAgLi4udG9VaW50OEFycmF5KHRyYWNrRGF0YS5pbmZvLmRlY29kZXJDb25maWcuZGVzY3JpcHRpb24pLFxuXSk7XG4vKiogVlAgQ29uZmlndXJhdGlvbiBCb3g6IFByb3ZpZGVzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIGRlY29kZXIuICovXG5leHBvcnQgY29uc3QgdnBjQyA9ICh0cmFja0RhdGEpID0+IHtcbiAgICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vd3d3LndlYm1wcm9qZWN0Lm9yZy92cDkvbXA0L1xuICAgIGlmICghdHJhY2tEYXRhLmluZm8uZGVjb2RlckNvbmZpZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlckNvbmZpZyA9IHRyYWNrRGF0YS5pbmZvLmRlY29kZXJDb25maWc7XG4gICAgY29uc3QgcGFydHMgPSBkZWNvZGVyQ29uZmlnLmNvZGVjLnNwbGl0KCcuJyk7IC8vIFdlIGNhbiBkZXJpdmUgdGhlIHJlcXVpcmVkIHZhbHVlcyBmcm9tIHRoZSBjb2RlYyBzdHJpbmdcbiAgICBjb25zdCBwcm9maWxlID0gTnVtYmVyKHBhcnRzWzFdKTtcbiAgICBjb25zdCBsZXZlbCA9IE51bWJlcihwYXJ0c1syXSk7XG4gICAgY29uc3QgYml0RGVwdGggPSBOdW1iZXIocGFydHNbM10pO1xuICAgIGNvbnN0IGNocm9tYVN1YnNhbXBsaW5nID0gcGFydHNbNF0gPyBOdW1iZXIocGFydHNbNF0pIDogMTsgLy8gNDoyOjAgY29sb2NhdGVkIHdpdGggbHVtYSAoMCwwKVxuICAgIGNvbnN0IHZpZGVvRnVsbFJhbmdlRmxhZyA9IHBhcnRzWzhdID8gTnVtYmVyKHBhcnRzWzhdKSA6IE51bWJlcihkZWNvZGVyQ29uZmlnLmNvbG9yU3BhY2U/LmZ1bGxSYW5nZSA/PyAwKTtcbiAgICBjb25zdCB0aGlyZEJ5dGUgPSAoYml0RGVwdGggPDwgNCkgKyAoY2hyb21hU3Vic2FtcGxpbmcgPDwgMSkgKyB2aWRlb0Z1bGxSYW5nZUZsYWc7XG4gICAgY29uc3QgY29sb3VyUHJpbWFyaWVzID0gcGFydHNbNV1cbiAgICAgICAgPyBOdW1iZXIocGFydHNbNV0pXG4gICAgICAgIDogZGVjb2RlckNvbmZpZy5jb2xvclNwYWNlPy5wcmltYXJpZXNcbiAgICAgICAgICAgID8gQ09MT1JfUFJJTUFSSUVTX01BUFtkZWNvZGVyQ29uZmlnLmNvbG9yU3BhY2UucHJpbWFyaWVzXVxuICAgICAgICAgICAgOiAyOyAvLyBEZWZhdWx0IHRvIHVuZGV0ZXJtaW5lZFxuICAgIGNvbnN0IHRyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzID0gcGFydHNbNl1cbiAgICAgICAgPyBOdW1iZXIocGFydHNbNl0pXG4gICAgICAgIDogZGVjb2RlckNvbmZpZy5jb2xvclNwYWNlPy50cmFuc2ZlclxuICAgICAgICAgICAgPyBUUkFOU0ZFUl9DSEFSQUNURVJJU1RJQ1NfTUFQW2RlY29kZXJDb25maWcuY29sb3JTcGFjZS50cmFuc2Zlcl1cbiAgICAgICAgICAgIDogMjtcbiAgICBjb25zdCBtYXRyaXhDb2VmZmljaWVudHMgPSBwYXJ0c1s3XVxuICAgICAgICA/IE51bWJlcihwYXJ0c1s3XSlcbiAgICAgICAgOiBkZWNvZGVyQ29uZmlnLmNvbG9yU3BhY2U/Lm1hdHJpeFxuICAgICAgICAgICAgPyBNQVRSSVhfQ09FRkZJQ0lFTlRTX01BUFtkZWNvZGVyQ29uZmlnLmNvbG9yU3BhY2UubWF0cml4XVxuICAgICAgICAgICAgOiAyO1xuICAgIHJldHVybiBmdWxsQm94KCd2cGNDJywgMSwgMCwgW1xuICAgICAgICB1OChwcm9maWxlKSwgLy8gUHJvZmlsZVxuICAgICAgICB1OChsZXZlbCksIC8vIExldmVsXG4gICAgICAgIHU4KHRoaXJkQnl0ZSksIC8vIEJpdCBkZXB0aCwgY2hyb21hIHN1YnNhbXBsaW5nLCBmdWxsIHJhbmdlXG4gICAgICAgIHU4KGNvbG91clByaW1hcmllcyksIC8vIENvbG91ciBwcmltYXJpZXNcbiAgICAgICAgdTgodHJhbnNmZXJDaGFyYWN0ZXJpc3RpY3MpLCAvLyBUcmFuc2ZlciBjaGFyYWN0ZXJpc3RpY3NcbiAgICAgICAgdTgobWF0cml4Q29lZmZpY2llbnRzKSwgLy8gTWF0cml4IGNvZWZmaWNpZW50c1xuICAgICAgICB1MTYoMCksIC8vIENvZGVjIGluaXRpYWxpemF0aW9uIGRhdGEgc2l6ZVxuICAgIF0pO1xufTtcbi8qKiBBVjEgQ29uZmlndXJhdGlvbiBCb3g6IFByb3ZpZGVzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIGRlY29kZXIuICovXG5leHBvcnQgY29uc3QgYXYxQyA9ICh0cmFja0RhdGEpID0+IHtcbiAgICByZXR1cm4gYm94KCdhdjFDJywgZ2VuZXJhdGVBdjFDb2RlY0NvbmZpZ3VyYXRpb25Gcm9tQ29kZWNTdHJpbmcodHJhY2tEYXRhLmluZm8uZGVjb2RlckNvbmZpZy5jb2RlYykpO1xufTtcbi8qKiBTb3VuZCBTYW1wbGUgRGVzY3JpcHRpb24gQm94OiBDb250YWlucyBpbmZvcm1hdGlvbiB0aGF0IGRlZmluZXMgaG93IHRvIGludGVycHJldCBzb3VuZCBtZWRpYSBkYXRhLiAqL1xuZXhwb3J0IGNvbnN0IHNvdW5kU2FtcGxlRGVzY3JpcHRpb24gPSAoY29tcHJlc3Npb25UeXBlLCB0cmFja0RhdGEpID0+IHtcbiAgICBsZXQgdmVyc2lvbiA9IDA7XG4gICAgbGV0IGNvbnRlbnRzO1xuICAgIGxldCBzYW1wbGVTaXplSW5CaXRzID0gMTY7XG4gICAgaWYgKFBDTV9BVURJT19DT0RFQ1MuaW5jbHVkZXModHJhY2tEYXRhLnRyYWNrLnNvdXJjZS5fY29kZWMpKSB7XG4gICAgICAgIGNvbnN0IGNvZGVjID0gdHJhY2tEYXRhLnRyYWNrLnNvdXJjZS5fY29kZWM7XG4gICAgICAgIGNvbnN0IHsgc2FtcGxlU2l6ZSB9ID0gcGFyc2VQY21Db2RlYyhjb2RlYyk7XG4gICAgICAgIHNhbXBsZVNpemVJbkJpdHMgPSA4ICogc2FtcGxlU2l6ZTtcbiAgICAgICAgaWYgKHNhbXBsZVNpemVJbkJpdHMgPiAxNikge1xuICAgICAgICAgICAgdmVyc2lvbiA9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgY29udGVudHMgPSBbXG4gICAgICAgICAgICBBcnJheSg2KS5maWxsKDApLCAvLyBSZXNlcnZlZFxuICAgICAgICAgICAgdTE2KDEpLCAvLyBEYXRhIHJlZmVyZW5jZSBpbmRleFxuICAgICAgICAgICAgdTE2KHZlcnNpb24pLCAvLyBWZXJzaW9uXG4gICAgICAgICAgICB1MTYoMCksIC8vIFJldmlzaW9uIGxldmVsXG4gICAgICAgICAgICB1MzIoMCksIC8vIFZlbmRvclxuICAgICAgICAgICAgdTE2KHRyYWNrRGF0YS5pbmZvLm51bWJlck9mQ2hhbm5lbHMpLCAvLyBOdW1iZXIgb2YgY2hhbm5lbHNcbiAgICAgICAgICAgIHUxNihzYW1wbGVTaXplSW5CaXRzKSwgLy8gU2FtcGxlIHNpemUgKGJpdHMpXG4gICAgICAgICAgICB1MTYoMCksIC8vIENvbXByZXNzaW9uIElEXG4gICAgICAgICAgICB1MTYoMCksIC8vIFBhY2tldCBzaXplXG4gICAgICAgICAgICB1MTYodHJhY2tEYXRhLmluZm8uc2FtcGxlUmF0ZSA8IDIgKiogMTYgPyB0cmFja0RhdGEuaW5mby5zYW1wbGVSYXRlIDogMCksIC8vIFNhbXBsZSByYXRlICh1cHBlcilcbiAgICAgICAgICAgIHUxNigwKSwgLy8gU2FtcGxlIHJhdGUgKGxvd2VyKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udGVudHMgPSBbXG4gICAgICAgICAgICBBcnJheSg2KS5maWxsKDApLCAvLyBSZXNlcnZlZFxuICAgICAgICAgICAgdTE2KDEpLCAvLyBEYXRhIHJlZmVyZW5jZSBpbmRleFxuICAgICAgICAgICAgdTE2KHZlcnNpb24pLCAvLyBWZXJzaW9uXG4gICAgICAgICAgICB1MTYoMCksIC8vIFJldmlzaW9uIGxldmVsXG4gICAgICAgICAgICB1MzIoMCksIC8vIFZlbmRvclxuICAgICAgICAgICAgdTE2KHRyYWNrRGF0YS5pbmZvLm51bWJlck9mQ2hhbm5lbHMpLCAvLyBOdW1iZXIgb2YgY2hhbm5lbHNcbiAgICAgICAgICAgIHUxNihNYXRoLm1pbihzYW1wbGVTaXplSW5CaXRzLCAxNikpLCAvLyBTYW1wbGUgc2l6ZSAoYml0cylcbiAgICAgICAgICAgIHUxNigwKSwgLy8gQ29tcHJlc3Npb24gSURcbiAgICAgICAgICAgIHUxNigwKSwgLy8gUGFja2V0IHNpemVcbiAgICAgICAgICAgIHUxNih0cmFja0RhdGEuaW5mby5zYW1wbGVSYXRlIDwgMiAqKiAxNiA/IHRyYWNrRGF0YS5pbmZvLnNhbXBsZVJhdGUgOiAwKSwgLy8gU2FtcGxlIHJhdGUgKHVwcGVyKVxuICAgICAgICAgICAgdTE2KDApLCAvLyBTYW1wbGUgcmF0ZSAobG93ZXIpXG4gICAgICAgICAgICB1MzIoMSksIC8vIFNhbXBsZXMgcGVyIHBhY2tldCAobXVzdCBiZSAxIGZvciB1bmNvbXByZXNzZWQgZm9ybWF0cylcbiAgICAgICAgICAgIHUzMihzYW1wbGVTaXplSW5CaXRzIC8gOCksIC8vIEJ5dGVzIHBlciBwYWNrZXRcbiAgICAgICAgICAgIHUzMih0cmFja0RhdGEuaW5mby5udW1iZXJPZkNoYW5uZWxzICogc2FtcGxlU2l6ZUluQml0cyAvIDgpLCAvLyBCeXRlcyBwZXIgZnJhbWVcbiAgICAgICAgICAgIHUzMigyKSwgLy8gQnl0ZXMgcGVyIHNhbXBsZSAoY29uc3RhbnQgaW4gRkZtcGVnKVxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gYm94KGNvbXByZXNzaW9uVHlwZSwgY29udGVudHMsIFtcbiAgICAgICAgYXVkaW9Db2RlY1RvQ29uZmlndXJhdGlvbkJveCh0cmFja0RhdGEudHJhY2suc291cmNlLl9jb2RlYywgdHJhY2tEYXRhLm11eGVyLmlzUXVpY2tUaW1lKT8uKHRyYWNrRGF0YSkgPz8gbnVsbCxcbiAgICBdKTtcbn07XG4vKiogTVBFRy00IEVsZW1lbnRhcnkgU3RyZWFtIERlc2NyaXB0b3IgQm94LiAqL1xuZXhwb3J0IGNvbnN0IGVzZHMgPSAodHJhY2tEYXRhKSA9PiB7XG4gICAgLy8gV2UgYnVpbGQgdXAgdGhlIGJ5dGVzIGluIGEgbGF5ZXJlZCB3YXkgd2hpY2ggcmVmbGVjdHMgdGhlIG5lc3RlZCBzdHJ1Y3R1cmVcbiAgICBsZXQgb2JqZWN0VHlwZUluZGljYXRpb247XG4gICAgc3dpdGNoICh0cmFja0RhdGEudHJhY2suc291cmNlLl9jb2RlYykge1xuICAgICAgICBjYXNlICdhYWMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9iamVjdFR5cGVJbmRpY2F0aW9uID0gMHg0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtcDMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9iamVjdFR5cGVJbmRpY2F0aW9uID0gMHg2YjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd2b3JiaXMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9iamVjdFR5cGVJbmRpY2F0aW9uID0gMHhkZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBhdWRpbyBjb2RlYzogJHt0cmFja0RhdGEudHJhY2suc291cmNlLl9jb2RlY31gKTtcbiAgICB9XG4gICAgbGV0IGJ5dGVzID0gW1xuICAgICAgICAuLi51OChvYmplY3RUeXBlSW5kaWNhdGlvbiksIC8vIE9iamVjdCB0eXBlIGluZGljYXRpb25cbiAgICAgICAgLi4udTgoMHgxNSksIC8vIHN0cmVhbSB0eXBlKDZiaXRzKT01IGF1ZGlvLCBmbGFncygyYml0cyk9MVxuICAgICAgICAuLi51MjQoMCksIC8vIDI0Yml0IGJ1ZmZlciBzaXplXG4gICAgICAgIC4uLnUzMigwKSwgLy8gbWF4IGJpdHJhdGVcbiAgICAgICAgLi4udTMyKDApLCAvLyBhdmcgYml0cmF0ZVxuICAgIF07XG4gICAgaWYgKHRyYWNrRGF0YS5pbmZvLmRlY29kZXJDb25maWcuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB0b1VpbnQ4QXJyYXkodHJhY2tEYXRhLmluZm8uZGVjb2RlckNvbmZpZy5kZXNjcmlwdGlvbik7XG4gICAgICAgIC8vIEFkZCB0aGUgZGVjb2RlciBkZXNjcmlwdGlvbiB0byB0aGUgZW5kXG4gICAgICAgIGJ5dGVzID0gW1xuICAgICAgICAgICAgLi4uYnl0ZXMsXG4gICAgICAgICAgICAuLi51OCgweDA1KSwgLy8gVEFHKDUpID0gRGVjb2RlclNwZWNpZmljSW5mb1xuICAgICAgICAgICAgLi4udmFyaWFibGVVbnNpZ25lZEludChkZXNjcmlwdGlvbi5ieXRlTGVuZ3RoKSxcbiAgICAgICAgICAgIC4uLmRlc2NyaXB0aW9uLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBieXRlcyA9IFtcbiAgICAgICAgLi4udTE2KDEpLCAvLyBFU19JRCA9IDFcbiAgICAgICAgLi4udTgoMHgwMCksIC8vIGZsYWdzIGV0YyA9IDBcbiAgICAgICAgLi4udTgoMHgwNCksIC8vIFRBRyg0KSA9IEVTIERlc2NyaXB0b3JcbiAgICAgICAgLi4udmFyaWFibGVVbnNpZ25lZEludChieXRlcy5sZW5ndGgpLFxuICAgICAgICAuLi5ieXRlcyxcbiAgICAgICAgLi4udTgoMHgwNiksIC8vIFRBRyg2KVxuICAgICAgICAuLi51OCgweDAxKSwgLy8gbGVuZ3RoXG4gICAgICAgIC4uLnU4KDB4MDIpLCAvLyBkYXRhXG4gICAgXTtcbiAgICBieXRlcyA9IFtcbiAgICAgICAgLi4udTgoMHgwMyksIC8vIFRBRygzKSA9IE9iamVjdCBEZXNjcmlwdG9yXG4gICAgICAgIC4uLnZhcmlhYmxlVW5zaWduZWRJbnQoYnl0ZXMubGVuZ3RoKSxcbiAgICAgICAgLi4uYnl0ZXMsXG4gICAgXTtcbiAgICByZXR1cm4gZnVsbEJveCgnZXNkcycsIDAsIDAsIGJ5dGVzKTtcbn07XG5leHBvcnQgY29uc3Qgd2F2ZSA9ICh0cmFja0RhdGEpID0+IHtcbiAgICByZXR1cm4gYm94KCd3YXZlJywgdW5kZWZpbmVkLCBbXG4gICAgICAgIGZybWEodHJhY2tEYXRhKSxcbiAgICAgICAgZW5kYSh0cmFja0RhdGEpLFxuICAgICAgICBib3goJ1xceDAwXFx4MDBcXHgwMFxceDAwJyksIC8vIE5VTEwgdGFnIGF0IHRoZSBlbmRcbiAgICBdKTtcbn07XG5leHBvcnQgY29uc3QgZnJtYSA9ICh0cmFja0RhdGEpID0+IHtcbiAgICByZXR1cm4gYm94KCdmcm1hJywgW1xuICAgICAgICBhc2NpaShhdWRpb0NvZGVjVG9Cb3hOYW1lKHRyYWNrRGF0YS50cmFjay5zb3VyY2UuX2NvZGVjLCB0cmFja0RhdGEubXV4ZXIuaXNRdWlja1RpbWUpKSxcbiAgICBdKTtcbn07XG4vLyBUaGlzIGJveCBzcGVjaWZpZXMgUENNIGVuZGlhbm5lc3NcbmV4cG9ydCBjb25zdCBlbmRhID0gKHRyYWNrRGF0YSkgPT4ge1xuICAgIGNvbnN0IHsgbGl0dGxlRW5kaWFuIH0gPSBwYXJzZVBjbUNvZGVjKHRyYWNrRGF0YS50cmFjay5zb3VyY2UuX2NvZGVjKTtcbiAgICByZXR1cm4gYm94KCdlbmRhJywgW1xuICAgICAgICB1MTYoK2xpdHRsZUVuZGlhbiksXG4gICAgXSk7XG59O1xuLyoqIE9wdXMgU3BlY2lmaWMgQm94LiAqL1xuZXhwb3J0IGNvbnN0IGRPcHMgPSAodHJhY2tEYXRhKSA9PiB7XG4gICAgbGV0IG91dHB1dENoYW5uZWxDb3VudCA9IHRyYWNrRGF0YS5pbmZvLm51bWJlck9mQ2hhbm5lbHM7XG4gICAgLy8gRGVmYXVsdCBQcmVTa2lwLCBzaG91bGQgYmUgYXQgbGVhc3QgODAgbWlsbGlzZWNvbmRzIHdvcnRoIG9mIHBsYXliYWNrLCBtZWFzdXJlZCBpbiA0ODAwMCBIeiBzYW1wbGVzXG4gICAgbGV0IHByZVNraXAgPSAzODQwO1xuICAgIGxldCBpbnB1dFNhbXBsZVJhdGUgPSB0cmFja0RhdGEuaW5mby5zYW1wbGVSYXRlO1xuICAgIGxldCBvdXRwdXRHYWluID0gMDtcbiAgICBsZXQgY2hhbm5lbE1hcHBpbmdGYW1pbHkgPSAwO1xuICAgIGxldCBjaGFubmVsTWFwcGluZ1RhYmxlID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgLy8gUmVhZCBwcmVza2lwIGFuZCBmcm9tIGNvZGVjIHByaXZhdGUgZGF0YSBmcm9tIHRoZSBlbmNvZGVyXG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzc4NDUjc2VjdGlvbi01XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB0cmFja0RhdGEuaW5mby5kZWNvZGVyQ29uZmlnPy5kZXNjcmlwdGlvbjtcbiAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgYXNzZXJ0KGRlc2NyaXB0aW9uLmJ5dGVMZW5ndGggPj0gMTgpO1xuICAgICAgICBjb25zdCBieXRlcyA9IHRvVWludDhBcnJheShkZXNjcmlwdGlvbik7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHBhcnNlT3B1c0lkZW50aWZpY2F0aW9uSGVhZGVyKGJ5dGVzKTtcbiAgICAgICAgb3V0cHV0Q2hhbm5lbENvdW50ID0gaGVhZGVyLm91dHB1dENoYW5uZWxDb3VudDtcbiAgICAgICAgcHJlU2tpcCA9IGhlYWRlci5wcmVTa2lwO1xuICAgICAgICBpbnB1dFNhbXBsZVJhdGUgPSBoZWFkZXIuaW5wdXRTYW1wbGVSYXRlO1xuICAgICAgICBvdXRwdXRHYWluID0gaGVhZGVyLm91dHB1dEdhaW47XG4gICAgICAgIGNoYW5uZWxNYXBwaW5nRmFtaWx5ID0gaGVhZGVyLmNoYW5uZWxNYXBwaW5nRmFtaWx5O1xuICAgICAgICBpZiAoaGVhZGVyLmNoYW5uZWxNYXBwaW5nVGFibGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWxNYXBwaW5nVGFibGUgPSBoZWFkZXIuY2hhbm5lbE1hcHBpbmdUYWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBodHRwczovL3d3dy5vcHVzLWNvZGVjLm9yZy9kb2NzL29wdXNfaW5faXNvYm1mZi5odG1sXG4gICAgcmV0dXJuIGJveCgnZE9wcycsIFtcbiAgICAgICAgdTgoMCksIC8vIFZlcnNpb25cbiAgICAgICAgdTgob3V0cHV0Q2hhbm5lbENvdW50KSwgLy8gT3V0cHV0Q2hhbm5lbENvdW50XG4gICAgICAgIHUxNihwcmVTa2lwKSwgLy8gUHJlU2tpcFxuICAgICAgICB1MzIoaW5wdXRTYW1wbGVSYXRlKSwgLy8gSW5wdXRTYW1wbGVSYXRlXG4gICAgICAgIGkxNihvdXRwdXRHYWluKSwgLy8gT3V0cHV0R2FpblxuICAgICAgICB1OChjaGFubmVsTWFwcGluZ0ZhbWlseSksIC8vIENoYW5uZWxNYXBwaW5nRmFtaWx5XG4gICAgICAgIC4uLmNoYW5uZWxNYXBwaW5nVGFibGUsXG4gICAgXSk7XG59O1xuLyoqIEZMQUMgc3BlY2lmaWMgYm94LiAqL1xuZXhwb3J0IGNvbnN0IGRmTGEgPSAodHJhY2tEYXRhKSA9PiB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB0cmFja0RhdGEuaW5mby5kZWNvZGVyQ29uZmlnPy5kZXNjcmlwdGlvbjtcbiAgICBhc3NlcnQoZGVzY3JpcHRpb24pO1xuICAgIGNvbnN0IGJ5dGVzID0gdG9VaW50OEFycmF5KGRlc2NyaXB0aW9uKTtcbiAgICByZXR1cm4gZnVsbEJveCgnZGZMYScsIDAsIDAsIFtcbiAgICAgICAgLi4uYnl0ZXMuc3ViYXJyYXkoNCksXG4gICAgXSk7XG59O1xuLyoqIFBDTSBDb25maWd1cmF0aW9uIEJveCwgSVNPL0lFQyAyMzAwMy01LiAqL1xuY29uc3QgcGNtQyA9ICh0cmFja0RhdGEpID0+IHtcbiAgICBjb25zdCB7IGxpdHRsZUVuZGlhbiwgc2FtcGxlU2l6ZSB9ID0gcGFyc2VQY21Db2RlYyh0cmFja0RhdGEudHJhY2suc291cmNlLl9jb2RlYyk7XG4gICAgY29uc3QgZm9ybWF0RmxhZ3MgPSArbGl0dGxlRW5kaWFuO1xuICAgIHJldHVybiBmdWxsQm94KCdwY21DJywgMCwgMCwgW1xuICAgICAgICB1OChmb3JtYXRGbGFncyksXG4gICAgICAgIHU4KDggKiBzYW1wbGVTaXplKSxcbiAgICBdKTtcbn07XG5leHBvcnQgY29uc3Qgc3VidGl0bGVTYW1wbGVEZXNjcmlwdGlvbiA9IChjb21wcmVzc2lvblR5cGUsIHRyYWNrRGF0YSkgPT4gYm94KGNvbXByZXNzaW9uVHlwZSwgW1xuICAgIEFycmF5KDYpLmZpbGwoMCksIC8vIFJlc2VydmVkXG4gICAgdTE2KDEpLCAvLyBEYXRhIHJlZmVyZW5jZSBpbmRleFxuXSwgW1xuICAgIFNVQlRJVExFX0NPREVDX1RPX0NPTkZJR1VSQVRJT05fQk9YW3RyYWNrRGF0YS50cmFjay5zb3VyY2UuX2NvZGVjXSh0cmFja0RhdGEpLFxuXSk7XG5leHBvcnQgY29uc3QgdnR0QyA9ICh0cmFja0RhdGEpID0+IGJveCgndnR0QycsIFtcbiAgICAuLi50ZXh0RW5jb2Rlci5lbmNvZGUodHJhY2tEYXRhLmluZm8uY29uZmlnLmRlc2NyaXB0aW9uKSxcbl0pO1xuZXhwb3J0IGNvbnN0IHR4dEMgPSAodGV4dENvbmZpZykgPT4gZnVsbEJveCgndHh0QycsIDAsIDAsIFtcbiAgICAuLi50ZXh0Q29uZmlnLCAwLCAvLyBUZXh0IGNvbmZpZyAobnVsbC10ZXJtaW5hdGVkKVxuXSk7XG4vKipcbiAqIFRpbWUtVG8tU2FtcGxlIEJveDogU3RvcmVzIGR1cmF0aW9uIGluZm9ybWF0aW9uIGZvciBhIG1lZGlhJ3Mgc2FtcGxlcywgcHJvdmlkaW5nIGEgbWFwcGluZyBmcm9tIGEgdGltZSBpbiBhIG1lZGlhXG4gKiB0byB0aGUgY29ycmVzcG9uZGluZyBkYXRhIHNhbXBsZS4gVGhlIHRhYmxlIGlzIGNvbXBhY3QsIG1lYW5pbmcgdGhhdCBjb25zZWN1dGl2ZSBzYW1wbGVzIHdpdGggdGhlIHNhbWUgdGltZSBkZWx0YVxuICogd2lsbCBiZSBncm91cGVkLlxuICovXG5leHBvcnQgY29uc3Qgc3R0cyA9ICh0cmFja0RhdGEpID0+IHtcbiAgICByZXR1cm4gZnVsbEJveCgnc3R0cycsIDAsIDAsIFtcbiAgICAgICAgdTMyKHRyYWNrRGF0YS50aW1lVG9TYW1wbGVUYWJsZS5sZW5ndGgpLCAvLyBOdW1iZXIgb2YgZW50cmllc1xuICAgICAgICB0cmFja0RhdGEudGltZVRvU2FtcGxlVGFibGUubWFwKHggPT4gW1xuICAgICAgICAgICAgdTMyKHguc2FtcGxlQ291bnQpLCAvLyBTYW1wbGUgY291bnRcbiAgICAgICAgICAgIHUzMih4LnNhbXBsZURlbHRhKSwgLy8gU2FtcGxlIGR1cmF0aW9uXG4gICAgICAgIF0pLFxuICAgIF0pO1xufTtcbi8qKiBTeW5jIFNhbXBsZSBCb3g6IElkZW50aWZpZXMgdGhlIGtleSBmcmFtZXMgaW4gdGhlIG1lZGlhLCBtYXJraW5nIHRoZSByYW5kb20gYWNjZXNzIHBvaW50cyB3aXRoaW4gYSBzdHJlYW0uICovXG5leHBvcnQgY29uc3Qgc3RzcyA9ICh0cmFja0RhdGEpID0+IHtcbiAgICBpZiAodHJhY2tEYXRhLnNhbXBsZXMuZXZlcnkoeCA9PiB4LnR5cGUgPT09ICdrZXknKSlcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIE5vIHN0c3MgYm94IC0+IGV2ZXJ5IGZyYW1lIGlzIGEga2V5IGZyYW1lXG4gICAgY29uc3Qga2V5U2FtcGxlcyA9IFsuLi50cmFja0RhdGEuc2FtcGxlcy5lbnRyaWVzKCldLmZpbHRlcigoWywgc2FtcGxlXSkgPT4gc2FtcGxlLnR5cGUgPT09ICdrZXknKTtcbiAgICByZXR1cm4gZnVsbEJveCgnc3RzcycsIDAsIDAsIFtcbiAgICAgICAgdTMyKGtleVNhbXBsZXMubGVuZ3RoKSwgLy8gTnVtYmVyIG9mIGVudHJpZXNcbiAgICAgICAga2V5U2FtcGxlcy5tYXAoKFtpbmRleF0pID0+IHUzMihpbmRleCArIDEpKSwgLy8gU3luYyBzYW1wbGUgdGFibGVcbiAgICBdKTtcbn07XG4vKipcbiAqIFNhbXBsZS1Uby1DaHVuayBCb3g6IEFzIHNhbXBsZXMgYXJlIGFkZGVkIHRvIGEgbWVkaWEsIHRoZXkgYXJlIGNvbGxlY3RlZCBpbnRvIGNodW5rcyB0aGF0IGFsbG93IG9wdGltaXplZCBkYXRhXG4gKiBhY2Nlc3MuIEEgY2h1bmsgY29udGFpbnMgb25lIG9yIG1vcmUgc2FtcGxlcy4gQ2h1bmtzIGluIGEgbWVkaWEgbWF5IGhhdmUgZGlmZmVyZW50IHNpemVzLCBhbmQgdGhlIHNhbXBsZXMgd2l0aGluIGFcbiAqIGNodW5rIG1heSBoYXZlIGRpZmZlcmVudCBzaXplcy4gVGhlIFNhbXBsZS1Uby1DaHVuayBCb3ggc3RvcmVzIGNodW5rIGluZm9ybWF0aW9uIGZvciB0aGUgc2FtcGxlcyBpbiBhIG1lZGlhLCBzdG9yZWRcbiAqIGluIGEgY29tcGFjdGx5LWNvZGVkIGZhc2hpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBzdHNjID0gKHRyYWNrRGF0YSkgPT4ge1xuICAgIHJldHVybiBmdWxsQm94KCdzdHNjJywgMCwgMCwgW1xuICAgICAgICB1MzIodHJhY2tEYXRhLmNvbXBhY3RseUNvZGVkQ2h1bmtUYWJsZS5sZW5ndGgpLCAvLyBOdW1iZXIgb2YgZW50cmllc1xuICAgICAgICB0cmFja0RhdGEuY29tcGFjdGx5Q29kZWRDaHVua1RhYmxlLm1hcCh4ID0+IFtcbiAgICAgICAgICAgIHUzMih4LmZpcnN0Q2h1bmspLCAvLyBGaXJzdCBjaHVua1xuICAgICAgICAgICAgdTMyKHguc2FtcGxlc1BlckNodW5rKSwgLy8gU2FtcGxlcyBwZXIgY2h1bmtcbiAgICAgICAgICAgIHUzMigxKSwgLy8gU2FtcGxlIGRlc2NyaXB0aW9uIGluZGV4XG4gICAgICAgIF0pLFxuICAgIF0pO1xufTtcbi8qKiBTYW1wbGUgU2l6ZSBCb3g6IFNwZWNpZmllcyB0aGUgYnl0ZSBzaXplIG9mIGVhY2ggc2FtcGxlIGluIHRoZSBtZWRpYS4gKi9cbmV4cG9ydCBjb25zdCBzdHN6ID0gKHRyYWNrRGF0YSkgPT4ge1xuICAgIGlmICh0cmFja0RhdGEudHlwZSA9PT0gJ2F1ZGlvJyAmJiB0cmFja0RhdGEuaW5mby5yZXF1aXJlc1BjbVRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgc2FtcGxlU2l6ZSB9ID0gcGFyc2VQY21Db2RlYyh0cmFja0RhdGEudHJhY2suc291cmNlLl9jb2RlYyk7XG4gICAgICAgIC8vIFdpdGggUENNLCBldmVyeSBzYW1wbGUgaGFzIHRoZSBzYW1lIHNpemVcbiAgICAgICAgcmV0dXJuIGZ1bGxCb3goJ3N0c3onLCAwLCAwLCBbXG4gICAgICAgICAgICB1MzIoc2FtcGxlU2l6ZSAqIHRyYWNrRGF0YS5pbmZvLm51bWJlck9mQ2hhbm5lbHMpLCAvLyBTYW1wbGUgc2l6ZVxuICAgICAgICAgICAgdTMyKHRyYWNrRGF0YS5zYW1wbGVzLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MgKyBpbnRvVGltZXNjYWxlKHguZHVyYXRpb24sIHRyYWNrRGF0YS50aW1lc2NhbGUpLCAwKSksXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gZnVsbEJveCgnc3RzeicsIDAsIDAsIFtcbiAgICAgICAgdTMyKDApLCAvLyBTYW1wbGUgc2l6ZSAoMCBtZWFucyBub24tY29uc3RhbnQgc2l6ZSlcbiAgICAgICAgdTMyKHRyYWNrRGF0YS5zYW1wbGVzLmxlbmd0aCksIC8vIE51bWJlciBvZiBlbnRyaWVzXG4gICAgICAgIHRyYWNrRGF0YS5zYW1wbGVzLm1hcCh4ID0+IHUzMih4LnNpemUpKSwgLy8gU2FtcGxlIHNpemUgdGFibGVcbiAgICBdKTtcbn07XG4vKiogQ2h1bmsgT2Zmc2V0IEJveDogSWRlbnRpZmllcyB0aGUgbG9jYXRpb24gb2YgZWFjaCBjaHVuayBvZiBkYXRhIGluIHRoZSBtZWRpYSdzIGRhdGEgc3RyZWFtLCByZWxhdGl2ZSB0byB0aGUgZmlsZS4gKi9cbmV4cG9ydCBjb25zdCBzdGNvID0gKHRyYWNrRGF0YSkgPT4ge1xuICAgIGlmICh0cmFja0RhdGEuZmluYWxpemVkQ2h1bmtzLmxlbmd0aCA+IDAgJiYgbGFzdCh0cmFja0RhdGEuZmluYWxpemVkQ2h1bmtzKS5vZmZzZXQgPj0gMiAqKiAzMikge1xuICAgICAgICAvLyBJZiB0aGUgZmlsZSBpcyBsYXJnZSwgdXNlIHRoZSBjbzY0IGJveFxuICAgICAgICByZXR1cm4gZnVsbEJveCgnY282NCcsIDAsIDAsIFtcbiAgICAgICAgICAgIHUzMih0cmFja0RhdGEuZmluYWxpemVkQ2h1bmtzLmxlbmd0aCksIC8vIE51bWJlciBvZiBlbnRyaWVzXG4gICAgICAgICAgICB0cmFja0RhdGEuZmluYWxpemVkQ2h1bmtzLm1hcCh4ID0+IHU2NCh4Lm9mZnNldCkpLCAvLyBDaHVuayBvZmZzZXQgdGFibGVcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiBmdWxsQm94KCdzdGNvJywgMCwgMCwgW1xuICAgICAgICB1MzIodHJhY2tEYXRhLmZpbmFsaXplZENodW5rcy5sZW5ndGgpLCAvLyBOdW1iZXIgb2YgZW50cmllc1xuICAgICAgICB0cmFja0RhdGEuZmluYWxpemVkQ2h1bmtzLm1hcCh4ID0+IHUzMih4Lm9mZnNldCkpLCAvLyBDaHVuayBvZmZzZXQgdGFibGVcbiAgICBdKTtcbn07XG4vKipcbiAqIENvbXBvc2l0aW9uIFRpbWUgdG8gU2FtcGxlIEJveDogU3RvcmVzIGNvbXBvc2l0aW9uIHRpbWUgb2Zmc2V0IGluZm9ybWF0aW9uIChQVFMtRFRTKSBmb3IgYVxuICogbWVkaWEncyBzYW1wbGVzLiBUaGUgdGFibGUgaXMgY29tcGFjdCwgbWVhbmluZyB0aGF0IGNvbnNlY3V0aXZlIHNhbXBsZXMgd2l0aCB0aGUgc2FtZSB0aW1lXG4gKiBjb21wb3NpdGlvbiB0aW1lIG9mZnNldCB3aWxsIGJlIGdyb3VwZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBjdHRzID0gKHRyYWNrRGF0YSkgPT4ge1xuICAgIHJldHVybiBmdWxsQm94KCdjdHRzJywgMSwgMCwgW1xuICAgICAgICB1MzIodHJhY2tEYXRhLmNvbXBvc2l0aW9uVGltZU9mZnNldFRhYmxlLmxlbmd0aCksIC8vIE51bWJlciBvZiBlbnRyaWVzXG4gICAgICAgIHRyYWNrRGF0YS5jb21wb3NpdGlvblRpbWVPZmZzZXRUYWJsZS5tYXAoeCA9PiBbXG4gICAgICAgICAgICB1MzIoeC5zYW1wbGVDb3VudCksIC8vIFNhbXBsZSBjb3VudFxuICAgICAgICAgICAgaTMyKHguc2FtcGxlQ29tcG9zaXRpb25UaW1lT2Zmc2V0KSwgLy8gU2FtcGxlIG9mZnNldFxuICAgICAgICBdKSxcbiAgICBdKTtcbn07XG4vKipcbiAqIENvbXBvc2l0aW9uIHRvIERlY29kZSBCb3g6IFN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY29tcG9zaXRpb24gYW5kIGRpc3BsYXkgdGltZXMgb2YgdGhlIG1lZGlhIHNhbXBsZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBjc2xnID0gKHRyYWNrRGF0YSkgPT4ge1xuICAgIGxldCBsZWFzdERlY29kZVRvRGlzcGxheURlbHRhID0gSW5maW5pdHk7XG4gICAgbGV0IGdyZWF0ZXN0RGVjb2RlVG9EaXNwbGF5RGVsdGEgPSAtSW5maW5pdHk7XG4gICAgbGV0IGNvbXBvc2l0aW9uU3RhcnRUaW1lID0gSW5maW5pdHk7XG4gICAgbGV0IGNvbXBvc2l0aW9uRW5kVGltZSA9IC1JbmZpbml0eTtcbiAgICBhc3NlcnQodHJhY2tEYXRhLmNvbXBvc2l0aW9uVGltZU9mZnNldFRhYmxlLmxlbmd0aCA+IDApO1xuICAgIGFzc2VydCh0cmFja0RhdGEuc2FtcGxlcy5sZW5ndGggPiAwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrRGF0YS5jb21wb3NpdGlvblRpbWVPZmZzZXRUYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRyYWNrRGF0YS5jb21wb3NpdGlvblRpbWVPZmZzZXRUYWJsZVtpXTtcbiAgICAgICAgbGVhc3REZWNvZGVUb0Rpc3BsYXlEZWx0YSA9IE1hdGgubWluKGxlYXN0RGVjb2RlVG9EaXNwbGF5RGVsdGEsIGVudHJ5LnNhbXBsZUNvbXBvc2l0aW9uVGltZU9mZnNldCk7XG4gICAgICAgIGdyZWF0ZXN0RGVjb2RlVG9EaXNwbGF5RGVsdGEgPSBNYXRoLm1heChncmVhdGVzdERlY29kZVRvRGlzcGxheURlbHRhLCBlbnRyeS5zYW1wbGVDb21wb3NpdGlvblRpbWVPZmZzZXQpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrRGF0YS5zYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNhbXBsZSA9IHRyYWNrRGF0YS5zYW1wbGVzW2ldO1xuICAgICAgICBjb21wb3NpdGlvblN0YXJ0VGltZSA9IE1hdGgubWluKGNvbXBvc2l0aW9uU3RhcnRUaW1lLCBpbnRvVGltZXNjYWxlKHNhbXBsZS50aW1lc3RhbXAsIHRyYWNrRGF0YS50aW1lc2NhbGUpKTtcbiAgICAgICAgY29tcG9zaXRpb25FbmRUaW1lID0gTWF0aC5tYXgoY29tcG9zaXRpb25FbmRUaW1lLCBpbnRvVGltZXNjYWxlKHNhbXBsZS50aW1lc3RhbXAgKyBzYW1wbGUuZHVyYXRpb24sIHRyYWNrRGF0YS50aW1lc2NhbGUpKTtcbiAgICB9XG4gICAgY29uc3QgY29tcG9zaXRpb25Ub0R0c1NoaWZ0ID0gTWF0aC5tYXgoLWxlYXN0RGVjb2RlVG9EaXNwbGF5RGVsdGEsIDApO1xuICAgIGlmIChjb21wb3NpdGlvbkVuZFRpbWUgPj0gMiAqKiAzMSkge1xuICAgICAgICAvLyBGb3IgdmVyeSBsYXJnZSBmaWxlcywgdGhlIGNvbXBvc2l0aW9uIGVuZCB0aW1lIGNhbid0IGJlIHJlcHJlc2VudGVkIGluIGkzMiwgc28gbGV0J3MganVzdCBzY3JhcCB0aGUgYm94IGluXG4gICAgICAgIC8vIHRoYXQgY2FzZS4gUXVpY2tUaW1lIGZhaWxzIHRvIHJlYWQgdGhlIGZpbGUgaWYgdGhlcmUncyBhIGNzbGcgYm94IHdpdGggdmVyc2lvbiAxLCBzbyB0aGF0J3Mgc2FkbHkgbm90IGFuXG4gICAgICAgIC8vIG9wdGlvbi5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmdWxsQm94KCdjc2xnJywgMCwgMCwgW1xuICAgICAgICBpMzIoY29tcG9zaXRpb25Ub0R0c1NoaWZ0KSwgLy8gQ29tcG9zaXRpb24gdG8gRFRTIHNoaWZ0XG4gICAgICAgIGkzMihsZWFzdERlY29kZVRvRGlzcGxheURlbHRhKSwgLy8gTGVhc3QgZGVjb2RlIHRvIGRpc3BsYXkgZGVsdGFcbiAgICAgICAgaTMyKGdyZWF0ZXN0RGVjb2RlVG9EaXNwbGF5RGVsdGEpLCAvLyBHcmVhdGVzdCBkZWNvZGUgdG8gZGlzcGxheSBkZWx0YVxuICAgICAgICBpMzIoY29tcG9zaXRpb25TdGFydFRpbWUpLCAvLyBDb21wb3NpdGlvbiBzdGFydCB0aW1lXG4gICAgICAgIGkzMihjb21wb3NpdGlvbkVuZFRpbWUpLCAvLyBDb21wb3NpdGlvbiBlbmQgdGltZVxuICAgIF0pO1xufTtcbi8qKlxuICogTW92aWUgRXh0ZW5kcyBCb3g6IFRoaXMgYm94IHNpZ25hbHMgdG8gcmVhZGVycyB0aGF0IHRoZSBmaWxlIGlzIGZyYWdtZW50ZWQuIENvbnRhaW5zIGEgc2luZ2xlIFRyYWNrIEV4dGVuZHMgQm94XG4gKiBmb3IgZWFjaCB0cmFjayBpbiB0aGUgbW92aWUuXG4gKi9cbmV4cG9ydCBjb25zdCBtdmV4ID0gKHRyYWNrRGF0YXMpID0+IHtcbiAgICByZXR1cm4gYm94KCdtdmV4JywgdW5kZWZpbmVkLCB0cmFja0RhdGFzLm1hcCh0cmV4KSk7XG59O1xuLyoqIFRyYWNrIEV4dGVuZHMgQm94OiBDb250YWlucyB0aGUgZGVmYXVsdCB2YWx1ZXMgdXNlZCBieSB0aGUgbW92aWUgZnJhZ21lbnRzLiAqL1xuZXhwb3J0IGNvbnN0IHRyZXggPSAodHJhY2tEYXRhKSA9PiB7XG4gICAgcmV0dXJuIGZ1bGxCb3goJ3RyZXgnLCAwLCAwLCBbXG4gICAgICAgIHUzMih0cmFja0RhdGEudHJhY2suaWQpLCAvLyBUcmFjayBJRFxuICAgICAgICB1MzIoMSksIC8vIERlZmF1bHQgc2FtcGxlIGRlc2NyaXB0aW9uIGluZGV4XG4gICAgICAgIHUzMigwKSwgLy8gRGVmYXVsdCBzYW1wbGUgZHVyYXRpb25cbiAgICAgICAgdTMyKDApLCAvLyBEZWZhdWx0IHNhbXBsZSBzaXplXG4gICAgICAgIHUzMigwKSwgLy8gRGVmYXVsdCBzYW1wbGUgZmxhZ3NcbiAgICBdKTtcbn07XG4vKipcbiAqIE1vdmllIEZyYWdtZW50IEJveDogVGhlIG1vdmllIGZyYWdtZW50cyBleHRlbmQgdGhlIHByZXNlbnRhdGlvbiBpbiB0aW1lLiBUaGV5IHByb3ZpZGUgdGhlIGluZm9ybWF0aW9uIHRoYXQgd291bGRcbiAqIHByZXZpb3VzbHkgaGF2ZSBiZWVuXHRpbiB0aGUgTW92aWUgQm94LlxuICovXG5leHBvcnQgY29uc3QgbW9vZiA9IChzZXF1ZW5jZU51bWJlciwgdHJhY2tEYXRhcykgPT4ge1xuICAgIHJldHVybiBib3goJ21vb2YnLCB1bmRlZmluZWQsIFtcbiAgICAgICAgbWZoZChzZXF1ZW5jZU51bWJlciksXG4gICAgICAgIC4uLnRyYWNrRGF0YXMubWFwKHRyYWYpLFxuICAgIF0pO1xufTtcbi8qKiBNb3ZpZSBGcmFnbWVudCBIZWFkZXIgQm94OiBDb250YWlucyBhIHNlcXVlbmNlIG51bWJlciBhcyBhIHNhZmV0eSBjaGVjay4gKi9cbmV4cG9ydCBjb25zdCBtZmhkID0gKHNlcXVlbmNlTnVtYmVyKSA9PiB7XG4gICAgcmV0dXJuIGZ1bGxCb3goJ21maGQnLCAwLCAwLCBbXG4gICAgICAgIHUzMihzZXF1ZW5jZU51bWJlciksIC8vIFNlcXVlbmNlIG51bWJlclxuICAgIF0pO1xufTtcbmNvbnN0IGZyYWdtZW50U2FtcGxlRmxhZ3MgPSAoc2FtcGxlKSA9PiB7XG4gICAgbGV0IGJ5dGUxID0gMDtcbiAgICBsZXQgYnl0ZTIgPSAwO1xuICAgIGNvbnN0IGJ5dGUzID0gMDtcbiAgICBjb25zdCBieXRlNCA9IDA7XG4gICAgY29uc3Qgc2FtcGxlSXNEaWZmZXJlbmNlU2FtcGxlID0gc2FtcGxlLnR5cGUgPT09ICdkZWx0YSc7XG4gICAgYnl0ZTIgfD0gK3NhbXBsZUlzRGlmZmVyZW5jZVNhbXBsZTtcbiAgICBpZiAoc2FtcGxlSXNEaWZmZXJlbmNlU2FtcGxlKSB7XG4gICAgICAgIGJ5dGUxIHw9IDE7IC8vIFRoZXJlIGlzIHJlZHVuZGFudCBjb2RpbmcgaW4gdGhpcyBzYW1wbGVcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJ5dGUxIHw9IDI7IC8vIFRoZXJlIGlzIG5vIHJlZHVuZGFudCBjb2RpbmcgaW4gdGhpcyBzYW1wbGVcbiAgICB9XG4gICAgLy8gTm90ZSB0aGF0IHRoZXJlIGFyZSBhIGxvdCBvZiBvdGhlciBmbGFncyB0byBwb3RlbnRpYWxseSBzZXQgaGVyZSwgYnV0IG1vc3QgYXJlIGlycmVsZXZhbnQgLyBub24tbmVjZXNzYXJ5XG4gICAgcmV0dXJuIGJ5dGUxIDw8IDI0IHwgYnl0ZTIgPDwgMTYgfCBieXRlMyA8PCA4IHwgYnl0ZTQ7XG59O1xuLyoqIFRyYWNrIEZyYWdtZW50IEJveCAqL1xuZXhwb3J0IGNvbnN0IHRyYWYgPSAodHJhY2tEYXRhKSA9PiB7XG4gICAgcmV0dXJuIGJveCgndHJhZicsIHVuZGVmaW5lZCwgW1xuICAgICAgICB0ZmhkKHRyYWNrRGF0YSksXG4gICAgICAgIHRmZHQodHJhY2tEYXRhKSxcbiAgICAgICAgdHJ1bih0cmFja0RhdGEpLFxuICAgIF0pO1xufTtcbi8qKiBUcmFjayBGcmFnbWVudCBIZWFkZXIgQm94OiBQcm92aWRlcyBhIHJlZmVyZW5jZSB0byB0aGUgZXh0ZW5kZWQgdHJhY2ssIGFuZCBmbGFncy4gKi9cbmV4cG9ydCBjb25zdCB0ZmhkID0gKHRyYWNrRGF0YSkgPT4ge1xuICAgIGFzc2VydCh0cmFja0RhdGEuY3VycmVudENodW5rKTtcbiAgICBsZXQgdGZGbGFncyA9IDA7XG4gICAgdGZGbGFncyB8PSAweDAwMDA4OyAvLyBEZWZhdWx0IHNhbXBsZSBkdXJhdGlvbiBwcmVzZW50XG4gICAgdGZGbGFncyB8PSAweDAwMDEwOyAvLyBEZWZhdWx0IHNhbXBsZSBzaXplIHByZXNlbnRcbiAgICB0ZkZsYWdzIHw9IDB4MDAwMjA7IC8vIERlZmF1bHQgc2FtcGxlIGZsYWdzIHByZXNlbnRcbiAgICB0ZkZsYWdzIHw9IDB4MjAwMDA7IC8vIERlZmF1bHQgYmFzZSBpcyBtb29mXG4gICAgLy8gUHJlZmVyIHRoZSBzZWNvbmQgc2FtcGxlIG92ZXIgdGhlIGZpcnN0IG9uZSwgYXMgdGhlIGZpcnN0IG9uZSBpcyBhIHN5bmMgc2FtcGxlIGFuZCB0aGVyZWZvcmUgdGhlIFwib2RkIG9uZSBvdXRcIlxuICAgIGNvbnN0IHJlZmVyZW5jZVNhbXBsZSA9IHRyYWNrRGF0YS5jdXJyZW50Q2h1bmsuc2FtcGxlc1sxXSA/PyB0cmFja0RhdGEuY3VycmVudENodW5rLnNhbXBsZXNbMF07XG4gICAgY29uc3QgcmVmZXJlbmNlU2FtcGxlSW5mbyA9IHtcbiAgICAgICAgZHVyYXRpb246IHJlZmVyZW5jZVNhbXBsZS50aW1lc2NhbGVVbml0c1RvTmV4dFNhbXBsZSxcbiAgICAgICAgc2l6ZTogcmVmZXJlbmNlU2FtcGxlLnNpemUsXG4gICAgICAgIGZsYWdzOiBmcmFnbWVudFNhbXBsZUZsYWdzKHJlZmVyZW5jZVNhbXBsZSksXG4gICAgfTtcbiAgICByZXR1cm4gZnVsbEJveCgndGZoZCcsIDAsIHRmRmxhZ3MsIFtcbiAgICAgICAgdTMyKHRyYWNrRGF0YS50cmFjay5pZCksIC8vIFRyYWNrIElEXG4gICAgICAgIHUzMihyZWZlcmVuY2VTYW1wbGVJbmZvLmR1cmF0aW9uKSwgLy8gRGVmYXVsdCBzYW1wbGUgZHVyYXRpb25cbiAgICAgICAgdTMyKHJlZmVyZW5jZVNhbXBsZUluZm8uc2l6ZSksIC8vIERlZmF1bHQgc2FtcGxlIHNpemVcbiAgICAgICAgdTMyKHJlZmVyZW5jZVNhbXBsZUluZm8uZmxhZ3MpLCAvLyBEZWZhdWx0IHNhbXBsZSBmbGFnc1xuICAgIF0pO1xufTtcbi8qKlxuICogVHJhY2sgRnJhZ21lbnQgRGVjb2RlIFRpbWUgQm94OiBQcm92aWRlcyB0aGUgYWJzb2x1dGUgZGVjb2RlIHRpbWUgb2YgdGhlIGZpcnN0IHNhbXBsZSBvZiB0aGUgZnJhZ21lbnQuIFRoaXMgaXNcbiAqIHVzZWZ1bCBmb3IgcGVyZm9ybWluZyByYW5kb20gYWNjZXNzIG9uIHRoZSBtZWRpYSBmaWxlLlxuICovXG5leHBvcnQgY29uc3QgdGZkdCA9ICh0cmFja0RhdGEpID0+IHtcbiAgICBhc3NlcnQodHJhY2tEYXRhLmN1cnJlbnRDaHVuayk7XG4gICAgcmV0dXJuIGZ1bGxCb3goJ3RmZHQnLCAxLCAwLCBbXG4gICAgICAgIHU2NChpbnRvVGltZXNjYWxlKHRyYWNrRGF0YS5jdXJyZW50Q2h1bmsuc3RhcnRUaW1lc3RhbXAsIHRyYWNrRGF0YS50aW1lc2NhbGUpKSwgLy8gQmFzZSBNZWRpYSBEZWNvZGUgVGltZVxuICAgIF0pO1xufTtcbi8qKiBUcmFjayBSdW4gQm94OiBTcGVjaWZpZXMgYSBydW4gb2YgY29udGlndW91cyBzYW1wbGVzIGZvciBhIGdpdmVuIHRyYWNrLiAqL1xuZXhwb3J0IGNvbnN0IHRydW4gPSAodHJhY2tEYXRhKSA9PiB7XG4gICAgYXNzZXJ0KHRyYWNrRGF0YS5jdXJyZW50Q2h1bmspO1xuICAgIGNvbnN0IGFsbFNhbXBsZUR1cmF0aW9ucyA9IHRyYWNrRGF0YS5jdXJyZW50Q2h1bmsuc2FtcGxlcy5tYXAoeCA9PiB4LnRpbWVzY2FsZVVuaXRzVG9OZXh0U2FtcGxlKTtcbiAgICBjb25zdCBhbGxTYW1wbGVTaXplcyA9IHRyYWNrRGF0YS5jdXJyZW50Q2h1bmsuc2FtcGxlcy5tYXAoeCA9PiB4LnNpemUpO1xuICAgIGNvbnN0IGFsbFNhbXBsZUZsYWdzID0gdHJhY2tEYXRhLmN1cnJlbnRDaHVuay5zYW1wbGVzLm1hcChmcmFnbWVudFNhbXBsZUZsYWdzKTtcbiAgICBjb25zdCBhbGxTYW1wbGVDb21wb3NpdGlvblRpbWVPZmZzZXRzID0gdHJhY2tEYXRhLmN1cnJlbnRDaHVuay5zYW1wbGVzXG4gICAgICAgIC5tYXAoeCA9PiBpbnRvVGltZXNjYWxlKHgudGltZXN0YW1wIC0geC5kZWNvZGVUaW1lc3RhbXAsIHRyYWNrRGF0YS50aW1lc2NhbGUpKTtcbiAgICBjb25zdCB1bmlxdWVTYW1wbGVEdXJhdGlvbnMgPSBuZXcgU2V0KGFsbFNhbXBsZUR1cmF0aW9ucyk7XG4gICAgY29uc3QgdW5pcXVlU2FtcGxlU2l6ZXMgPSBuZXcgU2V0KGFsbFNhbXBsZVNpemVzKTtcbiAgICBjb25zdCB1bmlxdWVTYW1wbGVGbGFncyA9IG5ldyBTZXQoYWxsU2FtcGxlRmxhZ3MpO1xuICAgIGNvbnN0IHVuaXF1ZVNhbXBsZUNvbXBvc2l0aW9uVGltZU9mZnNldHMgPSBuZXcgU2V0KGFsbFNhbXBsZUNvbXBvc2l0aW9uVGltZU9mZnNldHMpO1xuICAgIGNvbnN0IGZpcnN0U2FtcGxlRmxhZ3NQcmVzZW50ID0gdW5pcXVlU2FtcGxlRmxhZ3Muc2l6ZSA9PT0gMiAmJiBhbGxTYW1wbGVGbGFnc1swXSAhPT0gYWxsU2FtcGxlRmxhZ3NbMV07XG4gICAgY29uc3Qgc2FtcGxlRHVyYXRpb25QcmVzZW50ID0gdW5pcXVlU2FtcGxlRHVyYXRpb25zLnNpemUgPiAxO1xuICAgIGNvbnN0IHNhbXBsZVNpemVQcmVzZW50ID0gdW5pcXVlU2FtcGxlU2l6ZXMuc2l6ZSA+IDE7XG4gICAgY29uc3Qgc2FtcGxlRmxhZ3NQcmVzZW50ID0gIWZpcnN0U2FtcGxlRmxhZ3NQcmVzZW50ICYmIHVuaXF1ZVNhbXBsZUZsYWdzLnNpemUgPiAxO1xuICAgIGNvbnN0IHNhbXBsZUNvbXBvc2l0aW9uVGltZU9mZnNldHNQcmVzZW50ID0gdW5pcXVlU2FtcGxlQ29tcG9zaXRpb25UaW1lT2Zmc2V0cy5zaXplID4gMSB8fCBbLi4udW5pcXVlU2FtcGxlQ29tcG9zaXRpb25UaW1lT2Zmc2V0c10uc29tZSh4ID0+IHggIT09IDApO1xuICAgIGxldCBmbGFncyA9IDA7XG4gICAgZmxhZ3MgfD0gMHgwMDAxOyAvLyBEYXRhIG9mZnNldCBwcmVzZW50XG4gICAgZmxhZ3MgfD0gMHgwMDA0ICogK2ZpcnN0U2FtcGxlRmxhZ3NQcmVzZW50OyAvLyBGaXJzdCBzYW1wbGUgZmxhZ3MgcHJlc2VudFxuICAgIGZsYWdzIHw9IDB4MDEwMCAqICtzYW1wbGVEdXJhdGlvblByZXNlbnQ7IC8vIFNhbXBsZSBkdXJhdGlvbiBwcmVzZW50XG4gICAgZmxhZ3MgfD0gMHgwMjAwICogK3NhbXBsZVNpemVQcmVzZW50OyAvLyBTYW1wbGUgc2l6ZSBwcmVzZW50XG4gICAgZmxhZ3MgfD0gMHgwNDAwICogK3NhbXBsZUZsYWdzUHJlc2VudDsgLy8gU2FtcGxlIGZsYWdzIHByZXNlbnRcbiAgICBmbGFncyB8PSAweDA4MDAgKiArc2FtcGxlQ29tcG9zaXRpb25UaW1lT2Zmc2V0c1ByZXNlbnQ7IC8vIFNhbXBsZSBjb21wb3NpdGlvbiB0aW1lIG9mZnNldHMgcHJlc2VudFxuICAgIHJldHVybiBmdWxsQm94KCd0cnVuJywgMSwgZmxhZ3MsIFtcbiAgICAgICAgdTMyKHRyYWNrRGF0YS5jdXJyZW50Q2h1bmsuc2FtcGxlcy5sZW5ndGgpLCAvLyBTYW1wbGUgY291bnRcbiAgICAgICAgdTMyKHRyYWNrRGF0YS5jdXJyZW50Q2h1bmsub2Zmc2V0IC0gdHJhY2tEYXRhLmN1cnJlbnRDaHVuay5tb29mT2Zmc2V0IHx8IDApLCAvLyBEYXRhIG9mZnNldFxuICAgICAgICBmaXJzdFNhbXBsZUZsYWdzUHJlc2VudCA/IHUzMihhbGxTYW1wbGVGbGFnc1swXSkgOiBbXSxcbiAgICAgICAgdHJhY2tEYXRhLmN1cnJlbnRDaHVuay5zYW1wbGVzLm1hcCgoXywgaSkgPT4gW1xuICAgICAgICAgICAgc2FtcGxlRHVyYXRpb25QcmVzZW50ID8gdTMyKGFsbFNhbXBsZUR1cmF0aW9uc1tpXSkgOiBbXSwgLy8gU2FtcGxlIGR1cmF0aW9uXG4gICAgICAgICAgICBzYW1wbGVTaXplUHJlc2VudCA/IHUzMihhbGxTYW1wbGVTaXplc1tpXSkgOiBbXSwgLy8gU2FtcGxlIHNpemVcbiAgICAgICAgICAgIHNhbXBsZUZsYWdzUHJlc2VudCA/IHUzMihhbGxTYW1wbGVGbGFnc1tpXSkgOiBbXSwgLy8gU2FtcGxlIGZsYWdzXG4gICAgICAgICAgICAvLyBTYW1wbGUgY29tcG9zaXRpb24gdGltZSBvZmZzZXRzXG4gICAgICAgICAgICBzYW1wbGVDb21wb3NpdGlvblRpbWVPZmZzZXRzUHJlc2VudCA/IGkzMihhbGxTYW1wbGVDb21wb3NpdGlvblRpbWVPZmZzZXRzW2ldKSA6IFtdLFxuICAgICAgICBdKSxcbiAgICBdKTtcbn07XG4vKipcbiAqIE1vdmllIEZyYWdtZW50IFJhbmRvbSBBY2Nlc3MgQm94OiBGb3IgZWFjaCB0cmFjaywgcHJvdmlkZXMgcG9pbnRlcnMgdG8gc3luYyBzYW1wbGVzIHdpdGhpbiB0aGUgZmlsZVxuICogZm9yIHJhbmRvbSBhY2Nlc3MuXG4gKi9cbmV4cG9ydCBjb25zdCBtZnJhID0gKHRyYWNrRGF0YXMpID0+IHtcbiAgICByZXR1cm4gYm94KCdtZnJhJywgdW5kZWZpbmVkLCBbXG4gICAgICAgIC4uLnRyYWNrRGF0YXMubWFwKHRmcmEpLFxuICAgICAgICBtZnJvKCksXG4gICAgXSk7XG59O1xuLyoqIFRyYWNrIEZyYWdtZW50IFJhbmRvbSBBY2Nlc3MgQm94OiBQcm92aWRlcyBwb2ludGVycyB0byBzeW5jIHNhbXBsZXMgd2l0aGluIHRoZSBmaWxlIGZvciByYW5kb20gYWNjZXNzLiAqL1xuZXhwb3J0IGNvbnN0IHRmcmEgPSAodHJhY2tEYXRhLCB0cmFja0luZGV4KSA9PiB7XG4gICAgY29uc3QgdmVyc2lvbiA9IDE7IC8vIFVzaW5nIHRoaXMgdmVyc2lvbiBhbGxvd3MgdXMgdG8gdXNlIDY0LWJpdCB0aW1lIGFuZCBvZmZzZXQgdmFsdWVzXG4gICAgcmV0dXJuIGZ1bGxCb3goJ3RmcmEnLCB2ZXJzaW9uLCAwLCBbXG4gICAgICAgIHUzMih0cmFja0RhdGEudHJhY2suaWQpLCAvLyBUcmFjayBJRFxuICAgICAgICB1MzIoMGIxMTExMTEpLCAvLyBUaGlzIHNwZWNpZmllcyB0aGF0IHRyYWYgbnVtYmVyLCB0cnVuIG51bWJlciBhbmQgc2FtcGxlIG51bWJlciBhcmUgMzItYml0IGludHNcbiAgICAgICAgdTMyKHRyYWNrRGF0YS5maW5hbGl6ZWRDaHVua3MubGVuZ3RoKSwgLy8gTnVtYmVyIG9mIGVudHJpZXNcbiAgICAgICAgdHJhY2tEYXRhLmZpbmFsaXplZENodW5rcy5tYXAoY2h1bmsgPT4gW1xuICAgICAgICAgICAgdTY0KGludG9UaW1lc2NhbGUoY2h1bmsuc2FtcGxlc1swXS50aW1lc3RhbXAsIHRyYWNrRGF0YS50aW1lc2NhbGUpKSwgLy8gVGltZSAoaW4gcHJlc2VudGF0aW9uIHRpbWUpXG4gICAgICAgICAgICB1NjQoY2h1bmsubW9vZk9mZnNldCksIC8vIG1vb2Ygb2Zmc2V0XG4gICAgICAgICAgICB1MzIodHJhY2tJbmRleCArIDEpLCAvLyB0cmFmIG51bWJlclxuICAgICAgICAgICAgdTMyKDEpLCAvLyB0cnVuIG51bWJlclxuICAgICAgICAgICAgdTMyKDEpLCAvLyBTYW1wbGUgbnVtYmVyXG4gICAgICAgIF0pLFxuICAgIF0pO1xufTtcbi8qKlxuICogTW92aWUgRnJhZ21lbnQgUmFuZG9tIEFjY2VzcyBPZmZzZXQgQm94OiBQcm92aWRlcyB0aGUgc2l6ZSBvZiB0aGUgZW5jbG9zaW5nIG1mcmEgYm94LiBUaGlzIGJveCBjYW4gYmUgdXNlZCBieSByZWFkZXJzXG4gKiB0byBxdWlja2x5IGxvY2F0ZSB0aGUgbWZyYSBib3ggYnkgc2VhcmNoaW5nIGZyb20gdGhlIGVuZCBvZiB0aGUgZmlsZS5cbiAqL1xuZXhwb3J0IGNvbnN0IG1mcm8gPSAoKSA9PiB7XG4gICAgcmV0dXJuIGZ1bGxCb3goJ21mcm8nLCAwLCAwLCBbXG4gICAgICAgIC8vIFRoaXMgdmFsdWUgbmVlZHMgdG8gYmUgb3ZlcndyaXR0ZW4gbWFudWFsbHkgZnJvbSB0aGUgb3V0c2lkZSwgd2hlcmUgdGhlIGFjdHVhbCBzaXplIG9mIHRoZSBlbmNsb3NpbmcgbWZyYSBib3hcbiAgICAgICAgLy8gaXMga25vd25cbiAgICAgICAgdTMyKDApLCAvLyBTaXplXG4gICAgXSk7XG59O1xuLyoqIFZUVCBFbXB0eSBDdWUgQm94ICovXG5leHBvcnQgY29uc3QgdnR0ZSA9ICgpID0+IGJveCgndnR0ZScpO1xuLyoqIFZUVCBDdWUgQm94ICovXG5leHBvcnQgY29uc3QgdnR0YyA9IChwYXlsb2FkLCB0aW1lc3RhbXAsIGlkZW50aWZpZXIsIHNldHRpbmdzLCBzb3VyY2VJZCkgPT4gYm94KCd2dHRjJywgdW5kZWZpbmVkLCBbXG4gICAgc291cmNlSWQgIT09IG51bGwgPyBib3goJ3ZzaWQnLCBbaTMyKHNvdXJjZUlkKV0pIDogbnVsbCxcbiAgICBpZGVudGlmaWVyICE9PSBudWxsID8gYm94KCdpZGVuJywgWy4uLnRleHRFbmNvZGVyLmVuY29kZShpZGVudGlmaWVyKV0pIDogbnVsbCxcbiAgICB0aW1lc3RhbXAgIT09IG51bGwgPyBib3goJ2N0aW0nLCBbLi4udGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN1YnRpdGxlVGltZXN0YW1wKHRpbWVzdGFtcCkpXSkgOiBudWxsLFxuICAgIHNldHRpbmdzICE9PSBudWxsID8gYm94KCdzdHRnJywgWy4uLnRleHRFbmNvZGVyLmVuY29kZShzZXR0aW5ncyldKSA6IG51bGwsXG4gICAgYm94KCdwYXlsJywgWy4uLnRleHRFbmNvZGVyLmVuY29kZShwYXlsb2FkKV0pLFxuXSk7XG4vKiogVlRUIEFkZGl0aW9uYWwgVGV4dCBCb3ggKi9cbmV4cG9ydCBjb25zdCB2dHRhID0gKG5vdGVzKSA9PiBib3goJ3Z0dGEnLCBbLi4udGV4dEVuY29kZXIuZW5jb2RlKG5vdGVzKV0pO1xuLyoqIFVzZXIgRGF0YSBCb3ggKi9cbmNvbnN0IHVkdGEgPSAobXV4ZXIpID0+IHtcbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIC8vIERlcGVuZGluZyBvbiB0aGUgZm9ybWF0LCBtZXRhZGF0YSB0YWdzIGFyZSB3cml0dGVuIGRpZmZlcmVudGx5XG4gICAgaWYgKG11eGVyLmlzUXVpY2tUaW1lKSB7XG4gICAgICAgIGFkZFF1aWNrVGltZU1ldGFkYXRhVGFnQm94ZXMoYm94ZXMsIG11eGVyLm91dHB1dC5fbWV0YWRhdGFUYWdzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1ldGFCb3ggPSBtZXRhKG11eGVyLm91dHB1dC5fbWV0YWRhdGFUYWdzKTtcbiAgICAgICAgaWYgKG1ldGFCb3gpIHtcbiAgICAgICAgICAgIGJveGVzLnB1c2gobWV0YUJveCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJveGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGJveCgndWR0YScsIHVuZGVmaW5lZCwgYm94ZXMpO1xufTtcbmNvbnN0IGFkZFF1aWNrVGltZU1ldGFkYXRhVGFnQm94ZXMgPSAoYm94ZXMsIHRhZ3MpID0+IHtcbiAgICAvLyBodHRwczovL2V4aWZ0b29sLm9yZy9UYWdOYW1lcy9RdWlja1RpbWUuaHRtbCAoUXVpY2tUaW1lIFVzZXJEYXRhIFRhZ3MpXG4gICAgLy8gRm9yIFF1aWNrVGltZSBmaWxlcywgbWV0YWRhdGEgdGFncyBhcmUgZHVtcGVkIGludG8gdGhlIHVkdGEgYm94XG4gICAgZm9yIChjb25zdCB7IGtleSwgdmFsdWUgfSBvZiBrZXlWYWx1ZUl0ZXJhdG9yKHRhZ3MpKSB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICd0aXRsZSc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBib3hlcy5wdXNoKG1ldGFkYXRhVGFnU3RyaW5nQm94U2hvcnQoJ8KpbmFtJywgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGVzY3JpcHRpb24nOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYm94ZXMucHVzaChtZXRhZGF0YVRhZ1N0cmluZ0JveFNob3J0KCfCqWRlcycsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FydGlzdCc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBib3hlcy5wdXNoKG1ldGFkYXRhVGFnU3RyaW5nQm94U2hvcnQoJ8KpQVJUJywgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWxidW0nOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYm94ZXMucHVzaChtZXRhZGF0YVRhZ1N0cmluZ0JveFNob3J0KCfCqWFsYicsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FsYnVtQXJ0aXN0JzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJveGVzLnB1c2gobWV0YWRhdGFUYWdTdHJpbmdCb3hTaG9ydCgnYWxicicsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2dlbnJlJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJveGVzLnB1c2gobWV0YWRhdGFUYWdTdHJpbmdCb3hTaG9ydCgnwqlnZW4nLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJveGVzLnB1c2gobWV0YWRhdGFUYWdTdHJpbmdCb3hTaG9ydCgnwqlkYXknLCB2YWx1ZS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDEwKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJveGVzLnB1c2gobWV0YWRhdGFUYWdTdHJpbmdCb3hTaG9ydCgnwqljbXQnLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdseXJpY3MnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYm94ZXMucHVzaChtZXRhZGF0YVRhZ1N0cmluZ0JveFNob3J0KCfCqWx5cicsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGVkIGxhdGVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2NOdW1iZXInOlxuICAgICAgICAgICAgY2FzZSAnZGlzY3NUb3RhbCc6XG4gICAgICAgICAgICBjYXNlICd0cmFja051bWJlcic6XG4gICAgICAgICAgICBjYXNlICd0cmFja3NUb3RhbCc6XG4gICAgICAgICAgICBjYXNlICdpbWFnZXMnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IHdyaXR0ZW4gZm9yIFF1aWNrVGltZSAoY29tbW9uIEFwcGxlIEwpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IGFzc2VydE5ldmVyKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ3MucmF3KSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRhZ3MucmF3KSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRhZ3MucmF3W2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBrZXkubGVuZ3RoICE9PSA0IHx8IGJveGVzLnNvbWUoeCA9PiB4LnR5cGUgPT09IGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgYm94ZXMucHVzaChtZXRhZGF0YVRhZ1N0cmluZ0JveFNob3J0KGtleSwgdmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIGJveGVzLnB1c2goYm94KGtleSwgQXJyYXkuZnJvbSh2YWx1ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBtZXRhZGF0YVRhZ1N0cmluZ0JveFNob3J0ID0gKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgZW5jb2RlZCA9IHRleHRFbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgcmV0dXJuIGJveChuYW1lLCBbXG4gICAgICAgIHUxNihlbmNvZGVkLmxlbmd0aCksXG4gICAgICAgIHUxNihnZXRMYW5ndWFnZUNvZGVJbnQoJ3VuZCcpKSxcbiAgICAgICAgQXJyYXkuZnJvbShlbmNvZGVkKSxcbiAgICBdKTtcbn07XG5jb25zdCBEQVRBX0JPWF9NSU1FX1RZUEVfTUFQID0ge1xuICAgICdpbWFnZS9qcGVnJzogMTMsXG4gICAgJ2ltYWdlL3BuZyc6IDE0LFxuICAgICdpbWFnZS9ibXAnOiAyNyxcbn07XG4vKiogTWV0YWRhdGEgQm94ICovXG5jb25zdCBtZXRhID0gKHRhZ3MpID0+IHtcbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIC8vIGh0dHBzOi8vZXhpZnRvb2wub3JnL1RhZ05hbWVzL1F1aWNrVGltZS5odG1sIChRdWlja1RpbWUgSXRlbUxpc3QgVGFncylcbiAgICAvLyBUaGlzIGlzIHRoZSBtZXRhZGF0YSBmb3JtYXQgdXNlZCBmb3IgTVA0IGZpbGVzXG4gICAgZm9yIChjb25zdCB7IGtleSwgdmFsdWUgfSBvZiBrZXlWYWx1ZUl0ZXJhdG9yKHRhZ3MpKSB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICd0aXRsZSc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBib3hlcy5wdXNoKG1ldGFkYXRhVGFnU3RyaW5nQm94TG9uZygnwqluYW0nLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkZXNjcmlwdGlvbic6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBib3hlcy5wdXNoKG1ldGFkYXRhVGFnU3RyaW5nQm94TG9uZygnwqlkZXMnLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhcnRpc3QnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYm94ZXMucHVzaChtZXRhZGF0YVRhZ1N0cmluZ0JveExvbmcoJ8KpQVJUJywgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWxidW0nOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYm94ZXMucHVzaChtZXRhZGF0YVRhZ1N0cmluZ0JveExvbmcoJ8KpYWxiJywgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWxidW1BcnRpc3QnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYm94ZXMucHVzaChtZXRhZGF0YVRhZ1N0cmluZ0JveExvbmcoJ2FBUlQnLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJveGVzLnB1c2gobWV0YWRhdGFUYWdTdHJpbmdCb3hMb25nKCfCqWNtdCcsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2dlbnJlJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJveGVzLnB1c2gobWV0YWRhdGFUYWdTdHJpbmdCb3hMb25nKCfCqWdlbicsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2x5cmljcyc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBib3hlcy5wdXNoKG1ldGFkYXRhVGFnU3RyaW5nQm94TG9uZygnwqlseXInLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJveGVzLnB1c2gobWV0YWRhdGFUYWdTdHJpbmdCb3hMb25nKCfCqWRheScsIHZhbHVlLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgMTApKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ltYWdlcyc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGltYWdlIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2Uua2luZCAhPT0gJ2NvdmVyRnJvbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBib3hlcy5wdXNoKGJveCgnY292cicsIHVuZGVmaW5lZCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveCgnZGF0YScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdTMyKERBVEFfQk9YX01JTUVfVFlQRV9NQVBbaW1hZ2UubWltZVR5cGVdID8/IDApLCAvLyBUeXBlIGluZGljYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1MzIoMCksIC8vIExvY2FsZSBpbmRpY2F0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkuZnJvbShpbWFnZS5kYXRhKSwgLy8gS2luZGEgc2xvdywgaG9wZWZ1bGx5IHRlbXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0cmFja051bWJlcic6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBib3hlcy5wdXNoKGJveCgndHJrbicsIHVuZGVmaW5lZCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgYm94KCdkYXRhJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUzMigwKSwgLy8gOCBieXRlcyBlbXB0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUzMigwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1MTYoMCksIC8vIEVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdTE2KHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1MTYodGFncy50cmFja3NUb3RhbCA/PyAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1MTYoMCksIC8vIEVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkaXNjTnVtYmVyJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJveGVzLnB1c2goYm94KCdkaXNjJywgdW5kZWZpbmVkLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBib3goJ2RhdGEnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdTMyKDApLCAvLyA4IGJ5dGVzIGVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdTMyKDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUxNigwKSwgLy8gRW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1MTYodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUxNih0YWdzLmRpc2NzVG90YWwgPz8gMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdTE2KDApLCAvLyBFbXB0eVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndHJhY2tzVG90YWwnOlxuICAgICAgICAgICAgY2FzZSAnZGlzY3NUb3RhbCc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBhcmUgaW5jbHVkZWQgd2l0aCAndHJhY2tOdW1iZXInIGFuZCAnZGlzY051bWJlcicgcmVzcGVjdGl2ZWx5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGVkIGxhdGVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IGFzc2VydE5ldmVyKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ3MucmF3KSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRhZ3MucmF3KSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRhZ3MucmF3W2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBrZXkubGVuZ3RoICE9PSA0IHx8IGJveGVzLnNvbWUoeCA9PiB4LnR5cGUgPT09IGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgYm94ZXMucHVzaChtZXRhZGF0YVRhZ1N0cmluZ0JveExvbmcoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgYm94ZXMucHVzaChib3goa2V5LCB1bmRlZmluZWQsIFtcbiAgICAgICAgICAgICAgICAgICAgYm94KCdkYXRhJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgdTMyKDApLCAvLyBUeXBlIGluZGljYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgdTMyKDApLCAvLyBMb2NhbGUgaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5mcm9tKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSaWNoSW1hZ2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgYm94ZXMucHVzaChib3goa2V5LCB1bmRlZmluZWQsIFtcbiAgICAgICAgICAgICAgICAgICAgYm94KCdkYXRhJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgdTMyKERBVEFfQk9YX01JTUVfVFlQRV9NQVBbdmFsdWUubWltZVR5cGVdID8/IDApLCAvLyBUeXBlIGluZGljYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgdTMyKDApLCAvLyBMb2NhbGUgaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5mcm9tKHZhbHVlLmRhdGEpLCAvLyBLaW5kYSBzbG93LCBob3BlZnVsbHkgdGVtcFxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJveGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bGxCb3goJ21ldGEnLCAwLCAwLCB1bmRlZmluZWQsIFtcbiAgICAgICAgaGRscihmYWxzZSwgJ21kaXInLCAnJywgJ2FwcGwnKSxcbiAgICAgICAgYm94KCdpbHN0JywgdW5kZWZpbmVkLCBib3hlcyksXG4gICAgXSk7XG59O1xuY29uc3QgbWV0YWRhdGFUYWdTdHJpbmdCb3hMb25nID0gKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIGJveChuYW1lLCB1bmRlZmluZWQsIFtcbiAgICAgICAgYm94KCdkYXRhJywgW1xuICAgICAgICAgICAgdTMyKDEpLCAvLyBUeXBlIGluZGljYXRvciAoVVRGLTgpXG4gICAgICAgICAgICB1MzIoMCksIC8vIExvY2FsZSBpbmRpY2F0b3JcbiAgICAgICAgICAgIC4uLnRleHRFbmNvZGVyLmVuY29kZSh2YWx1ZSksXG4gICAgICAgIF0pLFxuICAgIF0pO1xufTtcbmNvbnN0IFZJREVPX0NPREVDX1RPX0JPWF9OQU1FID0ge1xuICAgIGF2YzogJ2F2YzEnLFxuICAgIGhldmM6ICdodmMxJyxcbiAgICB2cDg6ICd2cDA4JyxcbiAgICB2cDk6ICd2cDA5JyxcbiAgICBhdjE6ICdhdjAxJyxcbn07XG5jb25zdCBWSURFT19DT0RFQ19UT19DT05GSUdVUkFUSU9OX0JPWCA9IHtcbiAgICBhdmM6IGF2Y0MsXG4gICAgaGV2YzogaHZjQyxcbiAgICB2cDg6IHZwY0MsXG4gICAgdnA5OiB2cGNDLFxuICAgIGF2MTogYXYxQyxcbn07XG5jb25zdCBhdWRpb0NvZGVjVG9Cb3hOYW1lID0gKGNvZGVjLCBpc1F1aWNrVGltZSkgPT4ge1xuICAgIHN3aXRjaCAoY29kZWMpIHtcbiAgICAgICAgY2FzZSAnYWFjJzogcmV0dXJuICdtcDRhJztcbiAgICAgICAgY2FzZSAnbXAzJzogcmV0dXJuICdtcDRhJztcbiAgICAgICAgY2FzZSAnb3B1cyc6IHJldHVybiAnT3B1cyc7XG4gICAgICAgIGNhc2UgJ3ZvcmJpcyc6IHJldHVybiAnbXA0YSc7XG4gICAgICAgIGNhc2UgJ2ZsYWMnOiByZXR1cm4gJ2ZMYUMnO1xuICAgICAgICBjYXNlICd1bGF3JzogcmV0dXJuICd1bGF3JztcbiAgICAgICAgY2FzZSAnYWxhdyc6IHJldHVybiAnYWxhdyc7XG4gICAgICAgIGNhc2UgJ3BjbS11OCc6IHJldHVybiAncmF3ICc7XG4gICAgICAgIGNhc2UgJ3BjbS1zOCc6IHJldHVybiAnc293dCc7XG4gICAgfVxuICAgIC8vIExvZ2ljIGRpdmVyZ2VzIGhlcmVcbiAgICBpZiAoaXNRdWlja1RpbWUpIHtcbiAgICAgICAgc3dpdGNoIChjb2RlYykge1xuICAgICAgICAgICAgY2FzZSAncGNtLXMxNic6IHJldHVybiAnc293dCc7XG4gICAgICAgICAgICBjYXNlICdwY20tczE2YmUnOiByZXR1cm4gJ3R3b3MnO1xuICAgICAgICAgICAgY2FzZSAncGNtLXMyNCc6IHJldHVybiAnaW4yNCc7XG4gICAgICAgICAgICBjYXNlICdwY20tczI0YmUnOiByZXR1cm4gJ2luMjQnO1xuICAgICAgICAgICAgY2FzZSAncGNtLXMzMic6IHJldHVybiAnaW4zMic7XG4gICAgICAgICAgICBjYXNlICdwY20tczMyYmUnOiByZXR1cm4gJ2luMzInO1xuICAgICAgICAgICAgY2FzZSAncGNtLWYzMic6IHJldHVybiAnZmwzMic7XG4gICAgICAgICAgICBjYXNlICdwY20tZjMyYmUnOiByZXR1cm4gJ2ZsMzInO1xuICAgICAgICAgICAgY2FzZSAncGNtLWY2NCc6IHJldHVybiAnZmw2NCc7XG4gICAgICAgICAgICBjYXNlICdwY20tZjY0YmUnOiByZXR1cm4gJ2ZsNjQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgICAgICAgICBjYXNlICdwY20tczE2JzogcmV0dXJuICdpcGNtJztcbiAgICAgICAgICAgIGNhc2UgJ3BjbS1zMTZiZSc6IHJldHVybiAnaXBjbSc7XG4gICAgICAgICAgICBjYXNlICdwY20tczI0JzogcmV0dXJuICdpcGNtJztcbiAgICAgICAgICAgIGNhc2UgJ3BjbS1zMjRiZSc6IHJldHVybiAnaXBjbSc7XG4gICAgICAgICAgICBjYXNlICdwY20tczMyJzogcmV0dXJuICdpcGNtJztcbiAgICAgICAgICAgIGNhc2UgJ3BjbS1zMzJiZSc6IHJldHVybiAnaXBjbSc7XG4gICAgICAgICAgICBjYXNlICdwY20tZjMyJzogcmV0dXJuICdmcGNtJztcbiAgICAgICAgICAgIGNhc2UgJ3BjbS1mMzJiZSc6IHJldHVybiAnZnBjbSc7XG4gICAgICAgICAgICBjYXNlICdwY20tZjY0JzogcmV0dXJuICdmcGNtJztcbiAgICAgICAgICAgIGNhc2UgJ3BjbS1mNjRiZSc6IHJldHVybiAnZnBjbSc7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgYXVkaW9Db2RlY1RvQ29uZmlndXJhdGlvbkJveCA9IChjb2RlYywgaXNRdWlja1RpbWUpID0+IHtcbiAgICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgICAgIGNhc2UgJ2FhYyc6IHJldHVybiBlc2RzO1xuICAgICAgICBjYXNlICdtcDMnOiByZXR1cm4gZXNkcztcbiAgICAgICAgY2FzZSAnb3B1cyc6IHJldHVybiBkT3BzO1xuICAgICAgICBjYXNlICd2b3JiaXMnOiByZXR1cm4gZXNkcztcbiAgICAgICAgY2FzZSAnZmxhYyc6IHJldHVybiBkZkxhO1xuICAgIH1cbiAgICAvLyBMb2dpYyBkaXZlcmdlcyBoZXJlXG4gICAgaWYgKGlzUXVpY2tUaW1lKSB7XG4gICAgICAgIHN3aXRjaCAoY29kZWMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3BjbS1zMjQnOiByZXR1cm4gd2F2ZTtcbiAgICAgICAgICAgIGNhc2UgJ3BjbS1zMjRiZSc6IHJldHVybiB3YXZlO1xuICAgICAgICAgICAgY2FzZSAncGNtLXMzMic6IHJldHVybiB3YXZlO1xuICAgICAgICAgICAgY2FzZSAncGNtLXMzMmJlJzogcmV0dXJuIHdhdmU7XG4gICAgICAgICAgICBjYXNlICdwY20tZjMyJzogcmV0dXJuIHdhdmU7XG4gICAgICAgICAgICBjYXNlICdwY20tZjMyYmUnOiByZXR1cm4gd2F2ZTtcbiAgICAgICAgICAgIGNhc2UgJ3BjbS1mNjQnOiByZXR1cm4gd2F2ZTtcbiAgICAgICAgICAgIGNhc2UgJ3BjbS1mNjRiZSc6IHJldHVybiB3YXZlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgICAgICAgICBjYXNlICdwY20tczE2JzogcmV0dXJuIHBjbUM7XG4gICAgICAgICAgICBjYXNlICdwY20tczE2YmUnOiByZXR1cm4gcGNtQztcbiAgICAgICAgICAgIGNhc2UgJ3BjbS1zMjQnOiByZXR1cm4gcGNtQztcbiAgICAgICAgICAgIGNhc2UgJ3BjbS1zMjRiZSc6IHJldHVybiBwY21DO1xuICAgICAgICAgICAgY2FzZSAncGNtLXMzMic6IHJldHVybiBwY21DO1xuICAgICAgICAgICAgY2FzZSAncGNtLXMzMmJlJzogcmV0dXJuIHBjbUM7XG4gICAgICAgICAgICBjYXNlICdwY20tZjMyJzogcmV0dXJuIHBjbUM7XG4gICAgICAgICAgICBjYXNlICdwY20tZjMyYmUnOiByZXR1cm4gcGNtQztcbiAgICAgICAgICAgIGNhc2UgJ3BjbS1mNjQnOiByZXR1cm4gcGNtQztcbiAgICAgICAgICAgIGNhc2UgJ3BjbS1mNjRiZSc6IHJldHVybiBwY21DO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbmNvbnN0IFNVQlRJVExFX0NPREVDX1RPX0JPWF9OQU1FID0ge1xuICAgIHdlYnZ0dDogJ3d2dHQnLFxufTtcbmNvbnN0IFNVQlRJVExFX0NPREVDX1RPX0NPTkZJR1VSQVRJT05fQk9YID0ge1xuICAgIHdlYnZ0dDogdnR0Qyxcbn07XG5jb25zdCBnZXRMYW5ndWFnZUNvZGVJbnQgPSAoY29kZSkgPT4ge1xuICAgIGFzc2VydChjb2RlLmxlbmd0aCA9PT0gMyk7XG4gICAgO1xuICAgIGxldCBsYW5ndWFnZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgbGFuZ3VhZ2UgPDw9IDU7XG4gICAgICAgIGxhbmd1YWdlICs9IGNvZGUuY2hhckNvZGVBdChpKSAtIDB4NjA7XG4gICAgfVxuICAgIHJldHVybiBsYW5ndWFnZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-boxes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-misc.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-misc.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildIsobmffMimeType: () => (/* binding */ buildIsobmffMimeType)\n/* harmony export */ });\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nconst buildIsobmffMimeType = (info) => {\n    const base = info.hasVideo\n        ? 'video/'\n        : info.hasAudio\n            ? 'audio/'\n            : 'application/';\n    let string = base + (info.isQuickTime ? 'quicktime' : 'mp4');\n    if (info.codecStrings.length > 0) {\n        const uniqueCodecMimeTypes = [...new Set(info.codecStrings)];\n        string += `; codecs=\"${uniqueCodecMimeTypes.join(', ')}\"`;\n    }\n    return string;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL2lzb2JtZmYvaXNvYm1mZi1taXNjLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVLGdDQUFnQztBQUMvRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRjaC1jdXQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL21lZGlhYnVubnkvZGlzdC9tb2R1bGVzL3NyYy9pc29ibWZmL2lzb2JtZmYtbWlzYy5qcz9kZTEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDI1LXByZXNlbnQsIFZhbmlsYWd5IGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuZXhwb3J0IGNvbnN0IGJ1aWxkSXNvYm1mZk1pbWVUeXBlID0gKGluZm8pID0+IHtcbiAgICBjb25zdCBiYXNlID0gaW5mby5oYXNWaWRlb1xuICAgICAgICA/ICd2aWRlby8nXG4gICAgICAgIDogaW5mby5oYXNBdWRpb1xuICAgICAgICAgICAgPyAnYXVkaW8vJ1xuICAgICAgICAgICAgOiAnYXBwbGljYXRpb24vJztcbiAgICBsZXQgc3RyaW5nID0gYmFzZSArIChpbmZvLmlzUXVpY2tUaW1lID8gJ3F1aWNrdGltZScgOiAnbXA0Jyk7XG4gICAgaWYgKGluZm8uY29kZWNTdHJpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdW5pcXVlQ29kZWNNaW1lVHlwZXMgPSBbLi4ubmV3IFNldChpbmZvLmNvZGVjU3RyaW5ncyldO1xuICAgICAgICBzdHJpbmcgKz0gYDsgY29kZWNzPVwiJHt1bmlxdWVDb2RlY01pbWVUeXBlcy5qb2luKCcsICcpfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-misc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-muxer.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-muxer.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLOBAL_TIMESCALE: () => (/* binding */ GLOBAL_TIMESCALE),\n/* harmony export */   IsobmffMuxer: () => (/* binding */ IsobmffMuxer),\n/* harmony export */   getTrackMetadata: () => (/* binding */ getTrackMetadata),\n/* harmony export */   intoTimescale: () => (/* binding */ intoTimescale)\n/* harmony export */ });\n/* harmony import */ var _isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isobmff-boxes.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-boxes.js\");\n/* harmony import */ var _muxer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../muxer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/muxer.js\");\n/* harmony import */ var _writer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../writer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/writer.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/* harmony import */ var _output_format_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../output-format.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/output-format.js\");\n/* harmony import */ var _subtitles_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../subtitles.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/subtitles.js\");\n/* harmony import */ var _codec_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../codec.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec.js\");\n/* harmony import */ var _target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../target.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/target.js\");\n/* harmony import */ var _codec_data_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../codec-data.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec-data.js\");\n/* harmony import */ var _isobmff_misc_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isobmff-misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-misc.js\");\n/* harmony import */ var _isobmff_reader_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./isobmff-reader.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-reader.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n\n\n\n\n\n\nconst GLOBAL_TIMESCALE = 1000;\nconst TIMESTAMP_OFFSET = 2_082_844_800; // Seconds between Jan 1 1904 and Jan 1 1970\nconst getTrackMetadata = (trackData) => {\n    const metadata = {};\n    const track = trackData.track;\n    if (track.metadata.name !== undefined) {\n        metadata.name = track.metadata.name;\n    }\n    return metadata;\n};\nconst intoTimescale = (timeInSeconds, timescale, round = true) => {\n    const value = timeInSeconds * timescale;\n    return round ? Math.round(value) : value;\n};\nclass IsobmffMuxer extends _muxer_js__WEBPACK_IMPORTED_MODULE_0__.Muxer {\n    constructor(output, format) {\n        super(output);\n        this.auxTarget = new _target_js__WEBPACK_IMPORTED_MODULE_1__.BufferTarget();\n        this.auxWriter = this.auxTarget._createWriter();\n        this.auxBoxWriter = new _isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__.IsobmffBoxWriter(this.auxWriter);\n        this.mdat = null;\n        this.trackDatas = [];\n        this.allTracksKnown = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.promiseWithResolvers)();\n        this.creationTime = Math.floor(Date.now() / 1000) + TIMESTAMP_OFFSET;\n        this.finalizedChunks = [];\n        this.nextFragmentNumber = 1;\n        // Only relevant for fragmented files, to make sure new fragments start with the highest timestamp seen so far\n        this.maxWrittenTimestamp = -Infinity;\n        this.format = format;\n        this.writer = output._writer;\n        this.boxWriter = new _isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__.IsobmffBoxWriter(this.writer);\n        this.isQuickTime = format instanceof _output_format_js__WEBPACK_IMPORTED_MODULE_4__.MovOutputFormat;\n        // If the fastStart option isn't defined, enable in-memory fast start if the target is an ArrayBuffer, as the\n        // memory usage remains identical\n        const fastStartDefault = this.writer instanceof _writer_js__WEBPACK_IMPORTED_MODULE_5__.BufferTargetWriter ? 'in-memory' : false;\n        this.fastStart = format._options.fastStart ?? fastStartDefault;\n        this.isFragmented = this.fastStart === 'fragmented';\n        if (this.fastStart === 'in-memory' || this.isFragmented) {\n            this.writer.ensureMonotonicity = true;\n        }\n        this.minimumFragmentDuration = format._options.minimumFragmentDuration ?? 1;\n    }\n    async start() {\n        const release = await this.mutex.acquire();\n        const holdsAvc = this.output._tracks.some(x => x.type === 'video' && x.source._codec === 'avc');\n        // Write the header\n        {\n            if (this.format._options.onFtyp) {\n                this.writer.startTrackingWrites();\n            }\n            this.boxWriter.writeBox((0,_isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__.ftyp)({\n                isQuickTime: this.isQuickTime,\n                holdsAvc: holdsAvc,\n                fragmented: this.isFragmented,\n            }));\n            if (this.format._options.onFtyp) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onFtyp(data, start);\n            }\n        }\n        if (this.fastStart === 'in-memory') {\n            this.mdat = (0,_isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__.mdat)(false);\n        }\n        else if (this.isFragmented) {\n            // We write the moov box once we write out the first fragment to make sure we get the decoder configs\n        }\n        else {\n            if (this.format._options.onMdat) {\n                this.writer.startTrackingWrites();\n            }\n            this.mdat = (0,_isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__.mdat)(true); // Reserve large size by default, can refine this when finalizing.\n            this.boxWriter.writeBox(this.mdat);\n        }\n        await this.writer.flush();\n        release();\n    }\n    allTracksAreKnown() {\n        for (const track of this.output._tracks) {\n            if (!track.source._closed && !this.trackDatas.some(x => x.track === track)) {\n                return false; // We haven't seen a sample from this open track yet\n            }\n        }\n        return true;\n    }\n    async getMimeType() {\n        await this.allTracksKnown.promise;\n        const codecStrings = this.trackDatas.map((trackData) => {\n            if (trackData.type === 'video') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else if (trackData.type === 'audio') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else {\n                const map = {\n                    webvtt: 'wvtt',\n                };\n                return map[trackData.track.source._codec];\n            }\n        });\n        return (0,_isobmff_misc_js__WEBPACK_IMPORTED_MODULE_6__.buildIsobmffMimeType)({\n            isQuickTime: this.isQuickTime,\n            hasVideo: this.trackDatas.some(x => x.type === 'video'),\n            hasAudio: this.trackDatas.some(x => x.type === 'audio'),\n            codecStrings,\n        });\n    }\n    getVideoTrackData(track, packet, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        (0,_codec_js__WEBPACK_IMPORTED_MODULE_7__.validateVideoChunkMetadata)(meta);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(meta);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(meta.decoderConfig);\n        const decoderConfig = { ...meta.decoderConfig };\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(decoderConfig.codedWidth !== undefined);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(decoderConfig.codedHeight !== undefined);\n        let requiresAnnexBTransformation = false;\n        if (track.source._codec === 'avc' && !decoderConfig.description) {\n            // ISOBMFF can only hold AVC in the AVCC format, not in Annex B, but the missing description indicates\n            // Annex B. This means we'll need to do some converterino.\n            const decoderConfigurationRecord = (0,_codec_data_js__WEBPACK_IMPORTED_MODULE_8__.extractAvcDecoderConfigurationRecord)(packet.data);\n            if (!decoderConfigurationRecord) {\n                throw new Error('Couldn\\'t extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are'\n                    + ' in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or'\n                    + ' provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15)'\n                    + ' and ensure the packets are in AVCC format.');\n            }\n            decoderConfig.description = (0,_codec_data_js__WEBPACK_IMPORTED_MODULE_8__.serializeAvcDecoderConfigurationRecord)(decoderConfigurationRecord);\n            requiresAnnexBTransformation = true;\n        }\n        else if (track.source._codec === 'hevc' && !decoderConfig.description) {\n            // ISOBMFF can only hold HEVC in the HEVC format, not in Annex B, but the missing description indicates\n            // Annex B. This means we'll need to do some converterino.\n            const decoderConfigurationRecord = (0,_codec_data_js__WEBPACK_IMPORTED_MODULE_8__.extractHevcDecoderConfigurationRecord)(packet.data);\n            if (!decoderConfigurationRecord) {\n                throw new Error('Couldn\\'t extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets'\n                    + ' are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or'\n                    + ' provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15)'\n                    + ' and ensure the packets are in HEVC format.');\n            }\n            decoderConfig.description = (0,_codec_data_js__WEBPACK_IMPORTED_MODULE_8__.serializeHevcDecoderConfigurationRecord)(decoderConfigurationRecord);\n            requiresAnnexBTransformation = true;\n        }\n        // The frame rate set by the user may not be an integer. Since timescale is an integer, we'll approximate the\n        // frame time (inverse of frame rate) with a rational number, then use that approximation's denominator\n        // as the timescale.\n        const timescale = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.computeRationalApproximation)(1 / (track.metadata.frameRate ?? 57600), 1e6).denominator;\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'video',\n            info: {\n                width: decoderConfig.codedWidth,\n                height: decoderConfig.codedHeight,\n                decoderConfig: decoderConfig,\n                requiresAnnexBTransformation,\n            },\n            timescale,\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getAudioTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        (0,_codec_js__WEBPACK_IMPORTED_MODULE_7__.validateAudioChunkMetadata)(meta);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(meta);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(meta.decoderConfig);\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'audio',\n            info: {\n                numberOfChannels: meta.decoderConfig.numberOfChannels,\n                sampleRate: meta.decoderConfig.sampleRate,\n                decoderConfig: meta.decoderConfig,\n                requiresPcmTransformation: !this.isFragmented\n                    && _codec_js__WEBPACK_IMPORTED_MODULE_7__.PCM_AUDIO_CODECS.includes(track.source._codec),\n            },\n            timescale: meta.decoderConfig.sampleRate,\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getSubtitleTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        (0,_codec_js__WEBPACK_IMPORTED_MODULE_7__.validateSubtitleMetadata)(meta);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(meta);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(meta.config);\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'subtitle',\n            info: {\n                config: meta.config,\n            },\n            timescale: 1000, // Reasonable\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n            lastCueEndTimestamp: 0,\n            cueQueue: [],\n            nextSourceId: 0,\n            cueToSourceId: new WeakMap(),\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    async addEncodedVideoPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getVideoTrackData(track, packet, meta);\n            let packetData = packet.data;\n            if (trackData.info.requiresAnnexBTransformation) {\n                const transformedData = (0,_codec_data_js__WEBPACK_IMPORTED_MODULE_8__.transformAnnexBToLengthPrefixed)(packetData);\n                if (!transformedData) {\n                    throw new Error('Failed to transform packet data. Make sure all packets are provided in Annex B format, as'\n                        + ' specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.');\n                }\n                packetData = transformedData;\n            }\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');\n            const internalSample = this.createSampleForTrack(trackData, packetData, timestamp, packet.duration, packet.type);\n            await this.registerSample(trackData, internalSample);\n        }\n        finally {\n            release();\n        }\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getAudioTrackData(track, meta);\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');\n            const internalSample = this.createSampleForTrack(trackData, packet.data, timestamp, packet.duration, packet.type);\n            if (trackData.info.requiresPcmTransformation) {\n                await this.maybePadWithSilence(trackData, timestamp);\n            }\n            await this.registerSample(trackData, internalSample);\n        }\n        finally {\n            release();\n        }\n    }\n    async maybePadWithSilence(trackData, untilTimestamp) {\n        // The PCM transformation assumes that all samples are contiguous. This is not something that is enforced, so\n        // we need to pad the \"holes\" in between samples (and before the first sample) with additional\n        // \"silence samples\".\n        const lastSample = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.last)(trackData.samples);\n        const lastEndTimestamp = lastSample\n            ? lastSample.timestamp + lastSample.duration\n            : 0;\n        const delta = untilTimestamp - lastEndTimestamp;\n        const deltaInTimescale = intoTimescale(delta, trackData.timescale);\n        if (deltaInTimescale > 0) {\n            const { sampleSize, silentValue } = (0,_codec_js__WEBPACK_IMPORTED_MODULE_7__.parsePcmCodec)(trackData.info.decoderConfig.codec);\n            const samplesNeeded = deltaInTimescale * trackData.info.numberOfChannels;\n            const data = new Uint8Array(sampleSize * samplesNeeded).fill(silentValue);\n            const paddingSample = this.createSampleForTrack(trackData, new Uint8Array(data.buffer), lastEndTimestamp, delta, 'key');\n            await this.registerSample(trackData, paddingSample);\n        }\n    }\n    async addSubtitleCue(track, cue, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getSubtitleTrackData(track, meta);\n            this.validateAndNormalizeTimestamp(trackData.track, cue.timestamp, true);\n            if (track.source._codec === 'webvtt') {\n                trackData.cueQueue.push(cue);\n                await this.processWebVTTCues(trackData, cue.timestamp);\n            }\n            else {\n                // TODO\n            }\n        }\n        finally {\n            release();\n        }\n    }\n    async processWebVTTCues(trackData, until) {\n        // WebVTT cues need to undergo special processing as empty sections need to be padded out with samples, and\n        // overlapping samples require special logic. The algorithm produces the format specified in ISO 14496-30.\n        while (trackData.cueQueue.length > 0) {\n            const timestamps = new Set([]);\n            for (const cue of trackData.cueQueue) {\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(cue.timestamp <= until);\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(trackData.lastCueEndTimestamp <= cue.timestamp + cue.duration);\n                timestamps.add(Math.max(cue.timestamp, trackData.lastCueEndTimestamp)); // Start timestamp\n                timestamps.add(cue.timestamp + cue.duration); // End timestamp\n            }\n            const sortedTimestamps = [...timestamps].sort((a, b) => a - b);\n            // These are the timestamps of the next sample we'll create:\n            const sampleStart = sortedTimestamps[0];\n            const sampleEnd = sortedTimestamps[1] ?? sampleStart;\n            if (until < sampleEnd) {\n                break;\n            }\n            // We may need to pad out empty space with an vtte box\n            if (trackData.lastCueEndTimestamp < sampleStart) {\n                this.auxWriter.seek(0);\n                const box = (0,_isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__.vtte)();\n                this.auxBoxWriter.writeBox(box);\n                const body = this.auxWriter.getSlice(0, this.auxWriter.getPos());\n                const sample = this.createSampleForTrack(trackData, body, trackData.lastCueEndTimestamp, sampleStart - trackData.lastCueEndTimestamp, 'key');\n                await this.registerSample(trackData, sample);\n                trackData.lastCueEndTimestamp = sampleStart;\n            }\n            this.auxWriter.seek(0);\n            for (let i = 0; i < trackData.cueQueue.length; i++) {\n                const cue = trackData.cueQueue[i];\n                if (cue.timestamp >= sampleEnd) {\n                    break;\n                }\n                _subtitles_js__WEBPACK_IMPORTED_MODULE_9__.inlineTimestampRegex.lastIndex = 0;\n                const containsTimestamp = _subtitles_js__WEBPACK_IMPORTED_MODULE_9__.inlineTimestampRegex.test(cue.text);\n                const endTimestamp = cue.timestamp + cue.duration;\n                let sourceId = trackData.cueToSourceId.get(cue);\n                if (sourceId === undefined && sampleEnd < endTimestamp) {\n                    // We know this cue will appear in more than one sample, therefore we need to mark it with a\n                    // unique ID\n                    sourceId = trackData.nextSourceId++;\n                    trackData.cueToSourceId.set(cue, sourceId);\n                }\n                if (cue.notes) {\n                    // Any notes/comments are included in a special vtta box\n                    const box = (0,_isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__.vtta)(cue.notes);\n                    this.auxBoxWriter.writeBox(box);\n                }\n                const box = (0,_isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__.vttc)(cue.text, containsTimestamp ? sampleStart : null, cue.identifier ?? null, cue.settings ?? null, sourceId ?? null);\n                this.auxBoxWriter.writeBox(box);\n                if (endTimestamp === sampleEnd) {\n                    // The cue won't appear in any future sample, so we're done with it\n                    trackData.cueQueue.splice(i--, 1);\n                }\n            }\n            const body = this.auxWriter.getSlice(0, this.auxWriter.getPos());\n            const sample = this.createSampleForTrack(trackData, body, sampleStart, sampleEnd - sampleStart, 'key');\n            await this.registerSample(trackData, sample);\n            trackData.lastCueEndTimestamp = sampleEnd;\n        }\n    }\n    createSampleForTrack(trackData, data, timestamp, duration, type) {\n        const sample = {\n            timestamp,\n            decodeTimestamp: timestamp, // This may be refined later\n            duration,\n            data,\n            size: data.byteLength,\n            type,\n            timescaleUnitsToNextSample: intoTimescale(duration, trackData.timescale), // Will be refined\n        };\n        return sample;\n    }\n    processTimestamps(trackData, nextSample) {\n        if (trackData.timestampProcessingQueue.length === 0) {\n            return;\n        }\n        if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n            let totalDuration = 0;\n            // Compute the total duration in the track timescale (which is equal to the amount of PCM audio samples)\n            // and simply say that's how many new samples there are.\n            for (let i = 0; i < trackData.timestampProcessingQueue.length; i++) {\n                const sample = trackData.timestampProcessingQueue[i];\n                const duration = intoTimescale(sample.duration, trackData.timescale);\n                totalDuration += duration;\n            }\n            if (trackData.timeToSampleTable.length === 0) {\n                trackData.timeToSampleTable.push({\n                    sampleCount: totalDuration,\n                    sampleDelta: 1,\n                });\n            }\n            else {\n                const lastEntry = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.last)(trackData.timeToSampleTable);\n                lastEntry.sampleCount += totalDuration;\n            }\n            trackData.timestampProcessingQueue.length = 0;\n            return;\n        }\n        const sortedTimestamps = trackData.timestampProcessingQueue.map(x => x.timestamp).sort((a, b) => a - b);\n        for (let i = 0; i < trackData.timestampProcessingQueue.length; i++) {\n            const sample = trackData.timestampProcessingQueue[i];\n            // Since the user only supplies presentation time, but these may be out of order, we reverse-engineer from\n            // that a sensible decode timestamp. The notion of a decode timestamp doesn't really make sense\n            // (presentation timestamp & decode order are all you need), but it is a concept in ISOBMFF so we need to\n            // model it.\n            sample.decodeTimestamp = sortedTimestamps[i];\n            if (!this.isFragmented && trackData.lastTimescaleUnits === null) {\n                // In non-fragmented files, the first decode timestamp is always zero. If the first presentation\n                // timestamp isn't zero, we'll simply use the composition time offset to achieve it.\n                sample.decodeTimestamp = 0;\n            }\n            const sampleCompositionTimeOffset = intoTimescale(sample.timestamp - sample.decodeTimestamp, trackData.timescale);\n            const durationInTimescale = intoTimescale(sample.duration, trackData.timescale);\n            if (trackData.lastTimescaleUnits !== null) {\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(trackData.lastSample);\n                const timescaleUnits = intoTimescale(sample.decodeTimestamp, trackData.timescale, false);\n                const delta = Math.round(timescaleUnits - trackData.lastTimescaleUnits);\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(delta >= 0);\n                trackData.lastTimescaleUnits += delta;\n                trackData.lastSample.timescaleUnitsToNextSample = delta;\n                if (!this.isFragmented) {\n                    let lastTableEntry = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.last)(trackData.timeToSampleTable);\n                    (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(lastTableEntry);\n                    if (lastTableEntry.sampleCount === 1) {\n                        lastTableEntry.sampleDelta = delta;\n                        const entryBefore = trackData.timeToSampleTable[trackData.timeToSampleTable.length - 2];\n                        if (entryBefore && entryBefore.sampleDelta === delta) {\n                            // If the delta is the same as the previous one, merge the two entries\n                            entryBefore.sampleCount++;\n                            trackData.timeToSampleTable.pop();\n                            lastTableEntry = entryBefore;\n                        }\n                    }\n                    else if (lastTableEntry.sampleDelta !== delta) {\n                        // The delta has changed, so we need a new entry to reach the current sample\n                        lastTableEntry.sampleCount--;\n                        trackData.timeToSampleTable.push(lastTableEntry = {\n                            sampleCount: 1,\n                            sampleDelta: delta,\n                        });\n                    }\n                    if (lastTableEntry.sampleDelta === durationInTimescale) {\n                        // The sample's duration matches the delta, so we can increment the count\n                        lastTableEntry.sampleCount++;\n                    }\n                    else {\n                        // Add a new entry in order to maintain the last sample's true duration\n                        trackData.timeToSampleTable.push({\n                            sampleCount: 1,\n                            sampleDelta: durationInTimescale,\n                        });\n                    }\n                    const lastCompositionTimeOffsetTableEntry = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.last)(trackData.compositionTimeOffsetTable);\n                    (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(lastCompositionTimeOffsetTableEntry);\n                    if (lastCompositionTimeOffsetTableEntry.sampleCompositionTimeOffset === sampleCompositionTimeOffset) {\n                        // Simply increment the count\n                        lastCompositionTimeOffsetTableEntry.sampleCount++;\n                    }\n                    else {\n                        // The composition time offset has changed, so create a new entry with the new composition time\n                        // offset\n                        trackData.compositionTimeOffsetTable.push({\n                            sampleCount: 1,\n                            sampleCompositionTimeOffset: sampleCompositionTimeOffset,\n                        });\n                    }\n                }\n            }\n            else {\n                // Decode timestamp of the first sample\n                trackData.lastTimescaleUnits = intoTimescale(sample.decodeTimestamp, trackData.timescale, false);\n                if (!this.isFragmented) {\n                    trackData.timeToSampleTable.push({\n                        sampleCount: 1,\n                        sampleDelta: durationInTimescale,\n                    });\n                    trackData.compositionTimeOffsetTable.push({\n                        sampleCount: 1,\n                        sampleCompositionTimeOffset: sampleCompositionTimeOffset,\n                    });\n                }\n            }\n            trackData.lastSample = sample;\n        }\n        trackData.timestampProcessingQueue.length = 0;\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(trackData.lastSample);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(trackData.lastTimescaleUnits !== null);\n        if (nextSample !== undefined && trackData.lastSample.timescaleUnitsToNextSample === 0) {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(nextSample.type === 'key');\n            // Given the next sample, we can make a guess about the duration of the last sample. This avoids having\n            // the last sample's duration in each fragment be \"0\" for fragmented files. The guess we make here is\n            // actually correct most of the time, since typically, no delta frame with a lower timestamp follows the key\n            // frame (although it can happen).\n            const timescaleUnits = intoTimescale(nextSample.timestamp, trackData.timescale, false);\n            const delta = Math.round(timescaleUnits - trackData.lastTimescaleUnits);\n            trackData.lastSample.timescaleUnitsToNextSample = delta;\n        }\n    }\n    async registerSample(trackData, sample) {\n        if (sample.type === 'key') {\n            this.processTimestamps(trackData, sample);\n        }\n        trackData.timestampProcessingQueue.push(sample);\n        if (this.isFragmented) {\n            trackData.sampleQueue.push(sample);\n            await this.interleaveSamples();\n        }\n        else {\n            await this.addSampleToTrack(trackData, sample);\n        }\n    }\n    async addSampleToTrack(trackData, sample) {\n        if (!this.isFragmented) {\n            trackData.samples.push(sample);\n        }\n        let beginNewChunk = false;\n        if (!trackData.currentChunk) {\n            beginNewChunk = true;\n        }\n        else {\n            // Timestamp don't need to be monotonic (think B-frames), so we may need to update the start timestamp of\n            // the chunk\n            trackData.currentChunk.startTimestamp = Math.min(trackData.currentChunk.startTimestamp, sample.timestamp);\n            const currentChunkDuration = sample.timestamp - trackData.currentChunk.startTimestamp;\n            if (this.isFragmented) {\n                // We can only finalize this fragment (and begin a new one) if we know that each track will be able to\n                // start the new one with a key frame.\n                const keyFrameQueuedEverywhere = this.trackDatas.every((otherTrackData) => {\n                    if (trackData === otherTrackData) {\n                        return sample.type === 'key';\n                    }\n                    const firstQueuedSample = otherTrackData.sampleQueue[0];\n                    if (firstQueuedSample) {\n                        return firstQueuedSample.type === 'key';\n                    }\n                    return otherTrackData.track.source._closed;\n                });\n                if (currentChunkDuration >= this.minimumFragmentDuration\n                    && keyFrameQueuedEverywhere\n                    && sample.timestamp > this.maxWrittenTimestamp) {\n                    beginNewChunk = true;\n                    await this.finalizeFragment();\n                }\n            }\n            else {\n                beginNewChunk = currentChunkDuration >= 0.5; // Chunk is long enough, we need a new one\n            }\n        }\n        if (beginNewChunk) {\n            if (trackData.currentChunk) {\n                await this.finalizeCurrentChunk(trackData);\n            }\n            trackData.currentChunk = {\n                startTimestamp: sample.timestamp,\n                samples: [],\n                offset: null,\n                moofOffset: null,\n            };\n        }\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(trackData.currentChunk);\n        trackData.currentChunk.samples.push(sample);\n        if (this.isFragmented) {\n            this.maxWrittenTimestamp = Math.max(this.maxWrittenTimestamp, sample.timestamp);\n        }\n    }\n    async finalizeCurrentChunk(trackData) {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.isFragmented);\n        if (!trackData.currentChunk)\n            return;\n        trackData.finalizedChunks.push(trackData.currentChunk);\n        this.finalizedChunks.push(trackData.currentChunk);\n        let sampleCount = trackData.currentChunk.samples.length;\n        if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n            sampleCount = trackData.currentChunk.samples\n                .reduce((acc, sample) => acc + intoTimescale(sample.duration, trackData.timescale), 0);\n        }\n        if (trackData.compactlyCodedChunkTable.length === 0\n            || (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.last)(trackData.compactlyCodedChunkTable).samplesPerChunk !== sampleCount) {\n            trackData.compactlyCodedChunkTable.push({\n                firstChunk: trackData.finalizedChunks.length, // 1-indexed\n                samplesPerChunk: sampleCount,\n            });\n        }\n        if (this.fastStart === 'in-memory') {\n            trackData.currentChunk.offset = 0; // We'll compute the proper offset when finalizing\n            return;\n        }\n        // Write out the data\n        trackData.currentChunk.offset = this.writer.getPos();\n        for (const sample of trackData.currentChunk.samples) {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(sample.data);\n            this.writer.write(sample.data);\n            sample.data = null; // Can be GC'd\n        }\n        await this.writer.flush();\n    }\n    async interleaveSamples(isFinalCall = false) {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.isFragmented);\n        if (!isFinalCall) {\n            if (!this.allTracksAreKnown()) {\n                return; // We can't interleave yet as we don't yet know how many tracks we'll truly have\n            }\n        }\n        outer: while (true) {\n            let trackWithMinTimestamp = null;\n            let minTimestamp = Infinity;\n            for (const trackData of this.trackDatas) {\n                if (!isFinalCall && trackData.sampleQueue.length === 0 && !trackData.track.source._closed) {\n                    break outer;\n                }\n                if (trackData.sampleQueue.length > 0 && trackData.sampleQueue[0].timestamp < minTimestamp) {\n                    trackWithMinTimestamp = trackData;\n                    minTimestamp = trackData.sampleQueue[0].timestamp;\n                }\n            }\n            if (!trackWithMinTimestamp) {\n                break;\n            }\n            const sample = trackWithMinTimestamp.sampleQueue.shift();\n            await this.addSampleToTrack(trackWithMinTimestamp, sample);\n        }\n    }\n    async finalizeFragment(flushWriter = true) {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.isFragmented);\n        const fragmentNumber = this.nextFragmentNumber++;\n        if (fragmentNumber === 1) {\n            if (this.format._options.onMoov) {\n                this.writer.startTrackingWrites();\n            }\n            // Write the moov box now that we have all decoder configs\n            const movieBox = (0,_isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__.moov)(this, true);\n            this.boxWriter.writeBox(movieBox);\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n        }\n        // Not all tracks need to be present in every fragment\n        const tracksInFragment = this.trackDatas.filter(x => x.currentChunk);\n        // Create an initial moof box and measure it; we need this to know where the following mdat box will begin\n        const moofBox = (0,_isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__.moof)(fragmentNumber, tracksInFragment);\n        const moofOffset = this.writer.getPos();\n        const mdatStartPos = moofOffset + this.boxWriter.measureBox(moofBox);\n        let currentPos = mdatStartPos + _isobmff_reader_js__WEBPACK_IMPORTED_MODULE_10__.MIN_BOX_HEADER_SIZE;\n        let fragmentStartTimestamp = Infinity;\n        for (const trackData of tracksInFragment) {\n            trackData.currentChunk.offset = currentPos;\n            trackData.currentChunk.moofOffset = moofOffset;\n            for (const sample of trackData.currentChunk.samples) {\n                currentPos += sample.size;\n            }\n            fragmentStartTimestamp = Math.min(fragmentStartTimestamp, trackData.currentChunk.startTimestamp);\n        }\n        const mdatSize = currentPos - mdatStartPos;\n        const needsLargeMdatSize = mdatSize >= 2 ** 32;\n        if (needsLargeMdatSize) {\n            // Shift all offsets by 8. Previously, all chunks were shifted assuming the large box size, but due to what\n            // I suspect is a bug in WebKit, it failed in Safari (when livestreaming with MSE, not for static playback).\n            for (const trackData of tracksInFragment) {\n                trackData.currentChunk.offset += _isobmff_reader_js__WEBPACK_IMPORTED_MODULE_10__.MAX_BOX_HEADER_SIZE - _isobmff_reader_js__WEBPACK_IMPORTED_MODULE_10__.MIN_BOX_HEADER_SIZE;\n            }\n        }\n        if (this.format._options.onMoof) {\n            this.writer.startTrackingWrites();\n        }\n        const newMoofBox = (0,_isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__.moof)(fragmentNumber, tracksInFragment);\n        this.boxWriter.writeBox(newMoofBox);\n        if (this.format._options.onMoof) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onMoof(data, start, fragmentStartTimestamp);\n        }\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.writer.getPos() === mdatStartPos);\n        if (this.format._options.onMdat) {\n            this.writer.startTrackingWrites();\n        }\n        const mdatBox = (0,_isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__.mdat)(needsLargeMdatSize);\n        mdatBox.size = mdatSize;\n        this.boxWriter.writeBox(mdatBox);\n        this.writer.seek(mdatStartPos + (needsLargeMdatSize ? _isobmff_reader_js__WEBPACK_IMPORTED_MODULE_10__.MAX_BOX_HEADER_SIZE : _isobmff_reader_js__WEBPACK_IMPORTED_MODULE_10__.MIN_BOX_HEADER_SIZE));\n        // Write sample data\n        for (const trackData of tracksInFragment) {\n            for (const sample of trackData.currentChunk.samples) {\n                this.writer.write(sample.data);\n                sample.data = null; // Can be GC'd\n            }\n        }\n        if (this.format._options.onMdat) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onMdat(data, start);\n        }\n        for (const trackData of tracksInFragment) {\n            trackData.finalizedChunks.push(trackData.currentChunk);\n            this.finalizedChunks.push(trackData.currentChunk);\n            trackData.currentChunk = null;\n        }\n        if (flushWriter) {\n            await this.writer.flush();\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    async onTrackClose(track) {\n        const release = await this.mutex.acquire();\n        if (track.type === 'subtitle' && track.source._codec === 'webvtt') {\n            const trackData = this.trackDatas.find(x => x.track === track);\n            if (trackData) {\n                await this.processWebVTTCues(trackData, Infinity);\n            }\n        }\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        if (this.isFragmented) {\n            // Since a track is now closed, we may be able to write out chunks that were previously waiting\n            await this.interleaveSamples();\n        }\n        release();\n    }\n    /** Finalizes the file, making it ready for use. Must be called after all video and audio chunks have been added. */\n    async finalize() {\n        const release = await this.mutex.acquire();\n        this.allTracksKnown.resolve();\n        for (const trackData of this.trackDatas) {\n            if (trackData.type === 'subtitle' && trackData.track.source._codec === 'webvtt') {\n                await this.processWebVTTCues(trackData, Infinity);\n            }\n        }\n        if (this.isFragmented) {\n            await this.interleaveSamples(true);\n            for (const trackData of this.trackDatas) {\n                this.processTimestamps(trackData);\n            }\n            await this.finalizeFragment(false); // Don't flush the last fragment as we will flush it with the mfra box\n        }\n        else {\n            for (const trackData of this.trackDatas) {\n                this.processTimestamps(trackData);\n                await this.finalizeCurrentChunk(trackData);\n            }\n        }\n        if (this.fastStart === 'in-memory') {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.mdat);\n            let mdatSize;\n            // We know how many chunks there are, but computing the chunk positions requires an iterative approach:\n            // In order to know where the first chunk should go, we first need to know the size of the moov box. But we\n            // cannot write a proper moov box without first knowing all chunk positions. So, we generate a tentative\n            // moov box with placeholder values (0) for the chunk offsets to be able to compute its size. If it then\n            // turns out that appending all chunks exceeds 4 GiB, we need to repeat this process, now with the co64 box\n            // being used in the moov box instead, which will make it larger. After that, we definitely know the final\n            // size of the moov box and can compute the proper chunk positions.\n            for (let i = 0; i < 2; i++) {\n                const movieBox = (0,_isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__.moov)(this);\n                const movieBoxSize = this.boxWriter.measureBox(movieBox);\n                mdatSize = this.boxWriter.measureBox(this.mdat);\n                let currentChunkPos = this.writer.getPos() + movieBoxSize + mdatSize;\n                for (const chunk of this.finalizedChunks) {\n                    chunk.offset = currentChunkPos;\n                    for (const { data } of chunk.samples) {\n                        (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(data);\n                        currentChunkPos += data.byteLength;\n                        mdatSize += data.byteLength;\n                    }\n                }\n                if (currentChunkPos < 2 ** 32)\n                    break;\n                if (mdatSize >= 2 ** 32)\n                    this.mdat.largeSize = true;\n            }\n            if (this.format._options.onMoov) {\n                this.writer.startTrackingWrites();\n            }\n            const movieBox = (0,_isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__.moov)(this);\n            this.boxWriter.writeBox(movieBox);\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n            if (this.format._options.onMdat) {\n                this.writer.startTrackingWrites();\n            }\n            this.mdat.size = mdatSize;\n            this.boxWriter.writeBox(this.mdat);\n            for (const chunk of this.finalizedChunks) {\n                for (const sample of chunk.samples) {\n                    (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(sample.data);\n                    this.writer.write(sample.data);\n                    sample.data = null;\n                }\n            }\n            if (this.format._options.onMdat) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMdat(data, start);\n            }\n        }\n        else if (this.isFragmented) {\n            // Append the mfra box to the end of the file for better random access\n            const startPos = this.writer.getPos();\n            const mfraBox = (0,_isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__.mfra)(this.trackDatas);\n            this.boxWriter.writeBox(mfraBox);\n            // Patch the 'size' field of the mfro box at the end of the mfra box now that we know its actual size\n            const mfraBoxSize = this.writer.getPos() - startPos;\n            this.writer.seek(this.writer.getPos() - 4);\n            this.boxWriter.writeU32(mfraBoxSize);\n        }\n        else {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.mdat);\n            const mdatPos = this.boxWriter.offsets.get(this.mdat);\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(mdatPos !== undefined);\n            const mdatSize = this.writer.getPos() - mdatPos;\n            this.mdat.size = mdatSize;\n            this.mdat.largeSize = mdatSize >= 2 ** 32; // Only use the large size if we need it\n            this.boxWriter.patchBox(this.mdat);\n            if (this.format._options.onMdat) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMdat(data, start);\n            }\n            if (this.format._options.onMoov) {\n                this.writer.startTrackingWrites();\n            }\n            const movieBox = (0,_isobmff_boxes_js__WEBPACK_IMPORTED_MODULE_2__.moov)(this);\n            this.boxWriter.writeBox(movieBox);\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n        }\n        release();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL2lzb2JtZmYvaXNvYm1mZi1tdXhlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzRztBQUNsRTtBQUNjO0FBQzRDO0FBQ3hDO0FBQ0M7QUFDMEY7QUFDckc7QUFDc0w7QUFDeks7QUFDc0I7QUFDeEU7QUFDUCx3Q0FBd0M7QUFDakM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLDRDQUFLO0FBQ3ZDO0FBQ0E7QUFDQSw2QkFBNkIsb0RBQVk7QUFDekM7QUFDQSxnQ0FBZ0MsK0RBQWdCO0FBQ2hEO0FBQ0E7QUFDQSw4QkFBOEIsOERBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtEQUFnQjtBQUM3Qyw2Q0FBNkMsOERBQWU7QUFDNUQ7QUFDQTtBQUNBLHdEQUF3RCwwREFBa0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVEQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFJO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdURBQUksUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVEQUFJO0FBQ2pDO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0RBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1REFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQU07QUFDbEI7QUFDQSxZQUFZLGdEQUFNO0FBQ2xCO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdURBQUk7QUFDakM7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGNoLWN1dC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL2lzb2JtZmYvaXNvYm1mZi1tdXhlci5qcz9mN2M2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDI1LXByZXNlbnQsIFZhbmlsYWd5IGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgZnR5cCwgSXNvYm1mZkJveFdyaXRlciwgbWRhdCwgbWZyYSwgbW9vZiwgbW9vdiwgdnR0YSwgdnR0YywgdnR0ZSB9IGZyb20gJy4vaXNvYm1mZi1ib3hlcy5qcyc7XG5pbXBvcnQgeyBNdXhlciB9IGZyb20gJy4uL211eGVyLmpzJztcbmltcG9ydCB7IEJ1ZmZlclRhcmdldFdyaXRlciB9IGZyb20gJy4uL3dyaXRlci5qcyc7XG5pbXBvcnQgeyBhc3NlcnQsIGNvbXB1dGVSYXRpb25hbEFwcHJveGltYXRpb24sIGxhc3QsIHByb21pc2VXaXRoUmVzb2x2ZXJzIH0gZnJvbSAnLi4vbWlzYy5qcyc7XG5pbXBvcnQgeyBNb3ZPdXRwdXRGb3JtYXQgfSBmcm9tICcuLi9vdXRwdXQtZm9ybWF0LmpzJztcbmltcG9ydCB7IGlubGluZVRpbWVzdGFtcFJlZ2V4IH0gZnJvbSAnLi4vc3VidGl0bGVzLmpzJztcbmltcG9ydCB7IHBhcnNlUGNtQ29kZWMsIFBDTV9BVURJT19DT0RFQ1MsIHZhbGlkYXRlQXVkaW9DaHVua01ldGFkYXRhLCB2YWxpZGF0ZVN1YnRpdGxlTWV0YWRhdGEsIHZhbGlkYXRlVmlkZW9DaHVua01ldGFkYXRhLCB9IGZyb20gJy4uL2NvZGVjLmpzJztcbmltcG9ydCB7IEJ1ZmZlclRhcmdldCB9IGZyb20gJy4uL3RhcmdldC5qcyc7XG5pbXBvcnQgeyBleHRyYWN0QXZjRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmQsIGV4dHJhY3RIZXZjRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmQsIHNlcmlhbGl6ZUF2Y0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkLCBzZXJpYWxpemVIZXZjRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmQsIHRyYW5zZm9ybUFubmV4QlRvTGVuZ3RoUHJlZml4ZWQsIH0gZnJvbSAnLi4vY29kZWMtZGF0YS5qcyc7XG5pbXBvcnQgeyBidWlsZElzb2JtZmZNaW1lVHlwZSB9IGZyb20gJy4vaXNvYm1mZi1taXNjLmpzJztcbmltcG9ydCB7IE1BWF9CT1hfSEVBREVSX1NJWkUsIE1JTl9CT1hfSEVBREVSX1NJWkUgfSBmcm9tICcuL2lzb2JtZmYtcmVhZGVyLmpzJztcbmV4cG9ydCBjb25zdCBHTE9CQUxfVElNRVNDQUxFID0gMTAwMDtcbmNvbnN0IFRJTUVTVEFNUF9PRkZTRVQgPSAyXzA4Ml84NDRfODAwOyAvLyBTZWNvbmRzIGJldHdlZW4gSmFuIDEgMTkwNCBhbmQgSmFuIDEgMTk3MFxuZXhwb3J0IGNvbnN0IGdldFRyYWNrTWV0YWRhdGEgPSAodHJhY2tEYXRhKSA9PiB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB7fTtcbiAgICBjb25zdCB0cmFjayA9IHRyYWNrRGF0YS50cmFjaztcbiAgICBpZiAodHJhY2subWV0YWRhdGEubmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1ldGFkYXRhLm5hbWUgPSB0cmFjay5tZXRhZGF0YS5uYW1lO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YWRhdGE7XG59O1xuZXhwb3J0IGNvbnN0IGludG9UaW1lc2NhbGUgPSAodGltZUluU2Vjb25kcywgdGltZXNjYWxlLCByb3VuZCA9IHRydWUpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHRpbWVJblNlY29uZHMgKiB0aW1lc2NhbGU7XG4gICAgcmV0dXJuIHJvdW5kID8gTWF0aC5yb3VuZCh2YWx1ZSkgOiB2YWx1ZTtcbn07XG5leHBvcnQgY2xhc3MgSXNvYm1mZk11eGVyIGV4dGVuZHMgTXV4ZXIge1xuICAgIGNvbnN0cnVjdG9yKG91dHB1dCwgZm9ybWF0KSB7XG4gICAgICAgIHN1cGVyKG91dHB1dCk7XG4gICAgICAgIHRoaXMuYXV4VGFyZ2V0ID0gbmV3IEJ1ZmZlclRhcmdldCgpO1xuICAgICAgICB0aGlzLmF1eFdyaXRlciA9IHRoaXMuYXV4VGFyZ2V0Ll9jcmVhdGVXcml0ZXIoKTtcbiAgICAgICAgdGhpcy5hdXhCb3hXcml0ZXIgPSBuZXcgSXNvYm1mZkJveFdyaXRlcih0aGlzLmF1eFdyaXRlcik7XG4gICAgICAgIHRoaXMubWRhdCA9IG51bGw7XG4gICAgICAgIHRoaXMudHJhY2tEYXRhcyA9IFtdO1xuICAgICAgICB0aGlzLmFsbFRyYWNrc0tub3duID0gcHJvbWlzZVdpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgdGhpcy5jcmVhdGlvblRpbWUgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIFRJTUVTVEFNUF9PRkZTRVQ7XG4gICAgICAgIHRoaXMuZmluYWxpemVkQ2h1bmtzID0gW107XG4gICAgICAgIHRoaXMubmV4dEZyYWdtZW50TnVtYmVyID0gMTtcbiAgICAgICAgLy8gT25seSByZWxldmFudCBmb3IgZnJhZ21lbnRlZCBmaWxlcywgdG8gbWFrZSBzdXJlIG5ldyBmcmFnbWVudHMgc3RhcnQgd2l0aCB0aGUgaGlnaGVzdCB0aW1lc3RhbXAgc2VlbiBzbyBmYXJcbiAgICAgICAgdGhpcy5tYXhXcml0dGVuVGltZXN0YW1wID0gLUluZmluaXR5O1xuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgdGhpcy53cml0ZXIgPSBvdXRwdXQuX3dyaXRlcjtcbiAgICAgICAgdGhpcy5ib3hXcml0ZXIgPSBuZXcgSXNvYm1mZkJveFdyaXRlcih0aGlzLndyaXRlcik7XG4gICAgICAgIHRoaXMuaXNRdWlja1RpbWUgPSBmb3JtYXQgaW5zdGFuY2VvZiBNb3ZPdXRwdXRGb3JtYXQ7XG4gICAgICAgIC8vIElmIHRoZSBmYXN0U3RhcnQgb3B0aW9uIGlzbid0IGRlZmluZWQsIGVuYWJsZSBpbi1tZW1vcnkgZmFzdCBzdGFydCBpZiB0aGUgdGFyZ2V0IGlzIGFuIEFycmF5QnVmZmVyLCBhcyB0aGVcbiAgICAgICAgLy8gbWVtb3J5IHVzYWdlIHJlbWFpbnMgaWRlbnRpY2FsXG4gICAgICAgIGNvbnN0IGZhc3RTdGFydERlZmF1bHQgPSB0aGlzLndyaXRlciBpbnN0YW5jZW9mIEJ1ZmZlclRhcmdldFdyaXRlciA/ICdpbi1tZW1vcnknIDogZmFsc2U7XG4gICAgICAgIHRoaXMuZmFzdFN0YXJ0ID0gZm9ybWF0Ll9vcHRpb25zLmZhc3RTdGFydCA/PyBmYXN0U3RhcnREZWZhdWx0O1xuICAgICAgICB0aGlzLmlzRnJhZ21lbnRlZCA9IHRoaXMuZmFzdFN0YXJ0ID09PSAnZnJhZ21lbnRlZCc7XG4gICAgICAgIGlmICh0aGlzLmZhc3RTdGFydCA9PT0gJ2luLW1lbW9yeScgfHwgdGhpcy5pc0ZyYWdtZW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVyLmVuc3VyZU1vbm90b25pY2l0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5pbXVtRnJhZ21lbnREdXJhdGlvbiA9IGZvcm1hdC5fb3B0aW9ucy5taW5pbXVtRnJhZ21lbnREdXJhdGlvbiA/PyAxO1xuICAgIH1cbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgY29uc3QgcmVsZWFzZSA9IGF3YWl0IHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICBjb25zdCBob2xkc0F2YyA9IHRoaXMub3V0cHV0Ll90cmFja3Muc29tZSh4ID0+IHgudHlwZSA9PT0gJ3ZpZGVvJyAmJiB4LnNvdXJjZS5fY29kZWMgPT09ICdhdmMnKTtcbiAgICAgICAgLy8gV3JpdGUgdGhlIGhlYWRlclxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb3JtYXQuX29wdGlvbnMub25GdHlwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZXIuc3RhcnRUcmFja2luZ1dyaXRlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ib3hXcml0ZXIud3JpdGVCb3goZnR5cCh7XG4gICAgICAgICAgICAgICAgaXNRdWlja1RpbWU6IHRoaXMuaXNRdWlja1RpbWUsXG4gICAgICAgICAgICAgICAgaG9sZHNBdmM6IGhvbGRzQXZjLFxuICAgICAgICAgICAgICAgIGZyYWdtZW50ZWQ6IHRoaXMuaXNGcmFnbWVudGVkLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybWF0Ll9vcHRpb25zLm9uRnR5cCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgc3RhcnQgfSA9IHRoaXMud3JpdGVyLnN0b3BUcmFja2luZ1dyaXRlcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0Ll9vcHRpb25zLm9uRnR5cChkYXRhLCBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmFzdFN0YXJ0ID09PSAnaW4tbWVtb3J5Jykge1xuICAgICAgICAgICAgdGhpcy5tZGF0ID0gbWRhdChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc0ZyYWdtZW50ZWQpIHtcbiAgICAgICAgICAgIC8vIFdlIHdyaXRlIHRoZSBtb292IGJveCBvbmNlIHdlIHdyaXRlIG91dCB0aGUgZmlyc3QgZnJhZ21lbnQgdG8gbWFrZSBzdXJlIHdlIGdldCB0aGUgZGVjb2RlciBjb25maWdzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb3JtYXQuX29wdGlvbnMub25NZGF0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZXIuc3RhcnRUcmFja2luZ1dyaXRlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tZGF0ID0gbWRhdCh0cnVlKTsgLy8gUmVzZXJ2ZSBsYXJnZSBzaXplIGJ5IGRlZmF1bHQsIGNhbiByZWZpbmUgdGhpcyB3aGVuIGZpbmFsaXppbmcuXG4gICAgICAgICAgICB0aGlzLmJveFdyaXRlci53cml0ZUJveCh0aGlzLm1kYXQpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLmZsdXNoKCk7XG4gICAgICAgIHJlbGVhc2UoKTtcbiAgICB9XG4gICAgYWxsVHJhY2tzQXJlS25vd24oKSB7XG4gICAgICAgIGZvciAoY29uc3QgdHJhY2sgb2YgdGhpcy5vdXRwdXQuX3RyYWNrcykge1xuICAgICAgICAgICAgaWYgKCF0cmFjay5zb3VyY2UuX2Nsb3NlZCAmJiAhdGhpcy50cmFja0RhdGFzLnNvbWUoeCA9PiB4LnRyYWNrID09PSB0cmFjaykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFdlIGhhdmVuJ3Qgc2VlbiBhIHNhbXBsZSBmcm9tIHRoaXMgb3BlbiB0cmFjayB5ZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TWltZVR5cGUoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYWxsVHJhY2tzS25vd24ucHJvbWlzZTtcbiAgICAgICAgY29uc3QgY29kZWNTdHJpbmdzID0gdGhpcy50cmFja0RhdGFzLm1hcCgodHJhY2tEYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAodHJhY2tEYXRhLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2tEYXRhLmluZm8uZGVjb2RlckNvbmZpZy5jb2RlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRyYWNrRGF0YS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNrRGF0YS5pbmZvLmRlY29kZXJDb25maWcuY29kZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXAgPSB7XG4gICAgICAgICAgICAgICAgICAgIHdlYnZ0dDogJ3d2dHQnLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcFt0cmFja0RhdGEudHJhY2suc291cmNlLl9jb2RlY107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYnVpbGRJc29ibWZmTWltZVR5cGUoe1xuICAgICAgICAgICAgaXNRdWlja1RpbWU6IHRoaXMuaXNRdWlja1RpbWUsXG4gICAgICAgICAgICBoYXNWaWRlbzogdGhpcy50cmFja0RhdGFzLnNvbWUoeCA9PiB4LnR5cGUgPT09ICd2aWRlbycpLFxuICAgICAgICAgICAgaGFzQXVkaW86IHRoaXMudHJhY2tEYXRhcy5zb21lKHggPT4geC50eXBlID09PSAnYXVkaW8nKSxcbiAgICAgICAgICAgIGNvZGVjU3RyaW5ncyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFZpZGVvVHJhY2tEYXRhKHRyYWNrLCBwYWNrZXQsIG1ldGEpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdUcmFja0RhdGEgPSB0aGlzLnRyYWNrRGF0YXMuZmluZCh4ID0+IHgudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nVHJhY2tEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdUcmFja0RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVWaWRlb0NodW5rTWV0YWRhdGEobWV0YSk7XG4gICAgICAgIGFzc2VydChtZXRhKTtcbiAgICAgICAgYXNzZXJ0KG1ldGEuZGVjb2RlckNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGRlY29kZXJDb25maWcgPSB7IC4uLm1ldGEuZGVjb2RlckNvbmZpZyB9O1xuICAgICAgICBhc3NlcnQoZGVjb2RlckNvbmZpZy5jb2RlZFdpZHRoICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBhc3NlcnQoZGVjb2RlckNvbmZpZy5jb2RlZEhlaWdodCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgbGV0IHJlcXVpcmVzQW5uZXhCVHJhbnNmb3JtYXRpb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKHRyYWNrLnNvdXJjZS5fY29kZWMgPT09ICdhdmMnICYmICFkZWNvZGVyQ29uZmlnLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAvLyBJU09CTUZGIGNhbiBvbmx5IGhvbGQgQVZDIGluIHRoZSBBVkNDIGZvcm1hdCwgbm90IGluIEFubmV4IEIsIGJ1dCB0aGUgbWlzc2luZyBkZXNjcmlwdGlvbiBpbmRpY2F0ZXNcbiAgICAgICAgICAgIC8vIEFubmV4IEIuIFRoaXMgbWVhbnMgd2UnbGwgbmVlZCB0byBkbyBzb21lIGNvbnZlcnRlcmluby5cbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkID0gZXh0cmFjdEF2Y0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkKHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIGlmICghZGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkblxcJ3QgZXh0cmFjdCBhbiBBVkNEZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZCBmcm9tIHRoZSBBVkMgcGFja2V0LiBNYWtlIHN1cmUgdGhlIHBhY2tldHMgYXJlJ1xuICAgICAgICAgICAgICAgICAgICArICcgaW4gQW5uZXggQiBmb3JtYXQgKGFzIHNwZWNpZmllZCBpbiBJVFUtVC1SRUMtSC4yNjQpIHdoZW4gbm90IHByb3ZpZGluZyBhIGRlc2NyaXB0aW9uLCBvcidcbiAgICAgICAgICAgICAgICAgICAgKyAnIHByb3ZpZGUgYSBkZXNjcmlwdGlvbiAobXVzdCBiZSBhbiBBVkNEZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZCBhcyBzcGVjaWZpZWQgaW4gSVNPIDE0NDk2LTE1KSdcbiAgICAgICAgICAgICAgICAgICAgKyAnIGFuZCBlbnN1cmUgdGhlIHBhY2tldHMgYXJlIGluIEFWQ0MgZm9ybWF0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlckNvbmZpZy5kZXNjcmlwdGlvbiA9IHNlcmlhbGl6ZUF2Y0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkKGRlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkKTtcbiAgICAgICAgICAgIHJlcXVpcmVzQW5uZXhCVHJhbnNmb3JtYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRyYWNrLnNvdXJjZS5fY29kZWMgPT09ICdoZXZjJyAmJiAhZGVjb2RlckNvbmZpZy5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgLy8gSVNPQk1GRiBjYW4gb25seSBob2xkIEhFVkMgaW4gdGhlIEhFVkMgZm9ybWF0LCBub3QgaW4gQW5uZXggQiwgYnV0IHRoZSBtaXNzaW5nIGRlc2NyaXB0aW9uIGluZGljYXRlc1xuICAgICAgICAgICAgLy8gQW5uZXggQi4gVGhpcyBtZWFucyB3ZSdsbCBuZWVkIHRvIGRvIHNvbWUgY29udmVydGVyaW5vLlxuICAgICAgICAgICAgY29uc3QgZGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmQgPSBleHRyYWN0SGV2Y0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkKHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIGlmICghZGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkblxcJ3QgZXh0cmFjdCBhbiBIRVZDRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmQgZnJvbSB0aGUgSEVWQyBwYWNrZXQuIE1ha2Ugc3VyZSB0aGUgcGFja2V0cydcbiAgICAgICAgICAgICAgICAgICAgKyAnIGFyZSBpbiBBbm5leCBCIGZvcm1hdCAoYXMgc3BlY2lmaWVkIGluIElUVS1ULVJFQy1ILjI2NSkgd2hlbiBub3QgcHJvdmlkaW5nIGEgZGVzY3JpcHRpb24sIG9yJ1xuICAgICAgICAgICAgICAgICAgICArICcgcHJvdmlkZSBhIGRlc2NyaXB0aW9uIChtdXN0IGJlIGFuIEhFVkNEZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZCBhcyBzcGVjaWZpZWQgaW4gSVNPIDE0NDk2LTE1KSdcbiAgICAgICAgICAgICAgICAgICAgKyAnIGFuZCBlbnN1cmUgdGhlIHBhY2tldHMgYXJlIGluIEhFVkMgZm9ybWF0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlckNvbmZpZy5kZXNjcmlwdGlvbiA9IHNlcmlhbGl6ZUhldmNEZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZChkZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZCk7XG4gICAgICAgICAgICByZXF1aXJlc0FubmV4QlRyYW5zZm9ybWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgZnJhbWUgcmF0ZSBzZXQgYnkgdGhlIHVzZXIgbWF5IG5vdCBiZSBhbiBpbnRlZ2VyLiBTaW5jZSB0aW1lc2NhbGUgaXMgYW4gaW50ZWdlciwgd2UnbGwgYXBwcm94aW1hdGUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRpbWUgKGludmVyc2Ugb2YgZnJhbWUgcmF0ZSkgd2l0aCBhIHJhdGlvbmFsIG51bWJlciwgdGhlbiB1c2UgdGhhdCBhcHByb3hpbWF0aW9uJ3MgZGVub21pbmF0b3JcbiAgICAgICAgLy8gYXMgdGhlIHRpbWVzY2FsZS5cbiAgICAgICAgY29uc3QgdGltZXNjYWxlID0gY29tcHV0ZVJhdGlvbmFsQXBwcm94aW1hdGlvbigxIC8gKHRyYWNrLm1ldGFkYXRhLmZyYW1lUmF0ZSA/PyA1NzYwMCksIDFlNikuZGVub21pbmF0b3I7XG4gICAgICAgIGNvbnN0IG5ld1RyYWNrRGF0YSA9IHtcbiAgICAgICAgICAgIG11eGVyOiB0aGlzLFxuICAgICAgICAgICAgdHJhY2ssXG4gICAgICAgICAgICB0eXBlOiAndmlkZW8nLFxuICAgICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBkZWNvZGVyQ29uZmlnLmNvZGVkV2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBkZWNvZGVyQ29uZmlnLmNvZGVkSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGRlY29kZXJDb25maWc6IGRlY29kZXJDb25maWcsXG4gICAgICAgICAgICAgICAgcmVxdWlyZXNBbm5leEJUcmFuc2Zvcm1hdGlvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aW1lc2NhbGUsXG4gICAgICAgICAgICBzYW1wbGVzOiBbXSxcbiAgICAgICAgICAgIHNhbXBsZVF1ZXVlOiBbXSxcbiAgICAgICAgICAgIHRpbWVzdGFtcFByb2Nlc3NpbmdRdWV1ZTogW10sXG4gICAgICAgICAgICB0aW1lVG9TYW1wbGVUYWJsZTogW10sXG4gICAgICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXRUYWJsZTogW10sXG4gICAgICAgICAgICBsYXN0VGltZXNjYWxlVW5pdHM6IG51bGwsXG4gICAgICAgICAgICBsYXN0U2FtcGxlOiBudWxsLFxuICAgICAgICAgICAgZmluYWxpemVkQ2h1bmtzOiBbXSxcbiAgICAgICAgICAgIGN1cnJlbnRDaHVuazogbnVsbCxcbiAgICAgICAgICAgIGNvbXBhY3RseUNvZGVkQ2h1bmtUYWJsZTogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJhY2tEYXRhcy5wdXNoKG5ld1RyYWNrRGF0YSk7XG4gICAgICAgIHRoaXMudHJhY2tEYXRhcy5zb3J0KChhLCBiKSA9PiBhLnRyYWNrLmlkIC0gYi50cmFjay5pZCk7XG4gICAgICAgIGlmICh0aGlzLmFsbFRyYWNrc0FyZUtub3duKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsVHJhY2tzS25vd24ucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdUcmFja0RhdGE7XG4gICAgfVxuICAgIGdldEF1ZGlvVHJhY2tEYXRhKHRyYWNrLCBtZXRhKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVHJhY2tEYXRhID0gdGhpcy50cmFja0RhdGFzLmZpbmQoeCA9PiB4LnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgIGlmIChleGlzdGluZ1RyYWNrRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nVHJhY2tEYXRhO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlQXVkaW9DaHVua01ldGFkYXRhKG1ldGEpO1xuICAgICAgICBhc3NlcnQobWV0YSk7XG4gICAgICAgIGFzc2VydChtZXRhLmRlY29kZXJDb25maWcpO1xuICAgICAgICBjb25zdCBuZXdUcmFja0RhdGEgPSB7XG4gICAgICAgICAgICBtdXhlcjogdGhpcyxcbiAgICAgICAgICAgIHRyYWNrLFxuICAgICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgICAgICBudW1iZXJPZkNoYW5uZWxzOiBtZXRhLmRlY29kZXJDb25maWcubnVtYmVyT2ZDaGFubmVscyxcbiAgICAgICAgICAgICAgICBzYW1wbGVSYXRlOiBtZXRhLmRlY29kZXJDb25maWcuc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgICAgICBkZWNvZGVyQ29uZmlnOiBtZXRhLmRlY29kZXJDb25maWcsXG4gICAgICAgICAgICAgICAgcmVxdWlyZXNQY21UcmFuc2Zvcm1hdGlvbjogIXRoaXMuaXNGcmFnbWVudGVkXG4gICAgICAgICAgICAgICAgICAgICYmIFBDTV9BVURJT19DT0RFQ1MuaW5jbHVkZXModHJhY2suc291cmNlLl9jb2RlYyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltZXNjYWxlOiBtZXRhLmRlY29kZXJDb25maWcuc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgICAgICAgc2FtcGxlUXVldWU6IFtdLFxuICAgICAgICAgICAgdGltZXN0YW1wUHJvY2Vzc2luZ1F1ZXVlOiBbXSxcbiAgICAgICAgICAgIHRpbWVUb1NhbXBsZVRhYmxlOiBbXSxcbiAgICAgICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldFRhYmxlOiBbXSxcbiAgICAgICAgICAgIGxhc3RUaW1lc2NhbGVVbml0czogbnVsbCxcbiAgICAgICAgICAgIGxhc3RTYW1wbGU6IG51bGwsXG4gICAgICAgICAgICBmaW5hbGl6ZWRDaHVua3M6IFtdLFxuICAgICAgICAgICAgY3VycmVudENodW5rOiBudWxsLFxuICAgICAgICAgICAgY29tcGFjdGx5Q29kZWRDaHVua1RhYmxlOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFja0RhdGFzLnB1c2gobmV3VHJhY2tEYXRhKTtcbiAgICAgICAgdGhpcy50cmFja0RhdGFzLnNvcnQoKGEsIGIpID0+IGEudHJhY2suaWQgLSBiLnRyYWNrLmlkKTtcbiAgICAgICAgaWYgKHRoaXMuYWxsVHJhY2tzQXJlS25vd24oKSkge1xuICAgICAgICAgICAgdGhpcy5hbGxUcmFja3NLbm93bi5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1RyYWNrRGF0YTtcbiAgICB9XG4gICAgZ2V0U3VidGl0bGVUcmFja0RhdGEodHJhY2ssIG1ldGEpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdUcmFja0RhdGEgPSB0aGlzLnRyYWNrRGF0YXMuZmluZCh4ID0+IHgudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nVHJhY2tEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdUcmFja0RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVTdWJ0aXRsZU1ldGFkYXRhKG1ldGEpO1xuICAgICAgICBhc3NlcnQobWV0YSk7XG4gICAgICAgIGFzc2VydChtZXRhLmNvbmZpZyk7XG4gICAgICAgIGNvbnN0IG5ld1RyYWNrRGF0YSA9IHtcbiAgICAgICAgICAgIG11eGVyOiB0aGlzLFxuICAgICAgICAgICAgdHJhY2ssXG4gICAgICAgICAgICB0eXBlOiAnc3VidGl0bGUnLFxuICAgICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgICAgIGNvbmZpZzogbWV0YS5jb25maWcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltZXNjYWxlOiAxMDAwLCAvLyBSZWFzb25hYmxlXG4gICAgICAgICAgICBzYW1wbGVzOiBbXSxcbiAgICAgICAgICAgIHNhbXBsZVF1ZXVlOiBbXSxcbiAgICAgICAgICAgIHRpbWVzdGFtcFByb2Nlc3NpbmdRdWV1ZTogW10sXG4gICAgICAgICAgICB0aW1lVG9TYW1wbGVUYWJsZTogW10sXG4gICAgICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXRUYWJsZTogW10sXG4gICAgICAgICAgICBsYXN0VGltZXNjYWxlVW5pdHM6IG51bGwsXG4gICAgICAgICAgICBsYXN0U2FtcGxlOiBudWxsLFxuICAgICAgICAgICAgZmluYWxpemVkQ2h1bmtzOiBbXSxcbiAgICAgICAgICAgIGN1cnJlbnRDaHVuazogbnVsbCxcbiAgICAgICAgICAgIGNvbXBhY3RseUNvZGVkQ2h1bmtUYWJsZTogW10sXG4gICAgICAgICAgICBsYXN0Q3VlRW5kVGltZXN0YW1wOiAwLFxuICAgICAgICAgICAgY3VlUXVldWU6IFtdLFxuICAgICAgICAgICAgbmV4dFNvdXJjZUlkOiAwLFxuICAgICAgICAgICAgY3VlVG9Tb3VyY2VJZDogbmV3IFdlYWtNYXAoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFja0RhdGFzLnB1c2gobmV3VHJhY2tEYXRhKTtcbiAgICAgICAgdGhpcy50cmFja0RhdGFzLnNvcnQoKGEsIGIpID0+IGEudHJhY2suaWQgLSBiLnRyYWNrLmlkKTtcbiAgICAgICAgaWYgKHRoaXMuYWxsVHJhY2tzQXJlS25vd24oKSkge1xuICAgICAgICAgICAgdGhpcy5hbGxUcmFja3NLbm93bi5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1RyYWNrRGF0YTtcbiAgICB9XG4gICAgYXN5bmMgYWRkRW5jb2RlZFZpZGVvUGFja2V0KHRyYWNrLCBwYWNrZXQsIG1ldGEpIHtcbiAgICAgICAgY29uc3QgcmVsZWFzZSA9IGF3YWl0IHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdHJhY2tEYXRhID0gdGhpcy5nZXRWaWRlb1RyYWNrRGF0YSh0cmFjaywgcGFja2V0LCBtZXRhKTtcbiAgICAgICAgICAgIGxldCBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG4gICAgICAgICAgICBpZiAodHJhY2tEYXRhLmluZm8ucmVxdWlyZXNBbm5leEJUcmFuc2Zvcm1hdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkRGF0YSA9IHRyYW5zZm9ybUFubmV4QlRvTGVuZ3RoUHJlZml4ZWQocGFja2V0RGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmFuc2Zvcm1lZERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdHJhbnNmb3JtIHBhY2tldCBkYXRhLiBNYWtlIHN1cmUgYWxsIHBhY2tldHMgYXJlIHByb3ZpZGVkIGluIEFubmV4IEIgZm9ybWF0LCBhcydcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJyBzcGVjaWZpZWQgaW4gSVRVLVQtUkVDLUguMjY0IGFuZCBJVFUtVC1SRUMtSC4yNjUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhY2tldERhdGEgPSB0cmFuc2Zvcm1lZERhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSB0aGlzLnZhbGlkYXRlQW5kTm9ybWFsaXplVGltZXN0YW1wKHRyYWNrRGF0YS50cmFjaywgcGFja2V0LnRpbWVzdGFtcCwgcGFja2V0LnR5cGUgPT09ICdrZXknKTtcbiAgICAgICAgICAgIGNvbnN0IGludGVybmFsU2FtcGxlID0gdGhpcy5jcmVhdGVTYW1wbGVGb3JUcmFjayh0cmFja0RhdGEsIHBhY2tldERhdGEsIHRpbWVzdGFtcCwgcGFja2V0LmR1cmF0aW9uLCBwYWNrZXQudHlwZSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlZ2lzdGVyU2FtcGxlKHRyYWNrRGF0YSwgaW50ZXJuYWxTYW1wbGUpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGFkZEVuY29kZWRBdWRpb1BhY2tldCh0cmFjaywgcGFja2V0LCBtZXRhKSB7XG4gICAgICAgIGNvbnN0IHJlbGVhc2UgPSBhd2FpdCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrRGF0YSA9IHRoaXMuZ2V0QXVkaW9UcmFja0RhdGEodHJhY2ssIG1ldGEpO1xuICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gdGhpcy52YWxpZGF0ZUFuZE5vcm1hbGl6ZVRpbWVzdGFtcCh0cmFja0RhdGEudHJhY2ssIHBhY2tldC50aW1lc3RhbXAsIHBhY2tldC50eXBlID09PSAna2V5Jyk7XG4gICAgICAgICAgICBjb25zdCBpbnRlcm5hbFNhbXBsZSA9IHRoaXMuY3JlYXRlU2FtcGxlRm9yVHJhY2sodHJhY2tEYXRhLCBwYWNrZXQuZGF0YSwgdGltZXN0YW1wLCBwYWNrZXQuZHVyYXRpb24sIHBhY2tldC50eXBlKTtcbiAgICAgICAgICAgIGlmICh0cmFja0RhdGEuaW5mby5yZXF1aXJlc1BjbVRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tYXliZVBhZFdpdGhTaWxlbmNlKHRyYWNrRGF0YSwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVnaXN0ZXJTYW1wbGUodHJhY2tEYXRhLCBpbnRlcm5hbFNhbXBsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbWF5YmVQYWRXaXRoU2lsZW5jZSh0cmFja0RhdGEsIHVudGlsVGltZXN0YW1wKSB7XG4gICAgICAgIC8vIFRoZSBQQ00gdHJhbnNmb3JtYXRpb24gYXNzdW1lcyB0aGF0IGFsbCBzYW1wbGVzIGFyZSBjb250aWd1b3VzLiBUaGlzIGlzIG5vdCBzb21ldGhpbmcgdGhhdCBpcyBlbmZvcmNlZCwgc29cbiAgICAgICAgLy8gd2UgbmVlZCB0byBwYWQgdGhlIFwiaG9sZXNcIiBpbiBiZXR3ZWVuIHNhbXBsZXMgKGFuZCBiZWZvcmUgdGhlIGZpcnN0IHNhbXBsZSkgd2l0aCBhZGRpdGlvbmFsXG4gICAgICAgIC8vIFwic2lsZW5jZSBzYW1wbGVzXCIuXG4gICAgICAgIGNvbnN0IGxhc3RTYW1wbGUgPSBsYXN0KHRyYWNrRGF0YS5zYW1wbGVzKTtcbiAgICAgICAgY29uc3QgbGFzdEVuZFRpbWVzdGFtcCA9IGxhc3RTYW1wbGVcbiAgICAgICAgICAgID8gbGFzdFNhbXBsZS50aW1lc3RhbXAgKyBsYXN0U2FtcGxlLmR1cmF0aW9uXG4gICAgICAgICAgICA6IDA7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gdW50aWxUaW1lc3RhbXAgLSBsYXN0RW5kVGltZXN0YW1wO1xuICAgICAgICBjb25zdCBkZWx0YUluVGltZXNjYWxlID0gaW50b1RpbWVzY2FsZShkZWx0YSwgdHJhY2tEYXRhLnRpbWVzY2FsZSk7XG4gICAgICAgIGlmIChkZWx0YUluVGltZXNjYWxlID4gMCkge1xuICAgICAgICAgICAgY29uc3QgeyBzYW1wbGVTaXplLCBzaWxlbnRWYWx1ZSB9ID0gcGFyc2VQY21Db2RlYyh0cmFja0RhdGEuaW5mby5kZWNvZGVyQ29uZmlnLmNvZGVjKTtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZXNOZWVkZWQgPSBkZWx0YUluVGltZXNjYWxlICogdHJhY2tEYXRhLmluZm8ubnVtYmVyT2ZDaGFubmVscztcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShzYW1wbGVTaXplICogc2FtcGxlc05lZWRlZCkuZmlsbChzaWxlbnRWYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nU2FtcGxlID0gdGhpcy5jcmVhdGVTYW1wbGVGb3JUcmFjayh0cmFja0RhdGEsIG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyKSwgbGFzdEVuZFRpbWVzdGFtcCwgZGVsdGEsICdrZXknKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVnaXN0ZXJTYW1wbGUodHJhY2tEYXRhLCBwYWRkaW5nU2FtcGxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBhZGRTdWJ0aXRsZUN1ZSh0cmFjaywgY3VlLCBtZXRhKSB7XG4gICAgICAgIGNvbnN0IHJlbGVhc2UgPSBhd2FpdCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrRGF0YSA9IHRoaXMuZ2V0U3VidGl0bGVUcmFja0RhdGEodHJhY2ssIG1ldGEpO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUFuZE5vcm1hbGl6ZVRpbWVzdGFtcCh0cmFja0RhdGEudHJhY2ssIGN1ZS50aW1lc3RhbXAsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHRyYWNrLnNvdXJjZS5fY29kZWMgPT09ICd3ZWJ2dHQnKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tEYXRhLmN1ZVF1ZXVlLnB1c2goY3VlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NXZWJWVFRDdWVzKHRyYWNrRGF0YSwgY3VlLnRpbWVzdGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc1dlYlZUVEN1ZXModHJhY2tEYXRhLCB1bnRpbCkge1xuICAgICAgICAvLyBXZWJWVFQgY3VlcyBuZWVkIHRvIHVuZGVyZ28gc3BlY2lhbCBwcm9jZXNzaW5nIGFzIGVtcHR5IHNlY3Rpb25zIG5lZWQgdG8gYmUgcGFkZGVkIG91dCB3aXRoIHNhbXBsZXMsIGFuZFxuICAgICAgICAvLyBvdmVybGFwcGluZyBzYW1wbGVzIHJlcXVpcmUgc3BlY2lhbCBsb2dpYy4gVGhlIGFsZ29yaXRobSBwcm9kdWNlcyB0aGUgZm9ybWF0IHNwZWNpZmllZCBpbiBJU08gMTQ0OTYtMzAuXG4gICAgICAgIHdoaWxlICh0cmFja0RhdGEuY3VlUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wcyA9IG5ldyBTZXQoW10pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjdWUgb2YgdHJhY2tEYXRhLmN1ZVF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGN1ZS50aW1lc3RhbXAgPD0gdW50aWwpO1xuICAgICAgICAgICAgICAgIGFzc2VydCh0cmFja0RhdGEubGFzdEN1ZUVuZFRpbWVzdGFtcCA8PSBjdWUudGltZXN0YW1wICsgY3VlLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXBzLmFkZChNYXRoLm1heChjdWUudGltZXN0YW1wLCB0cmFja0RhdGEubGFzdEN1ZUVuZFRpbWVzdGFtcCkpOyAvLyBTdGFydCB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXBzLmFkZChjdWUudGltZXN0YW1wICsgY3VlLmR1cmF0aW9uKTsgLy8gRW5kIHRpbWVzdGFtcFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc29ydGVkVGltZXN0YW1wcyA9IFsuLi50aW1lc3RhbXBzXS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIHRpbWVzdGFtcHMgb2YgdGhlIG5leHQgc2FtcGxlIHdlJ2xsIGNyZWF0ZTpcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZVN0YXJ0ID0gc29ydGVkVGltZXN0YW1wc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUVuZCA9IHNvcnRlZFRpbWVzdGFtcHNbMV0gPz8gc2FtcGxlU3RhcnQ7XG4gICAgICAgICAgICBpZiAodW50aWwgPCBzYW1wbGVFbmQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIG1heSBuZWVkIHRvIHBhZCBvdXQgZW1wdHkgc3BhY2Ugd2l0aCBhbiB2dHRlIGJveFxuICAgICAgICAgICAgaWYgKHRyYWNrRGF0YS5sYXN0Q3VlRW5kVGltZXN0YW1wIDwgc2FtcGxlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1eFdyaXRlci5zZWVrKDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJveCA9IHZ0dGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF1eEJveFdyaXRlci53cml0ZUJveChib3gpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmF1eFdyaXRlci5nZXRTbGljZSgwLCB0aGlzLmF1eFdyaXRlci5nZXRQb3MoKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FtcGxlID0gdGhpcy5jcmVhdGVTYW1wbGVGb3JUcmFjayh0cmFja0RhdGEsIGJvZHksIHRyYWNrRGF0YS5sYXN0Q3VlRW5kVGltZXN0YW1wLCBzYW1wbGVTdGFydCAtIHRyYWNrRGF0YS5sYXN0Q3VlRW5kVGltZXN0YW1wLCAna2V5Jyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWdpc3RlclNhbXBsZSh0cmFja0RhdGEsIHNhbXBsZSk7XG4gICAgICAgICAgICAgICAgdHJhY2tEYXRhLmxhc3RDdWVFbmRUaW1lc3RhbXAgPSBzYW1wbGVTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXV4V3JpdGVyLnNlZWsoMCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrRGF0YS5jdWVRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1ZSA9IHRyYWNrRGF0YS5jdWVRdWV1ZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VlLnRpbWVzdGFtcCA+PSBzYW1wbGVFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlubGluZVRpbWVzdGFtcFJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGFpbnNUaW1lc3RhbXAgPSBpbmxpbmVUaW1lc3RhbXBSZWdleC50ZXN0KGN1ZS50ZXh0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRUaW1lc3RhbXAgPSBjdWUudGltZXN0YW1wICsgY3VlLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIGxldCBzb3VyY2VJZCA9IHRyYWNrRGF0YS5jdWVUb1NvdXJjZUlkLmdldChjdWUpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VJZCA9PT0gdW5kZWZpbmVkICYmIHNhbXBsZUVuZCA8IGVuZFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBrbm93IHRoaXMgY3VlIHdpbGwgYXBwZWFyIGluIG1vcmUgdGhhbiBvbmUgc2FtcGxlLCB0aGVyZWZvcmUgd2UgbmVlZCB0byBtYXJrIGl0IHdpdGggYVxuICAgICAgICAgICAgICAgICAgICAvLyB1bmlxdWUgSURcbiAgICAgICAgICAgICAgICAgICAgc291cmNlSWQgPSB0cmFja0RhdGEubmV4dFNvdXJjZUlkKys7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrRGF0YS5jdWVUb1NvdXJjZUlkLnNldChjdWUsIHNvdXJjZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1ZS5ub3Rlcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbnkgbm90ZXMvY29tbWVudHMgYXJlIGluY2x1ZGVkIGluIGEgc3BlY2lhbCB2dHRhIGJveFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3ggPSB2dHRhKGN1ZS5ub3Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV4Qm94V3JpdGVyLndyaXRlQm94KGJveCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJveCA9IHZ0dGMoY3VlLnRleHQsIGNvbnRhaW5zVGltZXN0YW1wID8gc2FtcGxlU3RhcnQgOiBudWxsLCBjdWUuaWRlbnRpZmllciA/PyBudWxsLCBjdWUuc2V0dGluZ3MgPz8gbnVsbCwgc291cmNlSWQgPz8gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXhCb3hXcml0ZXIud3JpdGVCb3goYm94KTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kVGltZXN0YW1wID09PSBzYW1wbGVFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGN1ZSB3b24ndCBhcHBlYXIgaW4gYW55IGZ1dHVyZSBzYW1wbGUsIHNvIHdlJ3JlIGRvbmUgd2l0aCBpdFxuICAgICAgICAgICAgICAgICAgICB0cmFja0RhdGEuY3VlUXVldWUuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuYXV4V3JpdGVyLmdldFNsaWNlKDAsIHRoaXMuYXV4V3JpdGVyLmdldFBvcygpKTtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZSA9IHRoaXMuY3JlYXRlU2FtcGxlRm9yVHJhY2sodHJhY2tEYXRhLCBib2R5LCBzYW1wbGVTdGFydCwgc2FtcGxlRW5kIC0gc2FtcGxlU3RhcnQsICdrZXknKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVnaXN0ZXJTYW1wbGUodHJhY2tEYXRhLCBzYW1wbGUpO1xuICAgICAgICAgICAgdHJhY2tEYXRhLmxhc3RDdWVFbmRUaW1lc3RhbXAgPSBzYW1wbGVFbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlU2FtcGxlRm9yVHJhY2sodHJhY2tEYXRhLCBkYXRhLCB0aW1lc3RhbXAsIGR1cmF0aW9uLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHNhbXBsZSA9IHtcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIGRlY29kZVRpbWVzdGFtcDogdGltZXN0YW1wLCAvLyBUaGlzIG1heSBiZSByZWZpbmVkIGxhdGVyXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBzaXplOiBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdGltZXNjYWxlVW5pdHNUb05leHRTYW1wbGU6IGludG9UaW1lc2NhbGUoZHVyYXRpb24sIHRyYWNrRGF0YS50aW1lc2NhbGUpLCAvLyBXaWxsIGJlIHJlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZTtcbiAgICB9XG4gICAgcHJvY2Vzc1RpbWVzdGFtcHModHJhY2tEYXRhLCBuZXh0U2FtcGxlKSB7XG4gICAgICAgIGlmICh0cmFja0RhdGEudGltZXN0YW1wUHJvY2Vzc2luZ1F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFja0RhdGEudHlwZSA9PT0gJ2F1ZGlvJyAmJiB0cmFja0RhdGEuaW5mby5yZXF1aXJlc1BjbVRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBsZXQgdG90YWxEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSB0b3RhbCBkdXJhdGlvbiBpbiB0aGUgdHJhY2sgdGltZXNjYWxlICh3aGljaCBpcyBlcXVhbCB0byB0aGUgYW1vdW50IG9mIFBDTSBhdWRpbyBzYW1wbGVzKVxuICAgICAgICAgICAgLy8gYW5kIHNpbXBseSBzYXkgdGhhdCdzIGhvdyBtYW55IG5ldyBzYW1wbGVzIHRoZXJlIGFyZS5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tEYXRhLnRpbWVzdGFtcFByb2Nlc3NpbmdRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNhbXBsZSA9IHRyYWNrRGF0YS50aW1lc3RhbXBQcm9jZXNzaW5nUXVldWVbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBpbnRvVGltZXNjYWxlKHNhbXBsZS5kdXJhdGlvbiwgdHJhY2tEYXRhLnRpbWVzY2FsZSk7XG4gICAgICAgICAgICAgICAgdG90YWxEdXJhdGlvbiArPSBkdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFja0RhdGEudGltZVRvU2FtcGxlVGFibGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tEYXRhLnRpbWVUb1NhbXBsZVRhYmxlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVDb3VudDogdG90YWxEdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlRGVsdGE6IDEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0RW50cnkgPSBsYXN0KHRyYWNrRGF0YS50aW1lVG9TYW1wbGVUYWJsZSk7XG4gICAgICAgICAgICAgICAgbGFzdEVudHJ5LnNhbXBsZUNvdW50ICs9IHRvdGFsRHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFja0RhdGEudGltZXN0YW1wUHJvY2Vzc2luZ1F1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc29ydGVkVGltZXN0YW1wcyA9IHRyYWNrRGF0YS50aW1lc3RhbXBQcm9jZXNzaW5nUXVldWUubWFwKHggPT4geC50aW1lc3RhbXApLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja0RhdGEudGltZXN0YW1wUHJvY2Vzc2luZ1F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGUgPSB0cmFja0RhdGEudGltZXN0YW1wUHJvY2Vzc2luZ1F1ZXVlW2ldO1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIHVzZXIgb25seSBzdXBwbGllcyBwcmVzZW50YXRpb24gdGltZSwgYnV0IHRoZXNlIG1heSBiZSBvdXQgb2Ygb3JkZXIsIHdlIHJldmVyc2UtZW5naW5lZXIgZnJvbVxuICAgICAgICAgICAgLy8gdGhhdCBhIHNlbnNpYmxlIGRlY29kZSB0aW1lc3RhbXAuIFRoZSBub3Rpb24gb2YgYSBkZWNvZGUgdGltZXN0YW1wIGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2VcbiAgICAgICAgICAgIC8vIChwcmVzZW50YXRpb24gdGltZXN0YW1wICYgZGVjb2RlIG9yZGVyIGFyZSBhbGwgeW91IG5lZWQpLCBidXQgaXQgaXMgYSBjb25jZXB0IGluIElTT0JNRkYgc28gd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gbW9kZWwgaXQuXG4gICAgICAgICAgICBzYW1wbGUuZGVjb2RlVGltZXN0YW1wID0gc29ydGVkVGltZXN0YW1wc1tpXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0ZyYWdtZW50ZWQgJiYgdHJhY2tEYXRhLmxhc3RUaW1lc2NhbGVVbml0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEluIG5vbi1mcmFnbWVudGVkIGZpbGVzLCB0aGUgZmlyc3QgZGVjb2RlIHRpbWVzdGFtcCBpcyBhbHdheXMgemVyby4gSWYgdGhlIGZpcnN0IHByZXNlbnRhdGlvblxuICAgICAgICAgICAgICAgIC8vIHRpbWVzdGFtcCBpc24ndCB6ZXJvLCB3ZSdsbCBzaW1wbHkgdXNlIHRoZSBjb21wb3NpdGlvbiB0aW1lIG9mZnNldCB0byBhY2hpZXZlIGl0LlxuICAgICAgICAgICAgICAgIHNhbXBsZS5kZWNvZGVUaW1lc3RhbXAgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2FtcGxlQ29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gaW50b1RpbWVzY2FsZShzYW1wbGUudGltZXN0YW1wIC0gc2FtcGxlLmRlY29kZVRpbWVzdGFtcCwgdHJhY2tEYXRhLnRpbWVzY2FsZSk7XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbkluVGltZXNjYWxlID0gaW50b1RpbWVzY2FsZShzYW1wbGUuZHVyYXRpb24sIHRyYWNrRGF0YS50aW1lc2NhbGUpO1xuICAgICAgICAgICAgaWYgKHRyYWNrRGF0YS5sYXN0VGltZXNjYWxlVW5pdHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQodHJhY2tEYXRhLmxhc3RTYW1wbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVzY2FsZVVuaXRzID0gaW50b1RpbWVzY2FsZShzYW1wbGUuZGVjb2RlVGltZXN0YW1wLCB0cmFja0RhdGEudGltZXNjYWxlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBNYXRoLnJvdW5kKHRpbWVzY2FsZVVuaXRzIC0gdHJhY2tEYXRhLmxhc3RUaW1lc2NhbGVVbml0cyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGRlbHRhID49IDApO1xuICAgICAgICAgICAgICAgIHRyYWNrRGF0YS5sYXN0VGltZXNjYWxlVW5pdHMgKz0gZGVsdGE7XG4gICAgICAgICAgICAgICAgdHJhY2tEYXRhLmxhc3RTYW1wbGUudGltZXNjYWxlVW5pdHNUb05leHRTYW1wbGUgPSBkZWx0YTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNGcmFnbWVudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0VGFibGVFbnRyeSA9IGxhc3QodHJhY2tEYXRhLnRpbWVUb1NhbXBsZVRhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGxhc3RUYWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RUYWJsZUVudHJ5LnNhbXBsZUNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0VGFibGVFbnRyeS5zYW1wbGVEZWx0YSA9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnlCZWZvcmUgPSB0cmFja0RhdGEudGltZVRvU2FtcGxlVGFibGVbdHJhY2tEYXRhLnRpbWVUb1NhbXBsZVRhYmxlLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5QmVmb3JlICYmIGVudHJ5QmVmb3JlLnNhbXBsZURlbHRhID09PSBkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkZWx0YSBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgb25lLCBtZXJnZSB0aGUgdHdvIGVudHJpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeUJlZm9yZS5zYW1wbGVDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrRGF0YS50aW1lVG9TYW1wbGVUYWJsZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0VGFibGVFbnRyeSA9IGVudHJ5QmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhc3RUYWJsZUVudHJ5LnNhbXBsZURlbHRhICE9PSBkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGRlbHRhIGhhcyBjaGFuZ2VkLCBzbyB3ZSBuZWVkIGEgbmV3IGVudHJ5IHRvIHJlYWNoIHRoZSBjdXJyZW50IHNhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFRhYmxlRW50cnkuc2FtcGxlQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrRGF0YS50aW1lVG9TYW1wbGVUYWJsZS5wdXNoKGxhc3RUYWJsZUVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUNvdW50OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZURlbHRhOiBkZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0VGFibGVFbnRyeS5zYW1wbGVEZWx0YSA9PT0gZHVyYXRpb25JblRpbWVzY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNhbXBsZSdzIGR1cmF0aW9uIG1hdGNoZXMgdGhlIGRlbHRhLCBzbyB3ZSBjYW4gaW5jcmVtZW50IHRoZSBjb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFRhYmxlRW50cnkuc2FtcGxlQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhIG5ldyBlbnRyeSBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgbGFzdCBzYW1wbGUncyB0cnVlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja0RhdGEudGltZVRvU2FtcGxlVGFibGUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlQ291bnQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlRGVsdGE6IGR1cmF0aW9uSW5UaW1lc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0Q29tcG9zaXRpb25UaW1lT2Zmc2V0VGFibGVFbnRyeSA9IGxhc3QodHJhY2tEYXRhLmNvbXBvc2l0aW9uVGltZU9mZnNldFRhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGxhc3RDb21wb3NpdGlvblRpbWVPZmZzZXRUYWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RDb21wb3NpdGlvblRpbWVPZmZzZXRUYWJsZUVudHJ5LnNhbXBsZUNvbXBvc2l0aW9uVGltZU9mZnNldCA9PT0gc2FtcGxlQ29tcG9zaXRpb25UaW1lT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbHkgaW5jcmVtZW50IHRoZSBjb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENvbXBvc2l0aW9uVGltZU9mZnNldFRhYmxlRW50cnkuc2FtcGxlQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjb21wb3NpdGlvbiB0aW1lIG9mZnNldCBoYXMgY2hhbmdlZCwgc28gY3JlYXRlIGEgbmV3IGVudHJ5IHdpdGggdGhlIG5ldyBjb21wb3NpdGlvbiB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrRGF0YS5jb21wb3NpdGlvblRpbWVPZmZzZXRUYWJsZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVDb3VudDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVDb21wb3NpdGlvblRpbWVPZmZzZXQ6IHNhbXBsZUNvbXBvc2l0aW9uVGltZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRGVjb2RlIHRpbWVzdGFtcCBvZiB0aGUgZmlyc3Qgc2FtcGxlXG4gICAgICAgICAgICAgICAgdHJhY2tEYXRhLmxhc3RUaW1lc2NhbGVVbml0cyA9IGludG9UaW1lc2NhbGUoc2FtcGxlLmRlY29kZVRpbWVzdGFtcCwgdHJhY2tEYXRhLnRpbWVzY2FsZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ZyYWdtZW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tEYXRhLnRpbWVUb1NhbXBsZVRhYmxlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlQ291bnQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVEZWx0YTogZHVyYXRpb25JblRpbWVzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrRGF0YS5jb21wb3NpdGlvblRpbWVPZmZzZXRUYWJsZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUNvdW50OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlQ29tcG9zaXRpb25UaW1lT2Zmc2V0OiBzYW1wbGVDb21wb3NpdGlvblRpbWVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrRGF0YS5sYXN0U2FtcGxlID0gc2FtcGxlO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrRGF0YS50aW1lc3RhbXBQcm9jZXNzaW5nUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgYXNzZXJ0KHRyYWNrRGF0YS5sYXN0U2FtcGxlKTtcbiAgICAgICAgYXNzZXJ0KHRyYWNrRGF0YS5sYXN0VGltZXNjYWxlVW5pdHMgIT09IG51bGwpO1xuICAgICAgICBpZiAobmV4dFNhbXBsZSAhPT0gdW5kZWZpbmVkICYmIHRyYWNrRGF0YS5sYXN0U2FtcGxlLnRpbWVzY2FsZVVuaXRzVG9OZXh0U2FtcGxlID09PSAwKSB7XG4gICAgICAgICAgICBhc3NlcnQobmV4dFNhbXBsZS50eXBlID09PSAna2V5Jyk7XG4gICAgICAgICAgICAvLyBHaXZlbiB0aGUgbmV4dCBzYW1wbGUsIHdlIGNhbiBtYWtlIGEgZ3Vlc3MgYWJvdXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBsYXN0IHNhbXBsZS4gVGhpcyBhdm9pZHMgaGF2aW5nXG4gICAgICAgICAgICAvLyB0aGUgbGFzdCBzYW1wbGUncyBkdXJhdGlvbiBpbiBlYWNoIGZyYWdtZW50IGJlIFwiMFwiIGZvciBmcmFnbWVudGVkIGZpbGVzLiBUaGUgZ3Vlc3Mgd2UgbWFrZSBoZXJlIGlzXG4gICAgICAgICAgICAvLyBhY3R1YWxseSBjb3JyZWN0IG1vc3Qgb2YgdGhlIHRpbWUsIHNpbmNlIHR5cGljYWxseSwgbm8gZGVsdGEgZnJhbWUgd2l0aCBhIGxvd2VyIHRpbWVzdGFtcCBmb2xsb3dzIHRoZSBrZXlcbiAgICAgICAgICAgIC8vIGZyYW1lIChhbHRob3VnaCBpdCBjYW4gaGFwcGVuKS5cbiAgICAgICAgICAgIGNvbnN0IHRpbWVzY2FsZVVuaXRzID0gaW50b1RpbWVzY2FsZShuZXh0U2FtcGxlLnRpbWVzdGFtcCwgdHJhY2tEYXRhLnRpbWVzY2FsZSwgZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBNYXRoLnJvdW5kKHRpbWVzY2FsZVVuaXRzIC0gdHJhY2tEYXRhLmxhc3RUaW1lc2NhbGVVbml0cyk7XG4gICAgICAgICAgICB0cmFja0RhdGEubGFzdFNhbXBsZS50aW1lc2NhbGVVbml0c1RvTmV4dFNhbXBsZSA9IGRlbHRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlZ2lzdGVyU2FtcGxlKHRyYWNrRGF0YSwgc2FtcGxlKSB7XG4gICAgICAgIGlmIChzYW1wbGUudHlwZSA9PT0gJ2tleScpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1RpbWVzdGFtcHModHJhY2tEYXRhLCBzYW1wbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrRGF0YS50aW1lc3RhbXBQcm9jZXNzaW5nUXVldWUucHVzaChzYW1wbGUpO1xuICAgICAgICBpZiAodGhpcy5pc0ZyYWdtZW50ZWQpIHtcbiAgICAgICAgICAgIHRyYWNrRGF0YS5zYW1wbGVRdWV1ZS5wdXNoKHNhbXBsZSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmludGVybGVhdmVTYW1wbGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFkZFNhbXBsZVRvVHJhY2sodHJhY2tEYXRhLCBzYW1wbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGFkZFNhbXBsZVRvVHJhY2sodHJhY2tEYXRhLCBzYW1wbGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRnJhZ21lbnRlZCkge1xuICAgICAgICAgICAgdHJhY2tEYXRhLnNhbXBsZXMucHVzaChzYW1wbGUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBiZWdpbk5ld0NodW5rID0gZmFsc2U7XG4gICAgICAgIGlmICghdHJhY2tEYXRhLmN1cnJlbnRDaHVuaykge1xuICAgICAgICAgICAgYmVnaW5OZXdDaHVuayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaW1lc3RhbXAgZG9uJ3QgbmVlZCB0byBiZSBtb25vdG9uaWMgKHRoaW5rIEItZnJhbWVzKSwgc28gd2UgbWF5IG5lZWQgdG8gdXBkYXRlIHRoZSBzdGFydCB0aW1lc3RhbXAgb2ZcbiAgICAgICAgICAgIC8vIHRoZSBjaHVua1xuICAgICAgICAgICAgdHJhY2tEYXRhLmN1cnJlbnRDaHVuay5zdGFydFRpbWVzdGFtcCA9IE1hdGgubWluKHRyYWNrRGF0YS5jdXJyZW50Q2h1bmsuc3RhcnRUaW1lc3RhbXAsIHNhbXBsZS50aW1lc3RhbXApO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENodW5rRHVyYXRpb24gPSBzYW1wbGUudGltZXN0YW1wIC0gdHJhY2tEYXRhLmN1cnJlbnRDaHVuay5zdGFydFRpbWVzdGFtcDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRnJhZ21lbnRlZCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBvbmx5IGZpbmFsaXplIHRoaXMgZnJhZ21lbnQgKGFuZCBiZWdpbiBhIG5ldyBvbmUpIGlmIHdlIGtub3cgdGhhdCBlYWNoIHRyYWNrIHdpbGwgYmUgYWJsZSB0b1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHRoZSBuZXcgb25lIHdpdGggYSBrZXkgZnJhbWUuXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5RnJhbWVRdWV1ZWRFdmVyeXdoZXJlID0gdGhpcy50cmFja0RhdGFzLmV2ZXJ5KChvdGhlclRyYWNrRGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tEYXRhID09PSBvdGhlclRyYWNrRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNhbXBsZS50eXBlID09PSAna2V5JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFF1ZXVlZFNhbXBsZSA9IG90aGVyVHJhY2tEYXRhLnNhbXBsZVF1ZXVlWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RRdWV1ZWRTYW1wbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdFF1ZXVlZFNhbXBsZS50eXBlID09PSAna2V5JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXJUcmFja0RhdGEudHJhY2suc291cmNlLl9jbG9zZWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaHVua0R1cmF0aW9uID49IHRoaXMubWluaW11bUZyYWdtZW50RHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgJiYga2V5RnJhbWVRdWV1ZWRFdmVyeXdoZXJlXG4gICAgICAgICAgICAgICAgICAgICYmIHNhbXBsZS50aW1lc3RhbXAgPiB0aGlzLm1heFdyaXR0ZW5UaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW5OZXdDaHVuayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZmluYWxpemVGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJlZ2luTmV3Q2h1bmsgPSBjdXJyZW50Q2h1bmtEdXJhdGlvbiA+PSAwLjU7IC8vIENodW5rIGlzIGxvbmcgZW5vdWdoLCB3ZSBuZWVkIGEgbmV3IG9uZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiZWdpbk5ld0NodW5rKSB7XG4gICAgICAgICAgICBpZiAodHJhY2tEYXRhLmN1cnJlbnRDaHVuaykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZmluYWxpemVDdXJyZW50Q2h1bmsodHJhY2tEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrRGF0YS5jdXJyZW50Q2h1bmsgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXA6IHNhbXBsZS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgc2FtcGxlczogW10sXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBudWxsLFxuICAgICAgICAgICAgICAgIG1vb2ZPZmZzZXQ6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCh0cmFja0RhdGEuY3VycmVudENodW5rKTtcbiAgICAgICAgdHJhY2tEYXRhLmN1cnJlbnRDaHVuay5zYW1wbGVzLnB1c2goc2FtcGxlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNGcmFnbWVudGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1heFdyaXR0ZW5UaW1lc3RhbXAgPSBNYXRoLm1heCh0aGlzLm1heFdyaXR0ZW5UaW1lc3RhbXAsIHNhbXBsZS50aW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZpbmFsaXplQ3VycmVudENodW5rKHRyYWNrRGF0YSkge1xuICAgICAgICBhc3NlcnQoIXRoaXMuaXNGcmFnbWVudGVkKTtcbiAgICAgICAgaWYgKCF0cmFja0RhdGEuY3VycmVudENodW5rKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0cmFja0RhdGEuZmluYWxpemVkQ2h1bmtzLnB1c2godHJhY2tEYXRhLmN1cnJlbnRDaHVuayk7XG4gICAgICAgIHRoaXMuZmluYWxpemVkQ2h1bmtzLnB1c2godHJhY2tEYXRhLmN1cnJlbnRDaHVuayk7XG4gICAgICAgIGxldCBzYW1wbGVDb3VudCA9IHRyYWNrRGF0YS5jdXJyZW50Q2h1bmsuc2FtcGxlcy5sZW5ndGg7XG4gICAgICAgIGlmICh0cmFja0RhdGEudHlwZSA9PT0gJ2F1ZGlvJyAmJiB0cmFja0RhdGEuaW5mby5yZXF1aXJlc1BjbVRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBzYW1wbGVDb3VudCA9IHRyYWNrRGF0YS5jdXJyZW50Q2h1bmsuc2FtcGxlc1xuICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgc2FtcGxlKSA9PiBhY2MgKyBpbnRvVGltZXNjYWxlKHNhbXBsZS5kdXJhdGlvbiwgdHJhY2tEYXRhLnRpbWVzY2FsZSksIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFja0RhdGEuY29tcGFjdGx5Q29kZWRDaHVua1RhYmxlLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgfHwgbGFzdCh0cmFja0RhdGEuY29tcGFjdGx5Q29kZWRDaHVua1RhYmxlKS5zYW1wbGVzUGVyQ2h1bmsgIT09IHNhbXBsZUNvdW50KSB7XG4gICAgICAgICAgICB0cmFja0RhdGEuY29tcGFjdGx5Q29kZWRDaHVua1RhYmxlLnB1c2goe1xuICAgICAgICAgICAgICAgIGZpcnN0Q2h1bms6IHRyYWNrRGF0YS5maW5hbGl6ZWRDaHVua3MubGVuZ3RoLCAvLyAxLWluZGV4ZWRcbiAgICAgICAgICAgICAgICBzYW1wbGVzUGVyQ2h1bms6IHNhbXBsZUNvdW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmFzdFN0YXJ0ID09PSAnaW4tbWVtb3J5Jykge1xuICAgICAgICAgICAgdHJhY2tEYXRhLmN1cnJlbnRDaHVuay5vZmZzZXQgPSAwOyAvLyBXZSdsbCBjb21wdXRlIHRoZSBwcm9wZXIgb2Zmc2V0IHdoZW4gZmluYWxpemluZ1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdyaXRlIG91dCB0aGUgZGF0YVxuICAgICAgICB0cmFja0RhdGEuY3VycmVudENodW5rLm9mZnNldCA9IHRoaXMud3JpdGVyLmdldFBvcygpO1xuICAgICAgICBmb3IgKGNvbnN0IHNhbXBsZSBvZiB0cmFja0RhdGEuY3VycmVudENodW5rLnNhbXBsZXMpIHtcbiAgICAgICAgICAgIGFzc2VydChzYW1wbGUuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLndyaXRlci53cml0ZShzYW1wbGUuZGF0YSk7XG4gICAgICAgICAgICBzYW1wbGUuZGF0YSA9IG51bGw7IC8vIENhbiBiZSBHQydkXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIuZmx1c2goKTtcbiAgICB9XG4gICAgYXN5bmMgaW50ZXJsZWF2ZVNhbXBsZXMoaXNGaW5hbENhbGwgPSBmYWxzZSkge1xuICAgICAgICBhc3NlcnQodGhpcy5pc0ZyYWdtZW50ZWQpO1xuICAgICAgICBpZiAoIWlzRmluYWxDYWxsKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsVHJhY2tzQXJlS25vd24oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gV2UgY2FuJ3QgaW50ZXJsZWF2ZSB5ZXQgYXMgd2UgZG9uJ3QgeWV0IGtub3cgaG93IG1hbnkgdHJhY2tzIHdlJ2xsIHRydWx5IGhhdmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRlcjogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGxldCB0cmFja1dpdGhNaW5UaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICAgICAgbGV0IG1pblRpbWVzdGFtcCA9IEluZmluaXR5O1xuICAgICAgICAgICAgZm9yIChjb25zdCB0cmFja0RhdGEgb2YgdGhpcy50cmFja0RhdGFzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZpbmFsQ2FsbCAmJiB0cmFja0RhdGEuc2FtcGxlUXVldWUubGVuZ3RoID09PSAwICYmICF0cmFja0RhdGEudHJhY2suc291cmNlLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cmFja0RhdGEuc2FtcGxlUXVldWUubGVuZ3RoID4gMCAmJiB0cmFja0RhdGEuc2FtcGxlUXVldWVbMF0udGltZXN0YW1wIDwgbWluVGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrV2l0aE1pblRpbWVzdGFtcCA9IHRyYWNrRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgbWluVGltZXN0YW1wID0gdHJhY2tEYXRhLnNhbXBsZVF1ZXVlWzBdLnRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRyYWNrV2l0aE1pblRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2FtcGxlID0gdHJhY2tXaXRoTWluVGltZXN0YW1wLnNhbXBsZVF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFkZFNhbXBsZVRvVHJhY2sodHJhY2tXaXRoTWluVGltZXN0YW1wLCBzYW1wbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZpbmFsaXplRnJhZ21lbnQoZmx1c2hXcml0ZXIgPSB0cnVlKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmlzRnJhZ21lbnRlZCk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50TnVtYmVyID0gdGhpcy5uZXh0RnJhZ21lbnROdW1iZXIrKztcbiAgICAgICAgaWYgKGZyYWdtZW50TnVtYmVyID09PSAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb3JtYXQuX29wdGlvbnMub25Nb292KSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZXIuc3RhcnRUcmFja2luZ1dyaXRlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV3JpdGUgdGhlIG1vb3YgYm94IG5vdyB0aGF0IHdlIGhhdmUgYWxsIGRlY29kZXIgY29uZmlnc1xuICAgICAgICAgICAgY29uc3QgbW92aWVCb3ggPSBtb292KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5ib3hXcml0ZXIud3JpdGVCb3gobW92aWVCb3gpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybWF0Ll9vcHRpb25zLm9uTW9vdikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgc3RhcnQgfSA9IHRoaXMud3JpdGVyLnN0b3BUcmFja2luZ1dyaXRlcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0Ll9vcHRpb25zLm9uTW9vdihkYXRhLCBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IGFsbCB0cmFja3MgbmVlZCB0byBiZSBwcmVzZW50IGluIGV2ZXJ5IGZyYWdtZW50XG4gICAgICAgIGNvbnN0IHRyYWNrc0luRnJhZ21lbnQgPSB0aGlzLnRyYWNrRGF0YXMuZmlsdGVyKHggPT4geC5jdXJyZW50Q2h1bmspO1xuICAgICAgICAvLyBDcmVhdGUgYW4gaW5pdGlhbCBtb29mIGJveCBhbmQgbWVhc3VyZSBpdDsgd2UgbmVlZCB0aGlzIHRvIGtub3cgd2hlcmUgdGhlIGZvbGxvd2luZyBtZGF0IGJveCB3aWxsIGJlZ2luXG4gICAgICAgIGNvbnN0IG1vb2ZCb3ggPSBtb29mKGZyYWdtZW50TnVtYmVyLCB0cmFja3NJbkZyYWdtZW50KTtcbiAgICAgICAgY29uc3QgbW9vZk9mZnNldCA9IHRoaXMud3JpdGVyLmdldFBvcygpO1xuICAgICAgICBjb25zdCBtZGF0U3RhcnRQb3MgPSBtb29mT2Zmc2V0ICsgdGhpcy5ib3hXcml0ZXIubWVhc3VyZUJveChtb29mQm94KTtcbiAgICAgICAgbGV0IGN1cnJlbnRQb3MgPSBtZGF0U3RhcnRQb3MgKyBNSU5fQk9YX0hFQURFUl9TSVpFO1xuICAgICAgICBsZXQgZnJhZ21lbnRTdGFydFRpbWVzdGFtcCA9IEluZmluaXR5O1xuICAgICAgICBmb3IgKGNvbnN0IHRyYWNrRGF0YSBvZiB0cmFja3NJbkZyYWdtZW50KSB7XG4gICAgICAgICAgICB0cmFja0RhdGEuY3VycmVudENodW5rLm9mZnNldCA9IGN1cnJlbnRQb3M7XG4gICAgICAgICAgICB0cmFja0RhdGEuY3VycmVudENodW5rLm1vb2ZPZmZzZXQgPSBtb29mT2Zmc2V0O1xuICAgICAgICAgICAgZm9yIChjb25zdCBzYW1wbGUgb2YgdHJhY2tEYXRhLmN1cnJlbnRDaHVuay5zYW1wbGVzKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvcyArPSBzYW1wbGUuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyYWdtZW50U3RhcnRUaW1lc3RhbXAgPSBNYXRoLm1pbihmcmFnbWVudFN0YXJ0VGltZXN0YW1wLCB0cmFja0RhdGEuY3VycmVudENodW5rLnN0YXJ0VGltZXN0YW1wKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZGF0U2l6ZSA9IGN1cnJlbnRQb3MgLSBtZGF0U3RhcnRQb3M7XG4gICAgICAgIGNvbnN0IG5lZWRzTGFyZ2VNZGF0U2l6ZSA9IG1kYXRTaXplID49IDIgKiogMzI7XG4gICAgICAgIGlmIChuZWVkc0xhcmdlTWRhdFNpemUpIHtcbiAgICAgICAgICAgIC8vIFNoaWZ0IGFsbCBvZmZzZXRzIGJ5IDguIFByZXZpb3VzbHksIGFsbCBjaHVua3Mgd2VyZSBzaGlmdGVkIGFzc3VtaW5nIHRoZSBsYXJnZSBib3ggc2l6ZSwgYnV0IGR1ZSB0byB3aGF0XG4gICAgICAgICAgICAvLyBJIHN1c3BlY3QgaXMgYSBidWcgaW4gV2ViS2l0LCBpdCBmYWlsZWQgaW4gU2FmYXJpICh3aGVuIGxpdmVzdHJlYW1pbmcgd2l0aCBNU0UsIG5vdCBmb3Igc3RhdGljIHBsYXliYWNrKS5cbiAgICAgICAgICAgIGZvciAoY29uc3QgdHJhY2tEYXRhIG9mIHRyYWNrc0luRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0cmFja0RhdGEuY3VycmVudENodW5rLm9mZnNldCArPSBNQVhfQk9YX0hFQURFUl9TSVpFIC0gTUlOX0JPWF9IRUFERVJfU0laRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mb3JtYXQuX29wdGlvbnMub25Nb29mKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlci5zdGFydFRyYWNraW5nV3JpdGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3TW9vZkJveCA9IG1vb2YoZnJhZ21lbnROdW1iZXIsIHRyYWNrc0luRnJhZ21lbnQpO1xuICAgICAgICB0aGlzLmJveFdyaXRlci53cml0ZUJveChuZXdNb29mQm94KTtcbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0Ll9vcHRpb25zLm9uTW9vZikge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBzdGFydCB9ID0gdGhpcy53cml0ZXIuc3RvcFRyYWNraW5nV3JpdGVzKCk7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdC5fb3B0aW9ucy5vbk1vb2YoZGF0YSwgc3RhcnQsIGZyYWdtZW50U3RhcnRUaW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCh0aGlzLndyaXRlci5nZXRQb3MoKSA9PT0gbWRhdFN0YXJ0UG9zKTtcbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0Ll9vcHRpb25zLm9uTWRhdCkge1xuICAgICAgICAgICAgdGhpcy53cml0ZXIuc3RhcnRUcmFja2luZ1dyaXRlcygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1kYXRCb3ggPSBtZGF0KG5lZWRzTGFyZ2VNZGF0U2l6ZSk7XG4gICAgICAgIG1kYXRCb3guc2l6ZSA9IG1kYXRTaXplO1xuICAgICAgICB0aGlzLmJveFdyaXRlci53cml0ZUJveChtZGF0Qm94KTtcbiAgICAgICAgdGhpcy53cml0ZXIuc2VlayhtZGF0U3RhcnRQb3MgKyAobmVlZHNMYXJnZU1kYXRTaXplID8gTUFYX0JPWF9IRUFERVJfU0laRSA6IE1JTl9CT1hfSEVBREVSX1NJWkUpKTtcbiAgICAgICAgLy8gV3JpdGUgc2FtcGxlIGRhdGFcbiAgICAgICAgZm9yIChjb25zdCB0cmFja0RhdGEgb2YgdHJhY2tzSW5GcmFnbWVudCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzYW1wbGUgb2YgdHJhY2tEYXRhLmN1cnJlbnRDaHVuay5zYW1wbGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZXIud3JpdGUoc2FtcGxlLmRhdGEpO1xuICAgICAgICAgICAgICAgIHNhbXBsZS5kYXRhID0gbnVsbDsgLy8gQ2FuIGJlIEdDJ2RcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mb3JtYXQuX29wdGlvbnMub25NZGF0KSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIHN0YXJ0IH0gPSB0aGlzLndyaXRlci5zdG9wVHJhY2tpbmdXcml0ZXMoKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0Ll9vcHRpb25zLm9uTWRhdChkYXRhLCBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB0cmFja0RhdGEgb2YgdHJhY2tzSW5GcmFnbWVudCkge1xuICAgICAgICAgICAgdHJhY2tEYXRhLmZpbmFsaXplZENodW5rcy5wdXNoKHRyYWNrRGF0YS5jdXJyZW50Q2h1bmspO1xuICAgICAgICAgICAgdGhpcy5maW5hbGl6ZWRDaHVua3MucHVzaCh0cmFja0RhdGEuY3VycmVudENodW5rKTtcbiAgICAgICAgICAgIHRyYWNrRGF0YS5jdXJyZW50Q2h1bmsgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbHVzaFdyaXRlcikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIuZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcbiAgICBhc3luYyBvblRyYWNrQ2xvc2UodHJhY2spIHtcbiAgICAgICAgY29uc3QgcmVsZWFzZSA9IGF3YWl0IHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICBpZiAodHJhY2sudHlwZSA9PT0gJ3N1YnRpdGxlJyAmJiB0cmFjay5zb3VyY2UuX2NvZGVjID09PSAnd2VidnR0Jykge1xuICAgICAgICAgICAgY29uc3QgdHJhY2tEYXRhID0gdGhpcy50cmFja0RhdGFzLmZpbmQoeCA9PiB4LnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgICAgICBpZiAodHJhY2tEYXRhKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzV2ViVlRUQ3Vlcyh0cmFja0RhdGEsIEluZmluaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbGxUcmFja3NBcmVLbm93bigpKSB7XG4gICAgICAgICAgICB0aGlzLmFsbFRyYWNrc0tub3duLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0ZyYWdtZW50ZWQpIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIGEgdHJhY2sgaXMgbm93IGNsb3NlZCwgd2UgbWF5IGJlIGFibGUgdG8gd3JpdGUgb3V0IGNodW5rcyB0aGF0IHdlcmUgcHJldmlvdXNseSB3YWl0aW5nXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmludGVybGVhdmVTYW1wbGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVsZWFzZSgpO1xuICAgIH1cbiAgICAvKiogRmluYWxpemVzIHRoZSBmaWxlLCBtYWtpbmcgaXQgcmVhZHkgZm9yIHVzZS4gTXVzdCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIHZpZGVvIGFuZCBhdWRpbyBjaHVua3MgaGF2ZSBiZWVuIGFkZGVkLiAqL1xuICAgIGFzeW5jIGZpbmFsaXplKCkge1xuICAgICAgICBjb25zdCByZWxlYXNlID0gYXdhaXQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgIHRoaXMuYWxsVHJhY2tzS25vd24ucmVzb2x2ZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IHRyYWNrRGF0YSBvZiB0aGlzLnRyYWNrRGF0YXMpIHtcbiAgICAgICAgICAgIGlmICh0cmFja0RhdGEudHlwZSA9PT0gJ3N1YnRpdGxlJyAmJiB0cmFja0RhdGEudHJhY2suc291cmNlLl9jb2RlYyA9PT0gJ3dlYnZ0dCcpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NXZWJWVFRDdWVzKHRyYWNrRGF0YSwgSW5maW5pdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzRnJhZ21lbnRlZCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbnRlcmxlYXZlU2FtcGxlcyh0cnVlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHJhY2tEYXRhIG9mIHRoaXMudHJhY2tEYXRhcykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1RpbWVzdGFtcHModHJhY2tEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZmluYWxpemVGcmFnbWVudChmYWxzZSk7IC8vIERvbid0IGZsdXNoIHRoZSBsYXN0IGZyYWdtZW50IGFzIHdlIHdpbGwgZmx1c2ggaXQgd2l0aCB0aGUgbWZyYSBib3hcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHJhY2tEYXRhIG9mIHRoaXMudHJhY2tEYXRhcykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1RpbWVzdGFtcHModHJhY2tEYXRhKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmZpbmFsaXplQ3VycmVudENodW5rKHRyYWNrRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmFzdFN0YXJ0ID09PSAnaW4tbWVtb3J5Jykge1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMubWRhdCk7XG4gICAgICAgICAgICBsZXQgbWRhdFNpemU7XG4gICAgICAgICAgICAvLyBXZSBrbm93IGhvdyBtYW55IGNodW5rcyB0aGVyZSBhcmUsIGJ1dCBjb21wdXRpbmcgdGhlIGNodW5rIHBvc2l0aW9ucyByZXF1aXJlcyBhbiBpdGVyYXRpdmUgYXBwcm9hY2g6XG4gICAgICAgICAgICAvLyBJbiBvcmRlciB0byBrbm93IHdoZXJlIHRoZSBmaXJzdCBjaHVuayBzaG91bGQgZ28sIHdlIGZpcnN0IG5lZWQgdG8ga25vdyB0aGUgc2l6ZSBvZiB0aGUgbW9vdiBib3guIEJ1dCB3ZVxuICAgICAgICAgICAgLy8gY2Fubm90IHdyaXRlIGEgcHJvcGVyIG1vb3YgYm94IHdpdGhvdXQgZmlyc3Qga25vd2luZyBhbGwgY2h1bmsgcG9zaXRpb25zLiBTbywgd2UgZ2VuZXJhdGUgYSB0ZW50YXRpdmVcbiAgICAgICAgICAgIC8vIG1vb3YgYm94IHdpdGggcGxhY2Vob2xkZXIgdmFsdWVzICgwKSBmb3IgdGhlIGNodW5rIG9mZnNldHMgdG8gYmUgYWJsZSB0byBjb21wdXRlIGl0cyBzaXplLiBJZiBpdCB0aGVuXG4gICAgICAgICAgICAvLyB0dXJucyBvdXQgdGhhdCBhcHBlbmRpbmcgYWxsIGNodW5rcyBleGNlZWRzIDQgR2lCLCB3ZSBuZWVkIHRvIHJlcGVhdCB0aGlzIHByb2Nlc3MsIG5vdyB3aXRoIHRoZSBjbzY0IGJveFxuICAgICAgICAgICAgLy8gYmVpbmcgdXNlZCBpbiB0aGUgbW9vdiBib3ggaW5zdGVhZCwgd2hpY2ggd2lsbCBtYWtlIGl0IGxhcmdlci4gQWZ0ZXIgdGhhdCwgd2UgZGVmaW5pdGVseSBrbm93IHRoZSBmaW5hbFxuICAgICAgICAgICAgLy8gc2l6ZSBvZiB0aGUgbW9vdiBib3ggYW5kIGNhbiBjb21wdXRlIHRoZSBwcm9wZXIgY2h1bmsgcG9zaXRpb25zLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb3ZpZUJveCA9IG1vb3YodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbW92aWVCb3hTaXplID0gdGhpcy5ib3hXcml0ZXIubWVhc3VyZUJveChtb3ZpZUJveCk7XG4gICAgICAgICAgICAgICAgbWRhdFNpemUgPSB0aGlzLmJveFdyaXRlci5tZWFzdXJlQm94KHRoaXMubWRhdCk7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRDaHVua1BvcyA9IHRoaXMud3JpdGVyLmdldFBvcygpICsgbW92aWVCb3hTaXplICsgbWRhdFNpemU7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiB0aGlzLmZpbmFsaXplZENodW5rcykge1xuICAgICAgICAgICAgICAgICAgICBjaHVuay5vZmZzZXQgPSBjdXJyZW50Q2h1bmtQb3M7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBkYXRhIH0gb2YgY2h1bmsuc2FtcGxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENodW5rUG9zICs9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1kYXRTaXplICs9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENodW5rUG9zIDwgMiAqKiAzMilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKG1kYXRTaXplID49IDIgKiogMzIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWRhdC5sYXJnZVNpemUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybWF0Ll9vcHRpb25zLm9uTW9vdikge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVyLnN0YXJ0VHJhY2tpbmdXcml0ZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vdmllQm94ID0gbW9vdih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYm94V3JpdGVyLndyaXRlQm94KG1vdmllQm94KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1hdC5fb3B0aW9ucy5vbk1vb3YpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIHN0YXJ0IH0gPSB0aGlzLndyaXRlci5zdG9wVHJhY2tpbmdXcml0ZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdC5fb3B0aW9ucy5vbk1vb3YoZGF0YSwgc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybWF0Ll9vcHRpb25zLm9uTWRhdCkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVyLnN0YXJ0VHJhY2tpbmdXcml0ZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWRhdC5zaXplID0gbWRhdFNpemU7XG4gICAgICAgICAgICB0aGlzLmJveFdyaXRlci53cml0ZUJveCh0aGlzLm1kYXQpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiB0aGlzLmZpbmFsaXplZENodW5rcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2FtcGxlIG9mIGNodW5rLnNhbXBsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHNhbXBsZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZXIud3JpdGUoc2FtcGxlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGUuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybWF0Ll9vcHRpb25zLm9uTWRhdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgc3RhcnQgfSA9IHRoaXMud3JpdGVyLnN0b3BUcmFja2luZ1dyaXRlcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0Ll9vcHRpb25zLm9uTWRhdChkYXRhLCBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc0ZyYWdtZW50ZWQpIHtcbiAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgbWZyYSBib3ggdG8gdGhlIGVuZCBvZiB0aGUgZmlsZSBmb3IgYmV0dGVyIHJhbmRvbSBhY2Nlc3NcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy53cml0ZXIuZ2V0UG9zKCk7XG4gICAgICAgICAgICBjb25zdCBtZnJhQm94ID0gbWZyYSh0aGlzLnRyYWNrRGF0YXMpO1xuICAgICAgICAgICAgdGhpcy5ib3hXcml0ZXIud3JpdGVCb3gobWZyYUJveCk7XG4gICAgICAgICAgICAvLyBQYXRjaCB0aGUgJ3NpemUnIGZpZWxkIG9mIHRoZSBtZnJvIGJveCBhdCB0aGUgZW5kIG9mIHRoZSBtZnJhIGJveCBub3cgdGhhdCB3ZSBrbm93IGl0cyBhY3R1YWwgc2l6ZVxuICAgICAgICAgICAgY29uc3QgbWZyYUJveFNpemUgPSB0aGlzLndyaXRlci5nZXRQb3MoKSAtIHN0YXJ0UG9zO1xuICAgICAgICAgICAgdGhpcy53cml0ZXIuc2Vlayh0aGlzLndyaXRlci5nZXRQb3MoKSAtIDQpO1xuICAgICAgICAgICAgdGhpcy5ib3hXcml0ZXIud3JpdGVVMzIobWZyYUJveFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMubWRhdCk7XG4gICAgICAgICAgICBjb25zdCBtZGF0UG9zID0gdGhpcy5ib3hXcml0ZXIub2Zmc2V0cy5nZXQodGhpcy5tZGF0KTtcbiAgICAgICAgICAgIGFzc2VydChtZGF0UG9zICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgY29uc3QgbWRhdFNpemUgPSB0aGlzLndyaXRlci5nZXRQb3MoKSAtIG1kYXRQb3M7XG4gICAgICAgICAgICB0aGlzLm1kYXQuc2l6ZSA9IG1kYXRTaXplO1xuICAgICAgICAgICAgdGhpcy5tZGF0LmxhcmdlU2l6ZSA9IG1kYXRTaXplID49IDIgKiogMzI7IC8vIE9ubHkgdXNlIHRoZSBsYXJnZSBzaXplIGlmIHdlIG5lZWQgaXRcbiAgICAgICAgICAgIHRoaXMuYm94V3JpdGVyLnBhdGNoQm94KHRoaXMubWRhdCk7XG4gICAgICAgICAgICBpZiAodGhpcy5mb3JtYXQuX29wdGlvbnMub25NZGF0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBzdGFydCB9ID0gdGhpcy53cml0ZXIuc3RvcFRyYWNraW5nV3JpdGVzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtYXQuX29wdGlvbnMub25NZGF0KGRhdGEsIHN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1hdC5fb3B0aW9ucy5vbk1vb3YpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlci5zdGFydFRyYWNraW5nV3JpdGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb3ZpZUJveCA9IG1vb3YodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmJveFdyaXRlci53cml0ZUJveChtb3ZpZUJveCk7XG4gICAgICAgICAgICBpZiAodGhpcy5mb3JtYXQuX29wdGlvbnMub25Nb292KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBzdGFydCB9ID0gdGhpcy53cml0ZXIuc3RvcFRyYWNraW5nV3JpdGVzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtYXQuX29wdGlvbnMub25Nb292KGRhdGEsIHN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWxlYXNlKCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-muxer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-reader.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-reader.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_BOX_HEADER_SIZE: () => (/* binding */ MAX_BOX_HEADER_SIZE),\n/* harmony export */   MIN_BOX_HEADER_SIZE: () => (/* binding */ MIN_BOX_HEADER_SIZE),\n/* harmony export */   readBoxHeader: () => (/* binding */ readBoxHeader),\n/* harmony export */   readDataBox: () => (/* binding */ readDataBox),\n/* harmony export */   readFixed_16_16: () => (/* binding */ readFixed_16_16),\n/* harmony export */   readFixed_2_30: () => (/* binding */ readFixed_2_30),\n/* harmony export */   readIsomVariableInteger: () => (/* binding */ readIsomVariableInteger),\n/* harmony export */   readMetadataStringShort: () => (/* binding */ readMetadataStringShort)\n/* harmony export */ });\n/* harmony import */ var _tags_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tags.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/tags.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/* harmony import */ var _reader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../reader.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/reader.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\nconst MIN_BOX_HEADER_SIZE = 8;\nconst MAX_BOX_HEADER_SIZE = 16;\nconst readBoxHeader = (slice) => {\n    let totalSize = (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readU32Be)(slice);\n    const name = (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readAscii)(slice, 4);\n    let headerSize = 8;\n    const hasLargeSize = totalSize === 1;\n    if (hasLargeSize) {\n        totalSize = (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readU64Be)(slice);\n        headerSize = 16;\n    }\n    const contentSize = totalSize - headerSize;\n    if (contentSize < 0) {\n        return null; // Hardly a box is it\n    }\n    return { name, totalSize, headerSize, contentSize };\n};\nconst readFixed_16_16 = (slice) => {\n    return (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readI32Be)(slice) / 0x10000;\n};\nconst readFixed_2_30 = (slice) => {\n    return (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readI32Be)(slice) / 0x40000000;\n};\nconst readIsomVariableInteger = (slice) => {\n    let result = 0;\n    for (let i = 0; i < 4; i++) {\n        result <<= 7;\n        const nextByte = (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readU8)(slice);\n        result |= nextByte & 0x7f;\n        if ((nextByte & 0x80) === 0) {\n            break;\n        }\n    }\n    return result;\n};\nconst readMetadataStringShort = (slice) => {\n    const stringLength = (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readU16Be)(slice);\n    slice.skip(2); // Language\n    return _misc_js__WEBPACK_IMPORTED_MODULE_1__.textDecoder.decode((0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readBytes)(slice, stringLength));\n};\nconst readDataBox = (slice) => {\n    const header = readBoxHeader(slice);\n    if (!header || header.name !== 'data') {\n        return null;\n    }\n    const typeIndicator = (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readU32Be)(slice);\n    slice.skip(4); // Locale indicator\n    const data = (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readBytes)(slice, header.contentSize - 8);\n    switch (typeIndicator) {\n        case 1: return _misc_js__WEBPACK_IMPORTED_MODULE_1__.textDecoder.decode(data); // UTF-8\n        case 2: return new TextDecoder('utf-16be').decode(data); // UTF-16-BE\n        case 13: return new _tags_js__WEBPACK_IMPORTED_MODULE_2__.RichImageData(data, 'image/jpeg');\n        case 14: return new _tags_js__WEBPACK_IMPORTED_MODULE_2__.RichImageData(data, 'image/png');\n        case 27: return new _tags_js__WEBPACK_IMPORTED_MODULE_2__.RichImageData(data, 'image/bmp');\n        default: return data;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL2lzb2JtZmYvaXNvYm1mZi1yZWFkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyQztBQUNGO0FBQytEO0FBQ2pHO0FBQ0E7QUFDQTtBQUNQLG9CQUFvQixxREFBUztBQUM3QixpQkFBaUIscURBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCxXQUFXLHFEQUFTO0FBQ3BCO0FBQ087QUFDUCxXQUFXLHFEQUFTO0FBQ3BCO0FBQ087QUFDUDtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0EseUJBQXlCLGtEQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx5QkFBeUIscURBQVM7QUFDbEMsbUJBQW1CO0FBQ25CLFdBQVcsaURBQVcsUUFBUSxxREFBUztBQUN2QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscURBQVM7QUFDbkMsbUJBQW1CO0FBQ25CLGlCQUFpQixxREFBUztBQUMxQjtBQUNBLHVCQUF1QixpREFBVyxlQUFlO0FBQ2pELGlFQUFpRTtBQUNqRSw0QkFBNEIsbURBQWE7QUFDekMsNEJBQTRCLG1EQUFhO0FBQ3pDLDRCQUE0QixtREFBYTtBQUN6QztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRjaC1jdXQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL21lZGlhYnVubnkvZGlzdC9tb2R1bGVzL3NyYy9pc29ibWZmL2lzb2JtZmYtcmVhZGVyLmpzP2NmMGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjUtcHJlc2VudCwgVmFuaWxhZ3kgYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgeyBSaWNoSW1hZ2VEYXRhIH0gZnJvbSAnLi4vdGFncy5qcyc7XG5pbXBvcnQgeyB0ZXh0RGVjb2RlciB9IGZyb20gJy4uL21pc2MuanMnO1xuaW1wb3J0IHsgcmVhZEFzY2lpLCByZWFkQnl0ZXMsIHJlYWRJMzJCZSwgcmVhZFUxNkJlLCByZWFkVTMyQmUsIHJlYWRVNjRCZSwgcmVhZFU4IH0gZnJvbSAnLi4vcmVhZGVyLmpzJztcbmV4cG9ydCBjb25zdCBNSU5fQk9YX0hFQURFUl9TSVpFID0gODtcbmV4cG9ydCBjb25zdCBNQVhfQk9YX0hFQURFUl9TSVpFID0gMTY7XG5leHBvcnQgY29uc3QgcmVhZEJveEhlYWRlciA9IChzbGljZSkgPT4ge1xuICAgIGxldCB0b3RhbFNpemUgPSByZWFkVTMyQmUoc2xpY2UpO1xuICAgIGNvbnN0IG5hbWUgPSByZWFkQXNjaWkoc2xpY2UsIDQpO1xuICAgIGxldCBoZWFkZXJTaXplID0gODtcbiAgICBjb25zdCBoYXNMYXJnZVNpemUgPSB0b3RhbFNpemUgPT09IDE7XG4gICAgaWYgKGhhc0xhcmdlU2l6ZSkge1xuICAgICAgICB0b3RhbFNpemUgPSByZWFkVTY0QmUoc2xpY2UpO1xuICAgICAgICBoZWFkZXJTaXplID0gMTY7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnRTaXplID0gdG90YWxTaXplIC0gaGVhZGVyU2l6ZTtcbiAgICBpZiAoY29udGVudFNpemUgPCAwKSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyBIYXJkbHkgYSBib3ggaXMgaXRcbiAgICB9XG4gICAgcmV0dXJuIHsgbmFtZSwgdG90YWxTaXplLCBoZWFkZXJTaXplLCBjb250ZW50U2l6ZSB9O1xufTtcbmV4cG9ydCBjb25zdCByZWFkRml4ZWRfMTZfMTYgPSAoc2xpY2UpID0+IHtcbiAgICByZXR1cm4gcmVhZEkzMkJlKHNsaWNlKSAvIDB4MTAwMDA7XG59O1xuZXhwb3J0IGNvbnN0IHJlYWRGaXhlZF8yXzMwID0gKHNsaWNlKSA9PiB7XG4gICAgcmV0dXJuIHJlYWRJMzJCZShzbGljZSkgLyAweDQwMDAwMDAwO1xufTtcbmV4cG9ydCBjb25zdCByZWFkSXNvbVZhcmlhYmxlSW50ZWdlciA9IChzbGljZSkgPT4ge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA8PD0gNztcbiAgICAgICAgY29uc3QgbmV4dEJ5dGUgPSByZWFkVTgoc2xpY2UpO1xuICAgICAgICByZXN1bHQgfD0gbmV4dEJ5dGUgJiAweDdmO1xuICAgICAgICBpZiAoKG5leHRCeXRlICYgMHg4MCkgPT09IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0IGNvbnN0IHJlYWRNZXRhZGF0YVN0cmluZ1Nob3J0ID0gKHNsaWNlKSA9PiB7XG4gICAgY29uc3Qgc3RyaW5nTGVuZ3RoID0gcmVhZFUxNkJlKHNsaWNlKTtcbiAgICBzbGljZS5za2lwKDIpOyAvLyBMYW5ndWFnZVxuICAgIHJldHVybiB0ZXh0RGVjb2Rlci5kZWNvZGUocmVhZEJ5dGVzKHNsaWNlLCBzdHJpbmdMZW5ndGgpKTtcbn07XG5leHBvcnQgY29uc3QgcmVhZERhdGFCb3ggPSAoc2xpY2UpID0+IHtcbiAgICBjb25zdCBoZWFkZXIgPSByZWFkQm94SGVhZGVyKHNsaWNlKTtcbiAgICBpZiAoIWhlYWRlciB8fCBoZWFkZXIubmFtZSAhPT0gJ2RhdGEnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB0eXBlSW5kaWNhdG9yID0gcmVhZFUzMkJlKHNsaWNlKTtcbiAgICBzbGljZS5za2lwKDQpOyAvLyBMb2NhbGUgaW5kaWNhdG9yXG4gICAgY29uc3QgZGF0YSA9IHJlYWRCeXRlcyhzbGljZSwgaGVhZGVyLmNvbnRlbnRTaXplIC0gOCk7XG4gICAgc3dpdGNoICh0eXBlSW5kaWNhdG9yKSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIHRleHREZWNvZGVyLmRlY29kZShkYXRhKTsgLy8gVVRGLThcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRleHREZWNvZGVyKCd1dGYtMTZiZScpLmRlY29kZShkYXRhKTsgLy8gVVRGLTE2LUJFXG4gICAgICAgIGNhc2UgMTM6IHJldHVybiBuZXcgUmljaEltYWdlRGF0YShkYXRhLCAnaW1hZ2UvanBlZycpO1xuICAgICAgICBjYXNlIDE0OiByZXR1cm4gbmV3IFJpY2hJbWFnZURhdGEoZGF0YSwgJ2ltYWdlL3BuZycpO1xuICAgICAgICBjYXNlIDI3OiByZXR1cm4gbmV3IFJpY2hJbWFnZURhdGEoZGF0YSwgJ2ltYWdlL2JtcCcpO1xuICAgICAgICBkZWZhdWx0OiByZXR1cm4gZGF0YTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-reader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/matroska/ebml.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/matroska/ebml.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CODEC_STRING_MAP: () => (/* binding */ CODEC_STRING_MAP),\n/* harmony export */   EBMLFloat32: () => (/* binding */ EBMLFloat32),\n/* harmony export */   EBMLFloat64: () => (/* binding */ EBMLFloat64),\n/* harmony export */   EBMLId: () => (/* binding */ EBMLId),\n/* harmony export */   EBMLSignedInt: () => (/* binding */ EBMLSignedInt),\n/* harmony export */   EBMLUnicodeString: () => (/* binding */ EBMLUnicodeString),\n/* harmony export */   EBMLWriter: () => (/* binding */ EBMLWriter),\n/* harmony export */   LEVEL_0_AND_1_EBML_IDS: () => (/* binding */ LEVEL_0_AND_1_EBML_IDS),\n/* harmony export */   LEVEL_0_EBML_IDS: () => (/* binding */ LEVEL_0_EBML_IDS),\n/* harmony export */   LEVEL_1_EBML_IDS: () => (/* binding */ LEVEL_1_EBML_IDS),\n/* harmony export */   MAX_HEADER_SIZE: () => (/* binding */ MAX_HEADER_SIZE),\n/* harmony export */   MAX_VAR_INT_SIZE: () => (/* binding */ MAX_VAR_INT_SIZE),\n/* harmony export */   MIN_HEADER_SIZE: () => (/* binding */ MIN_HEADER_SIZE),\n/* harmony export */   assertDefinedSize: () => (/* binding */ assertDefinedSize),\n/* harmony export */   measureSignedInt: () => (/* binding */ measureSignedInt),\n/* harmony export */   measureUnsignedInt: () => (/* binding */ measureUnsignedInt),\n/* harmony export */   measureVarInt: () => (/* binding */ measureVarInt),\n/* harmony export */   readAsciiString: () => (/* binding */ readAsciiString),\n/* harmony export */   readElementHeader: () => (/* binding */ readElementHeader),\n/* harmony export */   readElementId: () => (/* binding */ readElementId),\n/* harmony export */   readElementSize: () => (/* binding */ readElementSize),\n/* harmony export */   readFloat: () => (/* binding */ readFloat),\n/* harmony export */   readSignedInt: () => (/* binding */ readSignedInt),\n/* harmony export */   readUnicodeString: () => (/* binding */ readUnicodeString),\n/* harmony export */   readUnsignedInt: () => (/* binding */ readUnsignedInt),\n/* harmony export */   readVarInt: () => (/* binding */ readVarInt),\n/* harmony export */   readVarIntSize: () => (/* binding */ readVarIntSize),\n/* harmony export */   resync: () => (/* binding */ resync),\n/* harmony export */   searchForNextElementId: () => (/* binding */ searchForNextElementId)\n/* harmony export */ });\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/* harmony import */ var _reader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../reader.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/reader.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n/** Wrapper around a number to be able to differentiate it in the writer. */\nclass EBMLFloat32 {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/** Wrapper around a number to be able to differentiate it in the writer. */\nclass EBMLFloat64 {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/** Wrapper around a number to be able to differentiate it in the writer. */\nclass EBMLSignedInt {\n    constructor(value) {\n        this.value = value;\n    }\n}\nclass EBMLUnicodeString {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/** Defines some of the EBML IDs used by Matroska files. */\nvar EBMLId;\n(function (EBMLId) {\n    EBMLId[EBMLId[\"EBML\"] = 440786851] = \"EBML\";\n    EBMLId[EBMLId[\"EBMLVersion\"] = 17030] = \"EBMLVersion\";\n    EBMLId[EBMLId[\"EBMLReadVersion\"] = 17143] = \"EBMLReadVersion\";\n    EBMLId[EBMLId[\"EBMLMaxIDLength\"] = 17138] = \"EBMLMaxIDLength\";\n    EBMLId[EBMLId[\"EBMLMaxSizeLength\"] = 17139] = \"EBMLMaxSizeLength\";\n    EBMLId[EBMLId[\"DocType\"] = 17026] = \"DocType\";\n    EBMLId[EBMLId[\"DocTypeVersion\"] = 17031] = \"DocTypeVersion\";\n    EBMLId[EBMLId[\"DocTypeReadVersion\"] = 17029] = \"DocTypeReadVersion\";\n    EBMLId[EBMLId[\"Void\"] = 236] = \"Void\";\n    EBMLId[EBMLId[\"Segment\"] = 408125543] = \"Segment\";\n    EBMLId[EBMLId[\"SeekHead\"] = 290298740] = \"SeekHead\";\n    EBMLId[EBMLId[\"Seek\"] = 19899] = \"Seek\";\n    EBMLId[EBMLId[\"SeekID\"] = 21419] = \"SeekID\";\n    EBMLId[EBMLId[\"SeekPosition\"] = 21420] = \"SeekPosition\";\n    EBMLId[EBMLId[\"Duration\"] = 17545] = \"Duration\";\n    EBMLId[EBMLId[\"Info\"] = 357149030] = \"Info\";\n    EBMLId[EBMLId[\"TimestampScale\"] = 2807729] = \"TimestampScale\";\n    EBMLId[EBMLId[\"MuxingApp\"] = 19840] = \"MuxingApp\";\n    EBMLId[EBMLId[\"WritingApp\"] = 22337] = \"WritingApp\";\n    EBMLId[EBMLId[\"Tracks\"] = 374648427] = \"Tracks\";\n    EBMLId[EBMLId[\"TrackEntry\"] = 174] = \"TrackEntry\";\n    EBMLId[EBMLId[\"TrackNumber\"] = 215] = \"TrackNumber\";\n    EBMLId[EBMLId[\"TrackUID\"] = 29637] = \"TrackUID\";\n    EBMLId[EBMLId[\"TrackType\"] = 131] = \"TrackType\";\n    EBMLId[EBMLId[\"FlagEnabled\"] = 185] = \"FlagEnabled\";\n    EBMLId[EBMLId[\"FlagDefault\"] = 136] = \"FlagDefault\";\n    EBMLId[EBMLId[\"FlagForced\"] = 21930] = \"FlagForced\";\n    EBMLId[EBMLId[\"FlagLacing\"] = 156] = \"FlagLacing\";\n    EBMLId[EBMLId[\"Name\"] = 21358] = \"Name\";\n    EBMLId[EBMLId[\"Language\"] = 2274716] = \"Language\";\n    EBMLId[EBMLId[\"LanguageBCP47\"] = 2274717] = \"LanguageBCP47\";\n    EBMLId[EBMLId[\"CodecID\"] = 134] = \"CodecID\";\n    EBMLId[EBMLId[\"CodecPrivate\"] = 25506] = \"CodecPrivate\";\n    EBMLId[EBMLId[\"CodecDelay\"] = 22186] = \"CodecDelay\";\n    EBMLId[EBMLId[\"SeekPreRoll\"] = 22203] = \"SeekPreRoll\";\n    EBMLId[EBMLId[\"DefaultDuration\"] = 2352003] = \"DefaultDuration\";\n    EBMLId[EBMLId[\"Video\"] = 224] = \"Video\";\n    EBMLId[EBMLId[\"PixelWidth\"] = 176] = \"PixelWidth\";\n    EBMLId[EBMLId[\"PixelHeight\"] = 186] = \"PixelHeight\";\n    EBMLId[EBMLId[\"Audio\"] = 225] = \"Audio\";\n    EBMLId[EBMLId[\"SamplingFrequency\"] = 181] = \"SamplingFrequency\";\n    EBMLId[EBMLId[\"Channels\"] = 159] = \"Channels\";\n    EBMLId[EBMLId[\"BitDepth\"] = 25188] = \"BitDepth\";\n    EBMLId[EBMLId[\"SimpleBlock\"] = 163] = \"SimpleBlock\";\n    EBMLId[EBMLId[\"BlockGroup\"] = 160] = \"BlockGroup\";\n    EBMLId[EBMLId[\"Block\"] = 161] = \"Block\";\n    EBMLId[EBMLId[\"BlockAdditions\"] = 30113] = \"BlockAdditions\";\n    EBMLId[EBMLId[\"BlockMore\"] = 166] = \"BlockMore\";\n    EBMLId[EBMLId[\"BlockAdditional\"] = 165] = \"BlockAdditional\";\n    EBMLId[EBMLId[\"BlockAddID\"] = 238] = \"BlockAddID\";\n    EBMLId[EBMLId[\"BlockDuration\"] = 155] = \"BlockDuration\";\n    EBMLId[EBMLId[\"ReferenceBlock\"] = 251] = \"ReferenceBlock\";\n    EBMLId[EBMLId[\"Cluster\"] = 524531317] = \"Cluster\";\n    EBMLId[EBMLId[\"Timestamp\"] = 231] = \"Timestamp\";\n    EBMLId[EBMLId[\"Cues\"] = 475249515] = \"Cues\";\n    EBMLId[EBMLId[\"CuePoint\"] = 187] = \"CuePoint\";\n    EBMLId[EBMLId[\"CueTime\"] = 179] = \"CueTime\";\n    EBMLId[EBMLId[\"CueTrackPositions\"] = 183] = \"CueTrackPositions\";\n    EBMLId[EBMLId[\"CueTrack\"] = 247] = \"CueTrack\";\n    EBMLId[EBMLId[\"CueClusterPosition\"] = 241] = \"CueClusterPosition\";\n    EBMLId[EBMLId[\"Colour\"] = 21936] = \"Colour\";\n    EBMLId[EBMLId[\"MatrixCoefficients\"] = 21937] = \"MatrixCoefficients\";\n    EBMLId[EBMLId[\"TransferCharacteristics\"] = 21946] = \"TransferCharacteristics\";\n    EBMLId[EBMLId[\"Primaries\"] = 21947] = \"Primaries\";\n    EBMLId[EBMLId[\"Range\"] = 21945] = \"Range\";\n    EBMLId[EBMLId[\"Projection\"] = 30320] = \"Projection\";\n    EBMLId[EBMLId[\"ProjectionType\"] = 30321] = \"ProjectionType\";\n    EBMLId[EBMLId[\"ProjectionPoseRoll\"] = 30325] = \"ProjectionPoseRoll\";\n    EBMLId[EBMLId[\"Attachments\"] = 423732329] = \"Attachments\";\n    EBMLId[EBMLId[\"AttachedFile\"] = 24999] = \"AttachedFile\";\n    EBMLId[EBMLId[\"FileDescription\"] = 18046] = \"FileDescription\";\n    EBMLId[EBMLId[\"FileName\"] = 18030] = \"FileName\";\n    EBMLId[EBMLId[\"FileMediaType\"] = 18016] = \"FileMediaType\";\n    EBMLId[EBMLId[\"FileData\"] = 18012] = \"FileData\";\n    EBMLId[EBMLId[\"FileUID\"] = 18094] = \"FileUID\";\n    EBMLId[EBMLId[\"Chapters\"] = 272869232] = \"Chapters\";\n    EBMLId[EBMLId[\"Tags\"] = 307544935] = \"Tags\";\n    EBMLId[EBMLId[\"Tag\"] = 29555] = \"Tag\";\n    EBMLId[EBMLId[\"Targets\"] = 25536] = \"Targets\";\n    EBMLId[EBMLId[\"TargetTypeValue\"] = 26826] = \"TargetTypeValue\";\n    EBMLId[EBMLId[\"TargetType\"] = 25546] = \"TargetType\";\n    EBMLId[EBMLId[\"TagTrackUID\"] = 25541] = \"TagTrackUID\";\n    EBMLId[EBMLId[\"TagEditionUID\"] = 25545] = \"TagEditionUID\";\n    EBMLId[EBMLId[\"TagChapterUID\"] = 25540] = \"TagChapterUID\";\n    EBMLId[EBMLId[\"TagAttachmentUID\"] = 25542] = \"TagAttachmentUID\";\n    EBMLId[EBMLId[\"SimpleTag\"] = 26568] = \"SimpleTag\";\n    EBMLId[EBMLId[\"TagName\"] = 17827] = \"TagName\";\n    EBMLId[EBMLId[\"TagLanguage\"] = 17530] = \"TagLanguage\";\n    EBMLId[EBMLId[\"TagString\"] = 17543] = \"TagString\";\n    EBMLId[EBMLId[\"TagBinary\"] = 17541] = \"TagBinary\";\n})(EBMLId || (EBMLId = {}));\nconst LEVEL_0_EBML_IDS = [\n    EBMLId.EBML,\n    EBMLId.Segment,\n];\n// All the stuff that can appear in a segment, basically\nconst LEVEL_1_EBML_IDS = [\n    EBMLId.SeekHead,\n    EBMLId.Info,\n    EBMLId.Cluster,\n    EBMLId.Tracks,\n    EBMLId.Cues,\n    EBMLId.Attachments,\n    EBMLId.Chapters,\n    EBMLId.Tags,\n];\nconst LEVEL_0_AND_1_EBML_IDS = [\n    ...LEVEL_0_EBML_IDS,\n    ...LEVEL_1_EBML_IDS,\n];\nconst measureUnsignedInt = (value) => {\n    if (value < (1 << 8)) {\n        return 1;\n    }\n    else if (value < (1 << 16)) {\n        return 2;\n    }\n    else if (value < (1 << 24)) {\n        return 3;\n    }\n    else if (value < 2 ** 32) {\n        return 4;\n    }\n    else if (value < 2 ** 40) {\n        return 5;\n    }\n    else {\n        return 6;\n    }\n};\nconst measureSignedInt = (value) => {\n    if (value >= -(1 << 6) && value < (1 << 6)) {\n        return 1;\n    }\n    else if (value >= -(1 << 13) && value < (1 << 13)) {\n        return 2;\n    }\n    else if (value >= -(1 << 20) && value < (1 << 20)) {\n        return 3;\n    }\n    else if (value >= -(1 << 27) && value < (1 << 27)) {\n        return 4;\n    }\n    else if (value >= -(2 ** 34) && value < 2 ** 34) {\n        return 5;\n    }\n    else {\n        return 6;\n    }\n};\nconst measureVarInt = (value) => {\n    if (value < (1 << 7) - 1) {\n        /** Top bit is set, leaving 7 bits to hold the integer, but we can't store\n         * 127 because \"all bits set to one\" is a reserved value. Same thing for the\n         * other cases below:\n         */\n        return 1;\n    }\n    else if (value < (1 << 14) - 1) {\n        return 2;\n    }\n    else if (value < (1 << 21) - 1) {\n        return 3;\n    }\n    else if (value < (1 << 28) - 1) {\n        return 4;\n    }\n    else if (value < 2 ** 35 - 1) {\n        return 5;\n    }\n    else if (value < 2 ** 42 - 1) {\n        return 6;\n    }\n    else {\n        throw new Error('EBML varint size not supported ' + value);\n    }\n};\nclass EBMLWriter {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n        /**\n         * Stores the position from the start of the file to where EBML elements have been written. This is used to\n         * rewrite/edit elements that were already added before, and to measure sizes of things.\n         */\n        this.offsets = new WeakMap();\n        /** Same as offsets, but stores position where the element's data starts (after ID and size fields). */\n        this.dataOffsets = new WeakMap();\n    }\n    writeByte(value) {\n        this.helperView.setUint8(0, value);\n        this.writer.write(this.helper.subarray(0, 1));\n    }\n    writeFloat32(value) {\n        this.helperView.setFloat32(0, value, false);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeFloat64(value) {\n        this.helperView.setFloat64(0, value, false);\n        this.writer.write(this.helper);\n    }\n    writeUnsignedInt(value, width = measureUnsignedInt(value)) {\n        let pos = 0;\n        // Each case falls through:\n        switch (width) {\n            case 6:\n                // Need to use division to access >32 bits of floating point var\n                this.helperView.setUint8(pos++, (value / 2 ** 40) | 0);\n            // eslint-disable-next-line no-fallthrough\n            case 5:\n                this.helperView.setUint8(pos++, (value / 2 ** 32) | 0);\n            // eslint-disable-next-line no-fallthrough\n            case 4:\n                this.helperView.setUint8(pos++, value >> 24);\n            // eslint-disable-next-line no-fallthrough\n            case 3:\n                this.helperView.setUint8(pos++, value >> 16);\n            // eslint-disable-next-line no-fallthrough\n            case 2:\n                this.helperView.setUint8(pos++, value >> 8);\n            // eslint-disable-next-line no-fallthrough\n            case 1:\n                this.helperView.setUint8(pos++, value);\n                break;\n            default:\n                throw new Error('Bad unsigned int size ' + width);\n        }\n        this.writer.write(this.helper.subarray(0, pos));\n    }\n    writeSignedInt(value, width = measureSignedInt(value)) {\n        if (value < 0) {\n            // Two's complement stuff\n            value += 2 ** (width * 8);\n        }\n        this.writeUnsignedInt(value, width);\n    }\n    writeVarInt(value, width = measureVarInt(value)) {\n        let pos = 0;\n        switch (width) {\n            case 1:\n                this.helperView.setUint8(pos++, (1 << 7) | value);\n                break;\n            case 2:\n                this.helperView.setUint8(pos++, (1 << 6) | (value >> 8));\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 3:\n                this.helperView.setUint8(pos++, (1 << 5) | (value >> 16));\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 4:\n                this.helperView.setUint8(pos++, (1 << 4) | (value >> 24));\n                this.helperView.setUint8(pos++, value >> 16);\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 5:\n                /**\n                 * JavaScript converts its doubles to 32-bit integers for bitwise\n                 * operations, so we need to do a division by 2^32 instead of a\n                 * right-shift of 32 to retain those top 3 bits\n                 */\n                this.helperView.setUint8(pos++, (1 << 3) | ((value / 2 ** 32) & 0x7));\n                this.helperView.setUint8(pos++, value >> 24);\n                this.helperView.setUint8(pos++, value >> 16);\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 6:\n                this.helperView.setUint8(pos++, (1 << 2) | ((value / 2 ** 40) & 0x3));\n                this.helperView.setUint8(pos++, (value / 2 ** 32) | 0);\n                this.helperView.setUint8(pos++, value >> 24);\n                this.helperView.setUint8(pos++, value >> 16);\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            default:\n                throw new Error('Bad EBML varint size ' + width);\n        }\n        this.writer.write(this.helper.subarray(0, pos));\n    }\n    writeAsciiString(str) {\n        this.writer.write(new Uint8Array(str.split('').map(x => x.charCodeAt(0))));\n    }\n    writeEBML(data) {\n        if (data === null)\n            return;\n        if (data instanceof Uint8Array) {\n            this.writer.write(data);\n        }\n        else if (Array.isArray(data)) {\n            for (const elem of data) {\n                this.writeEBML(elem);\n            }\n        }\n        else {\n            this.offsets.set(data, this.writer.getPos());\n            this.writeUnsignedInt(data.id); // ID field\n            if (Array.isArray(data.data)) {\n                const sizePos = this.writer.getPos();\n                const sizeSize = data.size === -1 ? 1 : (data.size ?? 4);\n                if (data.size === -1) {\n                    // Write the reserved all-one-bits marker for unknown/unbounded size.\n                    this.writeByte(0xff);\n                }\n                else {\n                    this.writer.seek(this.writer.getPos() + sizeSize);\n                }\n                const startPos = this.writer.getPos();\n                this.dataOffsets.set(data, startPos);\n                this.writeEBML(data.data);\n                if (data.size !== -1) {\n                    const size = this.writer.getPos() - startPos;\n                    const endPos = this.writer.getPos();\n                    this.writer.seek(sizePos);\n                    this.writeVarInt(size, sizeSize);\n                    this.writer.seek(endPos);\n                }\n            }\n            else if (typeof data.data === 'number') {\n                const size = data.size ?? measureUnsignedInt(data.data);\n                this.writeVarInt(size);\n                this.writeUnsignedInt(data.data, size);\n            }\n            else if (typeof data.data === 'string') {\n                this.writeVarInt(data.data.length);\n                this.writeAsciiString(data.data);\n            }\n            else if (data.data instanceof Uint8Array) {\n                this.writeVarInt(data.data.byteLength, data.size);\n                this.writer.write(data.data);\n            }\n            else if (data.data instanceof EBMLFloat32) {\n                this.writeVarInt(4);\n                this.writeFloat32(data.data.value);\n            }\n            else if (data.data instanceof EBMLFloat64) {\n                this.writeVarInt(8);\n                this.writeFloat64(data.data.value);\n            }\n            else if (data.data instanceof EBMLSignedInt) {\n                const size = data.size ?? measureSignedInt(data.data.value);\n                this.writeVarInt(size);\n                this.writeSignedInt(data.data.value, size);\n            }\n            else if (data.data instanceof EBMLUnicodeString) {\n                const bytes = _misc_js__WEBPACK_IMPORTED_MODULE_0__.textEncoder.encode(data.data.value);\n                this.writeVarInt(bytes.length);\n                this.writer.write(bytes);\n            }\n            else {\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assertNever)(data.data);\n            }\n        }\n    }\n}\nconst MAX_VAR_INT_SIZE = 8;\nconst MIN_HEADER_SIZE = 2; // 1-byte ID and 1-byte size\nconst MAX_HEADER_SIZE = 2 * MAX_VAR_INT_SIZE; // 8-byte ID and 8-byte size\nconst readVarIntSize = (slice) => {\n    const firstByte = (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readU8)(slice);\n    slice.skip(-1);\n    if (firstByte === 0) {\n        return null; // Invalid VINT\n    }\n    let width = 1;\n    let mask = 0x80;\n    while ((firstByte & mask) === 0) {\n        width++;\n        mask >>= 1;\n    }\n    return width;\n};\nconst readVarInt = (slice) => {\n    // Read the first byte to determine the width of the variable-length integer\n    const firstByte = (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readU8)(slice);\n    if (firstByte === 0) {\n        return null; // Invalid VINT\n    }\n    // Find the position of VINT_MARKER, which determines the width\n    let width = 1;\n    let mask = 1 << 7;\n    while ((firstByte & mask) === 0) {\n        width++;\n        mask >>= 1;\n    }\n    // First byte's value needs the marker bit cleared\n    let value = firstByte & (mask - 1);\n    // Read remaining bytes\n    for (let i = 1; i < width; i++) {\n        value *= 1 << 8;\n        value += (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readU8)(slice);\n    }\n    return value;\n};\nconst readUnsignedInt = (slice, width) => {\n    if (width < 1 || width > 8) {\n        throw new Error('Bad unsigned int size ' + width);\n    }\n    let value = 0;\n    // Read bytes from most significant to least significant\n    for (let i = 0; i < width; i++) {\n        value *= 1 << 8;\n        value += (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readU8)(slice);\n    }\n    return value;\n};\nconst readSignedInt = (slice, width) => {\n    let value = readUnsignedInt(slice, width);\n    // If the highest bit is set, convert from two's complement\n    if (value & (1 << (width * 8 - 1))) {\n        value -= 2 ** (width * 8);\n    }\n    return value;\n};\nconst readElementId = (slice) => {\n    const size = readVarIntSize(slice);\n    if (size === null) {\n        return null;\n    }\n    const id = readUnsignedInt(slice, size);\n    return id;\n};\nconst readElementSize = (slice) => {\n    let size = (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readU8)(slice);\n    if (size === 0xff) {\n        size = null;\n    }\n    else {\n        slice.skip(-1);\n        size = readVarInt(slice);\n        // In some (livestreamed) files, this is the value of the size field. While this technically is just a very\n        // large number, it is intended to behave like the reserved size 0xFF, meaning the size is undefined. We\n        // catch the number here. Note that it cannot be perfectly represented as a double, but the comparison works\n        // nonetheless.\n        // eslint-disable-next-line no-loss-of-precision\n        if (size === 0x00ffffffffffffff) {\n            size = null;\n        }\n    }\n    return size;\n};\nconst readElementHeader = (slice) => {\n    const id = readElementId(slice);\n    if (id === null) {\n        return null;\n    }\n    const size = readElementSize(slice);\n    return { id, size };\n};\nconst readAsciiString = (slice, length) => {\n    const bytes = (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readBytes)(slice, length);\n    // Actual string length might be shorter due to null terminators\n    let strLength = 0;\n    while (strLength < length && bytes[strLength] !== 0) {\n        strLength += 1;\n    }\n    return String.fromCharCode(...bytes.subarray(0, strLength));\n};\nconst readUnicodeString = (slice, length) => {\n    const bytes = (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readBytes)(slice, length);\n    // Actual string length might be shorter due to null terminators\n    let strLength = 0;\n    while (strLength < length && bytes[strLength] !== 0) {\n        strLength += 1;\n    }\n    return _misc_js__WEBPACK_IMPORTED_MODULE_0__.textDecoder.decode(bytes.subarray(0, strLength));\n};\nconst readFloat = (slice, width) => {\n    if (width === 0) {\n        return 0;\n    }\n    if (width !== 4 && width !== 8) {\n        throw new Error('Bad float size ' + width);\n    }\n    return width === 4 ? (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readF32Be)(slice) : (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readF64Be)(slice);\n};\n/** Returns the byte offset in the file of the next element with a matching ID. */\nconst searchForNextElementId = async (reader, startPos, ids, until) => {\n    const idsSet = new Set(ids);\n    let currentPos = startPos;\n    while (until === null || currentPos < until) {\n        let slice = reader.requestSliceRange(currentPos, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            break;\n        const elementHeader = readElementHeader(slice);\n        if (!elementHeader) {\n            break;\n        }\n        if (idsSet.has(elementHeader.id)) {\n            return { pos: currentPos, found: true };\n        }\n        assertDefinedSize(elementHeader.size);\n        currentPos = slice.filePos + elementHeader.size;\n    }\n    return { pos: (until !== null && until > currentPos) ? until : currentPos, found: false };\n};\n/** Searches for the next occurrence of an element ID using a naive byte-wise search. */\nconst resync = async (reader, startPos, ids, until) => {\n    const CHUNK_SIZE = 2 ** 16; // So we don't need to grab thousands of slices\n    const idsSet = new Set(ids);\n    let currentPos = startPos;\n    while (currentPos < until) {\n        let slice = reader.requestSliceRange(currentPos, 0, Math.min(CHUNK_SIZE, until - currentPos));\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            break;\n        if (slice.length < MAX_VAR_INT_SIZE)\n            break;\n        for (let i = 0; i < slice.length - MAX_VAR_INT_SIZE; i++) {\n            slice.filePos = currentPos;\n            const elementId = readElementId(slice);\n            if (elementId !== null && idsSet.has(elementId)) {\n                return currentPos;\n            }\n            currentPos++;\n        }\n    }\n    return null;\n};\nconst CODEC_STRING_MAP = {\n    'avc': 'V_MPEG4/ISO/AVC',\n    'hevc': 'V_MPEGH/ISO/HEVC',\n    'vp8': 'V_VP8',\n    'vp9': 'V_VP9',\n    'av1': 'V_AV1',\n    'aac': 'A_AAC',\n    'mp3': 'A_MPEG/L3',\n    'opus': 'A_OPUS',\n    'vorbis': 'A_VORBIS',\n    'flac': 'A_FLAC',\n    'pcm-u8': 'A_PCM/INT/LIT',\n    'pcm-s16': 'A_PCM/INT/LIT',\n    'pcm-s16be': 'A_PCM/INT/BIG',\n    'pcm-s24': 'A_PCM/INT/LIT',\n    'pcm-s24be': 'A_PCM/INT/BIG',\n    'pcm-s32': 'A_PCM/INT/LIT',\n    'pcm-s32be': 'A_PCM/INT/BIG',\n    'pcm-f32': 'A_PCM/FLOAT/IEEE',\n    'pcm-f64': 'A_PCM/FLOAT/IEEE',\n    'webvtt': 'S_TEXT/WEBVTT',\n};\nfunction assertDefinedSize(size) {\n    if (size === null) {\n        throw new Error('Undefined element size is used in a place where it is not supported.');\n    }\n}\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL21hdHJvc2thL2VibWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ21FO0FBQ0k7QUFDdkU7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ2xCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpREFBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0EsMkJBQTJCO0FBQzNCLDhDQUE4QztBQUM5QztBQUNQLHNCQUFzQixrREFBTTtBQUM1QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxzQkFBc0Isa0RBQU07QUFDNUI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0EsaUJBQWlCLGtEQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0EsaUJBQWlCLGtEQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLGtEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLGtCQUFrQixxREFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0JBQWtCLHFEQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlEQUFXO0FBQ3RCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscURBQVMsVUFBVSxxREFBUztBQUNyRDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUNBQXFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRjaC1jdXQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL21lZGlhYnVubnkvZGlzdC9tb2R1bGVzL3NyYy9tYXRyb3NrYS9lYm1sLmpzPzQ2OGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjUtcHJlc2VudCwgVmFuaWxhZ3kgYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgeyBhc3NlcnROZXZlciwgdGV4dERlY29kZXIsIHRleHRFbmNvZGVyIH0gZnJvbSAnLi4vbWlzYy5qcyc7XG5pbXBvcnQgeyByZWFkQnl0ZXMsIHJlYWRGMzJCZSwgcmVhZEY2NEJlLCByZWFkVTggfSBmcm9tICcuLi9yZWFkZXIuanMnO1xuLyoqIFdyYXBwZXIgYXJvdW5kIGEgbnVtYmVyIHRvIGJlIGFibGUgdG8gZGlmZmVyZW50aWF0ZSBpdCBpbiB0aGUgd3JpdGVyLiAqL1xuZXhwb3J0IGNsYXNzIEVCTUxGbG9hdDMyIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuLyoqIFdyYXBwZXIgYXJvdW5kIGEgbnVtYmVyIHRvIGJlIGFibGUgdG8gZGlmZmVyZW50aWF0ZSBpdCBpbiB0aGUgd3JpdGVyLiAqL1xuZXhwb3J0IGNsYXNzIEVCTUxGbG9hdDY0IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuLyoqIFdyYXBwZXIgYXJvdW5kIGEgbnVtYmVyIHRvIGJlIGFibGUgdG8gZGlmZmVyZW50aWF0ZSBpdCBpbiB0aGUgd3JpdGVyLiAqL1xuZXhwb3J0IGNsYXNzIEVCTUxTaWduZWRJbnQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRUJNTFVuaWNvZGVTdHJpbmcge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59XG4vKiogRGVmaW5lcyBzb21lIG9mIHRoZSBFQk1MIElEcyB1c2VkIGJ5IE1hdHJvc2thIGZpbGVzLiAqL1xuZXhwb3J0IHZhciBFQk1MSWQ7XG4oZnVuY3Rpb24gKEVCTUxJZCkge1xuICAgIEVCTUxJZFtFQk1MSWRbXCJFQk1MXCJdID0gNDQwNzg2ODUxXSA9IFwiRUJNTFwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJFQk1MVmVyc2lvblwiXSA9IDE3MDMwXSA9IFwiRUJNTFZlcnNpb25cIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiRUJNTFJlYWRWZXJzaW9uXCJdID0gMTcxNDNdID0gXCJFQk1MUmVhZFZlcnNpb25cIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiRUJNTE1heElETGVuZ3RoXCJdID0gMTcxMzhdID0gXCJFQk1MTWF4SURMZW5ndGhcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiRUJNTE1heFNpemVMZW5ndGhcIl0gPSAxNzEzOV0gPSBcIkVCTUxNYXhTaXplTGVuZ3RoXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIkRvY1R5cGVcIl0gPSAxNzAyNl0gPSBcIkRvY1R5cGVcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiRG9jVHlwZVZlcnNpb25cIl0gPSAxNzAzMV0gPSBcIkRvY1R5cGVWZXJzaW9uXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIkRvY1R5cGVSZWFkVmVyc2lvblwiXSA9IDE3MDI5XSA9IFwiRG9jVHlwZVJlYWRWZXJzaW9uXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIlZvaWRcIl0gPSAyMzZdID0gXCJWb2lkXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIlNlZ21lbnRcIl0gPSA0MDgxMjU1NDNdID0gXCJTZWdtZW50XCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIlNlZWtIZWFkXCJdID0gMjkwMjk4NzQwXSA9IFwiU2Vla0hlYWRcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiU2Vla1wiXSA9IDE5ODk5XSA9IFwiU2Vla1wiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJTZWVrSURcIl0gPSAyMTQxOV0gPSBcIlNlZWtJRFwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJTZWVrUG9zaXRpb25cIl0gPSAyMTQyMF0gPSBcIlNlZWtQb3NpdGlvblwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJEdXJhdGlvblwiXSA9IDE3NTQ1XSA9IFwiRHVyYXRpb25cIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiSW5mb1wiXSA9IDM1NzE0OTAzMF0gPSBcIkluZm9cIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiVGltZXN0YW1wU2NhbGVcIl0gPSAyODA3NzI5XSA9IFwiVGltZXN0YW1wU2NhbGVcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiTXV4aW5nQXBwXCJdID0gMTk4NDBdID0gXCJNdXhpbmdBcHBcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiV3JpdGluZ0FwcFwiXSA9IDIyMzM3XSA9IFwiV3JpdGluZ0FwcFwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJUcmFja3NcIl0gPSAzNzQ2NDg0MjddID0gXCJUcmFja3NcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiVHJhY2tFbnRyeVwiXSA9IDE3NF0gPSBcIlRyYWNrRW50cnlcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiVHJhY2tOdW1iZXJcIl0gPSAyMTVdID0gXCJUcmFja051bWJlclwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJUcmFja1VJRFwiXSA9IDI5NjM3XSA9IFwiVHJhY2tVSURcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiVHJhY2tUeXBlXCJdID0gMTMxXSA9IFwiVHJhY2tUeXBlXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIkZsYWdFbmFibGVkXCJdID0gMTg1XSA9IFwiRmxhZ0VuYWJsZWRcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiRmxhZ0RlZmF1bHRcIl0gPSAxMzZdID0gXCJGbGFnRGVmYXVsdFwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJGbGFnRm9yY2VkXCJdID0gMjE5MzBdID0gXCJGbGFnRm9yY2VkXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIkZsYWdMYWNpbmdcIl0gPSAxNTZdID0gXCJGbGFnTGFjaW5nXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIk5hbWVcIl0gPSAyMTM1OF0gPSBcIk5hbWVcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiTGFuZ3VhZ2VcIl0gPSAyMjc0NzE2XSA9IFwiTGFuZ3VhZ2VcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiTGFuZ3VhZ2VCQ1A0N1wiXSA9IDIyNzQ3MTddID0gXCJMYW5ndWFnZUJDUDQ3XCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIkNvZGVjSURcIl0gPSAxMzRdID0gXCJDb2RlY0lEXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIkNvZGVjUHJpdmF0ZVwiXSA9IDI1NTA2XSA9IFwiQ29kZWNQcml2YXRlXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIkNvZGVjRGVsYXlcIl0gPSAyMjE4Nl0gPSBcIkNvZGVjRGVsYXlcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiU2Vla1ByZVJvbGxcIl0gPSAyMjIwM10gPSBcIlNlZWtQcmVSb2xsXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIkRlZmF1bHREdXJhdGlvblwiXSA9IDIzNTIwMDNdID0gXCJEZWZhdWx0RHVyYXRpb25cIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiVmlkZW9cIl0gPSAyMjRdID0gXCJWaWRlb1wiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJQaXhlbFdpZHRoXCJdID0gMTc2XSA9IFwiUGl4ZWxXaWR0aFwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJQaXhlbEhlaWdodFwiXSA9IDE4Nl0gPSBcIlBpeGVsSGVpZ2h0XCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIkF1ZGlvXCJdID0gMjI1XSA9IFwiQXVkaW9cIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiU2FtcGxpbmdGcmVxdWVuY3lcIl0gPSAxODFdID0gXCJTYW1wbGluZ0ZyZXF1ZW5jeVwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJDaGFubmVsc1wiXSA9IDE1OV0gPSBcIkNoYW5uZWxzXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIkJpdERlcHRoXCJdID0gMjUxODhdID0gXCJCaXREZXB0aFwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJTaW1wbGVCbG9ja1wiXSA9IDE2M10gPSBcIlNpbXBsZUJsb2NrXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIkJsb2NrR3JvdXBcIl0gPSAxNjBdID0gXCJCbG9ja0dyb3VwXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIkJsb2NrXCJdID0gMTYxXSA9IFwiQmxvY2tcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiQmxvY2tBZGRpdGlvbnNcIl0gPSAzMDExM10gPSBcIkJsb2NrQWRkaXRpb25zXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIkJsb2NrTW9yZVwiXSA9IDE2Nl0gPSBcIkJsb2NrTW9yZVwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJCbG9ja0FkZGl0aW9uYWxcIl0gPSAxNjVdID0gXCJCbG9ja0FkZGl0aW9uYWxcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiQmxvY2tBZGRJRFwiXSA9IDIzOF0gPSBcIkJsb2NrQWRkSURcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiQmxvY2tEdXJhdGlvblwiXSA9IDE1NV0gPSBcIkJsb2NrRHVyYXRpb25cIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiUmVmZXJlbmNlQmxvY2tcIl0gPSAyNTFdID0gXCJSZWZlcmVuY2VCbG9ja1wiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJDbHVzdGVyXCJdID0gNTI0NTMxMzE3XSA9IFwiQ2x1c3RlclwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJUaW1lc3RhbXBcIl0gPSAyMzFdID0gXCJUaW1lc3RhbXBcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiQ3Vlc1wiXSA9IDQ3NTI0OTUxNV0gPSBcIkN1ZXNcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiQ3VlUG9pbnRcIl0gPSAxODddID0gXCJDdWVQb2ludFwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJDdWVUaW1lXCJdID0gMTc5XSA9IFwiQ3VlVGltZVwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJDdWVUcmFja1Bvc2l0aW9uc1wiXSA9IDE4M10gPSBcIkN1ZVRyYWNrUG9zaXRpb25zXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIkN1ZVRyYWNrXCJdID0gMjQ3XSA9IFwiQ3VlVHJhY2tcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiQ3VlQ2x1c3RlclBvc2l0aW9uXCJdID0gMjQxXSA9IFwiQ3VlQ2x1c3RlclBvc2l0aW9uXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIkNvbG91clwiXSA9IDIxOTM2XSA9IFwiQ29sb3VyXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIk1hdHJpeENvZWZmaWNpZW50c1wiXSA9IDIxOTM3XSA9IFwiTWF0cml4Q29lZmZpY2llbnRzXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIlRyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzXCJdID0gMjE5NDZdID0gXCJUcmFuc2ZlckNoYXJhY3RlcmlzdGljc1wiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJQcmltYXJpZXNcIl0gPSAyMTk0N10gPSBcIlByaW1hcmllc1wiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJSYW5nZVwiXSA9IDIxOTQ1XSA9IFwiUmFuZ2VcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiUHJvamVjdGlvblwiXSA9IDMwMzIwXSA9IFwiUHJvamVjdGlvblwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJQcm9qZWN0aW9uVHlwZVwiXSA9IDMwMzIxXSA9IFwiUHJvamVjdGlvblR5cGVcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiUHJvamVjdGlvblBvc2VSb2xsXCJdID0gMzAzMjVdID0gXCJQcm9qZWN0aW9uUG9zZVJvbGxcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiQXR0YWNobWVudHNcIl0gPSA0MjM3MzIzMjldID0gXCJBdHRhY2htZW50c1wiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJBdHRhY2hlZEZpbGVcIl0gPSAyNDk5OV0gPSBcIkF0dGFjaGVkRmlsZVwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJGaWxlRGVzY3JpcHRpb25cIl0gPSAxODA0Nl0gPSBcIkZpbGVEZXNjcmlwdGlvblwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJGaWxlTmFtZVwiXSA9IDE4MDMwXSA9IFwiRmlsZU5hbWVcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiRmlsZU1lZGlhVHlwZVwiXSA9IDE4MDE2XSA9IFwiRmlsZU1lZGlhVHlwZVwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJGaWxlRGF0YVwiXSA9IDE4MDEyXSA9IFwiRmlsZURhdGFcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiRmlsZVVJRFwiXSA9IDE4MDk0XSA9IFwiRmlsZVVJRFwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJDaGFwdGVyc1wiXSA9IDI3Mjg2OTIzMl0gPSBcIkNoYXB0ZXJzXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIlRhZ3NcIl0gPSAzMDc1NDQ5MzVdID0gXCJUYWdzXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIlRhZ1wiXSA9IDI5NTU1XSA9IFwiVGFnXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIlRhcmdldHNcIl0gPSAyNTUzNl0gPSBcIlRhcmdldHNcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiVGFyZ2V0VHlwZVZhbHVlXCJdID0gMjY4MjZdID0gXCJUYXJnZXRUeXBlVmFsdWVcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiVGFyZ2V0VHlwZVwiXSA9IDI1NTQ2XSA9IFwiVGFyZ2V0VHlwZVwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJUYWdUcmFja1VJRFwiXSA9IDI1NTQxXSA9IFwiVGFnVHJhY2tVSURcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiVGFnRWRpdGlvblVJRFwiXSA9IDI1NTQ1XSA9IFwiVGFnRWRpdGlvblVJRFwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJUYWdDaGFwdGVyVUlEXCJdID0gMjU1NDBdID0gXCJUYWdDaGFwdGVyVUlEXCI7XG4gICAgRUJNTElkW0VCTUxJZFtcIlRhZ0F0dGFjaG1lbnRVSURcIl0gPSAyNTU0Ml0gPSBcIlRhZ0F0dGFjaG1lbnRVSURcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiU2ltcGxlVGFnXCJdID0gMjY1NjhdID0gXCJTaW1wbGVUYWdcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiVGFnTmFtZVwiXSA9IDE3ODI3XSA9IFwiVGFnTmFtZVwiO1xuICAgIEVCTUxJZFtFQk1MSWRbXCJUYWdMYW5ndWFnZVwiXSA9IDE3NTMwXSA9IFwiVGFnTGFuZ3VhZ2VcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiVGFnU3RyaW5nXCJdID0gMTc1NDNdID0gXCJUYWdTdHJpbmdcIjtcbiAgICBFQk1MSWRbRUJNTElkW1wiVGFnQmluYXJ5XCJdID0gMTc1NDFdID0gXCJUYWdCaW5hcnlcIjtcbn0pKEVCTUxJZCB8fCAoRUJNTElkID0ge30pKTtcbmV4cG9ydCBjb25zdCBMRVZFTF8wX0VCTUxfSURTID0gW1xuICAgIEVCTUxJZC5FQk1MLFxuICAgIEVCTUxJZC5TZWdtZW50LFxuXTtcbi8vIEFsbCB0aGUgc3R1ZmYgdGhhdCBjYW4gYXBwZWFyIGluIGEgc2VnbWVudCwgYmFzaWNhbGx5XG5leHBvcnQgY29uc3QgTEVWRUxfMV9FQk1MX0lEUyA9IFtcbiAgICBFQk1MSWQuU2Vla0hlYWQsXG4gICAgRUJNTElkLkluZm8sXG4gICAgRUJNTElkLkNsdXN0ZXIsXG4gICAgRUJNTElkLlRyYWNrcyxcbiAgICBFQk1MSWQuQ3VlcyxcbiAgICBFQk1MSWQuQXR0YWNobWVudHMsXG4gICAgRUJNTElkLkNoYXB0ZXJzLFxuICAgIEVCTUxJZC5UYWdzLFxuXTtcbmV4cG9ydCBjb25zdCBMRVZFTF8wX0FORF8xX0VCTUxfSURTID0gW1xuICAgIC4uLkxFVkVMXzBfRUJNTF9JRFMsXG4gICAgLi4uTEVWRUxfMV9FQk1MX0lEUyxcbl07XG5leHBvcnQgY29uc3QgbWVhc3VyZVVuc2lnbmVkSW50ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlIDwgKDEgPDwgOCkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlIDwgKDEgPDwgMTYpKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSA8ICgxIDw8IDI0KSkge1xuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgPCAyICoqIDMyKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSA8IDIgKiogNDApIHtcbiAgICAgICAgcmV0dXJuIDU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gNjtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IG1lYXN1cmVTaWduZWRJbnQgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPj0gLSgxIDw8IDYpICYmIHZhbHVlIDwgKDEgPDwgNikpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlID49IC0oMSA8PCAxMykgJiYgdmFsdWUgPCAoMSA8PCAxMykpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlID49IC0oMSA8PCAyMCkgJiYgdmFsdWUgPCAoMSA8PCAyMCkpIHtcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlID49IC0oMSA8PCAyNykgJiYgdmFsdWUgPCAoMSA8PCAyNykpIHtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlID49IC0oMiAqKiAzNCkgJiYgdmFsdWUgPCAyICoqIDM0KSB7XG4gICAgICAgIHJldHVybiA1O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDY7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBtZWFzdXJlVmFySW50ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlIDwgKDEgPDwgNykgLSAxKSB7XG4gICAgICAgIC8qKiBUb3AgYml0IGlzIHNldCwgbGVhdmluZyA3IGJpdHMgdG8gaG9sZCB0aGUgaW50ZWdlciwgYnV0IHdlIGNhbid0IHN0b3JlXG4gICAgICAgICAqIDEyNyBiZWNhdXNlIFwiYWxsIGJpdHMgc2V0IHRvIG9uZVwiIGlzIGEgcmVzZXJ2ZWQgdmFsdWUuIFNhbWUgdGhpbmcgZm9yIHRoZVxuICAgICAgICAgKiBvdGhlciBjYXNlcyBiZWxvdzpcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSA8ICgxIDw8IDE0KSAtIDEpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlIDwgKDEgPDwgMjEpIC0gMSkge1xuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgPCAoMSA8PCAyOCkgLSAxKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSA8IDIgKiogMzUgLSAxKSB7XG4gICAgICAgIHJldHVybiA1O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSA8IDIgKiogNDIgLSAxKSB7XG4gICAgICAgIHJldHVybiA2O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFQk1MIHZhcmludCBzaXplIG5vdCBzdXBwb3J0ZWQgJyArIHZhbHVlKTtcbiAgICB9XG59O1xuZXhwb3J0IGNsYXNzIEVCTUxXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHdyaXRlcikge1xuICAgICAgICB0aGlzLndyaXRlciA9IHdyaXRlcjtcbiAgICAgICAgdGhpcy5oZWxwZXIgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICAgICAgdGhpcy5oZWxwZXJWaWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuaGVscGVyLmJ1ZmZlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIHBvc2l0aW9uIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBmaWxlIHRvIHdoZXJlIEVCTUwgZWxlbWVudHMgaGF2ZSBiZWVuIHdyaXR0ZW4uIFRoaXMgaXMgdXNlZCB0b1xuICAgICAgICAgKiByZXdyaXRlL2VkaXQgZWxlbWVudHMgdGhhdCB3ZXJlIGFscmVhZHkgYWRkZWQgYmVmb3JlLCBhbmQgdG8gbWVhc3VyZSBzaXplcyBvZiB0aGluZ3MuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9mZnNldHMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICAvKiogU2FtZSBhcyBvZmZzZXRzLCBidXQgc3RvcmVzIHBvc2l0aW9uIHdoZXJlIHRoZSBlbGVtZW50J3MgZGF0YSBzdGFydHMgKGFmdGVyIElEIGFuZCBzaXplIGZpZWxkcykuICovXG4gICAgICAgIHRoaXMuZGF0YU9mZnNldHMgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICB3cml0ZUJ5dGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWxwZXJWaWV3LnNldFVpbnQ4KDAsIHZhbHVlKTtcbiAgICAgICAgdGhpcy53cml0ZXIud3JpdGUodGhpcy5oZWxwZXIuc3ViYXJyYXkoMCwgMSkpO1xuICAgIH1cbiAgICB3cml0ZUZsb2F0MzIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWxwZXJWaWV3LnNldEZsb2F0MzIoMCwgdmFsdWUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy53cml0ZXIud3JpdGUodGhpcy5oZWxwZXIuc3ViYXJyYXkoMCwgNCkpO1xuICAgIH1cbiAgICB3cml0ZUZsb2F0NjQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWxwZXJWaWV3LnNldEZsb2F0NjQoMCwgdmFsdWUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy53cml0ZXIud3JpdGUodGhpcy5oZWxwZXIpO1xuICAgIH1cbiAgICB3cml0ZVVuc2lnbmVkSW50KHZhbHVlLCB3aWR0aCA9IG1lYXN1cmVVbnNpZ25lZEludCh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIC8vIEVhY2ggY2FzZSBmYWxscyB0aHJvdWdoOlxuICAgICAgICBzd2l0Y2ggKHdpZHRoKSB7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byB1c2UgZGl2aXNpb24gdG8gYWNjZXNzID4zMiBiaXRzIG9mIGZsb2F0aW5nIHBvaW50IHZhclxuICAgICAgICAgICAgICAgIHRoaXMuaGVscGVyVmlldy5zZXRVaW50OChwb3MrKywgKHZhbHVlIC8gMiAqKiA0MCkgfCAwKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHRoaXMuaGVscGVyVmlldy5zZXRVaW50OChwb3MrKywgKHZhbHVlIC8gMiAqKiAzMikgfCAwKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHRoaXMuaGVscGVyVmlldy5zZXRVaW50OChwb3MrKywgdmFsdWUgPj4gMjQpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwZXJWaWV3LnNldFVpbnQ4KHBvcysrLCB2YWx1ZSA+PiAxNik7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGlzLmhlbHBlclZpZXcuc2V0VWludDgocG9zKyssIHZhbHVlID4+IDgpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwZXJWaWV3LnNldFVpbnQ4KHBvcysrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHVuc2lnbmVkIGludCBzaXplICcgKyB3aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZXIud3JpdGUodGhpcy5oZWxwZXIuc3ViYXJyYXkoMCwgcG9zKSk7XG4gICAgfVxuICAgIHdyaXRlU2lnbmVkSW50KHZhbHVlLCB3aWR0aCA9IG1lYXN1cmVTaWduZWRJbnQodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIC8vIFR3bydzIGNvbXBsZW1lbnQgc3R1ZmZcbiAgICAgICAgICAgIHZhbHVlICs9IDIgKiogKHdpZHRoICogOCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZVVuc2lnbmVkSW50KHZhbHVlLCB3aWR0aCk7XG4gICAgfVxuICAgIHdyaXRlVmFySW50KHZhbHVlLCB3aWR0aCA9IG1lYXN1cmVWYXJJbnQodmFsdWUpKSB7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBzd2l0Y2ggKHdpZHRoKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwZXJWaWV3LnNldFVpbnQ4KHBvcysrLCAoMSA8PCA3KSB8IHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGlzLmhlbHBlclZpZXcuc2V0VWludDgocG9zKyssICgxIDw8IDYpIHwgKHZhbHVlID4+IDgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlbHBlclZpZXcuc2V0VWludDgocG9zKyssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB0aGlzLmhlbHBlclZpZXcuc2V0VWludDgocG9zKyssICgxIDw8IDUpIHwgKHZhbHVlID4+IDE2KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwZXJWaWV3LnNldFVpbnQ4KHBvcysrLCB2YWx1ZSA+PiA4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlbHBlclZpZXcuc2V0VWludDgocG9zKyssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGlzLmhlbHBlclZpZXcuc2V0VWludDgocG9zKyssICgxIDw8IDQpIHwgKHZhbHVlID4+IDI0KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwZXJWaWV3LnNldFVpbnQ4KHBvcysrLCB2YWx1ZSA+PiAxNik7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwZXJWaWV3LnNldFVpbnQ4KHBvcysrLCB2YWx1ZSA+PiA4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlbHBlclZpZXcuc2V0VWludDgocG9zKyssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBKYXZhU2NyaXB0IGNvbnZlcnRzIGl0cyBkb3VibGVzIHRvIDMyLWJpdCBpbnRlZ2VycyBmb3IgYml0d2lzZVxuICAgICAgICAgICAgICAgICAqIG9wZXJhdGlvbnMsIHNvIHdlIG5lZWQgdG8gZG8gYSBkaXZpc2lvbiBieSAyXjMyIGluc3RlYWQgb2YgYVxuICAgICAgICAgICAgICAgICAqIHJpZ2h0LXNoaWZ0IG9mIDMyIHRvIHJldGFpbiB0aG9zZSB0b3AgMyBiaXRzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwZXJWaWV3LnNldFVpbnQ4KHBvcysrLCAoMSA8PCAzKSB8ICgodmFsdWUgLyAyICoqIDMyKSAmIDB4NykpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVscGVyVmlldy5zZXRVaW50OChwb3MrKywgdmFsdWUgPj4gMjQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVscGVyVmlldy5zZXRVaW50OChwb3MrKywgdmFsdWUgPj4gMTYpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVscGVyVmlldy5zZXRVaW50OChwb3MrKywgdmFsdWUgPj4gOCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwZXJWaWV3LnNldFVpbnQ4KHBvcysrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwZXJWaWV3LnNldFVpbnQ4KHBvcysrLCAoMSA8PCAyKSB8ICgodmFsdWUgLyAyICoqIDQwKSAmIDB4MykpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVscGVyVmlldy5zZXRVaW50OChwb3MrKywgKHZhbHVlIC8gMiAqKiAzMikgfCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlbHBlclZpZXcuc2V0VWludDgocG9zKyssIHZhbHVlID4+IDI0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlbHBlclZpZXcuc2V0VWludDgocG9zKyssIHZhbHVlID4+IDE2KTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlbHBlclZpZXcuc2V0VWludDgocG9zKyssIHZhbHVlID4+IDgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVscGVyVmlldy5zZXRVaW50OChwb3MrKywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBFQk1MIHZhcmludCBzaXplICcgKyB3aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZXIud3JpdGUodGhpcy5oZWxwZXIuc3ViYXJyYXkoMCwgcG9zKSk7XG4gICAgfVxuICAgIHdyaXRlQXNjaWlTdHJpbmcoc3RyKSB7XG4gICAgICAgIHRoaXMud3JpdGVyLndyaXRlKG5ldyBVaW50OEFycmF5KHN0ci5zcGxpdCgnJykubWFwKHggPT4geC5jaGFyQ29kZUF0KDApKSkpO1xuICAgIH1cbiAgICB3cml0ZUVCTUwoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlci53cml0ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW0gb2YgZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVFQk1MKGVsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXRzLnNldChkYXRhLCB0aGlzLndyaXRlci5nZXRQb3MoKSk7XG4gICAgICAgICAgICB0aGlzLndyaXRlVW5zaWduZWRJbnQoZGF0YS5pZCk7IC8vIElEIGZpZWxkXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZVBvcyA9IHRoaXMud3JpdGVyLmdldFBvcygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemVTaXplID0gZGF0YS5zaXplID09PSAtMSA/IDEgOiAoZGF0YS5zaXplID8/IDQpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnNpemUgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdyaXRlIHRoZSByZXNlcnZlZCBhbGwtb25lLWJpdHMgbWFya2VyIGZvciB1bmtub3duL3VuYm91bmRlZCBzaXplLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZSgweGZmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVyLnNlZWsodGhpcy53cml0ZXIuZ2V0UG9zKCkgKyBzaXplU2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy53cml0ZXIuZ2V0UG9zKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhT2Zmc2V0cy5zZXQoZGF0YSwgc3RhcnRQb3MpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVFQk1MKGRhdGEuZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc2l6ZSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMud3JpdGVyLmdldFBvcygpIC0gc3RhcnRQb3M7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZFBvcyA9IHRoaXMud3JpdGVyLmdldFBvcygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlci5zZWVrKHNpemVQb3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlVmFySW50KHNpemUsIHNpemVTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZXIuc2VlayhlbmRQb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhLmRhdGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGRhdGEuc2l6ZSA/PyBtZWFzdXJlVW5zaWduZWRJbnQoZGF0YS5kYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVmFySW50KHNpemUpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVVbnNpZ25lZEludChkYXRhLmRhdGEsIHNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGEuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVmFySW50KGRhdGEuZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVBc2NpaVN0cmluZyhkYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS5kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVWYXJJbnQoZGF0YS5kYXRhLmJ5dGVMZW5ndGgsIGRhdGEuc2l6ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZXIud3JpdGUoZGF0YS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEuZGF0YSBpbnN0YW5jZW9mIEVCTUxGbG9hdDMyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVZhckludCg0KTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlRmxvYXQzMihkYXRhLmRhdGEudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS5kYXRhIGluc3RhbmNlb2YgRUJNTEZsb2F0NjQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVmFySW50KDgpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVGbG9hdDY0KGRhdGEuZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhLmRhdGEgaW5zdGFuY2VvZiBFQk1MU2lnbmVkSW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGRhdGEuc2l6ZSA/PyBtZWFzdXJlU2lnbmVkSW50KGRhdGEuZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVZhckludChzaXplKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlU2lnbmVkSW50KGRhdGEuZGF0YS52YWx1ZSwgc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhLmRhdGEgaW5zdGFuY2VvZiBFQk1MVW5pY29kZVN0cmluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gdGV4dEVuY29kZXIuZW5jb2RlKGRhdGEuZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVZhckludChieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVyLndyaXRlKGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydE5ldmVyKGRhdGEuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY29uc3QgTUFYX1ZBUl9JTlRfU0laRSA9IDg7XG5leHBvcnQgY29uc3QgTUlOX0hFQURFUl9TSVpFID0gMjsgLy8gMS1ieXRlIElEIGFuZCAxLWJ5dGUgc2l6ZVxuZXhwb3J0IGNvbnN0IE1BWF9IRUFERVJfU0laRSA9IDIgKiBNQVhfVkFSX0lOVF9TSVpFOyAvLyA4LWJ5dGUgSUQgYW5kIDgtYnl0ZSBzaXplXG5leHBvcnQgY29uc3QgcmVhZFZhckludFNpemUgPSAoc2xpY2UpID0+IHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSByZWFkVTgoc2xpY2UpO1xuICAgIHNsaWNlLnNraXAoLTEpO1xuICAgIGlmIChmaXJzdEJ5dGUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIEludmFsaWQgVklOVFxuICAgIH1cbiAgICBsZXQgd2lkdGggPSAxO1xuICAgIGxldCBtYXNrID0gMHg4MDtcbiAgICB3aGlsZSAoKGZpcnN0Qnl0ZSAmIG1hc2spID09PSAwKSB7XG4gICAgICAgIHdpZHRoKys7XG4gICAgICAgIG1hc2sgPj49IDE7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aDtcbn07XG5leHBvcnQgY29uc3QgcmVhZFZhckludCA9IChzbGljZSkgPT4ge1xuICAgIC8vIFJlYWQgdGhlIGZpcnN0IGJ5dGUgdG8gZGV0ZXJtaW5lIHRoZSB3aWR0aCBvZiB0aGUgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSByZWFkVTgoc2xpY2UpO1xuICAgIGlmIChmaXJzdEJ5dGUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIEludmFsaWQgVklOVFxuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBwb3NpdGlvbiBvZiBWSU5UX01BUktFUiwgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgd2lkdGhcbiAgICBsZXQgd2lkdGggPSAxO1xuICAgIGxldCBtYXNrID0gMSA8PCA3O1xuICAgIHdoaWxlICgoZmlyc3RCeXRlICYgbWFzaykgPT09IDApIHtcbiAgICAgICAgd2lkdGgrKztcbiAgICAgICAgbWFzayA+Pj0gMTtcbiAgICB9XG4gICAgLy8gRmlyc3QgYnl0ZSdzIHZhbHVlIG5lZWRzIHRoZSBtYXJrZXIgYml0IGNsZWFyZWRcbiAgICBsZXQgdmFsdWUgPSBmaXJzdEJ5dGUgJiAobWFzayAtIDEpO1xuICAgIC8vIFJlYWQgcmVtYWluaW5nIGJ5dGVzXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlICo9IDEgPDwgODtcbiAgICAgICAgdmFsdWUgKz0gcmVhZFU4KHNsaWNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCByZWFkVW5zaWduZWRJbnQgPSAoc2xpY2UsIHdpZHRoKSA9PiB7XG4gICAgaWYgKHdpZHRoIDwgMSB8fCB3aWR0aCA+IDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgdW5zaWduZWQgaW50IHNpemUgJyArIHdpZHRoKTtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICAvLyBSZWFkIGJ5dGVzIGZyb20gbW9zdCBzaWduaWZpY2FudCB0byBsZWFzdCBzaWduaWZpY2FudFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICB2YWx1ZSAqPSAxIDw8IDg7XG4gICAgICAgIHZhbHVlICs9IHJlYWRVOChzbGljZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5leHBvcnQgY29uc3QgcmVhZFNpZ25lZEludCA9IChzbGljZSwgd2lkdGgpID0+IHtcbiAgICBsZXQgdmFsdWUgPSByZWFkVW5zaWduZWRJbnQoc2xpY2UsIHdpZHRoKTtcbiAgICAvLyBJZiB0aGUgaGlnaGVzdCBiaXQgaXMgc2V0LCBjb252ZXJ0IGZyb20gdHdvJ3MgY29tcGxlbWVudFxuICAgIGlmICh2YWx1ZSAmICgxIDw8ICh3aWR0aCAqIDggLSAxKSkpIHtcbiAgICAgICAgdmFsdWUgLT0gMiAqKiAod2lkdGggKiA4KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCByZWFkRWxlbWVudElkID0gKHNsaWNlKSA9PiB7XG4gICAgY29uc3Qgc2l6ZSA9IHJlYWRWYXJJbnRTaXplKHNsaWNlKTtcbiAgICBpZiAoc2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaWQgPSByZWFkVW5zaWduZWRJbnQoc2xpY2UsIHNpemUpO1xuICAgIHJldHVybiBpZDtcbn07XG5leHBvcnQgY29uc3QgcmVhZEVsZW1lbnRTaXplID0gKHNsaWNlKSA9PiB7XG4gICAgbGV0IHNpemUgPSByZWFkVTgoc2xpY2UpO1xuICAgIGlmIChzaXplID09PSAweGZmKSB7XG4gICAgICAgIHNpemUgPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2xpY2Uuc2tpcCgtMSk7XG4gICAgICAgIHNpemUgPSByZWFkVmFySW50KHNsaWNlKTtcbiAgICAgICAgLy8gSW4gc29tZSAobGl2ZXN0cmVhbWVkKSBmaWxlcywgdGhpcyBpcyB0aGUgdmFsdWUgb2YgdGhlIHNpemUgZmllbGQuIFdoaWxlIHRoaXMgdGVjaG5pY2FsbHkgaXMganVzdCBhIHZlcnlcbiAgICAgICAgLy8gbGFyZ2UgbnVtYmVyLCBpdCBpcyBpbnRlbmRlZCB0byBiZWhhdmUgbGlrZSB0aGUgcmVzZXJ2ZWQgc2l6ZSAweEZGLCBtZWFuaW5nIHRoZSBzaXplIGlzIHVuZGVmaW5lZC4gV2VcbiAgICAgICAgLy8gY2F0Y2ggdGhlIG51bWJlciBoZXJlLiBOb3RlIHRoYXQgaXQgY2Fubm90IGJlIHBlcmZlY3RseSByZXByZXNlbnRlZCBhcyBhIGRvdWJsZSwgYnV0IHRoZSBjb21wYXJpc29uIHdvcmtzXG4gICAgICAgIC8vIG5vbmV0aGVsZXNzLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9zcy1vZi1wcmVjaXNpb25cbiAgICAgICAgaWYgKHNpemUgPT09IDB4MDBmZmZmZmZmZmZmZmZmZikge1xuICAgICAgICAgICAgc2l6ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59O1xuZXhwb3J0IGNvbnN0IHJlYWRFbGVtZW50SGVhZGVyID0gKHNsaWNlKSA9PiB7XG4gICAgY29uc3QgaWQgPSByZWFkRWxlbWVudElkKHNsaWNlKTtcbiAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNpemUgPSByZWFkRWxlbWVudFNpemUoc2xpY2UpO1xuICAgIHJldHVybiB7IGlkLCBzaXplIH07XG59O1xuZXhwb3J0IGNvbnN0IHJlYWRBc2NpaVN0cmluZyA9IChzbGljZSwgbGVuZ3RoKSA9PiB7XG4gICAgY29uc3QgYnl0ZXMgPSByZWFkQnl0ZXMoc2xpY2UsIGxlbmd0aCk7XG4gICAgLy8gQWN0dWFsIHN0cmluZyBsZW5ndGggbWlnaHQgYmUgc2hvcnRlciBkdWUgdG8gbnVsbCB0ZXJtaW5hdG9yc1xuICAgIGxldCBzdHJMZW5ndGggPSAwO1xuICAgIHdoaWxlIChzdHJMZW5ndGggPCBsZW5ndGggJiYgYnl0ZXNbc3RyTGVuZ3RoXSAhPT0gMCkge1xuICAgICAgICBzdHJMZW5ndGggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uYnl0ZXMuc3ViYXJyYXkoMCwgc3RyTGVuZ3RoKSk7XG59O1xuZXhwb3J0IGNvbnN0IHJlYWRVbmljb2RlU3RyaW5nID0gKHNsaWNlLCBsZW5ndGgpID0+IHtcbiAgICBjb25zdCBieXRlcyA9IHJlYWRCeXRlcyhzbGljZSwgbGVuZ3RoKTtcbiAgICAvLyBBY3R1YWwgc3RyaW5nIGxlbmd0aCBtaWdodCBiZSBzaG9ydGVyIGR1ZSB0byBudWxsIHRlcm1pbmF0b3JzXG4gICAgbGV0IHN0ckxlbmd0aCA9IDA7XG4gICAgd2hpbGUgKHN0ckxlbmd0aCA8IGxlbmd0aCAmJiBieXRlc1tzdHJMZW5ndGhdICE9PSAwKSB7XG4gICAgICAgIHN0ckxlbmd0aCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dERlY29kZXIuZGVjb2RlKGJ5dGVzLnN1YmFycmF5KDAsIHN0ckxlbmd0aCkpO1xufTtcbmV4cG9ydCBjb25zdCByZWFkRmxvYXQgPSAoc2xpY2UsIHdpZHRoKSA9PiB7XG4gICAgaWYgKHdpZHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAod2lkdGggIT09IDQgJiYgd2lkdGggIT09IDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgZmxvYXQgc2l6ZSAnICsgd2lkdGgpO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGggPT09IDQgPyByZWFkRjMyQmUoc2xpY2UpIDogcmVhZEY2NEJlKHNsaWNlKTtcbn07XG4vKiogUmV0dXJucyB0aGUgYnl0ZSBvZmZzZXQgaW4gdGhlIGZpbGUgb2YgdGhlIG5leHQgZWxlbWVudCB3aXRoIGEgbWF0Y2hpbmcgSUQuICovXG5leHBvcnQgY29uc3Qgc2VhcmNoRm9yTmV4dEVsZW1lbnRJZCA9IGFzeW5jIChyZWFkZXIsIHN0YXJ0UG9zLCBpZHMsIHVudGlsKSA9PiB7XG4gICAgY29uc3QgaWRzU2V0ID0gbmV3IFNldChpZHMpO1xuICAgIGxldCBjdXJyZW50UG9zID0gc3RhcnRQb3M7XG4gICAgd2hpbGUgKHVudGlsID09PSBudWxsIHx8IGN1cnJlbnRQb3MgPCB1bnRpbCkge1xuICAgICAgICBsZXQgc2xpY2UgPSByZWFkZXIucmVxdWVzdFNsaWNlUmFuZ2UoY3VycmVudFBvcywgTUlOX0hFQURFUl9TSVpFLCBNQVhfSEVBREVSX1NJWkUpO1xuICAgICAgICBpZiAoc2xpY2UgaW5zdGFuY2VvZiBQcm9taXNlKVxuICAgICAgICAgICAgc2xpY2UgPSBhd2FpdCBzbGljZTtcbiAgICAgICAgaWYgKCFzbGljZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb25zdCBlbGVtZW50SGVhZGVyID0gcmVhZEVsZW1lbnRIZWFkZXIoc2xpY2UpO1xuICAgICAgICBpZiAoIWVsZW1lbnRIZWFkZXIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZHNTZXQuaGFzKGVsZW1lbnRIZWFkZXIuaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwb3M6IGN1cnJlbnRQb3MsIGZvdW5kOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0RGVmaW5lZFNpemUoZWxlbWVudEhlYWRlci5zaXplKTtcbiAgICAgICAgY3VycmVudFBvcyA9IHNsaWNlLmZpbGVQb3MgKyBlbGVtZW50SGVhZGVyLnNpemU7XG4gICAgfVxuICAgIHJldHVybiB7IHBvczogKHVudGlsICE9PSBudWxsICYmIHVudGlsID4gY3VycmVudFBvcykgPyB1bnRpbCA6IGN1cnJlbnRQb3MsIGZvdW5kOiBmYWxzZSB9O1xufTtcbi8qKiBTZWFyY2hlcyBmb3IgdGhlIG5leHQgb2NjdXJyZW5jZSBvZiBhbiBlbGVtZW50IElEIHVzaW5nIGEgbmFpdmUgYnl0ZS13aXNlIHNlYXJjaC4gKi9cbmV4cG9ydCBjb25zdCByZXN5bmMgPSBhc3luYyAocmVhZGVyLCBzdGFydFBvcywgaWRzLCB1bnRpbCkgPT4ge1xuICAgIGNvbnN0IENIVU5LX1NJWkUgPSAyICoqIDE2OyAvLyBTbyB3ZSBkb24ndCBuZWVkIHRvIGdyYWIgdGhvdXNhbmRzIG9mIHNsaWNlc1xuICAgIGNvbnN0IGlkc1NldCA9IG5ldyBTZXQoaWRzKTtcbiAgICBsZXQgY3VycmVudFBvcyA9IHN0YXJ0UG9zO1xuICAgIHdoaWxlIChjdXJyZW50UG9zIDwgdW50aWwpIHtcbiAgICAgICAgbGV0IHNsaWNlID0gcmVhZGVyLnJlcXVlc3RTbGljZVJhbmdlKGN1cnJlbnRQb3MsIDAsIE1hdGgubWluKENIVU5LX1NJWkUsIHVudGlsIC0gY3VycmVudFBvcykpO1xuICAgICAgICBpZiAoc2xpY2UgaW5zdGFuY2VvZiBQcm9taXNlKVxuICAgICAgICAgICAgc2xpY2UgPSBhd2FpdCBzbGljZTtcbiAgICAgICAgaWYgKCFzbGljZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoc2xpY2UubGVuZ3RoIDwgTUFYX1ZBUl9JTlRfU0laRSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWNlLmxlbmd0aCAtIE1BWF9WQVJfSU5UX1NJWkU7IGkrKykge1xuICAgICAgICAgICAgc2xpY2UuZmlsZVBvcyA9IGN1cnJlbnRQb3M7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50SWQgPSByZWFkRWxlbWVudElkKHNsaWNlKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50SWQgIT09IG51bGwgJiYgaWRzU2V0LmhhcyhlbGVtZW50SWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50UG9zKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuZXhwb3J0IGNvbnN0IENPREVDX1NUUklOR19NQVAgPSB7XG4gICAgJ2F2Yyc6ICdWX01QRUc0L0lTTy9BVkMnLFxuICAgICdoZXZjJzogJ1ZfTVBFR0gvSVNPL0hFVkMnLFxuICAgICd2cDgnOiAnVl9WUDgnLFxuICAgICd2cDknOiAnVl9WUDknLFxuICAgICdhdjEnOiAnVl9BVjEnLFxuICAgICdhYWMnOiAnQV9BQUMnLFxuICAgICdtcDMnOiAnQV9NUEVHL0wzJyxcbiAgICAnb3B1cyc6ICdBX09QVVMnLFxuICAgICd2b3JiaXMnOiAnQV9WT1JCSVMnLFxuICAgICdmbGFjJzogJ0FfRkxBQycsXG4gICAgJ3BjbS11OCc6ICdBX1BDTS9JTlQvTElUJyxcbiAgICAncGNtLXMxNic6ICdBX1BDTS9JTlQvTElUJyxcbiAgICAncGNtLXMxNmJlJzogJ0FfUENNL0lOVC9CSUcnLFxuICAgICdwY20tczI0JzogJ0FfUENNL0lOVC9MSVQnLFxuICAgICdwY20tczI0YmUnOiAnQV9QQ00vSU5UL0JJRycsXG4gICAgJ3BjbS1zMzInOiAnQV9QQ00vSU5UL0xJVCcsXG4gICAgJ3BjbS1zMzJiZSc6ICdBX1BDTS9JTlQvQklHJyxcbiAgICAncGNtLWYzMic6ICdBX1BDTS9GTE9BVC9JRUVFJyxcbiAgICAncGNtLWY2NCc6ICdBX1BDTS9GTE9BVC9JRUVFJyxcbiAgICAnd2VidnR0JzogJ1NfVEVYVC9XRUJWVFQnLFxufTtcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnREZWZpbmVkU2l6ZShzaXplKSB7XG4gICAgaWYgKHNpemUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmRlZmluZWQgZWxlbWVudCBzaXplIGlzIHVzZWQgaW4gYSBwbGFjZSB3aGVyZSBpdCBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbn1cbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/matroska/ebml.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/matroska/matroska-misc.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/matroska/matroska-misc.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildMatroskaMimeType: () => (/* binding */ buildMatroskaMimeType)\n/* harmony export */ });\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nconst buildMatroskaMimeType = (info) => {\n    const base = info.hasVideo\n        ? 'video/'\n        : info.hasAudio\n            ? 'audio/'\n            : 'application/';\n    let string = base + (info.isWebM ? 'webm' : 'x-matroska');\n    if (info.codecStrings.length > 0) {\n        const uniqueCodecMimeTypes = [...new Set(info.codecStrings.filter(Boolean))];\n        string += `; codecs=\"${uniqueCodecMimeTypes.join(', ')}\"`;\n    }\n    return string;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL21hdHJvc2thL21hdHJvc2thLW1pc2MuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVUsZ0NBQWdDO0FBQy9EO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGNoLWN1dC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL21hdHJvc2thL21hdHJvc2thLW1pc2MuanM/YjhkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAyNS1wcmVzZW50LCBWYW5pbGFneSBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmV4cG9ydCBjb25zdCBidWlsZE1hdHJvc2thTWltZVR5cGUgPSAoaW5mbykgPT4ge1xuICAgIGNvbnN0IGJhc2UgPSBpbmZvLmhhc1ZpZGVvXG4gICAgICAgID8gJ3ZpZGVvLydcbiAgICAgICAgOiBpbmZvLmhhc0F1ZGlvXG4gICAgICAgICAgICA/ICdhdWRpby8nXG4gICAgICAgICAgICA6ICdhcHBsaWNhdGlvbi8nO1xuICAgIGxldCBzdHJpbmcgPSBiYXNlICsgKGluZm8uaXNXZWJNID8gJ3dlYm0nIDogJ3gtbWF0cm9za2EnKTtcbiAgICBpZiAoaW5mby5jb2RlY1N0cmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB1bmlxdWVDb2RlY01pbWVUeXBlcyA9IFsuLi5uZXcgU2V0KGluZm8uY29kZWNTdHJpbmdzLmZpbHRlcihCb29sZWFuKSldO1xuICAgICAgICBzdHJpbmcgKz0gYDsgY29kZWNzPVwiJHt1bmlxdWVDb2RlY01pbWVUeXBlcy5qb2luKCcsICcpfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/matroska/matroska-misc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/matroska/matroska-muxer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/matroska/matroska-muxer.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MatroskaMuxer: () => (/* binding */ MatroskaMuxer)\n/* harmony export */ });\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/* harmony import */ var _ebml_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ebml.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/matroska/ebml.js\");\n/* harmony import */ var _matroska_misc_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./matroska-misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/matroska/matroska-misc.js\");\n/* harmony import */ var _output_format_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../output-format.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/output-format.js\");\n/* harmony import */ var _subtitles_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../subtitles.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/subtitles.js\");\n/* harmony import */ var _codec_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../codec.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec.js\");\n/* harmony import */ var _muxer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../muxer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/muxer.js\");\n/* harmony import */ var _codec_data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../codec-data.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec-data.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n\n\n\nconst MIN_CLUSTER_TIMESTAMP_MS = -(2 ** 15);\nconst MAX_CLUSTER_TIMESTAMP_MS = 2 ** 15 - 1;\nconst APP_NAME = 'Mediabunny';\nconst SEGMENT_SIZE_BYTES = 6;\nconst CLUSTER_SIZE_BYTES = 5;\nconst TRACK_TYPE_MAP = {\n    video: 1,\n    audio: 2,\n    subtitle: 17,\n};\nclass MatroskaMuxer extends _muxer_js__WEBPACK_IMPORTED_MODULE_0__.Muxer {\n    constructor(output, format) {\n        super(output);\n        this.trackDatas = [];\n        this.allTracksKnown = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.promiseWithResolvers)();\n        this.segment = null;\n        this.segmentInfo = null;\n        this.seekHead = null;\n        this.tracksElement = null;\n        this.tagsElement = null;\n        this.attachmentsElement = null;\n        this.segmentDuration = null;\n        this.cues = null;\n        this.currentCluster = null;\n        this.currentClusterStartMsTimestamp = null;\n        this.currentClusterMaxMsTimestamp = null;\n        this.trackDatasInCurrentCluster = new Map();\n        this.duration = 0;\n        this.writer = output._writer;\n        this.format = format;\n        this.ebmlWriter = new _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLWriter(this.writer);\n        if (this.format._options.appendOnly) {\n            this.writer.ensureMonotonicity = true;\n        }\n    }\n    async start() {\n        const release = await this.mutex.acquire();\n        this.writeEBMLHeader();\n        this.createSegmentInfo();\n        this.createCues();\n        await this.writer.flush();\n        release();\n    }\n    writeEBMLHeader() {\n        if (this.format._options.onEbmlHeader) {\n            this.writer.startTrackingWrites();\n        }\n        const ebmlHeader = { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.EBML, data: [\n                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.EBMLVersion, data: 1 },\n                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.EBMLReadVersion, data: 1 },\n                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.EBMLMaxIDLength, data: 4 },\n                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.EBMLMaxSizeLength, data: 8 },\n                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.DocType, data: this.format instanceof _output_format_js__WEBPACK_IMPORTED_MODULE_3__.WebMOutputFormat ? 'webm' : 'matroska' },\n                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.DocTypeVersion, data: 2 },\n                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.DocTypeReadVersion, data: 2 },\n            ] };\n        this.ebmlWriter.writeEBML(ebmlHeader);\n        if (this.format._options.onEbmlHeader) {\n            const { data, start } = this.writer.stopTrackingWrites(); // start should be 0\n            this.format._options.onEbmlHeader(data, start);\n        }\n    }\n    /**\n     * Creates a SeekHead element which is positioned near the start of the file and allows the media player to seek to\n     * relevant sections more easily. Since we don't know the positions of those sections yet, we'll set them later.\n     */\n    maybeCreateSeekHead(writeOffsets) {\n        if (this.format._options.appendOnly) {\n            return;\n        }\n        const kaxCues = new Uint8Array([0x1c, 0x53, 0xbb, 0x6b]);\n        const kaxInfo = new Uint8Array([0x15, 0x49, 0xa9, 0x66]);\n        const kaxTracks = new Uint8Array([0x16, 0x54, 0xae, 0x6b]);\n        const kaxAttachments = new Uint8Array([0x19, 0x41, 0xa4, 0x69]);\n        const kaxTags = new Uint8Array([0x12, 0x54, 0xc3, 0x67]);\n        const seekHead = { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.SeekHead, data: [\n                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Seek, data: [\n                        { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.SeekID, data: kaxCues },\n                        {\n                            id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.SeekPosition,\n                            size: 5,\n                            data: writeOffsets\n                                ? this.ebmlWriter.offsets.get(this.cues) - this.segmentDataOffset\n                                : 0,\n                        },\n                    ] },\n                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Seek, data: [\n                        { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.SeekID, data: kaxInfo },\n                        {\n                            id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.SeekPosition,\n                            size: 5,\n                            data: writeOffsets\n                                ? this.ebmlWriter.offsets.get(this.segmentInfo) - this.segmentDataOffset\n                                : 0,\n                        },\n                    ] },\n                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Seek, data: [\n                        { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.SeekID, data: kaxTracks },\n                        {\n                            id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.SeekPosition,\n                            size: 5,\n                            data: writeOffsets\n                                ? this.ebmlWriter.offsets.get(this.tracksElement) - this.segmentDataOffset\n                                : 0,\n                        },\n                    ] },\n                this.attachmentsElement\n                    ? { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Seek, data: [\n                            { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.SeekID, data: kaxAttachments },\n                            {\n                                id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.SeekPosition,\n                                size: 5,\n                                data: writeOffsets\n                                    ? this.ebmlWriter.offsets.get(this.attachmentsElement) - this.segmentDataOffset\n                                    : 0,\n                            },\n                        ] }\n                    : null,\n                this.tagsElement\n                    ? { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Seek, data: [\n                            { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.SeekID, data: kaxTags },\n                            {\n                                id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.SeekPosition,\n                                size: 5,\n                                data: writeOffsets\n                                    ? this.ebmlWriter.offsets.get(this.tagsElement) - this.segmentDataOffset\n                                    : 0,\n                            },\n                        ] }\n                    : null,\n            ] };\n        this.seekHead = seekHead;\n    }\n    createSegmentInfo() {\n        const segmentDuration = { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Duration, data: new _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLFloat64(0) };\n        this.segmentDuration = segmentDuration;\n        const segmentInfo = { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Info, data: [\n                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.TimestampScale, data: 1e6 },\n                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.MuxingApp, data: APP_NAME },\n                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.WritingApp, data: APP_NAME },\n                !this.format._options.appendOnly ? segmentDuration : null,\n            ] };\n        this.segmentInfo = segmentInfo;\n    }\n    createTracks() {\n        const tracksElement = { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Tracks, data: [] };\n        this.tracksElement = tracksElement;\n        for (const trackData of this.trackDatas) {\n            const codecId = _ebml_js__WEBPACK_IMPORTED_MODULE_2__.CODEC_STRING_MAP[trackData.track.source._codec];\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(codecId);\n            let seekPreRollNs = 0;\n            if (trackData.type === 'audio' && trackData.track.source._codec === 'opus') {\n                seekPreRollNs = 1e6 * 80; // In \"Matroska ticks\" (nanoseconds)\n                const description = trackData.info.decoderConfig.description;\n                if (description) {\n                    const bytes = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.toUint8Array)(description);\n                    const header = (0,_codec_data_js__WEBPACK_IMPORTED_MODULE_4__.parseOpusIdentificationHeader)(bytes);\n                    // Use the preSkip value from the header\n                    seekPreRollNs = Math.round(1e9 * (header.preSkip / _codec_js__WEBPACK_IMPORTED_MODULE_5__.OPUS_SAMPLE_RATE));\n                }\n            }\n            tracksElement.data.push({ id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.TrackEntry, data: [\n                    { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.TrackNumber, data: trackData.track.id },\n                    { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.TrackUID, data: trackData.track.id },\n                    { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.TrackType, data: TRACK_TYPE_MAP[trackData.type] },\n                    { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.FlagLacing, data: 0 },\n                    { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Language, data: trackData.track.metadata.languageCode ?? _misc_js__WEBPACK_IMPORTED_MODULE_1__.UNDETERMINED_LANGUAGE },\n                    { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.CodecID, data: codecId },\n                    { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.CodecDelay, data: 0 },\n                    { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.SeekPreRoll, data: seekPreRollNs },\n                    trackData.track.metadata.name !== undefined\n                        ? { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Name, data: new _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLUnicodeString(trackData.track.metadata.name) }\n                        : null,\n                    (trackData.type === 'video' ? this.videoSpecificTrackInfo(trackData) : null),\n                    (trackData.type === 'audio' ? this.audioSpecificTrackInfo(trackData) : null),\n                    (trackData.type === 'subtitle' ? this.subtitleSpecificTrackInfo(trackData) : null),\n                ] });\n        }\n    }\n    videoSpecificTrackInfo(trackData) {\n        const { frameRate, rotation } = trackData.track.metadata;\n        const elements = [\n            (trackData.info.decoderConfig.description\n                ? {\n                    id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.CodecPrivate,\n                    data: (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.toUint8Array)(trackData.info.decoderConfig.description),\n                }\n                : null),\n            (frameRate\n                ? {\n                    id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.DefaultDuration,\n                    data: 1e9 / frameRate,\n                }\n                : null),\n        ];\n        // Convert from clockwise to counter-clockwise\n        const flippedRotation = rotation ? (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.normalizeRotation)(-rotation) : 0;\n        const colorSpace = trackData.info.decoderConfig.colorSpace;\n        const videoElement = { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Video, data: [\n                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.PixelWidth, data: trackData.info.width },\n                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.PixelHeight, data: trackData.info.height },\n                ((0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.colorSpaceIsComplete)(colorSpace)\n                    ? {\n                        id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Colour,\n                        data: [\n                            {\n                                id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.MatrixCoefficients,\n                                data: _misc_js__WEBPACK_IMPORTED_MODULE_1__.MATRIX_COEFFICIENTS_MAP[colorSpace.matrix],\n                            },\n                            {\n                                id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.TransferCharacteristics,\n                                data: _misc_js__WEBPACK_IMPORTED_MODULE_1__.TRANSFER_CHARACTERISTICS_MAP[colorSpace.transfer],\n                            },\n                            {\n                                id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Primaries,\n                                data: _misc_js__WEBPACK_IMPORTED_MODULE_1__.COLOR_PRIMARIES_MAP[colorSpace.primaries],\n                            },\n                            {\n                                id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Range,\n                                data: colorSpace.fullRange ? 2 : 1,\n                            },\n                        ],\n                    }\n                    : null),\n                (flippedRotation\n                    ? {\n                        id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Projection,\n                        data: [\n                            {\n                                id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.ProjectionType,\n                                data: 0, // rectangular\n                            },\n                            {\n                                id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.ProjectionPoseRoll,\n                                data: new _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLFloat32((flippedRotation + 180) % 360 - 180), // [0, 270] -> [-180, 90]\n                            },\n                        ],\n                    }\n                    : null),\n            ] };\n        elements.push(videoElement);\n        return elements;\n    }\n    audioSpecificTrackInfo(trackData) {\n        const pcmInfo = _codec_js__WEBPACK_IMPORTED_MODULE_5__.PCM_AUDIO_CODECS.includes(trackData.track.source._codec)\n            ? (0,_codec_js__WEBPACK_IMPORTED_MODULE_5__.parsePcmCodec)(trackData.track.source._codec)\n            : null;\n        return [\n            (trackData.info.decoderConfig.description\n                ? {\n                    id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.CodecPrivate,\n                    data: (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.toUint8Array)(trackData.info.decoderConfig.description),\n                }\n                : null),\n            { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Audio, data: [\n                    { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.SamplingFrequency, data: new _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLFloat32(trackData.info.sampleRate) },\n                    { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Channels, data: trackData.info.numberOfChannels },\n                    pcmInfo ? { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.BitDepth, data: 8 * pcmInfo.sampleSize } : null,\n                ] },\n        ];\n    }\n    subtitleSpecificTrackInfo(trackData) {\n        return [\n            { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.CodecPrivate, data: _misc_js__WEBPACK_IMPORTED_MODULE_1__.textEncoder.encode(trackData.info.config.description) },\n        ];\n    }\n    maybeCreateTags() {\n        const simpleTags = [];\n        const addSimpleTag = (key, value) => {\n            simpleTags.push({ id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.SimpleTag, data: [\n                    { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.TagName, data: new _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLUnicodeString(key) },\n                    typeof value === 'string'\n                        ? { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.TagString, data: new _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLUnicodeString(value) }\n                        : { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.TagBinary, data: value },\n                ] });\n        };\n        const metadataTags = this.output._metadataTags;\n        const writtenTags = new Set();\n        for (const { key, value } of (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.keyValueIterator)(metadataTags)) {\n            switch (key) {\n                case 'title':\n                    {\n                        addSimpleTag('TITLE', value);\n                        writtenTags.add('TITLE');\n                    }\n                    ;\n                    break;\n                case 'description':\n                    {\n                        addSimpleTag('DESCRIPTION', value);\n                        writtenTags.add('DESCRIPTION');\n                    }\n                    ;\n                    break;\n                case 'artist':\n                    {\n                        addSimpleTag('ARTIST', value);\n                        writtenTags.add('ARTIST');\n                    }\n                    ;\n                    break;\n                case 'album':\n                    {\n                        addSimpleTag('ALBUM', value);\n                        writtenTags.add('ALBUM');\n                    }\n                    ;\n                    break;\n                case 'albumArtist':\n                    {\n                        addSimpleTag('ALBUM_ARTIST', value);\n                        writtenTags.add('ALBUM_ARTIST');\n                    }\n                    ;\n                    break;\n                case 'genre':\n                    {\n                        addSimpleTag('GENRE', value);\n                        writtenTags.add('GENRE');\n                    }\n                    ;\n                    break;\n                case 'comment':\n                    {\n                        addSimpleTag('COMMENT', value);\n                        writtenTags.add('COMMENT');\n                    }\n                    ;\n                    break;\n                case 'lyrics':\n                    {\n                        addSimpleTag('LYRICS', value);\n                        writtenTags.add('LYRICS');\n                    }\n                    ;\n                    break;\n                case 'date':\n                    {\n                        addSimpleTag('DATE', value.toISOString().slice(0, 10));\n                        writtenTags.add('DATE');\n                    }\n                    ;\n                    break;\n                case 'trackNumber':\n                    {\n                        const string = metadataTags.tracksTotal !== undefined\n                            ? `${value}/${metadataTags.tracksTotal}`\n                            : value.toString();\n                        addSimpleTag('PART_NUMBER', string);\n                        writtenTags.add('PART_NUMBER');\n                    }\n                    ;\n                    break;\n                case 'discNumber':\n                    {\n                        const string = metadataTags.discsTotal !== undefined\n                            ? `${value}/${metadataTags.discsTotal}`\n                            : value.toString();\n                        addSimpleTag('DISC', string);\n                        writtenTags.add('DISC');\n                    }\n                    ;\n                    break;\n                case 'tracksTotal':\n                case 'discsTotal':\n                    {\n                        // Handled with trackNumber and discNumber respectively\n                    }\n                    ;\n                    break;\n                case 'images':\n                case 'raw':\n                    {\n                        // Handled elsewhere\n                    }\n                    ;\n                    break;\n                default: (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assertNever)(key);\n            }\n        }\n        if (metadataTags.raw) {\n            for (const key in metadataTags.raw) {\n                const value = metadataTags.raw[key];\n                if (value == null || writtenTags.has(key)) {\n                    continue;\n                }\n                if (typeof value === 'string' || value instanceof Uint8Array) {\n                    addSimpleTag(key, value);\n                }\n            }\n        }\n        if (simpleTags.length === 0) {\n            return;\n        }\n        this.tagsElement = {\n            id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Tags,\n            data: [{ id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Tag, data: [\n                        { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Targets, data: [\n                                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.TargetTypeValue, data: 50 },\n                                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.TargetType, data: 'MOVIE' },\n                            ] },\n                        ...simpleTags,\n                    ] }],\n        };\n    }\n    maybeCreateAttachments() {\n        const metadataTags = this.output._metadataTags;\n        if (!metadataTags.images || metadataTags.images.length === 0) {\n            return;\n        }\n        const existingFileUids = new Set();\n        this.attachmentsElement = { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Attachments, data: metadataTags.images.map((image) => {\n                let imageName = image.name;\n                if (imageName === undefined) {\n                    const baseName = image.kind === 'coverFront' ? 'cover' : image.kind === 'coverBack' ? 'back' : 'image';\n                    imageName = baseName + ((0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.imageMimeTypeToExtension)(image.mimeType) ?? '');\n                }\n                let fileUid;\n                while (true) {\n                    fileUid = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);\n                    if (fileUid !== 0 && !existingFileUids.has(fileUid)) {\n                        break;\n                    }\n                }\n                existingFileUids.add(fileUid);\n                return {\n                    id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.AttachedFile,\n                    data: [\n                        image.description !== undefined\n                            ? { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.FileDescription, data: new _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLUnicodeString(image.description) }\n                            : null,\n                        { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.FileName, data: new _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLUnicodeString(imageName) },\n                        { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.FileMediaType, data: image.mimeType },\n                        { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.FileData, data: image.data },\n                        { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.FileUID, data: fileUid },\n                    ],\n                };\n            }) };\n    }\n    createSegment() {\n        this.createTracks();\n        this.maybeCreateTags();\n        this.maybeCreateAttachments();\n        this.maybeCreateSeekHead(false);\n        const segment = {\n            id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Segment,\n            size: this.format._options.appendOnly ? -1 : SEGMENT_SIZE_BYTES,\n            data: [\n                this.seekHead, // null if append-only\n                this.segmentInfo,\n                this.tracksElement,\n                // Matroska spec says put this at the end of the file, but I think placing it before the first cluster\n                // makes more sense, and FFmpeg agrees (argumentum ad ffmpegum fallacy)\n                this.attachmentsElement,\n                this.tagsElement,\n            ],\n        };\n        this.segment = segment;\n        if (this.format._options.onSegmentHeader) {\n            this.writer.startTrackingWrites();\n        }\n        this.ebmlWriter.writeEBML(segment);\n        if (this.format._options.onSegmentHeader) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onSegmentHeader(data, start);\n        }\n    }\n    createCues() {\n        this.cues = { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Cues, data: [] };\n    }\n    get segmentDataOffset() {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.segment);\n        return this.ebmlWriter.dataOffsets.get(this.segment);\n    }\n    allTracksAreKnown() {\n        for (const track of this.output._tracks) {\n            if (!track.source._closed && !this.trackDatas.some(x => x.track === track)) {\n                return false; // We haven't seen a sample from this open track yet\n            }\n        }\n        return true;\n    }\n    async getMimeType() {\n        await this.allTracksKnown.promise;\n        const codecStrings = this.trackDatas.map((trackData) => {\n            if (trackData.type === 'video') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else if (trackData.type === 'audio') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else {\n                const map = {\n                    webvtt: 'wvtt',\n                };\n                return map[trackData.track.source._codec];\n            }\n        });\n        return (0,_matroska_misc_js__WEBPACK_IMPORTED_MODULE_6__.buildMatroskaMimeType)({\n            isWebM: this.format instanceof _output_format_js__WEBPACK_IMPORTED_MODULE_3__.WebMOutputFormat,\n            hasVideo: this.trackDatas.some(x => x.type === 'video'),\n            hasAudio: this.trackDatas.some(x => x.type === 'audio'),\n            codecStrings,\n        });\n    }\n    getVideoTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        (0,_codec_js__WEBPACK_IMPORTED_MODULE_5__.validateVideoChunkMetadata)(meta);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(meta);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(meta.decoderConfig);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(meta.decoderConfig.codedWidth !== undefined);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(meta.decoderConfig.codedHeight !== undefined);\n        const newTrackData = {\n            track,\n            type: 'video',\n            info: {\n                width: meta.decoderConfig.codedWidth,\n                height: meta.decoderConfig.codedHeight,\n                decoderConfig: meta.decoderConfig,\n            },\n            chunkQueue: [],\n            lastWrittenMsTimestamp: null,\n        };\n        if (track.source._codec === 'vp9') {\n            // https://www.webmproject.org/docs/container specifies that VP9 \"SHOULD\" make use of the CodecPrivate\n            // field. Since WebCodecs makes no use of the description field for VP9, we need to derive it ourselves:\n            newTrackData.info.decoderConfig = {\n                ...newTrackData.info.decoderConfig,\n                description: new Uint8Array((0,_codec_js__WEBPACK_IMPORTED_MODULE_5__.generateVp9CodecConfigurationFromCodecString)(newTrackData.info.decoderConfig.codec)),\n            };\n        }\n        else if (track.source._codec === 'av1') {\n            // Per https://github.com/ietf-wg-cellar/matroska-specification/blob/master/codec/av1.md, AV1 requires\n            // CodecPrivate to be set, but WebCodecs makes no use of the description field for AV1. Thus, let's derive\n            // it ourselves:\n            newTrackData.info.decoderConfig = {\n                ...newTrackData.info.decoderConfig,\n                description: new Uint8Array((0,_codec_js__WEBPACK_IMPORTED_MODULE_5__.generateAv1CodecConfigurationFromCodecString)(newTrackData.info.decoderConfig.codec)),\n            };\n        }\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getAudioTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        (0,_codec_js__WEBPACK_IMPORTED_MODULE_5__.validateAudioChunkMetadata)(meta);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(meta);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(meta.decoderConfig);\n        const newTrackData = {\n            track,\n            type: 'audio',\n            info: {\n                numberOfChannels: meta.decoderConfig.numberOfChannels,\n                sampleRate: meta.decoderConfig.sampleRate,\n                decoderConfig: meta.decoderConfig,\n            },\n            chunkQueue: [],\n            lastWrittenMsTimestamp: null,\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getSubtitleTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        (0,_codec_js__WEBPACK_IMPORTED_MODULE_5__.validateSubtitleMetadata)(meta);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(meta);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(meta.config);\n        const newTrackData = {\n            track,\n            type: 'subtitle',\n            info: {\n                config: meta.config,\n            },\n            chunkQueue: [],\n            lastWrittenMsTimestamp: null,\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    async addEncodedVideoPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getVideoTrackData(track, meta);\n            const isKeyFrame = packet.type === 'key';\n            let timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, isKeyFrame);\n            let duration = packet.duration;\n            if (track.metadata.frameRate !== undefined) {\n                // Constrain the time values to the frame rate\n                timestamp = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.roundToMultiple)(timestamp, 1 / track.metadata.frameRate);\n                duration = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.roundToMultiple)(duration, 1 / track.metadata.frameRate);\n            }\n            const videoChunk = this.createInternalChunk(packet.data, timestamp, duration, packet.type);\n            if (track.source._codec === 'vp9')\n                this.fixVP9ColorSpace(trackData, videoChunk);\n            trackData.chunkQueue.push(videoChunk);\n            await this.interleaveChunks();\n        }\n        finally {\n            release();\n        }\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getAudioTrackData(track, meta);\n            const isKeyFrame = packet.type === 'key';\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, isKeyFrame);\n            const audioChunk = this.createInternalChunk(packet.data, timestamp, packet.duration, packet.type);\n            trackData.chunkQueue.push(audioChunk);\n            await this.interleaveChunks();\n        }\n        finally {\n            release();\n        }\n    }\n    async addSubtitleCue(track, cue, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getSubtitleTrackData(track, meta);\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, cue.timestamp, true);\n            let bodyText = cue.text;\n            const timestampMs = Math.round(timestamp * 1000);\n            // Replace in-body timestamps so that they're relative to the cue start time\n            _subtitles_js__WEBPACK_IMPORTED_MODULE_7__.inlineTimestampRegex.lastIndex = 0;\n            bodyText = bodyText.replace(_subtitles_js__WEBPACK_IMPORTED_MODULE_7__.inlineTimestampRegex, (match) => {\n                const time = (0,_subtitles_js__WEBPACK_IMPORTED_MODULE_7__.parseSubtitleTimestamp)(match.slice(1, -1));\n                const offsetTime = time - timestampMs;\n                return `<${(0,_subtitles_js__WEBPACK_IMPORTED_MODULE_7__.formatSubtitleTimestamp)(offsetTime)}>`;\n            });\n            const body = _misc_js__WEBPACK_IMPORTED_MODULE_1__.textEncoder.encode(bodyText);\n            const additions = `${cue.settings ?? ''}\\n${cue.identifier ?? ''}\\n${cue.notes ?? ''}`;\n            const subtitleChunk = this.createInternalChunk(body, timestamp, cue.duration, 'key', additions.trim() ? _misc_js__WEBPACK_IMPORTED_MODULE_1__.textEncoder.encode(additions) : null);\n            trackData.chunkQueue.push(subtitleChunk);\n            await this.interleaveChunks();\n        }\n        finally {\n            release();\n        }\n    }\n    async interleaveChunks(isFinalCall = false) {\n        if (!isFinalCall) {\n            if (!this.allTracksAreKnown()) {\n                return; // We can't interleave yet as we don't yet know how many tracks we'll truly have\n            }\n        }\n        outer: while (true) {\n            let trackWithMinTimestamp = null;\n            let minTimestamp = Infinity;\n            for (const trackData of this.trackDatas) {\n                if (!isFinalCall && trackData.chunkQueue.length === 0 && !trackData.track.source._closed) {\n                    break outer;\n                }\n                if (trackData.chunkQueue.length > 0 && trackData.chunkQueue[0].timestamp < minTimestamp) {\n                    trackWithMinTimestamp = trackData;\n                    minTimestamp = trackData.chunkQueue[0].timestamp;\n                }\n            }\n            if (!trackWithMinTimestamp) {\n                break;\n            }\n            const chunk = trackWithMinTimestamp.chunkQueue.shift();\n            this.writeBlock(trackWithMinTimestamp, chunk);\n        }\n        if (!isFinalCall) {\n            await this.writer.flush();\n        }\n    }\n    /**\n     * Due to [a bug in Chromium](https://bugs.chromium.org/p/chromium/issues/detail?id=1377842), VP9 streams often\n     * lack color space information. This method patches in that information.\n     */\n    fixVP9ColorSpace(trackData, chunk) {\n        // http://downloads.webmproject.org/docs/vp9/vp9-bitstream_superframe-and-uncompressed-header_v1.0.pdf\n        if (chunk.type !== 'key')\n            return;\n        if (!trackData.info.decoderConfig.colorSpace || !trackData.info.decoderConfig.colorSpace.matrix)\n            return;\n        const bitstream = new _misc_js__WEBPACK_IMPORTED_MODULE_1__.Bitstream(chunk.data);\n        bitstream.skipBits(2);\n        const profileLowBit = bitstream.readBits(1);\n        const profileHighBit = bitstream.readBits(1);\n        const profile = (profileHighBit << 1) + profileLowBit;\n        if (profile === 3)\n            bitstream.skipBits(1);\n        const showExistingFrame = bitstream.readBits(1);\n        if (showExistingFrame)\n            return;\n        const frameType = bitstream.readBits(1);\n        if (frameType !== 0)\n            return; // Just to be sure\n        bitstream.skipBits(2);\n        const syncCode = bitstream.readBits(24);\n        if (syncCode !== 0x498342)\n            return;\n        if (profile >= 2)\n            bitstream.skipBits(1);\n        const colorSpaceID = {\n            rgb: 7,\n            bt709: 2,\n            bt470bg: 1,\n            smpte170m: 3,\n        }[trackData.info.decoderConfig.colorSpace.matrix];\n        // The bitstream position is now at the start of the color space bits.\n        // We can use the global writeBits function here as requested.\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.writeBits)(chunk.data, bitstream.pos, bitstream.pos + 3, colorSpaceID);\n    }\n    /** Converts a read-only external chunk into an internal one for easier use. */\n    createInternalChunk(data, timestamp, duration, type, additions = null) {\n        const internalChunk = {\n            data,\n            type,\n            timestamp,\n            duration,\n            additions,\n        };\n        return internalChunk;\n    }\n    /** Writes a block containing media data to the file. */\n    writeBlock(trackData, chunk) {\n        // Due to the interlacing algorithm, this code will be run once we've seen one chunk from every media track.\n        if (!this.segment) {\n            this.createSegment();\n        }\n        const msTimestamp = Math.round(1000 * chunk.timestamp);\n        // We wanna only finalize this cluster (and begin a new one) if we know that each track will be able to\n        // start the new one with a key frame.\n        const keyFrameQueuedEverywhere = this.trackDatas.every((otherTrackData) => {\n            if (trackData === otherTrackData) {\n                return chunk.type === 'key';\n            }\n            const firstQueuedSample = otherTrackData.chunkQueue[0];\n            if (firstQueuedSample) {\n                return firstQueuedSample.type === 'key';\n            }\n            return otherTrackData.track.source._closed;\n        });\n        let shouldCreateNewCluster = false;\n        if (!this.currentCluster) {\n            shouldCreateNewCluster = true;\n        }\n        else {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.currentClusterStartMsTimestamp !== null);\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.currentClusterMaxMsTimestamp !== null);\n            const relativeTimestamp = msTimestamp - this.currentClusterStartMsTimestamp;\n            shouldCreateNewCluster = (keyFrameQueuedEverywhere\n                // This check is required because that means there is already a block with this timestamp in the\n                // CURRENT chunk, meaning that starting the next cluster at the same timestamp is forbidden (since\n                // the already-written block would belong into it instead).\n                && msTimestamp > this.currentClusterMaxMsTimestamp\n                && relativeTimestamp >= 1000 * (this.format._options.minimumClusterDuration ?? 1))\n                // The cluster would exceed its maximum allowed length. This puts us in an unfortunate position and forces\n                // us to begin the next cluster with a delta frame. Although this is undesirable, it is not forbidden by the\n                // spec and is supported by players.\n                || relativeTimestamp > MAX_CLUSTER_TIMESTAMP_MS;\n        }\n        if (shouldCreateNewCluster) {\n            this.createNewCluster(msTimestamp);\n        }\n        const relativeTimestamp = msTimestamp - this.currentClusterStartMsTimestamp;\n        if (relativeTimestamp < MIN_CLUSTER_TIMESTAMP_MS) {\n            // The block lies too far in the past, it's not representable within this cluster\n            return;\n        }\n        const prelude = new Uint8Array(4);\n        const view = new DataView(prelude.buffer);\n        // 0x80 to indicate it's the last byte of a multi-byte number\n        view.setUint8(0, 0x80 | trackData.track.id);\n        view.setInt16(1, relativeTimestamp, false);\n        const msDuration = Math.round(1000 * chunk.duration);\n        if (!chunk.additions) {\n            // No additions, we can write out a SimpleBlock\n            view.setUint8(3, Number(chunk.type === 'key') << 7); // Flags (keyframe flag only present for SimpleBlock)\n            const simpleBlock = { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.SimpleBlock, data: [\n                    prelude,\n                    chunk.data,\n                ] };\n            this.ebmlWriter.writeEBML(simpleBlock);\n        }\n        else {\n            const blockGroup = { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.BlockGroup, data: [\n                    { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Block, data: [\n                            prelude,\n                            chunk.data,\n                        ] },\n                    chunk.type === 'delta'\n                        ? {\n                            id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.ReferenceBlock,\n                            data: new _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLSignedInt(trackData.lastWrittenMsTimestamp - msTimestamp),\n                        }\n                        : null,\n                    chunk.additions\n                        ? { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.BlockAdditions, data: [\n                                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.BlockMore, data: [\n                                        { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.BlockAdditional, data: chunk.additions },\n                                        { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.BlockAddID, data: 1 },\n                                    ] },\n                            ] }\n                        : null,\n                    msDuration > 0 ? { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.BlockDuration, data: msDuration } : null,\n                ] };\n            this.ebmlWriter.writeEBML(blockGroup);\n        }\n        this.duration = Math.max(this.duration, msTimestamp + msDuration);\n        trackData.lastWrittenMsTimestamp = msTimestamp;\n        if (!this.trackDatasInCurrentCluster.has(trackData)) {\n            this.trackDatasInCurrentCluster.set(trackData, {\n                firstMsTimestamp: msTimestamp,\n            });\n        }\n        this.currentClusterMaxMsTimestamp = Math.max(this.currentClusterMaxMsTimestamp, msTimestamp);\n    }\n    /** Creates a new Cluster element to contain media chunks. */\n    createNewCluster(msTimestamp) {\n        if (this.currentCluster) {\n            this.finalizeCurrentCluster();\n        }\n        if (this.format._options.onCluster) {\n            this.writer.startTrackingWrites();\n        }\n        this.currentCluster = {\n            id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Cluster,\n            size: this.format._options.appendOnly ? -1 : CLUSTER_SIZE_BYTES,\n            data: [\n                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.Timestamp, data: msTimestamp },\n            ],\n        };\n        this.ebmlWriter.writeEBML(this.currentCluster);\n        this.currentClusterStartMsTimestamp = msTimestamp;\n        this.currentClusterMaxMsTimestamp = msTimestamp;\n        this.trackDatasInCurrentCluster.clear();\n    }\n    finalizeCurrentCluster() {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.currentCluster);\n        if (!this.format._options.appendOnly) {\n            const clusterSize = this.writer.getPos() - this.ebmlWriter.dataOffsets.get(this.currentCluster);\n            const endPos = this.writer.getPos();\n            // Write the size now that we know it\n            this.writer.seek(this.ebmlWriter.offsets.get(this.currentCluster) + 4);\n            this.ebmlWriter.writeVarInt(clusterSize, CLUSTER_SIZE_BYTES);\n            this.writer.seek(endPos);\n        }\n        if (this.format._options.onCluster) {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.currentClusterStartMsTimestamp !== null);\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onCluster(data, start, this.currentClusterStartMsTimestamp / 1000);\n        }\n        const clusterOffsetFromSegment = this.ebmlWriter.offsets.get(this.currentCluster) - this.segmentDataOffset;\n        // Group tracks by their first timestamp and create a CuePoint for each unique timestamp\n        const groupedByTimestamp = new Map();\n        for (const [trackData, { firstMsTimestamp }] of this.trackDatasInCurrentCluster) {\n            if (!groupedByTimestamp.has(firstMsTimestamp)) {\n                groupedByTimestamp.set(firstMsTimestamp, []);\n            }\n            groupedByTimestamp.get(firstMsTimestamp).push(trackData);\n        }\n        const groupedAndSortedByTimestamp = [...groupedByTimestamp.entries()].sort((a, b) => a[0] - b[0]);\n        // Add CuePoints to the Cues element for better seeking\n        for (const [msTimestamp, trackDatas] of groupedAndSortedByTimestamp) {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.cues);\n            this.cues.data.push({ id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.CuePoint, data: [\n                    { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.CueTime, data: msTimestamp },\n                    // Create CueTrackPositions for each track that starts at this timestamp\n                    ...trackDatas.map((trackData) => {\n                        return { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.CueTrackPositions, data: [\n                                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.CueTrack, data: trackData.track.id },\n                                { id: _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLId.CueClusterPosition, data: clusterOffsetFromSegment },\n                            ] };\n                    }),\n                ] });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    async onTrackClose() {\n        const release = await this.mutex.acquire();\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        // Since a track is now closed, we may be able to write out chunks that were previously waiting\n        await this.interleaveChunks();\n        release();\n    }\n    /** Finalizes the file, making it ready for use. Must be called after all media chunks have been added. */\n    async finalize() {\n        const release = await this.mutex.acquire();\n        this.allTracksKnown.resolve();\n        if (!this.segment) {\n            this.createSegment();\n        }\n        // Flush any remaining queued chunks to the file\n        await this.interleaveChunks(true);\n        if (this.currentCluster) {\n            this.finalizeCurrentCluster();\n        }\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.cues);\n        this.ebmlWriter.writeEBML(this.cues);\n        if (!this.format._options.appendOnly) {\n            const endPos = this.writer.getPos();\n            // Write the Segment size\n            const segmentSize = this.writer.getPos() - this.segmentDataOffset;\n            this.writer.seek(this.ebmlWriter.offsets.get(this.segment) + 4);\n            this.ebmlWriter.writeVarInt(segmentSize, SEGMENT_SIZE_BYTES);\n            // Write the duration of the media to the Segment\n            this.segmentDuration.data = new _ebml_js__WEBPACK_IMPORTED_MODULE_2__.EBMLFloat64(this.duration);\n            this.writer.seek(this.ebmlWriter.offsets.get(this.segmentDuration));\n            this.ebmlWriter.writeEBML(this.segmentDuration);\n            // Fill in SeekHead position data and write it again\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.seekHead);\n            this.writer.seek(this.ebmlWriter.offsets.get(this.seekHead));\n            this.maybeCreateSeekHead(true);\n            this.ebmlWriter.writeEBML(this.seekHead);\n            this.writer.seek(endPos);\n        }\n        release();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL21hdHJvc2thL21hdHJvc2thLW11eGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tVO0FBQ3BNO0FBQ25FO0FBQ0o7QUFDa0Q7QUFDc0o7QUFDM047QUFDNkI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsNENBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhEQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0RBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSSw0Q0FBTTtBQUN2QyxrQkFBa0IsSUFBSSw0Q0FBTSx1QkFBdUI7QUFDbkQsa0JBQWtCLElBQUksNENBQU0sMkJBQTJCO0FBQ3ZELGtCQUFrQixJQUFJLDRDQUFNLDJCQUEyQjtBQUN2RCxrQkFBa0IsSUFBSSw0Q0FBTSw2QkFBNkI7QUFDekQsa0JBQWtCLElBQUksNENBQU0sdUNBQXVDLCtEQUFnQix3QkFBd0I7QUFDM0csa0JBQWtCLElBQUksNENBQU0sMEJBQTBCO0FBQ3RELGtCQUFrQixJQUFJLDRDQUFNLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYyxvQ0FBb0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSSw0Q0FBTTtBQUNyQyxrQkFBa0IsSUFBSSw0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QUE0QyxpREFBVztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRjaC1jdXQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL21lZGlhYnVubnkvZGlzdC9tb2R1bGVzL3NyYy9tYXRyb3NrYS9tYXRyb3NrYS1tdXhlci5qcz8zM2FhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDI1LXByZXNlbnQsIFZhbmlsYWd5IGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgQml0c3RyZWFtLCBDT0xPUl9QUklNQVJJRVNfTUFQLCBNQVRSSVhfQ09FRkZJQ0lFTlRTX01BUCwgVFJBTlNGRVJfQ0hBUkFDVEVSSVNUSUNTX01BUCwgVU5ERVRFUk1JTkVEX0xBTkdVQUdFLCBhc3NlcnQsIGFzc2VydE5ldmVyLCBjb2xvclNwYWNlSXNDb21wbGV0ZSwgaW1hZ2VNaW1lVHlwZVRvRXh0ZW5zaW9uLCBrZXlWYWx1ZUl0ZXJhdG9yLCBub3JtYWxpemVSb3RhdGlvbiwgcHJvbWlzZVdpdGhSZXNvbHZlcnMsIHJvdW5kVG9NdWx0aXBsZSwgdGV4dEVuY29kZXIsIHRvVWludDhBcnJheSwgd3JpdGVCaXRzLCB9IGZyb20gJy4uL21pc2MuanMnO1xuaW1wb3J0IHsgQ09ERUNfU1RSSU5HX01BUCwgRUJNTEZsb2F0MzIsIEVCTUxGbG9hdDY0LCBFQk1MSWQsIEVCTUxTaWduZWRJbnQsIEVCTUxVbmljb2RlU3RyaW5nLCBFQk1MV3JpdGVyLCB9IGZyb20gJy4vZWJtbC5qcyc7XG5pbXBvcnQgeyBidWlsZE1hdHJvc2thTWltZVR5cGUgfSBmcm9tICcuL21hdHJvc2thLW1pc2MuanMnO1xuaW1wb3J0IHsgV2ViTU91dHB1dEZvcm1hdCB9IGZyb20gJy4uL291dHB1dC1mb3JtYXQuanMnO1xuaW1wb3J0IHsgZm9ybWF0U3VidGl0bGVUaW1lc3RhbXAsIGlubGluZVRpbWVzdGFtcFJlZ2V4LCBwYXJzZVN1YnRpdGxlVGltZXN0YW1wLCB9IGZyb20gJy4uL3N1YnRpdGxlcy5qcyc7XG5pbXBvcnQgeyBPUFVTX1NBTVBMRV9SQVRFLCBQQ01fQVVESU9fQ09ERUNTLCBnZW5lcmF0ZUF2MUNvZGVjQ29uZmlndXJhdGlvbkZyb21Db2RlY1N0cmluZywgZ2VuZXJhdGVWcDlDb2RlY0NvbmZpZ3VyYXRpb25Gcm9tQ29kZWNTdHJpbmcsIHBhcnNlUGNtQ29kZWMsIHZhbGlkYXRlQXVkaW9DaHVua01ldGFkYXRhLCB2YWxpZGF0ZVN1YnRpdGxlTWV0YWRhdGEsIHZhbGlkYXRlVmlkZW9DaHVua01ldGFkYXRhLCB9IGZyb20gJy4uL2NvZGVjLmpzJztcbmltcG9ydCB7IE11eGVyIH0gZnJvbSAnLi4vbXV4ZXIuanMnO1xuaW1wb3J0IHsgcGFyc2VPcHVzSWRlbnRpZmljYXRpb25IZWFkZXIgfSBmcm9tICcuLi9jb2RlYy1kYXRhLmpzJztcbmNvbnN0IE1JTl9DTFVTVEVSX1RJTUVTVEFNUF9NUyA9IC0oMiAqKiAxNSk7XG5jb25zdCBNQVhfQ0xVU1RFUl9USU1FU1RBTVBfTVMgPSAyICoqIDE1IC0gMTtcbmNvbnN0IEFQUF9OQU1FID0gJ01lZGlhYnVubnknO1xuY29uc3QgU0VHTUVOVF9TSVpFX0JZVEVTID0gNjtcbmNvbnN0IENMVVNURVJfU0laRV9CWVRFUyA9IDU7XG5jb25zdCBUUkFDS19UWVBFX01BUCA9IHtcbiAgICB2aWRlbzogMSxcbiAgICBhdWRpbzogMixcbiAgICBzdWJ0aXRsZTogMTcsXG59O1xuZXhwb3J0IGNsYXNzIE1hdHJvc2thTXV4ZXIgZXh0ZW5kcyBNdXhlciB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0LCBmb3JtYXQpIHtcbiAgICAgICAgc3VwZXIob3V0cHV0KTtcbiAgICAgICAgdGhpcy50cmFja0RhdGFzID0gW107XG4gICAgICAgIHRoaXMuYWxsVHJhY2tzS25vd24gPSBwcm9taXNlV2l0aFJlc29sdmVycygpO1xuICAgICAgICB0aGlzLnNlZ21lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnNlZ21lbnRJbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZWVrSGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMudHJhY2tzRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMudGFnc0VsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnRzRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VnbWVudER1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2x1c3RlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudENsdXN0ZXJTdGFydE1zVGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2x1c3Rlck1heE1zVGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmFja0RhdGFzSW5DdXJyZW50Q2x1c3RlciA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMud3JpdGVyID0gb3V0cHV0Ll93cml0ZXI7XG4gICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICB0aGlzLmVibWxXcml0ZXIgPSBuZXcgRUJNTFdyaXRlcih0aGlzLndyaXRlcik7XG4gICAgICAgIGlmICh0aGlzLmZvcm1hdC5fb3B0aW9ucy5hcHBlbmRPbmx5KSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlci5lbnN1cmVNb25vdG9uaWNpdHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICBjb25zdCByZWxlYXNlID0gYXdhaXQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgIHRoaXMud3JpdGVFQk1MSGVhZGVyKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlU2VnbWVudEluZm8oKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDdWVzKCk7XG4gICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLmZsdXNoKCk7XG4gICAgICAgIHJlbGVhc2UoKTtcbiAgICB9XG4gICAgd3JpdGVFQk1MSGVhZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5mb3JtYXQuX29wdGlvbnMub25FYm1sSGVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlci5zdGFydFRyYWNraW5nV3JpdGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWJtbEhlYWRlciA9IHsgaWQ6IEVCTUxJZC5FQk1MLCBkYXRhOiBbXG4gICAgICAgICAgICAgICAgeyBpZDogRUJNTElkLkVCTUxWZXJzaW9uLCBkYXRhOiAxIH0sXG4gICAgICAgICAgICAgICAgeyBpZDogRUJNTElkLkVCTUxSZWFkVmVyc2lvbiwgZGF0YTogMSB9LFxuICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5FQk1MTWF4SURMZW5ndGgsIGRhdGE6IDQgfSxcbiAgICAgICAgICAgICAgICB7IGlkOiBFQk1MSWQuRUJNTE1heFNpemVMZW5ndGgsIGRhdGE6IDggfSxcbiAgICAgICAgICAgICAgICB7IGlkOiBFQk1MSWQuRG9jVHlwZSwgZGF0YTogdGhpcy5mb3JtYXQgaW5zdGFuY2VvZiBXZWJNT3V0cHV0Rm9ybWF0ID8gJ3dlYm0nIDogJ21hdHJvc2thJyB9LFxuICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5Eb2NUeXBlVmVyc2lvbiwgZGF0YTogMiB9LFxuICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5Eb2NUeXBlUmVhZFZlcnNpb24sIGRhdGE6IDIgfSxcbiAgICAgICAgICAgIF0gfTtcbiAgICAgICAgdGhpcy5lYm1sV3JpdGVyLndyaXRlRUJNTChlYm1sSGVhZGVyKTtcbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0Ll9vcHRpb25zLm9uRWJtbEhlYWRlcikge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBzdGFydCB9ID0gdGhpcy53cml0ZXIuc3RvcFRyYWNraW5nV3JpdGVzKCk7IC8vIHN0YXJ0IHNob3VsZCBiZSAwXG4gICAgICAgICAgICB0aGlzLmZvcm1hdC5fb3B0aW9ucy5vbkVibWxIZWFkZXIoZGF0YSwgc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBTZWVrSGVhZCBlbGVtZW50IHdoaWNoIGlzIHBvc2l0aW9uZWQgbmVhciB0aGUgc3RhcnQgb2YgdGhlIGZpbGUgYW5kIGFsbG93cyB0aGUgbWVkaWEgcGxheWVyIHRvIHNlZWsgdG9cbiAgICAgKiByZWxldmFudCBzZWN0aW9ucyBtb3JlIGVhc2lseS4gU2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgcG9zaXRpb25zIG9mIHRob3NlIHNlY3Rpb25zIHlldCwgd2UnbGwgc2V0IHRoZW0gbGF0ZXIuXG4gICAgICovXG4gICAgbWF5YmVDcmVhdGVTZWVrSGVhZCh3cml0ZU9mZnNldHMpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0Ll9vcHRpb25zLmFwcGVuZE9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrYXhDdWVzID0gbmV3IFVpbnQ4QXJyYXkoWzB4MWMsIDB4NTMsIDB4YmIsIDB4NmJdKTtcbiAgICAgICAgY29uc3Qga2F4SW5mbyA9IG5ldyBVaW50OEFycmF5KFsweDE1LCAweDQ5LCAweGE5LCAweDY2XSk7XG4gICAgICAgIGNvbnN0IGtheFRyYWNrcyA9IG5ldyBVaW50OEFycmF5KFsweDE2LCAweDU0LCAweGFlLCAweDZiXSk7XG4gICAgICAgIGNvbnN0IGtheEF0dGFjaG1lbnRzID0gbmV3IFVpbnQ4QXJyYXkoWzB4MTksIDB4NDEsIDB4YTQsIDB4NjldKTtcbiAgICAgICAgY29uc3Qga2F4VGFncyA9IG5ldyBVaW50OEFycmF5KFsweDEyLCAweDU0LCAweGMzLCAweDY3XSk7XG4gICAgICAgIGNvbnN0IHNlZWtIZWFkID0geyBpZDogRUJNTElkLlNlZWtIZWFkLCBkYXRhOiBbXG4gICAgICAgICAgICAgICAgeyBpZDogRUJNTElkLlNlZWssIGRhdGE6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5TZWVrSUQsIGRhdGE6IGtheEN1ZXMgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogRUJNTElkLlNlZWtQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHdyaXRlT2Zmc2V0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZWJtbFdyaXRlci5vZmZzZXRzLmdldCh0aGlzLmN1ZXMpIC0gdGhpcy5zZWdtZW50RGF0YU9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdIH0sXG4gICAgICAgICAgICAgICAgeyBpZDogRUJNTElkLlNlZWssIGRhdGE6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5TZWVrSUQsIGRhdGE6IGtheEluZm8gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogRUJNTElkLlNlZWtQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHdyaXRlT2Zmc2V0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZWJtbFdyaXRlci5vZmZzZXRzLmdldCh0aGlzLnNlZ21lbnRJbmZvKSAtIHRoaXMuc2VnbWVudERhdGFPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSB9LFxuICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5TZWVrLCBkYXRhOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGlkOiBFQk1MSWQuU2Vla0lELCBkYXRhOiBrYXhUcmFja3MgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogRUJNTElkLlNlZWtQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHdyaXRlT2Zmc2V0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZWJtbFdyaXRlci5vZmZzZXRzLmdldCh0aGlzLnRyYWNrc0VsZW1lbnQpIC0gdGhpcy5zZWdtZW50RGF0YU9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdIH0sXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2htZW50c0VsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgPyB7IGlkOiBFQk1MSWQuU2VlaywgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5TZWVrSUQsIGRhdGE6IGtheEF0dGFjaG1lbnRzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogRUJNTElkLlNlZWtQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogd3JpdGVPZmZzZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZWJtbFdyaXRlci5vZmZzZXRzLmdldCh0aGlzLmF0dGFjaG1lbnRzRWxlbWVudCkgLSB0aGlzLnNlZ21lbnREYXRhT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0gfVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgdGhpcy50YWdzRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICA/IHsgaWQ6IEVCTUxJZC5TZWVrLCBkYXRhOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpZDogRUJNTElkLlNlZWtJRCwgZGF0YToga2F4VGFncyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IEVCTUxJZC5TZWVrUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHdyaXRlT2Zmc2V0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmVibWxXcml0ZXIub2Zmc2V0cy5nZXQodGhpcy50YWdzRWxlbWVudCkgLSB0aGlzLnNlZ21lbnREYXRhT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0gfVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICBdIH07XG4gICAgICAgIHRoaXMuc2Vla0hlYWQgPSBzZWVrSGVhZDtcbiAgICB9XG4gICAgY3JlYXRlU2VnbWVudEluZm8oKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnREdXJhdGlvbiA9IHsgaWQ6IEVCTUxJZC5EdXJhdGlvbiwgZGF0YTogbmV3IEVCTUxGbG9hdDY0KDApIH07XG4gICAgICAgIHRoaXMuc2VnbWVudER1cmF0aW9uID0gc2VnbWVudER1cmF0aW9uO1xuICAgICAgICBjb25zdCBzZWdtZW50SW5mbyA9IHsgaWQ6IEVCTUxJZC5JbmZvLCBkYXRhOiBbXG4gICAgICAgICAgICAgICAgeyBpZDogRUJNTElkLlRpbWVzdGFtcFNjYWxlLCBkYXRhOiAxZTYgfSxcbiAgICAgICAgICAgICAgICB7IGlkOiBFQk1MSWQuTXV4aW5nQXBwLCBkYXRhOiBBUFBfTkFNRSB9LFxuICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5Xcml0aW5nQXBwLCBkYXRhOiBBUFBfTkFNRSB9LFxuICAgICAgICAgICAgICAgICF0aGlzLmZvcm1hdC5fb3B0aW9ucy5hcHBlbmRPbmx5ID8gc2VnbWVudER1cmF0aW9uIDogbnVsbCxcbiAgICAgICAgICAgIF0gfTtcbiAgICAgICAgdGhpcy5zZWdtZW50SW5mbyA9IHNlZ21lbnRJbmZvO1xuICAgIH1cbiAgICBjcmVhdGVUcmFja3MoKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrc0VsZW1lbnQgPSB7IGlkOiBFQk1MSWQuVHJhY2tzLCBkYXRhOiBbXSB9O1xuICAgICAgICB0aGlzLnRyYWNrc0VsZW1lbnQgPSB0cmFja3NFbGVtZW50O1xuICAgICAgICBmb3IgKGNvbnN0IHRyYWNrRGF0YSBvZiB0aGlzLnRyYWNrRGF0YXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjSWQgPSBDT0RFQ19TVFJJTkdfTUFQW3RyYWNrRGF0YS50cmFjay5zb3VyY2UuX2NvZGVjXTtcbiAgICAgICAgICAgIGFzc2VydChjb2RlY0lkKTtcbiAgICAgICAgICAgIGxldCBzZWVrUHJlUm9sbE5zID0gMDtcbiAgICAgICAgICAgIGlmICh0cmFja0RhdGEudHlwZSA9PT0gJ2F1ZGlvJyAmJiB0cmFja0RhdGEudHJhY2suc291cmNlLl9jb2RlYyA9PT0gJ29wdXMnKSB7XG4gICAgICAgICAgICAgICAgc2Vla1ByZVJvbGxOcyA9IDFlNiAqIDgwOyAvLyBJbiBcIk1hdHJvc2thIHRpY2tzXCIgKG5hbm9zZWNvbmRzKVxuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdHJhY2tEYXRhLmluZm8uZGVjb2RlckNvbmZpZy5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0b1VpbnQ4QXJyYXkoZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBwYXJzZU9wdXNJZGVudGlmaWNhdGlvbkhlYWRlcihieXRlcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgcHJlU2tpcCB2YWx1ZSBmcm9tIHRoZSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgc2Vla1ByZVJvbGxOcyA9IE1hdGgucm91bmQoMWU5ICogKGhlYWRlci5wcmVTa2lwIC8gT1BVU19TQU1QTEVfUkFURSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrc0VsZW1lbnQuZGF0YS5wdXNoKHsgaWQ6IEVCTUxJZC5UcmFja0VudHJ5LCBkYXRhOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5UcmFja051bWJlciwgZGF0YTogdHJhY2tEYXRhLnRyYWNrLmlkIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5UcmFja1VJRCwgZGF0YTogdHJhY2tEYXRhLnRyYWNrLmlkIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5UcmFja1R5cGUsIGRhdGE6IFRSQUNLX1RZUEVfTUFQW3RyYWNrRGF0YS50eXBlXSB9LFxuICAgICAgICAgICAgICAgICAgICB7IGlkOiBFQk1MSWQuRmxhZ0xhY2luZywgZGF0YTogMCB9LFxuICAgICAgICAgICAgICAgICAgICB7IGlkOiBFQk1MSWQuTGFuZ3VhZ2UsIGRhdGE6IHRyYWNrRGF0YS50cmFjay5tZXRhZGF0YS5sYW5ndWFnZUNvZGUgPz8gVU5ERVRFUk1JTkVEX0xBTkdVQUdFIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5Db2RlY0lELCBkYXRhOiBjb2RlY0lkIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5Db2RlY0RlbGF5LCBkYXRhOiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5TZWVrUHJlUm9sbCwgZGF0YTogc2Vla1ByZVJvbGxOcyB9LFxuICAgICAgICAgICAgICAgICAgICB0cmFja0RhdGEudHJhY2subWV0YWRhdGEubmFtZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgaWQ6IEVCTUxJZC5OYW1lLCBkYXRhOiBuZXcgRUJNTFVuaWNvZGVTdHJpbmcodHJhY2tEYXRhLnRyYWNrLm1ldGFkYXRhLm5hbWUpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgKHRyYWNrRGF0YS50eXBlID09PSAndmlkZW8nID8gdGhpcy52aWRlb1NwZWNpZmljVHJhY2tJbmZvKHRyYWNrRGF0YSkgOiBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgKHRyYWNrRGF0YS50eXBlID09PSAnYXVkaW8nID8gdGhpcy5hdWRpb1NwZWNpZmljVHJhY2tJbmZvKHRyYWNrRGF0YSkgOiBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgKHRyYWNrRGF0YS50eXBlID09PSAnc3VidGl0bGUnID8gdGhpcy5zdWJ0aXRsZVNwZWNpZmljVHJhY2tJbmZvKHRyYWNrRGF0YSkgOiBudWxsKSxcbiAgICAgICAgICAgICAgICBdIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZGVvU3BlY2lmaWNUcmFja0luZm8odHJhY2tEYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgZnJhbWVSYXRlLCByb3RhdGlvbiB9ID0gdHJhY2tEYXRhLnRyYWNrLm1ldGFkYXRhO1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IFtcbiAgICAgICAgICAgICh0cmFja0RhdGEuaW5mby5kZWNvZGVyQ29uZmlnLmRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBFQk1MSWQuQ29kZWNQcml2YXRlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0b1VpbnQ4QXJyYXkodHJhY2tEYXRhLmluZm8uZGVjb2RlckNvbmZpZy5kZXNjcmlwdGlvbiksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogbnVsbCksXG4gICAgICAgICAgICAoZnJhbWVSYXRlXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBFQk1MSWQuRGVmYXVsdER1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiAxZTkgLyBmcmFtZVJhdGUsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogbnVsbCksXG4gICAgICAgIF07XG4gICAgICAgIC8vIENvbnZlcnQgZnJvbSBjbG9ja3dpc2UgdG8gY291bnRlci1jbG9ja3dpc2VcbiAgICAgICAgY29uc3QgZmxpcHBlZFJvdGF0aW9uID0gcm90YXRpb24gPyBub3JtYWxpemVSb3RhdGlvbigtcm90YXRpb24pIDogMDtcbiAgICAgICAgY29uc3QgY29sb3JTcGFjZSA9IHRyYWNrRGF0YS5pbmZvLmRlY29kZXJDb25maWcuY29sb3JTcGFjZTtcbiAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50ID0geyBpZDogRUJNTElkLlZpZGVvLCBkYXRhOiBbXG4gICAgICAgICAgICAgICAgeyBpZDogRUJNTElkLlBpeGVsV2lkdGgsIGRhdGE6IHRyYWNrRGF0YS5pbmZvLndpZHRoIH0sXG4gICAgICAgICAgICAgICAgeyBpZDogRUJNTElkLlBpeGVsSGVpZ2h0LCBkYXRhOiB0cmFja0RhdGEuaW5mby5oZWlnaHQgfSxcbiAgICAgICAgICAgICAgICAoY29sb3JTcGFjZUlzQ29tcGxldGUoY29sb3JTcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogRUJNTElkLkNvbG91cixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBFQk1MSWQuTWF0cml4Q29lZmZpY2llbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBNQVRSSVhfQ09FRkZJQ0lFTlRTX01BUFtjb2xvclNwYWNlLm1hdHJpeF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBFQk1MSWQuVHJhbnNmZXJDaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFRSQU5TRkVSX0NIQVJBQ1RFUklTVElDU19NQVBbY29sb3JTcGFjZS50cmFuc2Zlcl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBFQk1MSWQuUHJpbWFyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBDT0xPUl9QUklNQVJJRVNfTUFQW2NvbG9yU3BhY2UucHJpbWFyaWVzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IEVCTUxJZC5SYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY29sb3JTcGFjZS5mdWxsUmFuZ2UgPyAyIDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwpLFxuICAgICAgICAgICAgICAgIChmbGlwcGVkUm90YXRpb25cbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogRUJNTElkLlByb2plY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogRUJNTElkLlByb2plY3Rpb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAwLCAvLyByZWN0YW5ndWxhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogRUJNTElkLlByb2plY3Rpb25Qb3NlUm9sbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogbmV3IEVCTUxGbG9hdDMyKChmbGlwcGVkUm90YXRpb24gKyAxODApICUgMzYwIC0gMTgwKSwgLy8gWzAsIDI3MF0gLT4gWy0xODAsIDkwXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCksXG4gICAgICAgICAgICBdIH07XG4gICAgICAgIGVsZW1lbnRzLnB1c2godmlkZW9FbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cbiAgICBhdWRpb1NwZWNpZmljVHJhY2tJbmZvKHRyYWNrRGF0YSkge1xuICAgICAgICBjb25zdCBwY21JbmZvID0gUENNX0FVRElPX0NPREVDUy5pbmNsdWRlcyh0cmFja0RhdGEudHJhY2suc291cmNlLl9jb2RlYylcbiAgICAgICAgICAgID8gcGFyc2VQY21Db2RlYyh0cmFja0RhdGEudHJhY2suc291cmNlLl9jb2RlYylcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICh0cmFja0RhdGEuaW5mby5kZWNvZGVyQ29uZmlnLmRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBFQk1MSWQuQ29kZWNQcml2YXRlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0b1VpbnQ4QXJyYXkodHJhY2tEYXRhLmluZm8uZGVjb2RlckNvbmZpZy5kZXNjcmlwdGlvbiksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogbnVsbCksXG4gICAgICAgICAgICB7IGlkOiBFQk1MSWQuQXVkaW8sIGRhdGE6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBpZDogRUJNTElkLlNhbXBsaW5nRnJlcXVlbmN5LCBkYXRhOiBuZXcgRUJNTEZsb2F0MzIodHJhY2tEYXRhLmluZm8uc2FtcGxlUmF0ZSkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBpZDogRUJNTElkLkNoYW5uZWxzLCBkYXRhOiB0cmFja0RhdGEuaW5mby5udW1iZXJPZkNoYW5uZWxzIH0sXG4gICAgICAgICAgICAgICAgICAgIHBjbUluZm8gPyB7IGlkOiBFQk1MSWQuQml0RGVwdGgsIGRhdGE6IDggKiBwY21JbmZvLnNhbXBsZVNpemUgfSA6IG51bGwsXG4gICAgICAgICAgICAgICAgXSB9LFxuICAgICAgICBdO1xuICAgIH1cbiAgICBzdWJ0aXRsZVNwZWNpZmljVHJhY2tJbmZvKHRyYWNrRGF0YSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBpZDogRUJNTElkLkNvZGVjUHJpdmF0ZSwgZGF0YTogdGV4dEVuY29kZXIuZW5jb2RlKHRyYWNrRGF0YS5pbmZvLmNvbmZpZy5kZXNjcmlwdGlvbikgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgbWF5YmVDcmVhdGVUYWdzKCkge1xuICAgICAgICBjb25zdCBzaW1wbGVUYWdzID0gW107XG4gICAgICAgIGNvbnN0IGFkZFNpbXBsZVRhZyA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBzaW1wbGVUYWdzLnB1c2goeyBpZDogRUJNTElkLlNpbXBsZVRhZywgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICB7IGlkOiBFQk1MSWQuVGFnTmFtZSwgZGF0YTogbmV3IEVCTUxVbmljb2RlU3RyaW5nKGtleSkgfSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IGlkOiBFQk1MSWQuVGFnU3RyaW5nLCBkYXRhOiBuZXcgRUJNTFVuaWNvZGVTdHJpbmcodmFsdWUpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogeyBpZDogRUJNTElkLlRhZ0JpbmFyeSwgZGF0YTogdmFsdWUgfSxcbiAgICAgICAgICAgICAgICBdIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtZXRhZGF0YVRhZ3MgPSB0aGlzLm91dHB1dC5fbWV0YWRhdGFUYWdzO1xuICAgICAgICBjb25zdCB3cml0dGVuVGFncyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCB7IGtleSwgdmFsdWUgfSBvZiBrZXlWYWx1ZUl0ZXJhdG9yKG1ldGFkYXRhVGFncykpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndGl0bGUnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRTaW1wbGVUYWcoJ1RJVExFJywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlblRhZ3MuYWRkKCdUSVRMRScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGVzY3JpcHRpb24nOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRTaW1wbGVUYWcoJ0RFU0NSSVBUSU9OJywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlblRhZ3MuYWRkKCdERVNDUklQVElPTicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYXJ0aXN0JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkU2ltcGxlVGFnKCdBUlRJU1QnLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0dGVuVGFncy5hZGQoJ0FSVElTVCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYWxidW0nOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRTaW1wbGVUYWcoJ0FMQlVNJywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlblRhZ3MuYWRkKCdBTEJVTScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYWxidW1BcnRpc3QnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRTaW1wbGVUYWcoJ0FMQlVNX0FSVElTVCcsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXR0ZW5UYWdzLmFkZCgnQUxCVU1fQVJUSVNUJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnZW5yZSc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFNpbXBsZVRhZygnR0VOUkUnLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0dGVuVGFncy5hZGQoJ0dFTlJFJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkU2ltcGxlVGFnKCdDT01NRU5UJywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlblRhZ3MuYWRkKCdDT01NRU5UJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdseXJpY3MnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRTaW1wbGVUYWcoJ0xZUklDUycsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXR0ZW5UYWdzLmFkZCgnTFlSSUNTJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkU2ltcGxlVGFnKCdEQVRFJywgdmFsdWUudG9JU09TdHJpbmcoKS5zbGljZSgwLCAxMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlblRhZ3MuYWRkKCdEQVRFJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd0cmFja051bWJlcic6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZyA9IG1ldGFkYXRhVGFncy50cmFja3NUb3RhbCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHt2YWx1ZX0vJHttZXRhZGF0YVRhZ3MudHJhY2tzVG90YWx9YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFNpbXBsZVRhZygnUEFSVF9OVU1CRVInLCBzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlblRhZ3MuYWRkKCdQQVJUX05VTUJFUicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY051bWJlcic6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZyA9IG1ldGFkYXRhVGFncy5kaXNjc1RvdGFsICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGAke3ZhbHVlfS8ke21ldGFkYXRhVGFncy5kaXNjc1RvdGFsfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRTaW1wbGVUYWcoJ0RJU0MnLCBzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlblRhZ3MuYWRkKCdESVNDJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd0cmFja3NUb3RhbCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY3NUb3RhbCc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZWQgd2l0aCB0cmFja051bWJlciBhbmQgZGlzY051bWJlciByZXNwZWN0aXZlbHlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ltYWdlcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAncmF3JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlZCBlbHNld2hlcmVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGFzc2VydE5ldmVyKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhVGFncy5yYXcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1ldGFkYXRhVGFncy5yYXcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1ldGFkYXRhVGFncy5yYXdba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB3cml0dGVuVGFncy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFNpbXBsZVRhZyhrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpbXBsZVRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YWdzRWxlbWVudCA9IHtcbiAgICAgICAgICAgIGlkOiBFQk1MSWQuVGFncyxcbiAgICAgICAgICAgIGRhdGE6IFt7IGlkOiBFQk1MSWQuVGFnLCBkYXRhOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGlkOiBFQk1MSWQuVGFyZ2V0cywgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGlkOiBFQk1MSWQuVGFyZ2V0VHlwZVZhbHVlLCBkYXRhOiA1MCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGlkOiBFQk1MSWQuVGFyZ2V0VHlwZSwgZGF0YTogJ01PVklFJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnNpbXBsZVRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIF0gfV0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIG1heWJlQ3JlYXRlQXR0YWNobWVudHMoKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhVGFncyA9IHRoaXMub3V0cHV0Ll9tZXRhZGF0YVRhZ3M7XG4gICAgICAgIGlmICghbWV0YWRhdGFUYWdzLmltYWdlcyB8fCBtZXRhZGF0YVRhZ3MuaW1hZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRmlsZVVpZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuYXR0YWNobWVudHNFbGVtZW50ID0geyBpZDogRUJNTElkLkF0dGFjaG1lbnRzLCBkYXRhOiBtZXRhZGF0YVRhZ3MuaW1hZ2VzLm1hcCgoaW1hZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaW1hZ2VOYW1lID0gaW1hZ2UubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZU5hbWUgPSBpbWFnZS5raW5kID09PSAnY292ZXJGcm9udCcgPyAnY292ZXInIDogaW1hZ2Uua2luZCA9PT0gJ2NvdmVyQmFjaycgPyAnYmFjaycgOiAnaW1hZ2UnO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZU5hbWUgPSBiYXNlTmFtZSArIChpbWFnZU1pbWVUeXBlVG9FeHRlbnNpb24oaW1hZ2UubWltZVR5cGUpID8/ICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGZpbGVVaWQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZVVpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVVaWQgIT09IDAgJiYgIWV4aXN0aW5nRmlsZVVpZHMuaGFzKGZpbGVVaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleGlzdGluZ0ZpbGVVaWRzLmFkZChmaWxlVWlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpZDogRUJNTElkLkF0dGFjaGVkRmlsZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geyBpZDogRUJNTElkLkZpbGVEZXNjcmlwdGlvbiwgZGF0YTogbmV3IEVCTUxVbmljb2RlU3RyaW5nKGltYWdlLmRlc2NyaXB0aW9uKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBpZDogRUJNTElkLkZpbGVOYW1lLCBkYXRhOiBuZXcgRUJNTFVuaWNvZGVTdHJpbmcoaW1hZ2VOYW1lKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBpZDogRUJNTElkLkZpbGVNZWRpYVR5cGUsIGRhdGE6IGltYWdlLm1pbWVUeXBlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGlkOiBFQk1MSWQuRmlsZURhdGEsIGRhdGE6IGltYWdlLmRhdGEgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5GaWxlVUlELCBkYXRhOiBmaWxlVWlkIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pIH07XG4gICAgfVxuICAgIGNyZWF0ZVNlZ21lbnQoKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlVHJhY2tzKCk7XG4gICAgICAgIHRoaXMubWF5YmVDcmVhdGVUYWdzKCk7XG4gICAgICAgIHRoaXMubWF5YmVDcmVhdGVBdHRhY2htZW50cygpO1xuICAgICAgICB0aGlzLm1heWJlQ3JlYXRlU2Vla0hlYWQoZmFsc2UpO1xuICAgICAgICBjb25zdCBzZWdtZW50ID0ge1xuICAgICAgICAgICAgaWQ6IEVCTUxJZC5TZWdtZW50LFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5mb3JtYXQuX29wdGlvbnMuYXBwZW5kT25seSA/IC0xIDogU0VHTUVOVF9TSVpFX0JZVEVTLFxuICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vla0hlYWQsIC8vIG51bGwgaWYgYXBwZW5kLW9ubHlcbiAgICAgICAgICAgICAgICB0aGlzLnNlZ21lbnRJbmZvLFxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tzRWxlbWVudCxcbiAgICAgICAgICAgICAgICAvLyBNYXRyb3NrYSBzcGVjIHNheXMgcHV0IHRoaXMgYXQgdGhlIGVuZCBvZiB0aGUgZmlsZSwgYnV0IEkgdGhpbmsgcGxhY2luZyBpdCBiZWZvcmUgdGhlIGZpcnN0IGNsdXN0ZXJcbiAgICAgICAgICAgICAgICAvLyBtYWtlcyBtb3JlIHNlbnNlLCBhbmQgRkZtcGVnIGFncmVlcyAoYXJndW1lbnR1bSBhZCBmZm1wZWd1bSBmYWxsYWN5KVxuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNobWVudHNFbGVtZW50LFxuICAgICAgICAgICAgICAgIHRoaXMudGFnc0VsZW1lbnQsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlZ21lbnQgPSBzZWdtZW50O1xuICAgICAgICBpZiAodGhpcy5mb3JtYXQuX29wdGlvbnMub25TZWdtZW50SGVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlci5zdGFydFRyYWNraW5nV3JpdGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYm1sV3JpdGVyLndyaXRlRUJNTChzZWdtZW50KTtcbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0Ll9vcHRpb25zLm9uU2VnbWVudEhlYWRlcikge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBzdGFydCB9ID0gdGhpcy53cml0ZXIuc3RvcFRyYWNraW5nV3JpdGVzKCk7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdC5fb3B0aW9ucy5vblNlZ21lbnRIZWFkZXIoZGF0YSwgc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUN1ZXMoKSB7XG4gICAgICAgIHRoaXMuY3VlcyA9IHsgaWQ6IEVCTUxJZC5DdWVzLCBkYXRhOiBbXSB9O1xuICAgIH1cbiAgICBnZXQgc2VnbWVudERhdGFPZmZzZXQoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLnNlZ21lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5lYm1sV3JpdGVyLmRhdGFPZmZzZXRzLmdldCh0aGlzLnNlZ21lbnQpO1xuICAgIH1cbiAgICBhbGxUcmFja3NBcmVLbm93bigpIHtcbiAgICAgICAgZm9yIChjb25zdCB0cmFjayBvZiB0aGlzLm91dHB1dC5fdHJhY2tzKSB7XG4gICAgICAgICAgICBpZiAoIXRyYWNrLnNvdXJjZS5fY2xvc2VkICYmICF0aGlzLnRyYWNrRGF0YXMuc29tZSh4ID0+IHgudHJhY2sgPT09IHRyYWNrKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gV2UgaGF2ZW4ndCBzZWVuIGEgc2FtcGxlIGZyb20gdGhpcyBvcGVuIHRyYWNrIHlldFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBnZXRNaW1lVHlwZSgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5hbGxUcmFja3NLbm93bi5wcm9taXNlO1xuICAgICAgICBjb25zdCBjb2RlY1N0cmluZ3MgPSB0aGlzLnRyYWNrRGF0YXMubWFwKCh0cmFja0RhdGEpID0+IHtcbiAgICAgICAgICAgIGlmICh0cmFja0RhdGEudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFja0RhdGEuaW5mby5kZWNvZGVyQ29uZmlnLmNvZGVjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHJhY2tEYXRhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2tEYXRhLmluZm8uZGVjb2RlckNvbmZpZy5jb2RlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgd2VidnR0OiAnd3Z0dCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwW3RyYWNrRGF0YS50cmFjay5zb3VyY2UuX2NvZGVjXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBidWlsZE1hdHJvc2thTWltZVR5cGUoe1xuICAgICAgICAgICAgaXNXZWJNOiB0aGlzLmZvcm1hdCBpbnN0YW5jZW9mIFdlYk1PdXRwdXRGb3JtYXQsXG4gICAgICAgICAgICBoYXNWaWRlbzogdGhpcy50cmFja0RhdGFzLnNvbWUoeCA9PiB4LnR5cGUgPT09ICd2aWRlbycpLFxuICAgICAgICAgICAgaGFzQXVkaW86IHRoaXMudHJhY2tEYXRhcy5zb21lKHggPT4geC50eXBlID09PSAnYXVkaW8nKSxcbiAgICAgICAgICAgIGNvZGVjU3RyaW5ncyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFZpZGVvVHJhY2tEYXRhKHRyYWNrLCBtZXRhKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVHJhY2tEYXRhID0gdGhpcy50cmFja0RhdGFzLmZpbmQoeCA9PiB4LnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgIGlmIChleGlzdGluZ1RyYWNrRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nVHJhY2tEYXRhO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlVmlkZW9DaHVua01ldGFkYXRhKG1ldGEpO1xuICAgICAgICBhc3NlcnQobWV0YSk7XG4gICAgICAgIGFzc2VydChtZXRhLmRlY29kZXJDb25maWcpO1xuICAgICAgICBhc3NlcnQobWV0YS5kZWNvZGVyQ29uZmlnLmNvZGVkV2lkdGggIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGFzc2VydChtZXRhLmRlY29kZXJDb25maWcuY29kZWRIZWlnaHQgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IG5ld1RyYWNrRGF0YSA9IHtcbiAgICAgICAgICAgIHRyYWNrLFxuICAgICAgICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogbWV0YS5kZWNvZGVyQ29uZmlnLmNvZGVkV2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBtZXRhLmRlY29kZXJDb25maWcuY29kZWRIZWlnaHQsXG4gICAgICAgICAgICAgICAgZGVjb2RlckNvbmZpZzogbWV0YS5kZWNvZGVyQ29uZmlnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNodW5rUXVldWU6IFtdLFxuICAgICAgICAgICAgbGFzdFdyaXR0ZW5Nc1RpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRyYWNrLnNvdXJjZS5fY29kZWMgPT09ICd2cDknKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53ZWJtcHJvamVjdC5vcmcvZG9jcy9jb250YWluZXIgc3BlY2lmaWVzIHRoYXQgVlA5IFwiU0hPVUxEXCIgbWFrZSB1c2Ugb2YgdGhlIENvZGVjUHJpdmF0ZVxuICAgICAgICAgICAgLy8gZmllbGQuIFNpbmNlIFdlYkNvZGVjcyBtYWtlcyBubyB1c2Ugb2YgdGhlIGRlc2NyaXB0aW9uIGZpZWxkIGZvciBWUDksIHdlIG5lZWQgdG8gZGVyaXZlIGl0IG91cnNlbHZlczpcbiAgICAgICAgICAgIG5ld1RyYWNrRGF0YS5pbmZvLmRlY29kZXJDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgLi4ubmV3VHJhY2tEYXRhLmluZm8uZGVjb2RlckNvbmZpZyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogbmV3IFVpbnQ4QXJyYXkoZ2VuZXJhdGVWcDlDb2RlY0NvbmZpZ3VyYXRpb25Gcm9tQ29kZWNTdHJpbmcobmV3VHJhY2tEYXRhLmluZm8uZGVjb2RlckNvbmZpZy5jb2RlYykpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmFjay5zb3VyY2UuX2NvZGVjID09PSAnYXYxJykge1xuICAgICAgICAgICAgLy8gUGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9pZXRmLXdnLWNlbGxhci9tYXRyb3NrYS1zcGVjaWZpY2F0aW9uL2Jsb2IvbWFzdGVyL2NvZGVjL2F2MS5tZCwgQVYxIHJlcXVpcmVzXG4gICAgICAgICAgICAvLyBDb2RlY1ByaXZhdGUgdG8gYmUgc2V0LCBidXQgV2ViQ29kZWNzIG1ha2VzIG5vIHVzZSBvZiB0aGUgZGVzY3JpcHRpb24gZmllbGQgZm9yIEFWMS4gVGh1cywgbGV0J3MgZGVyaXZlXG4gICAgICAgICAgICAvLyBpdCBvdXJzZWx2ZXM6XG4gICAgICAgICAgICBuZXdUcmFja0RhdGEuaW5mby5kZWNvZGVyQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIC4uLm5ld1RyYWNrRGF0YS5pbmZvLmRlY29kZXJDb25maWcsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG5ldyBVaW50OEFycmF5KGdlbmVyYXRlQXYxQ29kZWNDb25maWd1cmF0aW9uRnJvbUNvZGVjU3RyaW5nKG5ld1RyYWNrRGF0YS5pbmZvLmRlY29kZXJDb25maWcuY29kZWMpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja0RhdGFzLnB1c2gobmV3VHJhY2tEYXRhKTtcbiAgICAgICAgdGhpcy50cmFja0RhdGFzLnNvcnQoKGEsIGIpID0+IGEudHJhY2suaWQgLSBiLnRyYWNrLmlkKTtcbiAgICAgICAgaWYgKHRoaXMuYWxsVHJhY2tzQXJlS25vd24oKSkge1xuICAgICAgICAgICAgdGhpcy5hbGxUcmFja3NLbm93bi5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1RyYWNrRGF0YTtcbiAgICB9XG4gICAgZ2V0QXVkaW9UcmFja0RhdGEodHJhY2ssIG1ldGEpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdUcmFja0RhdGEgPSB0aGlzLnRyYWNrRGF0YXMuZmluZCh4ID0+IHgudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nVHJhY2tEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdUcmFja0RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVBdWRpb0NodW5rTWV0YWRhdGEobWV0YSk7XG4gICAgICAgIGFzc2VydChtZXRhKTtcbiAgICAgICAgYXNzZXJ0KG1ldGEuZGVjb2RlckNvbmZpZyk7XG4gICAgICAgIGNvbnN0IG5ld1RyYWNrRGF0YSA9IHtcbiAgICAgICAgICAgIHRyYWNrLFxuICAgICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgICAgICBudW1iZXJPZkNoYW5uZWxzOiBtZXRhLmRlY29kZXJDb25maWcubnVtYmVyT2ZDaGFubmVscyxcbiAgICAgICAgICAgICAgICBzYW1wbGVSYXRlOiBtZXRhLmRlY29kZXJDb25maWcuc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgICAgICBkZWNvZGVyQ29uZmlnOiBtZXRhLmRlY29kZXJDb25maWcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2h1bmtRdWV1ZTogW10sXG4gICAgICAgICAgICBsYXN0V3JpdHRlbk1zVGltZXN0YW1wOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYWNrRGF0YXMucHVzaChuZXdUcmFja0RhdGEpO1xuICAgICAgICB0aGlzLnRyYWNrRGF0YXMuc29ydCgoYSwgYikgPT4gYS50cmFjay5pZCAtIGIudHJhY2suaWQpO1xuICAgICAgICBpZiAodGhpcy5hbGxUcmFja3NBcmVLbm93bigpKSB7XG4gICAgICAgICAgICB0aGlzLmFsbFRyYWNrc0tub3duLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3VHJhY2tEYXRhO1xuICAgIH1cbiAgICBnZXRTdWJ0aXRsZVRyYWNrRGF0YSh0cmFjaywgbWV0YSkge1xuICAgICAgICBjb25zdCBleGlzdGluZ1RyYWNrRGF0YSA9IHRoaXMudHJhY2tEYXRhcy5maW5kKHggPT4geC50cmFjayA9PT0gdHJhY2spO1xuICAgICAgICBpZiAoZXhpc3RpbmdUcmFja0RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ1RyYWNrRGF0YTtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZVN1YnRpdGxlTWV0YWRhdGEobWV0YSk7XG4gICAgICAgIGFzc2VydChtZXRhKTtcbiAgICAgICAgYXNzZXJ0KG1ldGEuY29uZmlnKTtcbiAgICAgICAgY29uc3QgbmV3VHJhY2tEYXRhID0ge1xuICAgICAgICAgICAgdHJhY2ssXG4gICAgICAgICAgICB0eXBlOiAnc3VidGl0bGUnLFxuICAgICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgICAgIGNvbmZpZzogbWV0YS5jb25maWcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2h1bmtRdWV1ZTogW10sXG4gICAgICAgICAgICBsYXN0V3JpdHRlbk1zVGltZXN0YW1wOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYWNrRGF0YXMucHVzaChuZXdUcmFja0RhdGEpO1xuICAgICAgICB0aGlzLnRyYWNrRGF0YXMuc29ydCgoYSwgYikgPT4gYS50cmFjay5pZCAtIGIudHJhY2suaWQpO1xuICAgICAgICBpZiAodGhpcy5hbGxUcmFja3NBcmVLbm93bigpKSB7XG4gICAgICAgICAgICB0aGlzLmFsbFRyYWNrc0tub3duLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3VHJhY2tEYXRhO1xuICAgIH1cbiAgICBhc3luYyBhZGRFbmNvZGVkVmlkZW9QYWNrZXQodHJhY2ssIHBhY2tldCwgbWV0YSkge1xuICAgICAgICBjb25zdCByZWxlYXNlID0gYXdhaXQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0cmFja0RhdGEgPSB0aGlzLmdldFZpZGVvVHJhY2tEYXRhKHRyYWNrLCBtZXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGlzS2V5RnJhbWUgPSBwYWNrZXQudHlwZSA9PT0gJ2tleSc7XG4gICAgICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy52YWxpZGF0ZUFuZE5vcm1hbGl6ZVRpbWVzdGFtcCh0cmFja0RhdGEudHJhY2ssIHBhY2tldC50aW1lc3RhbXAsIGlzS2V5RnJhbWUpO1xuICAgICAgICAgICAgbGV0IGR1cmF0aW9uID0gcGFja2V0LmR1cmF0aW9uO1xuICAgICAgICAgICAgaWYgKHRyYWNrLm1ldGFkYXRhLmZyYW1lUmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29uc3RyYWluIHRoZSB0aW1lIHZhbHVlcyB0byB0aGUgZnJhbWUgcmF0ZVxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IHJvdW5kVG9NdWx0aXBsZSh0aW1lc3RhbXAsIDEgLyB0cmFjay5tZXRhZGF0YS5mcmFtZVJhdGUpO1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gcm91bmRUb011bHRpcGxlKGR1cmF0aW9uLCAxIC8gdHJhY2subWV0YWRhdGEuZnJhbWVSYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZpZGVvQ2h1bmsgPSB0aGlzLmNyZWF0ZUludGVybmFsQ2h1bmsocGFja2V0LmRhdGEsIHRpbWVzdGFtcCwgZHVyYXRpb24sIHBhY2tldC50eXBlKTtcbiAgICAgICAgICAgIGlmICh0cmFjay5zb3VyY2UuX2NvZGVjID09PSAndnA5JylcbiAgICAgICAgICAgICAgICB0aGlzLmZpeFZQOUNvbG9yU3BhY2UodHJhY2tEYXRhLCB2aWRlb0NodW5rKTtcbiAgICAgICAgICAgIHRyYWNrRGF0YS5jaHVua1F1ZXVlLnB1c2godmlkZW9DaHVuayk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmludGVybGVhdmVDaHVua3MoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBhZGRFbmNvZGVkQXVkaW9QYWNrZXQodHJhY2ssIHBhY2tldCwgbWV0YSkge1xuICAgICAgICBjb25zdCByZWxlYXNlID0gYXdhaXQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0cmFja0RhdGEgPSB0aGlzLmdldEF1ZGlvVHJhY2tEYXRhKHRyYWNrLCBtZXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGlzS2V5RnJhbWUgPSBwYWNrZXQudHlwZSA9PT0gJ2tleSc7XG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSB0aGlzLnZhbGlkYXRlQW5kTm9ybWFsaXplVGltZXN0YW1wKHRyYWNrRGF0YS50cmFjaywgcGFja2V0LnRpbWVzdGFtcCwgaXNLZXlGcmFtZSk7XG4gICAgICAgICAgICBjb25zdCBhdWRpb0NodW5rID0gdGhpcy5jcmVhdGVJbnRlcm5hbENodW5rKHBhY2tldC5kYXRhLCB0aW1lc3RhbXAsIHBhY2tldC5kdXJhdGlvbiwgcGFja2V0LnR5cGUpO1xuICAgICAgICAgICAgdHJhY2tEYXRhLmNodW5rUXVldWUucHVzaChhdWRpb0NodW5rKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW50ZXJsZWF2ZUNodW5rcygpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGFkZFN1YnRpdGxlQ3VlKHRyYWNrLCBjdWUsIG1ldGEpIHtcbiAgICAgICAgY29uc3QgcmVsZWFzZSA9IGF3YWl0IHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdHJhY2tEYXRhID0gdGhpcy5nZXRTdWJ0aXRsZVRyYWNrRGF0YSh0cmFjaywgbWV0YSk7XG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSB0aGlzLnZhbGlkYXRlQW5kTm9ybWFsaXplVGltZXN0YW1wKHRyYWNrRGF0YS50cmFjaywgY3VlLnRpbWVzdGFtcCwgdHJ1ZSk7XG4gICAgICAgICAgICBsZXQgYm9keVRleHQgPSBjdWUudGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcE1zID0gTWF0aC5yb3VuZCh0aW1lc3RhbXAgKiAxMDAwKTtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgaW4tYm9keSB0aW1lc3RhbXBzIHNvIHRoYXQgdGhleSdyZSByZWxhdGl2ZSB0byB0aGUgY3VlIHN0YXJ0IHRpbWVcbiAgICAgICAgICAgIGlubGluZVRpbWVzdGFtcFJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBib2R5VGV4dCA9IGJvZHlUZXh0LnJlcGxhY2UoaW5saW5lVGltZXN0YW1wUmVnZXgsIChtYXRjaCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBwYXJzZVN1YnRpdGxlVGltZXN0YW1wKG1hdGNoLnNsaWNlKDEsIC0xKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0VGltZSA9IHRpbWUgLSB0aW1lc3RhbXBNcztcbiAgICAgICAgICAgICAgICByZXR1cm4gYDwke2Zvcm1hdFN1YnRpdGxlVGltZXN0YW1wKG9mZnNldFRpbWUpfT5gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdGV4dEVuY29kZXIuZW5jb2RlKGJvZHlUZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9ucyA9IGAke2N1ZS5zZXR0aW5ncyA/PyAnJ31cXG4ke2N1ZS5pZGVudGlmaWVyID8/ICcnfVxcbiR7Y3VlLm5vdGVzID8/ICcnfWA7XG4gICAgICAgICAgICBjb25zdCBzdWJ0aXRsZUNodW5rID0gdGhpcy5jcmVhdGVJbnRlcm5hbENodW5rKGJvZHksIHRpbWVzdGFtcCwgY3VlLmR1cmF0aW9uLCAna2V5JywgYWRkaXRpb25zLnRyaW0oKSA/IHRleHRFbmNvZGVyLmVuY29kZShhZGRpdGlvbnMpIDogbnVsbCk7XG4gICAgICAgICAgICB0cmFja0RhdGEuY2h1bmtRdWV1ZS5wdXNoKHN1YnRpdGxlQ2h1bmspO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbnRlcmxlYXZlQ2h1bmtzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaW50ZXJsZWF2ZUNodW5rcyhpc0ZpbmFsQ2FsbCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghaXNGaW5hbENhbGwpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxUcmFja3NBcmVLbm93bigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBXZSBjYW4ndCBpbnRlcmxlYXZlIHlldCBhcyB3ZSBkb24ndCB5ZXQga25vdyBob3cgbWFueSB0cmFja3Mgd2UnbGwgdHJ1bHkgaGF2ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dGVyOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IHRyYWNrV2l0aE1pblRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbWluVGltZXN0YW1wID0gSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRyYWNrRGF0YSBvZiB0aGlzLnRyYWNrRGF0YXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmluYWxDYWxsICYmIHRyYWNrRGF0YS5jaHVua1F1ZXVlLmxlbmd0aCA9PT0gMCAmJiAhdHJhY2tEYXRhLnRyYWNrLnNvdXJjZS5fY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHJhY2tEYXRhLmNodW5rUXVldWUubGVuZ3RoID4gMCAmJiB0cmFja0RhdGEuY2h1bmtRdWV1ZVswXS50aW1lc3RhbXAgPCBtaW5UaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tXaXRoTWluVGltZXN0YW1wID0gdHJhY2tEYXRhO1xuICAgICAgICAgICAgICAgICAgICBtaW5UaW1lc3RhbXAgPSB0cmFja0RhdGEuY2h1bmtRdWV1ZVswXS50aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0cmFja1dpdGhNaW5UaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdHJhY2tXaXRoTWluVGltZXN0YW1wLmNodW5rUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCbG9jayh0cmFja1dpdGhNaW5UaW1lc3RhbXAsIGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRmluYWxDYWxsKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIER1ZSB0byBbYSBidWcgaW4gQ2hyb21pdW1dKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEzNzc4NDIpLCBWUDkgc3RyZWFtcyBvZnRlblxuICAgICAqIGxhY2sgY29sb3Igc3BhY2UgaW5mb3JtYXRpb24uIFRoaXMgbWV0aG9kIHBhdGNoZXMgaW4gdGhhdCBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBmaXhWUDlDb2xvclNwYWNlKHRyYWNrRGF0YSwgY2h1bmspIHtcbiAgICAgICAgLy8gaHR0cDovL2Rvd25sb2Fkcy53ZWJtcHJvamVjdC5vcmcvZG9jcy92cDkvdnA5LWJpdHN0cmVhbV9zdXBlcmZyYW1lLWFuZC11bmNvbXByZXNzZWQtaGVhZGVyX3YxLjAucGRmXG4gICAgICAgIGlmIChjaHVuay50eXBlICE9PSAna2V5JylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCF0cmFja0RhdGEuaW5mby5kZWNvZGVyQ29uZmlnLmNvbG9yU3BhY2UgfHwgIXRyYWNrRGF0YS5pbmZvLmRlY29kZXJDb25maWcuY29sb3JTcGFjZS5tYXRyaXgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGJpdHN0cmVhbSA9IG5ldyBCaXRzdHJlYW0oY2h1bmsuZGF0YSk7XG4gICAgICAgIGJpdHN0cmVhbS5za2lwQml0cygyKTtcbiAgICAgICAgY29uc3QgcHJvZmlsZUxvd0JpdCA9IGJpdHN0cmVhbS5yZWFkQml0cygxKTtcbiAgICAgICAgY29uc3QgcHJvZmlsZUhpZ2hCaXQgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7XG4gICAgICAgIGNvbnN0IHByb2ZpbGUgPSAocHJvZmlsZUhpZ2hCaXQgPDwgMSkgKyBwcm9maWxlTG93Qml0O1xuICAgICAgICBpZiAocHJvZmlsZSA9PT0gMylcbiAgICAgICAgICAgIGJpdHN0cmVhbS5za2lwQml0cygxKTtcbiAgICAgICAgY29uc3Qgc2hvd0V4aXN0aW5nRnJhbWUgPSBiaXRzdHJlYW0ucmVhZEJpdHMoMSk7XG4gICAgICAgIGlmIChzaG93RXhpc3RpbmdGcmFtZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZnJhbWVUeXBlID0gYml0c3RyZWFtLnJlYWRCaXRzKDEpO1xuICAgICAgICBpZiAoZnJhbWVUeXBlICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBKdXN0IHRvIGJlIHN1cmVcbiAgICAgICAgYml0c3RyZWFtLnNraXBCaXRzKDIpO1xuICAgICAgICBjb25zdCBzeW5jQ29kZSA9IGJpdHN0cmVhbS5yZWFkQml0cygyNCk7XG4gICAgICAgIGlmIChzeW5jQ29kZSAhPT0gMHg0OTgzNDIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwcm9maWxlID49IDIpXG4gICAgICAgICAgICBiaXRzdHJlYW0uc2tpcEJpdHMoMSk7XG4gICAgICAgIGNvbnN0IGNvbG9yU3BhY2VJRCA9IHtcbiAgICAgICAgICAgIHJnYjogNyxcbiAgICAgICAgICAgIGJ0NzA5OiAyLFxuICAgICAgICAgICAgYnQ0NzBiZzogMSxcbiAgICAgICAgICAgIHNtcHRlMTcwbTogMyxcbiAgICAgICAgfVt0cmFja0RhdGEuaW5mby5kZWNvZGVyQ29uZmlnLmNvbG9yU3BhY2UubWF0cml4XTtcbiAgICAgICAgLy8gVGhlIGJpdHN0cmVhbSBwb3NpdGlvbiBpcyBub3cgYXQgdGhlIHN0YXJ0IG9mIHRoZSBjb2xvciBzcGFjZSBiaXRzLlxuICAgICAgICAvLyBXZSBjYW4gdXNlIHRoZSBnbG9iYWwgd3JpdGVCaXRzIGZ1bmN0aW9uIGhlcmUgYXMgcmVxdWVzdGVkLlxuICAgICAgICB3cml0ZUJpdHMoY2h1bmsuZGF0YSwgYml0c3RyZWFtLnBvcywgYml0c3RyZWFtLnBvcyArIDMsIGNvbG9yU3BhY2VJRCk7XG4gICAgfVxuICAgIC8qKiBDb252ZXJ0cyBhIHJlYWQtb25seSBleHRlcm5hbCBjaHVuayBpbnRvIGFuIGludGVybmFsIG9uZSBmb3IgZWFzaWVyIHVzZS4gKi9cbiAgICBjcmVhdGVJbnRlcm5hbENodW5rKGRhdGEsIHRpbWVzdGFtcCwgZHVyYXRpb24sIHR5cGUsIGFkZGl0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxDaHVuayA9IHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICBhZGRpdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpbnRlcm5hbENodW5rO1xuICAgIH1cbiAgICAvKiogV3JpdGVzIGEgYmxvY2sgY29udGFpbmluZyBtZWRpYSBkYXRhIHRvIHRoZSBmaWxlLiAqL1xuICAgIHdyaXRlQmxvY2sodHJhY2tEYXRhLCBjaHVuaykge1xuICAgICAgICAvLyBEdWUgdG8gdGhlIGludGVybGFjaW5nIGFsZ29yaXRobSwgdGhpcyBjb2RlIHdpbGwgYmUgcnVuIG9uY2Ugd2UndmUgc2VlbiBvbmUgY2h1bmsgZnJvbSBldmVyeSBtZWRpYSB0cmFjay5cbiAgICAgICAgaWYgKCF0aGlzLnNlZ21lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU2VnbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1zVGltZXN0YW1wID0gTWF0aC5yb3VuZCgxMDAwICogY2h1bmsudGltZXN0YW1wKTtcbiAgICAgICAgLy8gV2Ugd2FubmEgb25seSBmaW5hbGl6ZSB0aGlzIGNsdXN0ZXIgKGFuZCBiZWdpbiBhIG5ldyBvbmUpIGlmIHdlIGtub3cgdGhhdCBlYWNoIHRyYWNrIHdpbGwgYmUgYWJsZSB0b1xuICAgICAgICAvLyBzdGFydCB0aGUgbmV3IG9uZSB3aXRoIGEga2V5IGZyYW1lLlxuICAgICAgICBjb25zdCBrZXlGcmFtZVF1ZXVlZEV2ZXJ5d2hlcmUgPSB0aGlzLnRyYWNrRGF0YXMuZXZlcnkoKG90aGVyVHJhY2tEYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAodHJhY2tEYXRhID09PSBvdGhlclRyYWNrRGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaHVuay50eXBlID09PSAna2V5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UXVldWVkU2FtcGxlID0gb3RoZXJUcmFja0RhdGEuY2h1bmtRdWV1ZVswXTtcbiAgICAgICAgICAgIGlmIChmaXJzdFF1ZXVlZFNhbXBsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdFF1ZXVlZFNhbXBsZS50eXBlID09PSAna2V5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdGhlclRyYWNrRGF0YS50cmFjay5zb3VyY2UuX2Nsb3NlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBzaG91bGRDcmVhdGVOZXdDbHVzdGVyID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50Q2x1c3Rlcikge1xuICAgICAgICAgICAgc2hvdWxkQ3JlYXRlTmV3Q2x1c3RlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5jdXJyZW50Q2x1c3RlclN0YXJ0TXNUaW1lc3RhbXAgIT09IG51bGwpO1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMuY3VycmVudENsdXN0ZXJNYXhNc1RpbWVzdGFtcCAhPT0gbnVsbCk7XG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZVRpbWVzdGFtcCA9IG1zVGltZXN0YW1wIC0gdGhpcy5jdXJyZW50Q2x1c3RlclN0YXJ0TXNUaW1lc3RhbXA7XG4gICAgICAgICAgICBzaG91bGRDcmVhdGVOZXdDbHVzdGVyID0gKGtleUZyYW1lUXVldWVkRXZlcnl3aGVyZVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2hlY2sgaXMgcmVxdWlyZWQgYmVjYXVzZSB0aGF0IG1lYW5zIHRoZXJlIGlzIGFscmVhZHkgYSBibG9jayB3aXRoIHRoaXMgdGltZXN0YW1wIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIENVUlJFTlQgY2h1bmssIG1lYW5pbmcgdGhhdCBzdGFydGluZyB0aGUgbmV4dCBjbHVzdGVyIGF0IHRoZSBzYW1lIHRpbWVzdGFtcCBpcyBmb3JiaWRkZW4gKHNpbmNlXG4gICAgICAgICAgICAgICAgLy8gdGhlIGFscmVhZHktd3JpdHRlbiBibG9jayB3b3VsZCBiZWxvbmcgaW50byBpdCBpbnN0ZWFkKS5cbiAgICAgICAgICAgICAgICAmJiBtc1RpbWVzdGFtcCA+IHRoaXMuY3VycmVudENsdXN0ZXJNYXhNc1RpbWVzdGFtcFxuICAgICAgICAgICAgICAgICYmIHJlbGF0aXZlVGltZXN0YW1wID49IDEwMDAgKiAodGhpcy5mb3JtYXQuX29wdGlvbnMubWluaW11bUNsdXN0ZXJEdXJhdGlvbiA/PyAxKSlcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2x1c3RlciB3b3VsZCBleGNlZWQgaXRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGguIFRoaXMgcHV0cyB1cyBpbiBhbiB1bmZvcnR1bmF0ZSBwb3NpdGlvbiBhbmQgZm9yY2VzXG4gICAgICAgICAgICAgICAgLy8gdXMgdG8gYmVnaW4gdGhlIG5leHQgY2x1c3RlciB3aXRoIGEgZGVsdGEgZnJhbWUuIEFsdGhvdWdoIHRoaXMgaXMgdW5kZXNpcmFibGUsIGl0IGlzIG5vdCBmb3JiaWRkZW4gYnkgdGhlXG4gICAgICAgICAgICAgICAgLy8gc3BlYyBhbmQgaXMgc3VwcG9ydGVkIGJ5IHBsYXllcnMuXG4gICAgICAgICAgICAgICAgfHwgcmVsYXRpdmVUaW1lc3RhbXAgPiBNQVhfQ0xVU1RFUl9USU1FU1RBTVBfTVM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZENyZWF0ZU5ld0NsdXN0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlTmV3Q2x1c3Rlcihtc1RpbWVzdGFtcCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVsYXRpdmVUaW1lc3RhbXAgPSBtc1RpbWVzdGFtcCAtIHRoaXMuY3VycmVudENsdXN0ZXJTdGFydE1zVGltZXN0YW1wO1xuICAgICAgICBpZiAocmVsYXRpdmVUaW1lc3RhbXAgPCBNSU5fQ0xVU1RFUl9USU1FU1RBTVBfTVMpIHtcbiAgICAgICAgICAgIC8vIFRoZSBibG9jayBsaWVzIHRvbyBmYXIgaW4gdGhlIHBhc3QsIGl0J3Mgbm90IHJlcHJlc2VudGFibGUgd2l0aGluIHRoaXMgY2x1c3RlclxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWx1ZGUgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhwcmVsdWRlLmJ1ZmZlcik7XG4gICAgICAgIC8vIDB4ODAgdG8gaW5kaWNhdGUgaXQncyB0aGUgbGFzdCBieXRlIG9mIGEgbXVsdGktYnl0ZSBudW1iZXJcbiAgICAgICAgdmlldy5zZXRVaW50OCgwLCAweDgwIHwgdHJhY2tEYXRhLnRyYWNrLmlkKTtcbiAgICAgICAgdmlldy5zZXRJbnQxNigxLCByZWxhdGl2ZVRpbWVzdGFtcCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBtc0R1cmF0aW9uID0gTWF0aC5yb3VuZCgxMDAwICogY2h1bmsuZHVyYXRpb24pO1xuICAgICAgICBpZiAoIWNodW5rLmFkZGl0aW9ucykge1xuICAgICAgICAgICAgLy8gTm8gYWRkaXRpb25zLCB3ZSBjYW4gd3JpdGUgb3V0IGEgU2ltcGxlQmxvY2tcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgoMywgTnVtYmVyKGNodW5rLnR5cGUgPT09ICdrZXknKSA8PCA3KTsgLy8gRmxhZ3MgKGtleWZyYW1lIGZsYWcgb25seSBwcmVzZW50IGZvciBTaW1wbGVCbG9jaylcbiAgICAgICAgICAgIGNvbnN0IHNpbXBsZUJsb2NrID0geyBpZDogRUJNTElkLlNpbXBsZUJsb2NrLCBkYXRhOiBbXG4gICAgICAgICAgICAgICAgICAgIHByZWx1ZGUsXG4gICAgICAgICAgICAgICAgICAgIGNodW5rLmRhdGEsXG4gICAgICAgICAgICAgICAgXSB9O1xuICAgICAgICAgICAgdGhpcy5lYm1sV3JpdGVyLndyaXRlRUJNTChzaW1wbGVCbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja0dyb3VwID0geyBpZDogRUJNTElkLkJsb2NrR3JvdXAsIGRhdGE6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBpZDogRUJNTElkLkJsb2NrLCBkYXRhOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlbHVkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSB9LFxuICAgICAgICAgICAgICAgICAgICBjaHVuay50eXBlID09PSAnZGVsdGEnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogRUJNTElkLlJlZmVyZW5jZUJsb2NrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IG5ldyBFQk1MU2lnbmVkSW50KHRyYWNrRGF0YS5sYXN0V3JpdHRlbk1zVGltZXN0YW1wIC0gbXNUaW1lc3RhbXApLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjaHVuay5hZGRpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBpZDogRUJNTElkLkJsb2NrQWRkaXRpb25zLCBkYXRhOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5CbG9ja01vcmUsIGRhdGE6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGlkOiBFQk1MSWQuQmxvY2tBZGRpdGlvbmFsLCBkYXRhOiBjaHVuay5hZGRpdGlvbnMgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGlkOiBFQk1MSWQuQmxvY2tBZGRJRCwgZGF0YTogMSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0gfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtc0R1cmF0aW9uID4gMCA/IHsgaWQ6IEVCTUxJZC5CbG9ja0R1cmF0aW9uLCBkYXRhOiBtc0R1cmF0aW9uIH0gOiBudWxsLFxuICAgICAgICAgICAgICAgIF0gfTtcbiAgICAgICAgICAgIHRoaXMuZWJtbFdyaXRlci53cml0ZUVCTUwoYmxvY2tHcm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IE1hdGgubWF4KHRoaXMuZHVyYXRpb24sIG1zVGltZXN0YW1wICsgbXNEdXJhdGlvbik7XG4gICAgICAgIHRyYWNrRGF0YS5sYXN0V3JpdHRlbk1zVGltZXN0YW1wID0gbXNUaW1lc3RhbXA7XG4gICAgICAgIGlmICghdGhpcy50cmFja0RhdGFzSW5DdXJyZW50Q2x1c3Rlci5oYXModHJhY2tEYXRhKSkge1xuICAgICAgICAgICAgdGhpcy50cmFja0RhdGFzSW5DdXJyZW50Q2x1c3Rlci5zZXQodHJhY2tEYXRhLCB7XG4gICAgICAgICAgICAgICAgZmlyc3RNc1RpbWVzdGFtcDogbXNUaW1lc3RhbXAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRDbHVzdGVyTWF4TXNUaW1lc3RhbXAgPSBNYXRoLm1heCh0aGlzLmN1cnJlbnRDbHVzdGVyTWF4TXNUaW1lc3RhbXAsIG1zVGltZXN0YW1wKTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgQ2x1c3RlciBlbGVtZW50IHRvIGNvbnRhaW4gbWVkaWEgY2h1bmtzLiAqL1xuICAgIGNyZWF0ZU5ld0NsdXN0ZXIobXNUaW1lc3RhbXApIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENsdXN0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemVDdXJyZW50Q2x1c3RlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvcm1hdC5fb3B0aW9ucy5vbkNsdXN0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVyLnN0YXJ0VHJhY2tpbmdXcml0ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRDbHVzdGVyID0ge1xuICAgICAgICAgICAgaWQ6IEVCTUxJZC5DbHVzdGVyLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5mb3JtYXQuX29wdGlvbnMuYXBwZW5kT25seSA/IC0xIDogQ0xVU1RFUl9TSVpFX0JZVEVTLFxuICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgIHsgaWQ6IEVCTUxJZC5UaW1lc3RhbXAsIGRhdGE6IG1zVGltZXN0YW1wIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVibWxXcml0ZXIud3JpdGVFQk1MKHRoaXMuY3VycmVudENsdXN0ZXIpO1xuICAgICAgICB0aGlzLmN1cnJlbnRDbHVzdGVyU3RhcnRNc1RpbWVzdGFtcCA9IG1zVGltZXN0YW1wO1xuICAgICAgICB0aGlzLmN1cnJlbnRDbHVzdGVyTWF4TXNUaW1lc3RhbXAgPSBtc1RpbWVzdGFtcDtcbiAgICAgICAgdGhpcy50cmFja0RhdGFzSW5DdXJyZW50Q2x1c3Rlci5jbGVhcigpO1xuICAgIH1cbiAgICBmaW5hbGl6ZUN1cnJlbnRDbHVzdGVyKCkge1xuICAgICAgICBhc3NlcnQodGhpcy5jdXJyZW50Q2x1c3Rlcik7XG4gICAgICAgIGlmICghdGhpcy5mb3JtYXQuX29wdGlvbnMuYXBwZW5kT25seSkge1xuICAgICAgICAgICAgY29uc3QgY2x1c3RlclNpemUgPSB0aGlzLndyaXRlci5nZXRQb3MoKSAtIHRoaXMuZWJtbFdyaXRlci5kYXRhT2Zmc2V0cy5nZXQodGhpcy5jdXJyZW50Q2x1c3Rlcik7XG4gICAgICAgICAgICBjb25zdCBlbmRQb3MgPSB0aGlzLndyaXRlci5nZXRQb3MoKTtcbiAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBzaXplIG5vdyB0aGF0IHdlIGtub3cgaXRcbiAgICAgICAgICAgIHRoaXMud3JpdGVyLnNlZWsodGhpcy5lYm1sV3JpdGVyLm9mZnNldHMuZ2V0KHRoaXMuY3VycmVudENsdXN0ZXIpICsgNCk7XG4gICAgICAgICAgICB0aGlzLmVibWxXcml0ZXIud3JpdGVWYXJJbnQoY2x1c3RlclNpemUsIENMVVNURVJfU0laRV9CWVRFUyk7XG4gICAgICAgICAgICB0aGlzLndyaXRlci5zZWVrKGVuZFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0Ll9vcHRpb25zLm9uQ2x1c3Rlcikge1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMuY3VycmVudENsdXN0ZXJTdGFydE1zVGltZXN0YW1wICE9PSBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgc3RhcnQgfSA9IHRoaXMud3JpdGVyLnN0b3BUcmFja2luZ1dyaXRlcygpO1xuICAgICAgICAgICAgdGhpcy5mb3JtYXQuX29wdGlvbnMub25DbHVzdGVyKGRhdGEsIHN0YXJ0LCB0aGlzLmN1cnJlbnRDbHVzdGVyU3RhcnRNc1RpbWVzdGFtcCAvIDEwMDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJPZmZzZXRGcm9tU2VnbWVudCA9IHRoaXMuZWJtbFdyaXRlci5vZmZzZXRzLmdldCh0aGlzLmN1cnJlbnRDbHVzdGVyKSAtIHRoaXMuc2VnbWVudERhdGFPZmZzZXQ7XG4gICAgICAgIC8vIEdyb3VwIHRyYWNrcyBieSB0aGVpciBmaXJzdCB0aW1lc3RhbXAgYW5kIGNyZWF0ZSBhIEN1ZVBvaW50IGZvciBlYWNoIHVuaXF1ZSB0aW1lc3RhbXBcbiAgICAgICAgY29uc3QgZ3JvdXBlZEJ5VGltZXN0YW1wID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFt0cmFja0RhdGEsIHsgZmlyc3RNc1RpbWVzdGFtcCB9XSBvZiB0aGlzLnRyYWNrRGF0YXNJbkN1cnJlbnRDbHVzdGVyKSB7XG4gICAgICAgICAgICBpZiAoIWdyb3VwZWRCeVRpbWVzdGFtcC5oYXMoZmlyc3RNc1RpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgICAgICBncm91cGVkQnlUaW1lc3RhbXAuc2V0KGZpcnN0TXNUaW1lc3RhbXAsIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyb3VwZWRCeVRpbWVzdGFtcC5nZXQoZmlyc3RNc1RpbWVzdGFtcCkucHVzaCh0cmFja0RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdyb3VwZWRBbmRTb3J0ZWRCeVRpbWVzdGFtcCA9IFsuLi5ncm91cGVkQnlUaW1lc3RhbXAuZW50cmllcygpXS5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSk7XG4gICAgICAgIC8vIEFkZCBDdWVQb2ludHMgdG8gdGhlIEN1ZXMgZWxlbWVudCBmb3IgYmV0dGVyIHNlZWtpbmdcbiAgICAgICAgZm9yIChjb25zdCBbbXNUaW1lc3RhbXAsIHRyYWNrRGF0YXNdIG9mIGdyb3VwZWRBbmRTb3J0ZWRCeVRpbWVzdGFtcCkge1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMuY3Vlcyk7XG4gICAgICAgICAgICB0aGlzLmN1ZXMuZGF0YS5wdXNoKHsgaWQ6IEVCTUxJZC5DdWVQb2ludCwgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICB7IGlkOiBFQk1MSWQuQ3VlVGltZSwgZGF0YTogbXNUaW1lc3RhbXAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIEN1ZVRyYWNrUG9zaXRpb25zIGZvciBlYWNoIHRyYWNrIHRoYXQgc3RhcnRzIGF0IHRoaXMgdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgICAgIC4uLnRyYWNrRGF0YXMubWFwKCh0cmFja0RhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGlkOiBFQk1MSWQuQ3VlVHJhY2tQb3NpdGlvbnMsIGRhdGE6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpZDogRUJNTElkLkN1ZVRyYWNrLCBkYXRhOiB0cmFja0RhdGEudHJhY2suaWQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpZDogRUJNTElkLkN1ZUNsdXN0ZXJQb3NpdGlvbiwgZGF0YTogY2x1c3Rlck9mZnNldEZyb21TZWdtZW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSB9O1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBdIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbWlzdXNlZC1wcm9taXNlc1xuICAgIGFzeW5jIG9uVHJhY2tDbG9zZSgpIHtcbiAgICAgICAgY29uc3QgcmVsZWFzZSA9IGF3YWl0IHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICBpZiAodGhpcy5hbGxUcmFja3NBcmVLbm93bigpKSB7XG4gICAgICAgICAgICB0aGlzLmFsbFRyYWNrc0tub3duLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSBhIHRyYWNrIGlzIG5vdyBjbG9zZWQsIHdlIG1heSBiZSBhYmxlIHRvIHdyaXRlIG91dCBjaHVua3MgdGhhdCB3ZXJlIHByZXZpb3VzbHkgd2FpdGluZ1xuICAgICAgICBhd2FpdCB0aGlzLmludGVybGVhdmVDaHVua3MoKTtcbiAgICAgICAgcmVsZWFzZSgpO1xuICAgIH1cbiAgICAvKiogRmluYWxpemVzIHRoZSBmaWxlLCBtYWtpbmcgaXQgcmVhZHkgZm9yIHVzZS4gTXVzdCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIG1lZGlhIGNodW5rcyBoYXZlIGJlZW4gYWRkZWQuICovXG4gICAgYXN5bmMgZmluYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJlbGVhc2UgPSBhd2FpdCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgdGhpcy5hbGxUcmFja3NLbm93bi5yZXNvbHZlKCk7XG4gICAgICAgIGlmICghdGhpcy5zZWdtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVNlZ21lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGbHVzaCBhbnkgcmVtYWluaW5nIHF1ZXVlZCBjaHVua3MgdG8gdGhlIGZpbGVcbiAgICAgICAgYXdhaXQgdGhpcy5pbnRlcmxlYXZlQ2h1bmtzKHRydWUpO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2x1c3Rlcikge1xuICAgICAgICAgICAgdGhpcy5maW5hbGl6ZUN1cnJlbnRDbHVzdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KHRoaXMuY3Vlcyk7XG4gICAgICAgIHRoaXMuZWJtbFdyaXRlci53cml0ZUVCTUwodGhpcy5jdWVzKTtcbiAgICAgICAgaWYgKCF0aGlzLmZvcm1hdC5fb3B0aW9ucy5hcHBlbmRPbmx5KSB7XG4gICAgICAgICAgICBjb25zdCBlbmRQb3MgPSB0aGlzLndyaXRlci5nZXRQb3MoKTtcbiAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBTZWdtZW50IHNpemVcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRTaXplID0gdGhpcy53cml0ZXIuZ2V0UG9zKCkgLSB0aGlzLnNlZ21lbnREYXRhT2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy53cml0ZXIuc2Vlayh0aGlzLmVibWxXcml0ZXIub2Zmc2V0cy5nZXQodGhpcy5zZWdtZW50KSArIDQpO1xuICAgICAgICAgICAgdGhpcy5lYm1sV3JpdGVyLndyaXRlVmFySW50KHNlZ21lbnRTaXplLCBTRUdNRU5UX1NJWkVfQllURVMpO1xuICAgICAgICAgICAgLy8gV3JpdGUgdGhlIGR1cmF0aW9uIG9mIHRoZSBtZWRpYSB0byB0aGUgU2VnbWVudFxuICAgICAgICAgICAgdGhpcy5zZWdtZW50RHVyYXRpb24uZGF0YSA9IG5ldyBFQk1MRmxvYXQ2NCh0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVyLnNlZWsodGhpcy5lYm1sV3JpdGVyLm9mZnNldHMuZ2V0KHRoaXMuc2VnbWVudER1cmF0aW9uKSk7XG4gICAgICAgICAgICB0aGlzLmVibWxXcml0ZXIud3JpdGVFQk1MKHRoaXMuc2VnbWVudER1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIEZpbGwgaW4gU2Vla0hlYWQgcG9zaXRpb24gZGF0YSBhbmQgd3JpdGUgaXQgYWdhaW5cbiAgICAgICAgICAgIGFzc2VydCh0aGlzLnNlZWtIZWFkKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVyLnNlZWsodGhpcy5lYm1sV3JpdGVyLm9mZnNldHMuZ2V0KHRoaXMuc2Vla0hlYWQpKTtcbiAgICAgICAgICAgIHRoaXMubWF5YmVDcmVhdGVTZWVrSGVhZCh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuZWJtbFdyaXRlci53cml0ZUVCTUwodGhpcy5zZWVrSGVhZCk7XG4gICAgICAgICAgICB0aGlzLndyaXRlci5zZWVrKGVuZFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVsZWFzZSgpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/matroska/matroska-muxer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/media-sink.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/media-sink.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioBufferSink: () => (/* binding */ AudioBufferSink),\n/* harmony export */   AudioSampleSink: () => (/* binding */ AudioSampleSink),\n/* harmony export */   BaseMediaSampleSink: () => (/* binding */ BaseMediaSampleSink),\n/* harmony export */   CanvasSink: () => (/* binding */ CanvasSink),\n/* harmony export */   EncodedPacketSink: () => (/* binding */ EncodedPacketSink),\n/* harmony export */   VideoSampleSink: () => (/* binding */ VideoSampleSink)\n/* harmony export */ });\n/* harmony import */ var _codec_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./codec.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec.js\");\n/* harmony import */ var _codec_data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./codec-data.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec-data.js\");\n/* harmony import */ var _custom_coder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./custom-coder.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/custom-coder.js\");\n/* harmony import */ var _input_track_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./input-track.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/input-track.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/* harmony import */ var _packet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packet.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/packet.js\");\n/* harmony import */ var _pcm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pcm.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/pcm.js\");\n/* harmony import */ var _sample_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sample.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/sample.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n\n\n\nconst validatePacketRetrievalOptions = (options) => {\n    if (!options || typeof options !== 'object') {\n        throw new TypeError('options must be an object.');\n    }\n    if (options.metadataOnly !== undefined && typeof options.metadataOnly !== 'boolean') {\n        throw new TypeError('options.metadataOnly, when defined, must be a boolean.');\n    }\n    if (options.verifyKeyPackets !== undefined && typeof options.verifyKeyPackets !== 'boolean') {\n        throw new TypeError('options.verifyKeyPackets, when defined, must be a boolean.');\n    }\n    if (options.verifyKeyPackets && options.metadataOnly) {\n        throw new TypeError('options.verifyKeyPackets and options.metadataOnly cannot be enabled together.');\n    }\n};\nconst validateTimestamp = (timestamp) => {\n    if (typeof timestamp !== 'number' || Number.isNaN(timestamp)) {\n        throw new TypeError('timestamp must be a number.'); // It can be non-finite, that's fine\n    }\n};\nconst maybeFixPacketType = (track, promise, options) => {\n    if (options.verifyKeyPackets) {\n        return promise.then(async (packet) => {\n            if (!packet || packet.type === 'delta') {\n                return packet;\n            }\n            const determinedType = await track.determinePacketType(packet);\n            if (determinedType) {\n                // @ts-expect-error Technically readonly\n                packet.type = determinedType;\n            }\n            return packet;\n        });\n    }\n    else {\n        return promise;\n    }\n};\n/**\n * Sink for retrieving encoded packets from an input track.\n * @group Media sinks\n * @public\n */\nclass EncodedPacketSink {\n    /** Creates a new {@link EncodedPacketSink} for the given {@link InputTrack}. */\n    constructor(track) {\n        if (!(track instanceof _input_track_js__WEBPACK_IMPORTED_MODULE_0__.InputTrack)) {\n            throw new TypeError('track must be an InputTrack.');\n        }\n        this._track = track;\n    }\n    /**\n     * Retrieves the track's first packet (in decode order), or null if it has no packets. The first packet is very\n     * likely to be a key packet.\n     */\n    getFirstPacket(options = {}) {\n        validatePacketRetrievalOptions(options);\n        return maybeFixPacketType(this._track, this._track._backing.getFirstPacket(options), options);\n    }\n    /**\n     * Retrieves the packet corresponding to the given timestamp, in seconds. More specifically, returns the last packet\n     * (in presentation order) with a start timestamp less than or equal to the given timestamp. This method can be\n     * used to retrieve a track's last packet using `getPacket(Infinity)`. The method returns null if the timestamp\n     * is before the first packet in the track.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    getPacket(timestamp, options = {}) {\n        validateTimestamp(timestamp);\n        validatePacketRetrievalOptions(options);\n        return maybeFixPacketType(this._track, this._track._backing.getPacket(timestamp, options), options);\n    }\n    /**\n     * Retrieves the packet following the given packet (in decode order), or null if the given packet is the\n     * last packet.\n     */\n    getNextPacket(packet, options = {}) {\n        if (!(packet instanceof _packet_js__WEBPACK_IMPORTED_MODULE_1__.EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        validatePacketRetrievalOptions(options);\n        return maybeFixPacketType(this._track, this._track._backing.getNextPacket(packet, options), options);\n    }\n    /**\n     * Retrieves the key packet corresponding to the given timestamp, in seconds. More specifically, returns the last\n     * key packet (in presentation order) with a start timestamp less than or equal to the given timestamp. A key packet\n     * is a packet that doesn't require previous packets to be decoded. This method can be used to retrieve a track's\n     * last key packet using `getKeyPacket(Infinity)`. The method returns null if the timestamp is before the first\n     * key packet in the track.\n     *\n     * To ensure that the returned packet is guaranteed to be a real key frame, enable `options.verifyKeyPackets`.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    async getKeyPacket(timestamp, options = {}) {\n        validateTimestamp(timestamp);\n        validatePacketRetrievalOptions(options);\n        if (!options.verifyKeyPackets) {\n            return this._track._backing.getKeyPacket(timestamp, options);\n        }\n        const packet = await this._track._backing.getKeyPacket(timestamp, options);\n        if (!packet || packet.type === 'delta') {\n            return packet;\n        }\n        const determinedType = await this._track.determinePacketType(packet);\n        if (determinedType === 'delta') {\n            // Try returning the previous key packet (in hopes that it's actually a key packet)\n            return this.getKeyPacket(packet.timestamp - 1 / this._track.timeResolution, options);\n        }\n        return packet;\n    }\n    /**\n     * Retrieves the key packet following the given packet (in decode order), or null if the given packet is the last\n     * key packet.\n     *\n     * To ensure that the returned packet is guaranteed to be a real key frame, enable `options.verifyKeyPackets`.\n     */\n    async getNextKeyPacket(packet, options = {}) {\n        if (!(packet instanceof _packet_js__WEBPACK_IMPORTED_MODULE_1__.EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        validatePacketRetrievalOptions(options);\n        if (!options.verifyKeyPackets) {\n            return this._track._backing.getNextKeyPacket(packet, options);\n        }\n        const nextPacket = await this._track._backing.getNextKeyPacket(packet, options);\n        if (!nextPacket || nextPacket.type === 'delta') {\n            return nextPacket;\n        }\n        const determinedType = await this._track.determinePacketType(nextPacket);\n        if (determinedType === 'delta') {\n            // Try returning the next key packet (in hopes that it's actually a key packet)\n            return this.getNextKeyPacket(nextPacket, options);\n        }\n        return nextPacket;\n    }\n    /**\n     * Creates an async iterator that yields the packets in this track in decode order. To enable fast iteration, this\n     * method will intelligently preload packets based on the speed of the consumer.\n     *\n     * @param startPacket - (optional) The packet from which iteration should begin. This packet will also be yielded.\n     * @param endTimestamp - (optional) The timestamp at which iteration should end. This packet will _not_ be yielded.\n     */\n    packets(startPacket, endPacket, options = {}) {\n        if (startPacket !== undefined && !(startPacket instanceof _packet_js__WEBPACK_IMPORTED_MODULE_1__.EncodedPacket)) {\n            throw new TypeError('startPacket must be an EncodedPacket.');\n        }\n        if (startPacket !== undefined && startPacket.isMetadataOnly && !options?.metadataOnly) {\n            throw new TypeError('startPacket can only be metadata-only if options.metadataOnly is enabled.');\n        }\n        if (endPacket !== undefined && !(endPacket instanceof _packet_js__WEBPACK_IMPORTED_MODULE_1__.EncodedPacket)) {\n            throw new TypeError('endPacket must be an EncodedPacket.');\n        }\n        validatePacketRetrievalOptions(options);\n        const packetQueue = [];\n        let { promise: queueNotEmpty, resolve: onQueueNotEmpty } = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.promiseWithResolvers)();\n        let { promise: queueDequeue, resolve: onQueueDequeue } = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.promiseWithResolvers)();\n        let ended = false;\n        let terminated = false;\n        // This stores errors that are \"out of band\" in the sense that they didn't occur in the normal flow of this\n        // method but instead in a different context. This error should not go unnoticed and must be bubbled up to\n        // the consumer.\n        let outOfBandError = null;\n        const timestamps = [];\n        // The queue should always be big enough to hold 1 second worth of packets\n        const maxQueueSize = () => Math.max(2, timestamps.length);\n        // The following is the \"pump\" process that keeps pumping packets into the queue\n        (async () => {\n            let packet = startPacket ?? await this.getFirstPacket(options);\n            while (packet && !terminated) {\n                if (endPacket && packet.sequenceNumber >= endPacket?.sequenceNumber) {\n                    break;\n                }\n                if (packetQueue.length > maxQueueSize()) {\n                    ({ promise: queueDequeue, resolve: onQueueDequeue } = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.promiseWithResolvers)());\n                    await queueDequeue;\n                    continue;\n                }\n                packetQueue.push(packet);\n                onQueueNotEmpty();\n                ({ promise: queueNotEmpty, resolve: onQueueNotEmpty } = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.promiseWithResolvers)());\n                packet = await this.getNextPacket(packet, options);\n            }\n            ended = true;\n            onQueueNotEmpty();\n        })().catch((error) => {\n            if (!outOfBandError) {\n                outOfBandError = error;\n                onQueueNotEmpty();\n            }\n        });\n        return {\n            async next() {\n                while (true) {\n                    if (terminated) {\n                        return { value: undefined, done: true };\n                    }\n                    else if (outOfBandError) {\n                        throw outOfBandError;\n                    }\n                    else if (packetQueue.length > 0) {\n                        const value = packetQueue.shift();\n                        const now = performance.now();\n                        timestamps.push(now);\n                        while (timestamps.length > 0 && now - timestamps[0] >= 1000) {\n                            timestamps.shift();\n                        }\n                        onQueueDequeue();\n                        return { value, done: false };\n                    }\n                    else if (ended) {\n                        return { value: undefined, done: true };\n                    }\n                    else {\n                        await queueNotEmpty;\n                    }\n                }\n            },\n            async return() {\n                terminated = true;\n                onQueueDequeue();\n                onQueueNotEmpty();\n                return { value: undefined, done: true };\n            },\n            async throw(error) {\n                throw error;\n            },\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n}\nclass DecoderWrapper {\n    constructor(onSample, onError) {\n        this.onSample = onSample;\n        this.onError = onError;\n    }\n}\n/**\n * Base class for decoded media sample sinks.\n * @group Media sinks\n * @public\n */\nclass BaseMediaSampleSink {\n    /** @internal */\n    mediaSamplesInRange(startTimestamp = 0, endTimestamp = Infinity) {\n        validateTimestamp(startTimestamp);\n        validateTimestamp(endTimestamp);\n        const sampleQueue = [];\n        let firstSampleQueued = false;\n        let lastSample = null;\n        let { promise: queueNotEmpty, resolve: onQueueNotEmpty } = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.promiseWithResolvers)();\n        let { promise: queueDequeue, resolve: onQueueDequeue } = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.promiseWithResolvers)();\n        let decoderIsFlushed = false;\n        let ended = false;\n        let terminated = false;\n        // This stores errors that are \"out of band\" in the sense that they didn't occur in the normal flow of this\n        // method but instead in a different context. This error should not go unnoticed and must be bubbled up to\n        // the consumer.\n        let outOfBandError = null;\n        // The following is the \"pump\" process that keeps pumping packets into the decoder\n        (async () => {\n            const decoderError = new Error();\n            const decoder = await this._createDecoder((sample) => {\n                onQueueDequeue();\n                if (sample.timestamp >= endTimestamp) {\n                    ended = true;\n                }\n                if (ended) {\n                    sample.close();\n                    return;\n                }\n                if (lastSample) {\n                    if (sample.timestamp > startTimestamp) {\n                        // We don't know ahead of time what the first first is. This is because the first first is the\n                        // last first whose timestamp is less than or equal to the start timestamp. Therefore we need to\n                        // wait for the first first after the start timestamp, and then we'll know that the previous\n                        // first was the first first.\n                        sampleQueue.push(lastSample);\n                        firstSampleQueued = true;\n                    }\n                    else {\n                        lastSample.close();\n                    }\n                }\n                if (sample.timestamp >= startTimestamp) {\n                    sampleQueue.push(sample);\n                    firstSampleQueued = true;\n                }\n                lastSample = firstSampleQueued ? null : sample;\n                if (sampleQueue.length > 0) {\n                    onQueueNotEmpty();\n                    ({ promise: queueNotEmpty, resolve: onQueueNotEmpty } = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.promiseWithResolvers)());\n                }\n            }, (error) => {\n                if (!outOfBandError) {\n                    error.stack = decoderError.stack; // Provide a more useful stack trace\n                    outOfBandError = error;\n                    onQueueNotEmpty();\n                }\n            });\n            const packetSink = this._createPacketSink();\n            const keyPacket = await packetSink.getKeyPacket(startTimestamp, { verifyKeyPackets: true })\n                ?? await packetSink.getFirstPacket();\n            if (!keyPacket) {\n                return;\n            }\n            let currentPacket = keyPacket;\n            let endPacket = undefined;\n            if (endTimestamp < Infinity) {\n                // When an end timestamp is set, we cannot simply use that for the packet iterator due to out-of-order\n                // frames (B-frames). Instead, we'll need to keep decoding packets until we get a frame that exceeds\n                // this end time. However, we can still put a bound on it: Since key frames are by definition never\n                // out of order, we can stop at the first key frame after the end timestamp.\n                const packet = await packetSink.getPacket(endTimestamp);\n                const keyPacket = !packet\n                    ? null\n                    : packet.type === 'key' && packet.timestamp === endTimestamp\n                        ? packet\n                        : await packetSink.getNextKeyPacket(packet, { verifyKeyPackets: true });\n                if (keyPacket) {\n                    endPacket = keyPacket;\n                }\n            }\n            const packets = packetSink.packets(keyPacket, endPacket);\n            await packets.next(); // Skip the start packet as we already have it\n            while (currentPacket && !ended) {\n                const maxQueueSize = computeMaxQueueSize(sampleQueue.length);\n                if (sampleQueue.length + decoder.getDecodeQueueSize() > maxQueueSize) {\n                    ({ promise: queueDequeue, resolve: onQueueDequeue } = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.promiseWithResolvers)());\n                    await queueDequeue;\n                    continue;\n                }\n                decoder.decode(currentPacket);\n                const packetResult = await packets.next();\n                if (packetResult.done) {\n                    break;\n                }\n                currentPacket = packetResult.value;\n            }\n            await packets.return();\n            if (!terminated)\n                await decoder.flush();\n            decoder.close();\n            if (!firstSampleQueued && lastSample) {\n                sampleQueue.push(lastSample);\n            }\n            decoderIsFlushed = true;\n            onQueueNotEmpty(); // To unstuck the generator\n        })().catch((error) => {\n            if (!outOfBandError) {\n                outOfBandError = error;\n                onQueueNotEmpty();\n            }\n        });\n        return {\n            async next() {\n                while (true) {\n                    if (terminated) {\n                        return { value: undefined, done: true };\n                    }\n                    else if (outOfBandError) {\n                        throw outOfBandError;\n                    }\n                    else if (sampleQueue.length > 0) {\n                        const value = sampleQueue.shift();\n                        onQueueDequeue();\n                        return { value, done: false };\n                    }\n                    else if (!decoderIsFlushed) {\n                        await queueNotEmpty;\n                    }\n                    else {\n                        return { value: undefined, done: true };\n                    }\n                }\n            },\n            async return() {\n                terminated = true;\n                ended = true;\n                onQueueDequeue();\n                onQueueNotEmpty();\n                lastSample?.close();\n                for (const sample of sampleQueue) {\n                    sample.close();\n                }\n                return { value: undefined, done: true };\n            },\n            async throw(error) {\n                throw error;\n            },\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n    /** @internal */\n    mediaSamplesAtTimestamps(timestamps) {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.validateAnyIterable)(timestamps);\n        const timestampIterator = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.toAsyncIterator)(timestamps);\n        const timestampsOfInterest = [];\n        const sampleQueue = [];\n        let { promise: queueNotEmpty, resolve: onQueueNotEmpty } = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.promiseWithResolvers)();\n        let { promise: queueDequeue, resolve: onQueueDequeue } = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.promiseWithResolvers)();\n        let decoderIsFlushed = false;\n        let terminated = false;\n        // This stores errors that are \"out of band\" in the sense that they didn't occur in the normal flow of this\n        // method but instead in a different context. This error should not go unnoticed and must be bubbled up to\n        // the consumer.\n        let outOfBandError = null;\n        const pushToQueue = (sample) => {\n            sampleQueue.push(sample);\n            onQueueNotEmpty();\n            ({ promise: queueNotEmpty, resolve: onQueueNotEmpty } = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.promiseWithResolvers)());\n        };\n        // The following is the \"pump\" process that keeps pumping packets into the decoder\n        (async () => {\n            const decoderError = new Error();\n            const decoder = await this._createDecoder((sample) => {\n                onQueueDequeue();\n                if (terminated) {\n                    sample.close();\n                    return;\n                }\n                let sampleUses = 0;\n                while (timestampsOfInterest.length > 0\n                    && sample.timestamp - timestampsOfInterest[0] > -1e-10 // Give it a little epsilon\n                ) {\n                    sampleUses++;\n                    timestampsOfInterest.shift();\n                }\n                if (sampleUses > 0) {\n                    for (let i = 0; i < sampleUses; i++) {\n                        // Clone the sample if we need to emit it multiple times\n                        pushToQueue((i < sampleUses - 1 ? sample.clone() : sample));\n                    }\n                }\n                else {\n                    sample.close();\n                }\n            }, (error) => {\n                if (!outOfBandError) {\n                    error.stack = decoderError.stack; // Provide a more useful stack trace\n                    outOfBandError = error;\n                    onQueueNotEmpty();\n                }\n            });\n            const packetSink = this._createPacketSink();\n            let lastPacket = null;\n            let lastKeyPacket = null;\n            // The end sequence number (inclusive) in the next batch of packets that will be decoded. The batch starts\n            // at the last key frame and goes until this sequence number.\n            let maxSequenceNumber = -1;\n            const decodePackets = async () => {\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(lastKeyPacket);\n                // Start at the current key packet\n                let currentPacket = lastKeyPacket;\n                decoder.decode(currentPacket);\n                while (currentPacket.sequenceNumber < maxSequenceNumber) {\n                    const maxQueueSize = computeMaxQueueSize(sampleQueue.length);\n                    while (sampleQueue.length + decoder.getDecodeQueueSize() > maxQueueSize && !terminated) {\n                        ({ promise: queueDequeue, resolve: onQueueDequeue } = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.promiseWithResolvers)());\n                        await queueDequeue;\n                    }\n                    if (terminated) {\n                        break;\n                    }\n                    const nextPacket = await packetSink.getNextPacket(currentPacket);\n                    (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(nextPacket);\n                    decoder.decode(nextPacket);\n                    currentPacket = nextPacket;\n                }\n                maxSequenceNumber = -1;\n            };\n            const flushDecoder = async () => {\n                await decoder.flush();\n                // We don't expect this list to have any elements in it anymore, but in case it does, let's emit\n                // nulls for every remaining element, then clear it.\n                for (let i = 0; i < timestampsOfInterest.length; i++) {\n                    pushToQueue(null);\n                }\n                timestampsOfInterest.length = 0;\n            };\n            for await (const timestamp of timestampIterator) {\n                validateTimestamp(timestamp);\n                if (terminated) {\n                    break;\n                }\n                const targetPacket = await packetSink.getPacket(timestamp);\n                const keyPacket = targetPacket && await packetSink.getKeyPacket(timestamp, { verifyKeyPackets: true });\n                if (!keyPacket) {\n                    if (maxSequenceNumber !== -1) {\n                        await decodePackets();\n                        await flushDecoder();\n                    }\n                    pushToQueue(null);\n                    lastPacket = null;\n                    continue;\n                }\n                // Check if the key packet has changed or if we're going back in time\n                if (lastPacket\n                    && (keyPacket.sequenceNumber !== lastKeyPacket.sequenceNumber\n                        || targetPacket.timestamp < lastPacket.timestamp)) {\n                    await decodePackets();\n                    await flushDecoder(); // Always flush here, improves decoder compatibility\n                }\n                timestampsOfInterest.push(targetPacket.timestamp);\n                maxSequenceNumber = Math.max(targetPacket.sequenceNumber, maxSequenceNumber);\n                lastPacket = targetPacket;\n                lastKeyPacket = keyPacket;\n            }\n            if (!terminated) {\n                if (maxSequenceNumber !== -1) {\n                    // We still need to decode packets\n                    await decodePackets();\n                }\n                await flushDecoder();\n            }\n            decoder.close();\n            decoderIsFlushed = true;\n            onQueueNotEmpty(); // To unstuck the generator\n        })().catch((error) => {\n            if (!outOfBandError) {\n                outOfBandError = error;\n                onQueueNotEmpty();\n            }\n        });\n        return {\n            async next() {\n                while (true) {\n                    if (terminated) {\n                        return { value: undefined, done: true };\n                    }\n                    else if (outOfBandError) {\n                        throw outOfBandError;\n                    }\n                    else if (sampleQueue.length > 0) {\n                        const value = sampleQueue.shift();\n                        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(value !== undefined);\n                        onQueueDequeue();\n                        return { value, done: false };\n                    }\n                    else if (!decoderIsFlushed) {\n                        await queueNotEmpty;\n                    }\n                    else {\n                        return { value: undefined, done: true };\n                    }\n                }\n            },\n            async return() {\n                terminated = true;\n                onQueueDequeue();\n                onQueueNotEmpty();\n                for (const sample of sampleQueue) {\n                    sample?.close();\n                }\n                return { value: undefined, done: true };\n            },\n            async throw(error) {\n                throw error;\n            },\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n}\nconst computeMaxQueueSize = (decodedSampleQueueSize) => {\n    // If we have decoded samples lying around, limit the total queue size to a small value (decoded samples can use up\n    // a lot of memory). If not, we're fine with a much bigger queue of encoded packets waiting to be decoded. In fact,\n    // some decoders only start flushing out decoded chunks when the packet queue is large enough.\n    return decodedSampleQueueSize === 0 ? 40 : 8;\n};\nclass VideoDecoderWrapper extends DecoderWrapper {\n    constructor(onSample, onError, codec, decoderConfig, rotation, timeResolution) {\n        super(onSample, onError);\n        this.codec = codec;\n        this.decoderConfig = decoderConfig;\n        this.rotation = rotation;\n        this.timeResolution = timeResolution;\n        this.decoder = null;\n        this.customDecoder = null;\n        this.customDecoderCallSerializer = new _misc_js__WEBPACK_IMPORTED_MODULE_2__.CallSerializer();\n        this.customDecoderQueueSize = 0;\n        this.inputTimestamps = []; // Timestamps input into the decoder, sorted.\n        this.sampleQueue = []; // Safari-specific thing, check usage.\n        this.currentPacketIndex = 0;\n        this.raslSkipped = false; // For HEVC stuff\n        const MatchingCustomDecoder = _custom_coder_js__WEBPACK_IMPORTED_MODULE_3__.customVideoDecoders.find(x => x.supports(codec, decoderConfig));\n        if (MatchingCustomDecoder) {\n            // @ts-expect-error \"Can't create instance of abstract class 🤓\"\n            this.customDecoder = new MatchingCustomDecoder();\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.codec = codec;\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.config = decoderConfig;\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.onSample = (sample) => {\n                if (!(sample instanceof _sample_js__WEBPACK_IMPORTED_MODULE_4__.VideoSample)) {\n                    throw new TypeError('The argument passed to onSample must be a VideoSample.');\n                }\n                this.finalizeAndEmitSample(sample);\n            };\n            void this.customDecoderCallSerializer.call(() => this.customDecoder.init());\n        }\n        else {\n            // Specific handler for the WebCodecs VideoDecoder to iron out browser differences\n            const sampleHandler = (sample) => {\n                if ((0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.isSafari)()) {\n                    // For correct B-frame handling, we don't just hand over the frames directly but instead add them to\n                    // a queue, because we want to ensure frames are emitted in presentation order. We flush the queue\n                    // each time we receive a frame with a timestamp larger than the highest we've seen so far, as we\n                    // can sure that is not a B-frame. Typically, WebCodecs automatically guarantees that frames are\n                    // emitted in presentation order, but Safari doesn't always follow this rule.\n                    if (this.sampleQueue.length > 0 && (sample.timestamp >= (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.last)(this.sampleQueue).timestamp)) {\n                        for (const sample of this.sampleQueue) {\n                            this.finalizeAndEmitSample(sample);\n                        }\n                        this.sampleQueue.length = 0;\n                    }\n                    (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.insertSorted)(this.sampleQueue, sample, x => x.timestamp);\n                }\n                else {\n                    // Assign it the next earliest timestamp from the input. We do this because browsers, by spec, are\n                    // required to emit decoded frames in presentation order *while* retaining the timestamp of their\n                    // originating EncodedVideoChunk. For files with B-frames but no out-of-order timestamps (like a\n                    // missing ctts box, for example), this causes a mismatch. We therefore fix the timestamps and\n                    // ensure they are sorted by doing this.\n                    const timestamp = this.inputTimestamps.shift();\n                    // There's no way we'd have more decoded frames than encoded packets we passed in. Actually, the\n                    // correspondence should be 1:1.\n                    (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(timestamp !== undefined);\n                    sample.setTimestamp(timestamp);\n                    this.finalizeAndEmitSample(sample);\n                }\n            };\n            this.decoder = new VideoDecoder({\n                output: frame => sampleHandler(new _sample_js__WEBPACK_IMPORTED_MODULE_4__.VideoSample(frame)),\n                error: onError,\n            });\n            this.decoder.configure(decoderConfig);\n        }\n    }\n    finalizeAndEmitSample(sample) {\n        // Round the timestamps to the time resolution\n        sample.setTimestamp(Math.round(sample.timestamp * this.timeResolution) / this.timeResolution);\n        sample.setDuration(Math.round(sample.duration * this.timeResolution) / this.timeResolution);\n        sample.setRotation(this.rotation);\n        this.onSample(sample);\n    }\n    getDecodeQueueSize() {\n        if (this.customDecoder) {\n            return this.customDecoderQueueSize;\n        }\n        else {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.decoder);\n            return this.decoder.decodeQueueSize;\n        }\n    }\n    decode(packet) {\n        if (this.codec === 'hevc' && this.currentPacketIndex > 0 && !this.raslSkipped) {\n            // If we're using HEVC, we need to make sure to skip any RASL slices that follow a non-IDR key frame such as\n            // CRA_NUT. This is because RASL slices cannot be decoded without data before the CRA_NUT. Browsers behave\n            // differently here: Chromium drops the packets, Safari throws a decoder error. Either way, it's not good\n            // and causes bugs upstream. So, let's take the dropping into our own hands.\n            const nalUnits = (0,_codec_data_js__WEBPACK_IMPORTED_MODULE_5__.extractHevcNalUnits)(packet.data, this.decoderConfig);\n            const hasRaslPicture = nalUnits.some((x) => {\n                const type = (0,_codec_data_js__WEBPACK_IMPORTED_MODULE_5__.extractNalUnitTypeForHevc)(x);\n                return type === _codec_data_js__WEBPACK_IMPORTED_MODULE_5__.HevcNalUnitType.RASL_N || type === _codec_data_js__WEBPACK_IMPORTED_MODULE_5__.HevcNalUnitType.RASL_R;\n            });\n            if (hasRaslPicture) {\n                return; // Drop\n            }\n            this.raslSkipped = true;\n        }\n        this.currentPacketIndex++;\n        if (this.customDecoder) {\n            this.customDecoderQueueSize++;\n            void this.customDecoderCallSerializer\n                .call(() => this.customDecoder.decode(packet))\n                .then(() => this.customDecoderQueueSize--);\n        }\n        else {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.decoder);\n            if (!(0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.isSafari)()) {\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.insertSorted)(this.inputTimestamps, packet.timestamp, x => x);\n            }\n            this.decoder.decode(packet.toEncodedVideoChunk());\n        }\n    }\n    async flush() {\n        if (this.customDecoder) {\n            await this.customDecoderCallSerializer.call(() => this.customDecoder.flush());\n        }\n        else {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.decoder);\n            await this.decoder.flush();\n        }\n        if ((0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.isSafari)()) {\n            for (const sample of this.sampleQueue) {\n                this.finalizeAndEmitSample(sample);\n            }\n            this.sampleQueue.length = 0;\n        }\n        this.currentPacketIndex = 0;\n        this.raslSkipped = false;\n    }\n    close() {\n        if (this.customDecoder) {\n            void this.customDecoderCallSerializer.call(() => this.customDecoder.close());\n        }\n        else {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.decoder);\n            this.decoder.close();\n        }\n        for (const sample of this.sampleQueue) {\n            sample.close();\n        }\n        this.sampleQueue.length = 0;\n    }\n}\n/**\n * A sink that retrieves decoded video samples (video frames) from a video track.\n * @group Media sinks\n * @public\n */\nclass VideoSampleSink extends BaseMediaSampleSink {\n    /** Creates a new {@link VideoSampleSink} for the given {@link InputVideoTrack}. */\n    constructor(videoTrack) {\n        if (!(videoTrack instanceof _input_track_js__WEBPACK_IMPORTED_MODULE_0__.InputVideoTrack)) {\n            throw new TypeError('videoTrack must be an InputVideoTrack.');\n        }\n        super();\n        this._videoTrack = videoTrack;\n    }\n    /** @internal */\n    async _createDecoder(onSample, onError) {\n        if (!(await this._videoTrack.canDecode())) {\n            throw new Error('This video track cannot be decoded by this browser. Make sure to check decodability before using'\n                + ' a track.');\n        }\n        const codec = this._videoTrack.codec;\n        const rotation = this._videoTrack.rotation;\n        const decoderConfig = await this._videoTrack.getDecoderConfig();\n        const timeResolution = this._videoTrack.timeResolution;\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(codec && decoderConfig);\n        return new VideoDecoderWrapper(onSample, onError, codec, decoderConfig, rotation, timeResolution);\n    }\n    /** @internal */\n    _createPacketSink() {\n        return new EncodedPacketSink(this._videoTrack);\n    }\n    /**\n     * Retrieves the video sample (frame) corresponding to the given timestamp, in seconds. More specifically, returns\n     * the last video sample (in presentation order) with a start timestamp less than or equal to the given timestamp.\n     * Returns null if the timestamp is before the track's first timestamp.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    async getSample(timestamp) {\n        validateTimestamp(timestamp);\n        for await (const sample of this.mediaSamplesAtTimestamps([timestamp])) {\n            return sample;\n        }\n        throw new Error('Internal error: Iterator returned nothing.');\n    }\n    /**\n     * Creates an async iterator that yields the video samples (frames) of this track in presentation order. This method\n     * will intelligently pre-decode a few frames ahead to enable fast iteration.\n     *\n     * @param startTimestamp - The timestamp in seconds at which to start yielding samples (inclusive).\n     * @param endTimestamp - The timestamp in seconds at which to stop yielding samples (exclusive).\n     */\n    samples(startTimestamp = 0, endTimestamp = Infinity) {\n        return this.mediaSamplesInRange(startTimestamp, endTimestamp);\n    }\n    /**\n     * Creates an async iterator that yields a video sample (frame) for each timestamp in the argument. This method\n     * uses an optimized decoding pipeline if these timestamps are monotonically sorted, decoding each packet at most\n     * once, and is therefore more efficient than manually getting the sample for every timestamp. The iterator may\n     * yield null if no frame is available for a given timestamp.\n     *\n     * @param timestamps - An iterable or async iterable of timestamps in seconds.\n     */\n    samplesAtTimestamps(timestamps) {\n        return this.mediaSamplesAtTimestamps(timestamps);\n    }\n}\n/**\n * A sink that renders video samples (frames) of the given video track to canvases. This is often more useful than\n * directly retrieving frames, as it comes with common preprocessing steps such as resizing or applying rotation\n * metadata.\n *\n * This sink will yield `HTMLCanvasElement`s when in a DOM context, and `OffscreenCanvas`es otherwise.\n *\n * @group Media sinks\n * @public\n */\nclass CanvasSink {\n    /** Creates a new {@link CanvasSink} for the given {@link InputVideoTrack}. */\n    constructor(videoTrack, options = {}) {\n        /** @internal */\n        this._nextCanvasIndex = 0;\n        if (!(videoTrack instanceof _input_track_js__WEBPACK_IMPORTED_MODULE_0__.InputVideoTrack)) {\n            throw new TypeError('videoTrack must be an InputVideoTrack.');\n        }\n        if (options && typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.width !== undefined && (!Number.isInteger(options.width) || options.width <= 0)) {\n            throw new TypeError('options.width, when defined, must be a positive integer.');\n        }\n        if (options.height !== undefined && (!Number.isInteger(options.height) || options.height <= 0)) {\n            throw new TypeError('options.height, when defined, must be a positive integer.');\n        }\n        if (options.fit !== undefined && !['fill', 'contain', 'cover'].includes(options.fit)) {\n            throw new TypeError('options.fit, when provided, must be one of \"fill\", \"contain\", or \"cover\".');\n        }\n        if (options.width !== undefined\n            && options.height !== undefined\n            && options.fit === undefined) {\n            throw new TypeError('When both options.width and options.height are provided, options.fit must also be provided.');\n        }\n        if (options.rotation !== undefined && ![0, 90, 180, 270].includes(options.rotation)) {\n            throw new TypeError('options.rotation, when provided, must be 0, 90, 180 or 270.');\n        }\n        if (options.poolSize !== undefined\n            && (typeof options.poolSize !== 'number' || !Number.isInteger(options.poolSize) || options.poolSize < 0)) {\n            throw new TypeError('poolSize must be a non-negative integer.');\n        }\n        const rotation = options.rotation ?? videoTrack.rotation;\n        let [width, height] = rotation % 180 === 0\n            ? [videoTrack.codedWidth, videoTrack.codedHeight]\n            : [videoTrack.codedHeight, videoTrack.codedWidth];\n        const originalAspectRatio = width / height;\n        // If width and height aren't defined together, deduce the missing value using the aspect ratio\n        if (options.width !== undefined && options.height === undefined) {\n            width = options.width;\n            height = Math.round(width / originalAspectRatio);\n        }\n        else if (options.width === undefined && options.height !== undefined) {\n            height = options.height;\n            width = Math.round(height * originalAspectRatio);\n        }\n        else if (options.width !== undefined && options.height !== undefined) {\n            width = options.width;\n            height = options.height;\n        }\n        this._videoTrack = videoTrack;\n        this._width = width;\n        this._height = height;\n        this._rotation = rotation;\n        this._fit = options.fit ?? 'fill';\n        this._videoSampleSink = new VideoSampleSink(videoTrack);\n        this._canvasPool = Array.from({ length: options.poolSize ?? 0 }, () => null);\n    }\n    /** @internal */\n    _videoSampleToWrappedCanvas(sample) {\n        let canvas = this._canvasPool[this._nextCanvasIndex];\n        let canvasIsNew = false;\n        if (!canvas) {\n            if (typeof document !== 'undefined') {\n                // Prefer an HTMLCanvasElement\n                canvas = document.createElement('canvas');\n                canvas.width = this._width;\n                canvas.height = this._height;\n            }\n            else {\n                canvas = new OffscreenCanvas(this._width, this._height);\n            }\n            if (this._canvasPool.length > 0) {\n                this._canvasPool[this._nextCanvasIndex] = canvas;\n            }\n            canvasIsNew = true;\n        }\n        if (this._canvasPool.length > 0) {\n            this._nextCanvasIndex = (this._nextCanvasIndex + 1) % this._canvasPool.length;\n        }\n        const context = canvas.getContext('2d', { alpha: false });\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(context);\n        context.resetTransform();\n        if (!canvasIsNew) {\n            context.clearRect(0, 0, this._width, this._height);\n        }\n        sample.drawWithFit(context, {\n            fit: this._fit,\n            rotation: this._rotation,\n        });\n        const result = {\n            canvas,\n            timestamp: sample.timestamp,\n            duration: sample.duration,\n        };\n        sample.close();\n        return result;\n    }\n    /**\n     * Retrieves a canvas with the video frame corresponding to the given timestamp, in seconds. More specifically,\n     * returns the last video frame (in presentation order) with a start timestamp less than or equal to the given\n     * timestamp. Returns null if the timestamp is before the track's first timestamp.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    async getCanvas(timestamp) {\n        validateTimestamp(timestamp);\n        const sample = await this._videoSampleSink.getSample(timestamp);\n        return sample && this._videoSampleToWrappedCanvas(sample);\n    }\n    /**\n     * Creates an async iterator that yields canvases with the video frames of this track in presentation order. This\n     * method will intelligently pre-decode a few frames ahead to enable fast iteration.\n     *\n     * @param startTimestamp - The timestamp in seconds at which to start yielding canvases (inclusive).\n     * @param endTimestamp - The timestamp in seconds at which to stop yielding canvases (exclusive).\n     */\n    canvases(startTimestamp = 0, endTimestamp = Infinity) {\n        return (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.mapAsyncGenerator)(this._videoSampleSink.samples(startTimestamp, endTimestamp), sample => this._videoSampleToWrappedCanvas(sample));\n    }\n    /**\n     * Creates an async iterator that yields a canvas for each timestamp in the argument. This method uses an optimized\n     * decoding pipeline if these timestamps are monotonically sorted, decoding each packet at most once, and is\n     * therefore more efficient than manually getting the canvas for every timestamp. The iterator may yield null if\n     * no frame is available for a given timestamp.\n     *\n     * @param timestamps - An iterable or async iterable of timestamps in seconds.\n     */\n    canvasesAtTimestamps(timestamps) {\n        return (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.mapAsyncGenerator)(this._videoSampleSink.samplesAtTimestamps(timestamps), sample => sample && this._videoSampleToWrappedCanvas(sample));\n    }\n}\nclass AudioDecoderWrapper extends DecoderWrapper {\n    constructor(onSample, onError, codec, decoderConfig) {\n        super(onSample, onError);\n        this.decoder = null;\n        this.customDecoder = null;\n        this.customDecoderCallSerializer = new _misc_js__WEBPACK_IMPORTED_MODULE_2__.CallSerializer();\n        this.customDecoderQueueSize = 0;\n        // Internal state to accumulate a precise current timestamp based on audio durations, not the (potentially\n        // inaccurate) packet timestamps.\n        this.currentTimestamp = null;\n        const sampleHandler = (sample) => {\n            if (this.currentTimestamp === null\n                || Math.abs(sample.timestamp - this.currentTimestamp) >= sample.duration) {\n                // We need to sync with the sample timestamp again\n                this.currentTimestamp = sample.timestamp;\n            }\n            const preciseTimestamp = this.currentTimestamp;\n            this.currentTimestamp += sample.duration;\n            if (sample.numberOfFrames === 0) {\n                // We skip zero-data (empty) AudioSamples. These are sometimes emitted, for example, by Firefox when it\n                // decodes Vorbis (at the start).\n                sample.close();\n                return;\n            }\n            // Round the timestamp to the sample rate\n            const sampleRate = decoderConfig.sampleRate;\n            sample.setTimestamp(Math.round(preciseTimestamp * sampleRate) / sampleRate);\n            onSample(sample);\n        };\n        const MatchingCustomDecoder = _custom_coder_js__WEBPACK_IMPORTED_MODULE_3__.customAudioDecoders.find(x => x.supports(codec, decoderConfig));\n        if (MatchingCustomDecoder) {\n            // @ts-expect-error \"Can't create instance of abstract class 🤓\"\n            this.customDecoder = new MatchingCustomDecoder();\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.codec = codec;\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.config = decoderConfig;\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.onSample = (sample) => {\n                if (!(sample instanceof _sample_js__WEBPACK_IMPORTED_MODULE_4__.AudioSample)) {\n                    throw new TypeError('The argument passed to onSample must be an AudioSample.');\n                }\n                sampleHandler(sample);\n            };\n            void this.customDecoderCallSerializer.call(() => this.customDecoder.init());\n        }\n        else {\n            this.decoder = new AudioDecoder({\n                output: data => sampleHandler(new _sample_js__WEBPACK_IMPORTED_MODULE_4__.AudioSample(data)),\n                error: onError,\n            });\n            this.decoder.configure(decoderConfig);\n        }\n    }\n    getDecodeQueueSize() {\n        if (this.customDecoder) {\n            return this.customDecoderQueueSize;\n        }\n        else {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.decoder);\n            return this.decoder.decodeQueueSize;\n        }\n    }\n    decode(packet) {\n        if (this.customDecoder) {\n            this.customDecoderQueueSize++;\n            void this.customDecoderCallSerializer\n                .call(() => this.customDecoder.decode(packet))\n                .then(() => this.customDecoderQueueSize--);\n        }\n        else {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.decoder);\n            this.decoder.decode(packet.toEncodedAudioChunk());\n        }\n    }\n    flush() {\n        if (this.customDecoder) {\n            return this.customDecoderCallSerializer.call(() => this.customDecoder.flush());\n        }\n        else {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.decoder);\n            return this.decoder.flush();\n        }\n    }\n    close() {\n        if (this.customDecoder) {\n            void this.customDecoderCallSerializer.call(() => this.customDecoder.close());\n        }\n        else {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.decoder);\n            this.decoder.close();\n        }\n    }\n}\n// There are a lot of PCM variants not natively supported by the browser and by AudioData. Therefore we need a simple\n// decoder that maps any input PCM format into a PCM format supported by the browser.\nclass PcmAudioDecoderWrapper extends DecoderWrapper {\n    constructor(onSample, onError, decoderConfig) {\n        super(onSample, onError);\n        this.decoderConfig = decoderConfig;\n        // Internal state to accumulate a precise current timestamp based on audio durations, not the (potentially\n        // inaccurate) packet timestamps.\n        this.currentTimestamp = null;\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(_codec_js__WEBPACK_IMPORTED_MODULE_6__.PCM_AUDIO_CODECS.includes(decoderConfig.codec));\n        this.codec = decoderConfig.codec;\n        const { dataType, sampleSize, littleEndian } = (0,_codec_js__WEBPACK_IMPORTED_MODULE_6__.parsePcmCodec)(this.codec);\n        this.inputSampleSize = sampleSize;\n        switch (sampleSize) {\n            case 1:\n                {\n                    if (dataType === 'unsigned') {\n                        this.readInputValue = (view, byteOffset) => view.getUint8(byteOffset) - 2 ** 7;\n                    }\n                    else if (dataType === 'signed') {\n                        this.readInputValue = (view, byteOffset) => view.getInt8(byteOffset);\n                    }\n                    else if (dataType === 'ulaw') {\n                        this.readInputValue = (view, byteOffset) => (0,_pcm_js__WEBPACK_IMPORTED_MODULE_7__.fromUlaw)(view.getUint8(byteOffset));\n                    }\n                    else if (dataType === 'alaw') {\n                        this.readInputValue = (view, byteOffset) => (0,_pcm_js__WEBPACK_IMPORTED_MODULE_7__.fromAlaw)(view.getUint8(byteOffset));\n                    }\n                    else {\n                        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false);\n                    }\n                }\n                ;\n                break;\n            case 2:\n                {\n                    if (dataType === 'unsigned') {\n                        this.readInputValue = (view, byteOffset) => view.getUint16(byteOffset, littleEndian) - 2 ** 15;\n                    }\n                    else if (dataType === 'signed') {\n                        this.readInputValue = (view, byteOffset) => view.getInt16(byteOffset, littleEndian);\n                    }\n                    else {\n                        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false);\n                    }\n                }\n                ;\n                break;\n            case 3:\n                {\n                    if (dataType === 'unsigned') {\n                        this.readInputValue = (view, byteOffset) => (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.getUint24)(view, byteOffset, littleEndian) - 2 ** 23;\n                    }\n                    else if (dataType === 'signed') {\n                        this.readInputValue = (view, byteOffset) => (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.getInt24)(view, byteOffset, littleEndian);\n                    }\n                    else {\n                        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false);\n                    }\n                }\n                ;\n                break;\n            case 4:\n                {\n                    if (dataType === 'unsigned') {\n                        this.readInputValue = (view, byteOffset) => view.getUint32(byteOffset, littleEndian) - 2 ** 31;\n                    }\n                    else if (dataType === 'signed') {\n                        this.readInputValue = (view, byteOffset) => view.getInt32(byteOffset, littleEndian);\n                    }\n                    else if (dataType === 'float') {\n                        this.readInputValue = (view, byteOffset) => view.getFloat32(byteOffset, littleEndian);\n                    }\n                    else {\n                        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false);\n                    }\n                }\n                ;\n                break;\n            case 8:\n                {\n                    if (dataType === 'float') {\n                        this.readInputValue = (view, byteOffset) => view.getFloat64(byteOffset, littleEndian);\n                    }\n                    else {\n                        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false);\n                    }\n                }\n                ;\n                break;\n            default:\n                {\n                    (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assertNever)(sampleSize);\n                    (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false);\n                }\n                ;\n        }\n        switch (sampleSize) {\n            case 1:\n                {\n                    if (dataType === 'ulaw' || dataType === 'alaw') {\n                        this.outputSampleSize = 2;\n                        this.outputFormat = 's16';\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt16(byteOffset, value, true);\n                    }\n                    else {\n                        this.outputSampleSize = 1;\n                        this.outputFormat = 'u8';\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint8(byteOffset, value + 2 ** 7);\n                    }\n                }\n                ;\n                break;\n            case 2:\n                {\n                    this.outputSampleSize = 2;\n                    this.outputFormat = 's16';\n                    this.writeOutputValue = (view, byteOffset, value) => view.setInt16(byteOffset, value, true);\n                }\n                ;\n                break;\n            case 3:\n                {\n                    this.outputSampleSize = 4;\n                    this.outputFormat = 's32';\n                    // From https://www.w3.org/TR/webcodecs:\n                    // AudioData containing 24-bit samples SHOULD store those samples in s32 or f32. When samples are\n                    // stored in s32, each sample MUST be left-shifted by 8 bits.\n                    this.writeOutputValue = (view, byteOffset, value) => view.setInt32(byteOffset, value << 8, true);\n                }\n                ;\n                break;\n            case 4:\n                {\n                    this.outputSampleSize = 4;\n                    if (dataType === 'float') {\n                        this.outputFormat = 'f32';\n                        this.writeOutputValue = (view, byteOffset, value) => view.setFloat32(byteOffset, value, true);\n                    }\n                    else {\n                        this.outputFormat = 's32';\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt32(byteOffset, value, true);\n                    }\n                }\n                ;\n                break;\n            case 8:\n                {\n                    this.outputSampleSize = 4;\n                    this.outputFormat = 'f32';\n                    this.writeOutputValue = (view, byteOffset, value) => view.setFloat32(byteOffset, value, true);\n                }\n                ;\n                break;\n            default:\n                {\n                    (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assertNever)(sampleSize);\n                    (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false);\n                }\n                ;\n        }\n        ;\n    }\n    getDecodeQueueSize() {\n        return 0;\n    }\n    decode(packet) {\n        const inputView = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.toDataView)(packet.data);\n        const numberOfFrames = packet.byteLength / this.decoderConfig.numberOfChannels / this.inputSampleSize;\n        const outputBufferSize = numberOfFrames * this.decoderConfig.numberOfChannels * this.outputSampleSize;\n        const outputBuffer = new ArrayBuffer(outputBufferSize);\n        const outputView = new DataView(outputBuffer);\n        for (let i = 0; i < numberOfFrames * this.decoderConfig.numberOfChannels; i++) {\n            const inputIndex = i * this.inputSampleSize;\n            const outputIndex = i * this.outputSampleSize;\n            const value = this.readInputValue(inputView, inputIndex);\n            this.writeOutputValue(outputView, outputIndex, value);\n        }\n        const preciseDuration = numberOfFrames / this.decoderConfig.sampleRate;\n        if (this.currentTimestamp === null || Math.abs(packet.timestamp - this.currentTimestamp) >= preciseDuration) {\n            // We need to sync with the packet timestamp again\n            this.currentTimestamp = packet.timestamp;\n        }\n        const preciseTimestamp = this.currentTimestamp;\n        this.currentTimestamp += preciseDuration;\n        const audioSample = new _sample_js__WEBPACK_IMPORTED_MODULE_4__.AudioSample({\n            format: this.outputFormat,\n            data: outputBuffer,\n            numberOfChannels: this.decoderConfig.numberOfChannels,\n            sampleRate: this.decoderConfig.sampleRate,\n            numberOfFrames,\n            timestamp: preciseTimestamp,\n        });\n        this.onSample(audioSample);\n    }\n    async flush() {\n        // Do nothing\n    }\n    close() {\n        // Do nothing\n    }\n}\n/**\n * Sink for retrieving decoded audio samples from an audio track.\n * @group Media sinks\n * @public\n */\nclass AudioSampleSink extends BaseMediaSampleSink {\n    /** Creates a new {@link AudioSampleSink} for the given {@link InputAudioTrack}. */\n    constructor(audioTrack) {\n        if (!(audioTrack instanceof _input_track_js__WEBPACK_IMPORTED_MODULE_0__.InputAudioTrack)) {\n            throw new TypeError('audioTrack must be an InputAudioTrack.');\n        }\n        super();\n        this._audioTrack = audioTrack;\n    }\n    /** @internal */\n    async _createDecoder(onSample, onError) {\n        if (!(await this._audioTrack.canDecode())) {\n            throw new Error('This audio track cannot be decoded by this browser. Make sure to check decodability before using'\n                + ' a track.');\n        }\n        const codec = this._audioTrack.codec;\n        const decoderConfig = await this._audioTrack.getDecoderConfig();\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(codec && decoderConfig);\n        if (_codec_js__WEBPACK_IMPORTED_MODULE_6__.PCM_AUDIO_CODECS.includes(decoderConfig.codec)) {\n            return new PcmAudioDecoderWrapper(onSample, onError, decoderConfig);\n        }\n        else {\n            return new AudioDecoderWrapper(onSample, onError, codec, decoderConfig);\n        }\n    }\n    /** @internal */\n    _createPacketSink() {\n        return new EncodedPacketSink(this._audioTrack);\n    }\n    /**\n     * Retrieves the audio sample corresponding to the given timestamp, in seconds. More specifically, returns\n     * the last audio sample (in presentation order) with a start timestamp less than or equal to the given timestamp.\n     * Returns null if the timestamp is before the track's first timestamp.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    async getSample(timestamp) {\n        validateTimestamp(timestamp);\n        for await (const sample of this.mediaSamplesAtTimestamps([timestamp])) {\n            return sample;\n        }\n        throw new Error('Internal error: Iterator returned nothing.');\n    }\n    /**\n     * Creates an async iterator that yields the audio samples of this track in presentation order. This method\n     * will intelligently pre-decode a few samples ahead to enable fast iteration.\n     *\n     * @param startTimestamp - The timestamp in seconds at which to start yielding samples (inclusive).\n     * @param endTimestamp - The timestamp in seconds at which to stop yielding samples (exclusive).\n     */\n    samples(startTimestamp = 0, endTimestamp = Infinity) {\n        return this.mediaSamplesInRange(startTimestamp, endTimestamp);\n    }\n    /**\n     * Creates an async iterator that yields an audio sample for each timestamp in the argument. This method\n     * uses an optimized decoding pipeline if these timestamps are monotonically sorted, decoding each packet at most\n     * once, and is therefore more efficient than manually getting the sample for every timestamp. The iterator may\n     * yield null if no sample is available for a given timestamp.\n     *\n     * @param timestamps - An iterable or async iterable of timestamps in seconds.\n     */\n    samplesAtTimestamps(timestamps) {\n        return this.mediaSamplesAtTimestamps(timestamps);\n    }\n}\n/**\n * A sink that retrieves decoded audio samples from an audio track and converts them to `AudioBuffer` instances. This is\n * often more useful than directly retrieving audio samples, as audio buffers can be directly used with the\n * Web Audio API.\n * @group Media sinks\n * @public\n */\nclass AudioBufferSink {\n    /** Creates a new {@link AudioBufferSink} for the given {@link InputAudioTrack}. */\n    constructor(audioTrack) {\n        if (!(audioTrack instanceof _input_track_js__WEBPACK_IMPORTED_MODULE_0__.InputAudioTrack)) {\n            throw new TypeError('audioTrack must be an InputAudioTrack.');\n        }\n        this._audioSampleSink = new AudioSampleSink(audioTrack);\n    }\n    /** @internal */\n    _audioSampleToWrappedArrayBuffer(sample) {\n        return {\n            buffer: sample.toAudioBuffer(),\n            timestamp: sample.timestamp,\n            duration: sample.duration,\n        };\n    }\n    /**\n     * Retrieves the audio buffer corresponding to the given timestamp, in seconds. More specifically, returns\n     * the last audio buffer (in presentation order) with a start timestamp less than or equal to the given timestamp.\n     * Returns null if the timestamp is before the track's first timestamp.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    async getBuffer(timestamp) {\n        validateTimestamp(timestamp);\n        const data = await this._audioSampleSink.getSample(timestamp);\n        return data && this._audioSampleToWrappedArrayBuffer(data);\n    }\n    /**\n     * Creates an async iterator that yields audio buffers of this track in presentation order. This method\n     * will intelligently pre-decode a few buffers ahead to enable fast iteration.\n     *\n     * @param startTimestamp - The timestamp in seconds at which to start yielding buffers (inclusive).\n     * @param endTimestamp - The timestamp in seconds at which to stop yielding buffers (exclusive).\n     */\n    buffers(startTimestamp = 0, endTimestamp = Infinity) {\n        return (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.mapAsyncGenerator)(this._audioSampleSink.samples(startTimestamp, endTimestamp), data => this._audioSampleToWrappedArrayBuffer(data));\n    }\n    /**\n     * Creates an async iterator that yields an audio buffer for each timestamp in the argument. This method\n     * uses an optimized decoding pipeline if these timestamps are monotonically sorted, decoding each packet at most\n     * once, and is therefore more efficient than manually getting the buffer for every timestamp. The iterator may\n     * yield null if no buffer is available for a given timestamp.\n     *\n     * @param timestamps - An iterable or async iterable of timestamps in seconds.\n     */\n    buffersAtTimestamps(timestamps) {\n        return (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.mapAsyncGenerator)(this._audioSampleSink.samplesAtTimestamps(timestamps), data => data && this._audioSampleToWrappedArrayBuffer(data));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL21lZGlhLXNpbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUNxQztBQUNyQjtBQUNHO0FBQytIO0FBQ25LO0FBQ0U7QUFDUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx1QkFBdUIseUJBQXlCLGVBQWUsaUJBQWlCO0FBQ2hGO0FBQ0EsK0JBQStCLHVEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLGdDQUFnQyxxREFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxnQ0FBZ0MscURBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELGtFQUFrRSxxREFBYTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHFEQUFhO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtREFBbUQsRUFBRSw4REFBb0I7QUFDdkYsY0FBYyxpREFBaUQsRUFBRSw4REFBb0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBaUQsRUFBRSw4REFBb0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtREFBbUQsRUFBRSw4REFBb0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtREFBbUQsRUFBRSw4REFBb0I7QUFDdkYsY0FBYyxpREFBaUQsRUFBRSw4REFBb0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFtRCxFQUFFLDhEQUFvQjtBQUNoRztBQUNBLGFBQWE7QUFDYjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw4RUFBOEUsd0JBQXdCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHdCQUF3QjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBaUQsRUFBRSw4REFBb0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZEQUFtQjtBQUMzQixrQ0FBa0MseURBQWU7QUFDakQ7QUFDQTtBQUNBLGNBQWMsbURBQW1ELEVBQUUsOERBQW9CO0FBQ3ZGLGNBQWMsaURBQWlELEVBQUUsOERBQW9CO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQW1ELEVBQUUsOERBQW9CO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpREFBaUQsRUFBRSw4REFBb0I7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdEQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQ0FBaUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsd0JBQXdCO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0RBQU07QUFDOUI7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG9EQUFjO0FBQzdEO0FBQ0EsbUNBQW1DO0FBQ25DLCtCQUErQjtBQUMvQjtBQUNBLGtDQUFrQztBQUNsQyxzQ0FBc0MsaUVBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtREFBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSw4Q0FBSTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdEQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsbURBQVc7QUFDOUQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUVBQW1CO0FBQ2hEO0FBQ0EsNkJBQTZCLHlFQUF5QjtBQUN0RCxnQ0FBZ0MsMkRBQWUsb0JBQW9CLDJEQUFlO0FBQ2xGLGFBQWE7QUFDYjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBTTtBQUNsQixpQkFBaUIsa0RBQVE7QUFDekIsZ0JBQWdCLHNEQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQU07QUFDbEI7QUFDQTtBQUNBLFlBQVksa0RBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx1QkFBdUIsdUJBQXVCLGVBQWUsc0JBQXNCO0FBQ25GO0FBQ0Esb0NBQW9DLDREQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsdUJBQXVCLGtCQUFrQixlQUFlLHNCQUFzQjtBQUM5RSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLG9DQUFvQyw0REFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsUUFBUSxnREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyREFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJEQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvREFBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlFQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbURBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxtREFBVztBQUM3RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQU0sQ0FBQyx1REFBZ0I7QUFDL0I7QUFDQSxnQkFBZ0IscUNBQXFDLEVBQUUsd0RBQWE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxpREFBUTtBQUM1RTtBQUNBO0FBQ0Esb0VBQW9FLGlEQUFRO0FBQzVFO0FBQ0E7QUFDQSx3QkFBd0IsZ0RBQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0RBQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsbURBQVM7QUFDN0U7QUFDQTtBQUNBLG9FQUFvRSxrREFBUTtBQUM1RTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVztBQUMvQixvQkFBb0IsZ0RBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVztBQUMvQixvQkFBb0IsZ0RBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9EQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBEQUEwRDtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbURBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHVCQUF1Qix1QkFBdUIsZUFBZSxzQkFBc0I7QUFDbkY7QUFDQSxvQ0FBb0MsNERBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFNO0FBQ2QsWUFBWSx1REFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsdUJBQXVCLHVCQUF1QixlQUFlLHNCQUFzQjtBQUNuRjtBQUNBLG9DQUFvQyw0REFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyREFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJEQUFpQjtBQUNoQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWF0Y2gtY3V0LWdlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9tZWRpYWJ1bm55L2Rpc3QvbW9kdWxlcy9zcmMvbWVkaWEtc2luay5qcz80ZGNiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDI1LXByZXNlbnQsIFZhbmlsYWd5IGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgcGFyc2VQY21Db2RlYywgUENNX0FVRElPX0NPREVDUyB9IGZyb20gJy4vY29kZWMuanMnO1xuaW1wb3J0IHsgZXh0cmFjdEhldmNOYWxVbml0cywgZXh0cmFjdE5hbFVuaXRUeXBlRm9ySGV2YywgSGV2Y05hbFVuaXRUeXBlIH0gZnJvbSAnLi9jb2RlYy1kYXRhLmpzJztcbmltcG9ydCB7IGN1c3RvbVZpZGVvRGVjb2RlcnMsIGN1c3RvbUF1ZGlvRGVjb2RlcnMgfSBmcm9tICcuL2N1c3RvbS1jb2Rlci5qcyc7XG5pbXBvcnQgeyBJbnB1dEF1ZGlvVHJhY2ssIElucHV0VHJhY2ssIElucHV0VmlkZW9UcmFjayB9IGZyb20gJy4vaW5wdXQtdHJhY2suanMnO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnROZXZlciwgQ2FsbFNlcmlhbGl6ZXIsIGdldEludDI0LCBnZXRVaW50MjQsIGluc2VydFNvcnRlZCwgaXNTYWZhcmksIGxhc3QsIG1hcEFzeW5jR2VuZXJhdG9yLCBwcm9taXNlV2l0aFJlc29sdmVycywgdG9Bc3luY0l0ZXJhdG9yLCB0b0RhdGFWaWV3LCB2YWxpZGF0ZUFueUl0ZXJhYmxlLCB9IGZyb20gJy4vbWlzYy5qcyc7XG5pbXBvcnQgeyBFbmNvZGVkUGFja2V0IH0gZnJvbSAnLi9wYWNrZXQuanMnO1xuaW1wb3J0IHsgZnJvbUFsYXcsIGZyb21VbGF3IH0gZnJvbSAnLi9wY20uanMnO1xuaW1wb3J0IHsgQXVkaW9TYW1wbGUsIFZpZGVvU2FtcGxlIH0gZnJvbSAnLi9zYW1wbGUuanMnO1xuY29uc3QgdmFsaWRhdGVQYWNrZXRSZXRyaWV2YWxPcHRpb25zID0gKG9wdGlvbnMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm1ldGFkYXRhT25seSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLm1ldGFkYXRhT25seSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMubWV0YWRhdGFPbmx5LCB3aGVuIGRlZmluZWQsIG11c3QgYmUgYSBib29sZWFuLicpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy52ZXJpZnlLZXlQYWNrZXRzICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMudmVyaWZ5S2V5UGFja2V0cyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMudmVyaWZ5S2V5UGFja2V0cywgd2hlbiBkZWZpbmVkLCBtdXN0IGJlIGEgYm9vbGVhbi4nKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudmVyaWZ5S2V5UGFja2V0cyAmJiBvcHRpb25zLm1ldGFkYXRhT25seSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLnZlcmlmeUtleVBhY2tldHMgYW5kIG9wdGlvbnMubWV0YWRhdGFPbmx5IGNhbm5vdCBiZSBlbmFibGVkIHRvZ2V0aGVyLicpO1xuICAgIH1cbn07XG5jb25zdCB2YWxpZGF0ZVRpbWVzdGFtcCA9ICh0aW1lc3RhbXApID0+IHtcbiAgICBpZiAodHlwZW9mIHRpbWVzdGFtcCAhPT0gJ251bWJlcicgfHwgTnVtYmVyLmlzTmFOKHRpbWVzdGFtcCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGltZXN0YW1wIG11c3QgYmUgYSBudW1iZXIuJyk7IC8vIEl0IGNhbiBiZSBub24tZmluaXRlLCB0aGF0J3MgZmluZVxuICAgIH1cbn07XG5jb25zdCBtYXliZUZpeFBhY2tldFR5cGUgPSAodHJhY2ssIHByb21pc2UsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAob3B0aW9ucy52ZXJpZnlLZXlQYWNrZXRzKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oYXN5bmMgKHBhY2tldCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwYWNrZXQgfHwgcGFja2V0LnR5cGUgPT09ICdkZWx0YScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFja2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGV0ZXJtaW5lZFR5cGUgPSBhd2FpdCB0cmFjay5kZXRlcm1pbmVQYWNrZXRUeXBlKHBhY2tldCk7XG4gICAgICAgICAgICBpZiAoZGV0ZXJtaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRlY2huaWNhbGx5IHJlYWRvbmx5XG4gICAgICAgICAgICAgICAgcGFja2V0LnR5cGUgPSBkZXRlcm1pbmVkVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYWNrZXQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxufTtcbi8qKlxuICogU2luayBmb3IgcmV0cmlldmluZyBlbmNvZGVkIHBhY2tldHMgZnJvbSBhbiBpbnB1dCB0cmFjay5cbiAqIEBncm91cCBNZWRpYSBzaW5rc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgRW5jb2RlZFBhY2tldFNpbmsge1xuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHtAbGluayBFbmNvZGVkUGFja2V0U2lua30gZm9yIHRoZSBnaXZlbiB7QGxpbmsgSW5wdXRUcmFja30uICovXG4gICAgY29uc3RydWN0b3IodHJhY2spIHtcbiAgICAgICAgaWYgKCEodHJhY2sgaW5zdGFuY2VvZiBJbnB1dFRyYWNrKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndHJhY2sgbXVzdCBiZSBhbiBJbnB1dFRyYWNrLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYWNrID0gdHJhY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdHJhY2sncyBmaXJzdCBwYWNrZXQgKGluIGRlY29kZSBvcmRlciksIG9yIG51bGwgaWYgaXQgaGFzIG5vIHBhY2tldHMuIFRoZSBmaXJzdCBwYWNrZXQgaXMgdmVyeVxuICAgICAqIGxpa2VseSB0byBiZSBhIGtleSBwYWNrZXQuXG4gICAgICovXG4gICAgZ2V0Rmlyc3RQYWNrZXQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHZhbGlkYXRlUGFja2V0UmV0cmlldmFsT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG1heWJlRml4UGFja2V0VHlwZSh0aGlzLl90cmFjaywgdGhpcy5fdHJhY2suX2JhY2tpbmcuZ2V0Rmlyc3RQYWNrZXQob3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHBhY2tldCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiB0aW1lc3RhbXAsIGluIHNlY29uZHMuIE1vcmUgc3BlY2lmaWNhbGx5LCByZXR1cm5zIHRoZSBsYXN0IHBhY2tldFxuICAgICAqIChpbiBwcmVzZW50YXRpb24gb3JkZXIpIHdpdGggYSBzdGFydCB0aW1lc3RhbXAgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiB0aW1lc3RhbXAuIFRoaXMgbWV0aG9kIGNhbiBiZVxuICAgICAqIHVzZWQgdG8gcmV0cmlldmUgYSB0cmFjaydzIGxhc3QgcGFja2V0IHVzaW5nIGBnZXRQYWNrZXQoSW5maW5pdHkpYC4gVGhlIG1ldGhvZCByZXR1cm5zIG51bGwgaWYgdGhlIHRpbWVzdGFtcFxuICAgICAqIGlzIGJlZm9yZSB0aGUgZmlyc3QgcGFja2V0IGluIHRoZSB0cmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lc3RhbXAgLSBUaGUgdGltZXN0YW1wIHVzZWQgZm9yIHJldHJpZXZhbCwgaW4gc2Vjb25kcy5cbiAgICAgKi9cbiAgICBnZXRQYWNrZXQodGltZXN0YW1wLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFsaWRhdGVUaW1lc3RhbXAodGltZXN0YW1wKTtcbiAgICAgICAgdmFsaWRhdGVQYWNrZXRSZXRyaWV2YWxPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbWF5YmVGaXhQYWNrZXRUeXBlKHRoaXMuX3RyYWNrLCB0aGlzLl90cmFjay5fYmFja2luZy5nZXRQYWNrZXQodGltZXN0YW1wLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgcGFja2V0IGZvbGxvd2luZyB0aGUgZ2l2ZW4gcGFja2V0IChpbiBkZWNvZGUgb3JkZXIpLCBvciBudWxsIGlmIHRoZSBnaXZlbiBwYWNrZXQgaXMgdGhlXG4gICAgICogbGFzdCBwYWNrZXQuXG4gICAgICovXG4gICAgZ2V0TmV4dFBhY2tldChwYWNrZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoIShwYWNrZXQgaW5zdGFuY2VvZiBFbmNvZGVkUGFja2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFja2V0IG11c3QgYmUgYW4gRW5jb2RlZFBhY2tldC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZVBhY2tldFJldHJpZXZhbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBtYXliZUZpeFBhY2tldFR5cGUodGhpcy5fdHJhY2ssIHRoaXMuX3RyYWNrLl9iYWNraW5nLmdldE5leHRQYWNrZXQocGFja2V0LCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUga2V5IHBhY2tldCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiB0aW1lc3RhbXAsIGluIHNlY29uZHMuIE1vcmUgc3BlY2lmaWNhbGx5LCByZXR1cm5zIHRoZSBsYXN0XG4gICAgICoga2V5IHBhY2tldCAoaW4gcHJlc2VudGF0aW9uIG9yZGVyKSB3aXRoIGEgc3RhcnQgdGltZXN0YW1wIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gdGltZXN0YW1wLiBBIGtleSBwYWNrZXRcbiAgICAgKiBpcyBhIHBhY2tldCB0aGF0IGRvZXNuJ3QgcmVxdWlyZSBwcmV2aW91cyBwYWNrZXRzIHRvIGJlIGRlY29kZWQuIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlIGEgdHJhY2snc1xuICAgICAqIGxhc3Qga2V5IHBhY2tldCB1c2luZyBgZ2V0S2V5UGFja2V0KEluZmluaXR5KWAuIFRoZSBtZXRob2QgcmV0dXJucyBudWxsIGlmIHRoZSB0aW1lc3RhbXAgaXMgYmVmb3JlIHRoZSBmaXJzdFxuICAgICAqIGtleSBwYWNrZXQgaW4gdGhlIHRyYWNrLlxuICAgICAqXG4gICAgICogVG8gZW5zdXJlIHRoYXQgdGhlIHJldHVybmVkIHBhY2tldCBpcyBndWFyYW50ZWVkIHRvIGJlIGEgcmVhbCBrZXkgZnJhbWUsIGVuYWJsZSBgb3B0aW9ucy52ZXJpZnlLZXlQYWNrZXRzYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lc3RhbXAgLSBUaGUgdGltZXN0YW1wIHVzZWQgZm9yIHJldHJpZXZhbCwgaW4gc2Vjb25kcy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRLZXlQYWNrZXQodGltZXN0YW1wLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFsaWRhdGVUaW1lc3RhbXAodGltZXN0YW1wKTtcbiAgICAgICAgdmFsaWRhdGVQYWNrZXRSZXRyaWV2YWxPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBpZiAoIW9wdGlvbnMudmVyaWZ5S2V5UGFja2V0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrLl9iYWNraW5nLmdldEtleVBhY2tldCh0aW1lc3RhbXAsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IGF3YWl0IHRoaXMuX3RyYWNrLl9iYWNraW5nLmdldEtleVBhY2tldCh0aW1lc3RhbXAsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXBhY2tldCB8fCBwYWNrZXQudHlwZSA9PT0gJ2RlbHRhJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhY2tldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXRlcm1pbmVkVHlwZSA9IGF3YWl0IHRoaXMuX3RyYWNrLmRldGVybWluZVBhY2tldFR5cGUocGFja2V0KTtcbiAgICAgICAgaWYgKGRldGVybWluZWRUeXBlID09PSAnZGVsdGEnKSB7XG4gICAgICAgICAgICAvLyBUcnkgcmV0dXJuaW5nIHRoZSBwcmV2aW91cyBrZXkgcGFja2V0IChpbiBob3BlcyB0aGF0IGl0J3MgYWN0dWFsbHkgYSBrZXkgcGFja2V0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5UGFja2V0KHBhY2tldC50aW1lc3RhbXAgLSAxIC8gdGhpcy5fdHJhY2sudGltZVJlc29sdXRpb24sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWNrZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUga2V5IHBhY2tldCBmb2xsb3dpbmcgdGhlIGdpdmVuIHBhY2tldCAoaW4gZGVjb2RlIG9yZGVyKSwgb3IgbnVsbCBpZiB0aGUgZ2l2ZW4gcGFja2V0IGlzIHRoZSBsYXN0XG4gICAgICoga2V5IHBhY2tldC5cbiAgICAgKlxuICAgICAqIFRvIGVuc3VyZSB0aGF0IHRoZSByZXR1cm5lZCBwYWNrZXQgaXMgZ3VhcmFudGVlZCB0byBiZSBhIHJlYWwga2V5IGZyYW1lLCBlbmFibGUgYG9wdGlvbnMudmVyaWZ5S2V5UGFja2V0c2AuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TmV4dEtleVBhY2tldChwYWNrZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoIShwYWNrZXQgaW5zdGFuY2VvZiBFbmNvZGVkUGFja2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFja2V0IG11c3QgYmUgYW4gRW5jb2RlZFBhY2tldC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZVBhY2tldFJldHJpZXZhbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGlmICghb3B0aW9ucy52ZXJpZnlLZXlQYWNrZXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2suX2JhY2tpbmcuZ2V0TmV4dEtleVBhY2tldChwYWNrZXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRQYWNrZXQgPSBhd2FpdCB0aGlzLl90cmFjay5fYmFja2luZy5nZXROZXh0S2V5UGFja2V0KHBhY2tldCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghbmV4dFBhY2tldCB8fCBuZXh0UGFja2V0LnR5cGUgPT09ICdkZWx0YScpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0UGFja2V0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRldGVybWluZWRUeXBlID0gYXdhaXQgdGhpcy5fdHJhY2suZGV0ZXJtaW5lUGFja2V0VHlwZShuZXh0UGFja2V0KTtcbiAgICAgICAgaWYgKGRldGVybWluZWRUeXBlID09PSAnZGVsdGEnKSB7XG4gICAgICAgICAgICAvLyBUcnkgcmV0dXJuaW5nIHRoZSBuZXh0IGtleSBwYWNrZXQgKGluIGhvcGVzIHRoYXQgaXQncyBhY3R1YWxseSBhIGtleSBwYWNrZXQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROZXh0S2V5UGFja2V0KG5leHRQYWNrZXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0UGFja2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFzeW5jIGl0ZXJhdG9yIHRoYXQgeWllbGRzIHRoZSBwYWNrZXRzIGluIHRoaXMgdHJhY2sgaW4gZGVjb2RlIG9yZGVyLiBUbyBlbmFibGUgZmFzdCBpdGVyYXRpb24sIHRoaXNcbiAgICAgKiBtZXRob2Qgd2lsbCBpbnRlbGxpZ2VudGx5IHByZWxvYWQgcGFja2V0cyBiYXNlZCBvbiB0aGUgc3BlZWQgb2YgdGhlIGNvbnN1bWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0UGFja2V0IC0gKG9wdGlvbmFsKSBUaGUgcGFja2V0IGZyb20gd2hpY2ggaXRlcmF0aW9uIHNob3VsZCBiZWdpbi4gVGhpcyBwYWNrZXQgd2lsbCBhbHNvIGJlIHlpZWxkZWQuXG4gICAgICogQHBhcmFtIGVuZFRpbWVzdGFtcCAtIChvcHRpb25hbCkgVGhlIHRpbWVzdGFtcCBhdCB3aGljaCBpdGVyYXRpb24gc2hvdWxkIGVuZC4gVGhpcyBwYWNrZXQgd2lsbCBfbm90XyBiZSB5aWVsZGVkLlxuICAgICAqL1xuICAgIHBhY2tldHMoc3RhcnRQYWNrZXQsIGVuZFBhY2tldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChzdGFydFBhY2tldCAhPT0gdW5kZWZpbmVkICYmICEoc3RhcnRQYWNrZXQgaW5zdGFuY2VvZiBFbmNvZGVkUGFja2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RhcnRQYWNrZXQgbXVzdCBiZSBhbiBFbmNvZGVkUGFja2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydFBhY2tldCAhPT0gdW5kZWZpbmVkICYmIHN0YXJ0UGFja2V0LmlzTWV0YWRhdGFPbmx5ICYmICFvcHRpb25zPy5tZXRhZGF0YU9ubHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0YXJ0UGFja2V0IGNhbiBvbmx5IGJlIG1ldGFkYXRhLW9ubHkgaWYgb3B0aW9ucy5tZXRhZGF0YU9ubHkgaXMgZW5hYmxlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kUGFja2V0ICE9PSB1bmRlZmluZWQgJiYgIShlbmRQYWNrZXQgaW5zdGFuY2VvZiBFbmNvZGVkUGFja2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5kUGFja2V0IG11c3QgYmUgYW4gRW5jb2RlZFBhY2tldC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZVBhY2tldFJldHJpZXZhbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHBhY2tldFF1ZXVlID0gW107XG4gICAgICAgIGxldCB7IHByb21pc2U6IHF1ZXVlTm90RW1wdHksIHJlc29sdmU6IG9uUXVldWVOb3RFbXB0eSB9ID0gcHJvbWlzZVdpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgbGV0IHsgcHJvbWlzZTogcXVldWVEZXF1ZXVlLCByZXNvbHZlOiBvblF1ZXVlRGVxdWV1ZSB9ID0gcHJvbWlzZVdpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgbGV0IGVuZGVkID0gZmFsc2U7XG4gICAgICAgIGxldCB0ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgICAgIC8vIFRoaXMgc3RvcmVzIGVycm9ycyB0aGF0IGFyZSBcIm91dCBvZiBiYW5kXCIgaW4gdGhlIHNlbnNlIHRoYXQgdGhleSBkaWRuJ3Qgb2NjdXIgaW4gdGhlIG5vcm1hbCBmbG93IG9mIHRoaXNcbiAgICAgICAgLy8gbWV0aG9kIGJ1dCBpbnN0ZWFkIGluIGEgZGlmZmVyZW50IGNvbnRleHQuIFRoaXMgZXJyb3Igc2hvdWxkIG5vdCBnbyB1bm5vdGljZWQgYW5kIG11c3QgYmUgYnViYmxlZCB1cCB0b1xuICAgICAgICAvLyB0aGUgY29uc3VtZXIuXG4gICAgICAgIGxldCBvdXRPZkJhbmRFcnJvciA9IG51bGw7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBbXTtcbiAgICAgICAgLy8gVGhlIHF1ZXVlIHNob3VsZCBhbHdheXMgYmUgYmlnIGVub3VnaCB0byBob2xkIDEgc2Vjb25kIHdvcnRoIG9mIHBhY2tldHNcbiAgICAgICAgY29uc3QgbWF4UXVldWVTaXplID0gKCkgPT4gTWF0aC5tYXgoMiwgdGltZXN0YW1wcy5sZW5ndGgpO1xuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGlzIHRoZSBcInB1bXBcIiBwcm9jZXNzIHRoYXQga2VlcHMgcHVtcGluZyBwYWNrZXRzIGludG8gdGhlIHF1ZXVlXG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcGFja2V0ID0gc3RhcnRQYWNrZXQgPz8gYXdhaXQgdGhpcy5nZXRGaXJzdFBhY2tldChvcHRpb25zKTtcbiAgICAgICAgICAgIHdoaWxlIChwYWNrZXQgJiYgIXRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kUGFja2V0ICYmIHBhY2tldC5zZXF1ZW5jZU51bWJlciA+PSBlbmRQYWNrZXQ/LnNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFja2V0UXVldWUubGVuZ3RoID4gbWF4UXVldWVTaXplKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgKHsgcHJvbWlzZTogcXVldWVEZXF1ZXVlLCByZXNvbHZlOiBvblF1ZXVlRGVxdWV1ZSB9ID0gcHJvbWlzZVdpdGhSZXNvbHZlcnMoKSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHF1ZXVlRGVxdWV1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhY2tldFF1ZXVlLnB1c2gocGFja2V0KTtcbiAgICAgICAgICAgICAgICBvblF1ZXVlTm90RW1wdHkoKTtcbiAgICAgICAgICAgICAgICAoeyBwcm9taXNlOiBxdWV1ZU5vdEVtcHR5LCByZXNvbHZlOiBvblF1ZXVlTm90RW1wdHkgfSA9IHByb21pc2VXaXRoUmVzb2x2ZXJzKCkpO1xuICAgICAgICAgICAgICAgIHBhY2tldCA9IGF3YWl0IHRoaXMuZ2V0TmV4dFBhY2tldChwYWNrZXQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgb25RdWV1ZU5vdEVtcHR5KCk7XG4gICAgICAgIH0pKCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW91dE9mQmFuZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgb3V0T2ZCYW5kRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICBvblF1ZXVlTm90RW1wdHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3V0T2ZCYW5kRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG91dE9mQmFuZEVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhY2tldFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFja2V0UXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wcy5wdXNoKG5vdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGltZXN0YW1wcy5sZW5ndGggPiAwICYmIG5vdyAtIHRpbWVzdGFtcHNbMF0gPj0gMTAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUXVldWVEZXF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcXVldWVOb3RFbXB0eTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyByZXR1cm4oKSB7XG4gICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgb25RdWV1ZURlcXVldWUoKTtcbiAgICAgICAgICAgICAgICBvblF1ZXVlTm90RW1wdHkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgdGhyb3coZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5jbGFzcyBEZWNvZGVyV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3Iob25TYW1wbGUsIG9uRXJyb3IpIHtcbiAgICAgICAgdGhpcy5vblNhbXBsZSA9IG9uU2FtcGxlO1xuICAgICAgICB0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuICAgIH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgZGVjb2RlZCBtZWRpYSBzYW1wbGUgc2lua3MuXG4gKiBAZ3JvdXAgTWVkaWEgc2lua3NcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VNZWRpYVNhbXBsZVNpbmsge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBtZWRpYVNhbXBsZXNJblJhbmdlKHN0YXJ0VGltZXN0YW1wID0gMCwgZW5kVGltZXN0YW1wID0gSW5maW5pdHkpIHtcbiAgICAgICAgdmFsaWRhdGVUaW1lc3RhbXAoc3RhcnRUaW1lc3RhbXApO1xuICAgICAgICB2YWxpZGF0ZVRpbWVzdGFtcChlbmRUaW1lc3RhbXApO1xuICAgICAgICBjb25zdCBzYW1wbGVRdWV1ZSA9IFtdO1xuICAgICAgICBsZXQgZmlyc3RTYW1wbGVRdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGxhc3RTYW1wbGUgPSBudWxsO1xuICAgICAgICBsZXQgeyBwcm9taXNlOiBxdWV1ZU5vdEVtcHR5LCByZXNvbHZlOiBvblF1ZXVlTm90RW1wdHkgfSA9IHByb21pc2VXaXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIGxldCB7IHByb21pc2U6IHF1ZXVlRGVxdWV1ZSwgcmVzb2x2ZTogb25RdWV1ZURlcXVldWUgfSA9IHByb21pc2VXaXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIGxldCBkZWNvZGVySXNGbHVzaGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBlbmRlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgdGVybWluYXRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBUaGlzIHN0b3JlcyBlcnJvcnMgdGhhdCBhcmUgXCJvdXQgb2YgYmFuZFwiIGluIHRoZSBzZW5zZSB0aGF0IHRoZXkgZGlkbid0IG9jY3VyIGluIHRoZSBub3JtYWwgZmxvdyBvZiB0aGlzXG4gICAgICAgIC8vIG1ldGhvZCBidXQgaW5zdGVhZCBpbiBhIGRpZmZlcmVudCBjb250ZXh0LiBUaGlzIGVycm9yIHNob3VsZCBub3QgZ28gdW5ub3RpY2VkIGFuZCBtdXN0IGJlIGJ1YmJsZWQgdXAgdG9cbiAgICAgICAgLy8gdGhlIGNvbnN1bWVyLlxuICAgICAgICBsZXQgb3V0T2ZCYW5kRXJyb3IgPSBudWxsO1xuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGlzIHRoZSBcInB1bXBcIiBwcm9jZXNzIHRoYXQga2VlcHMgcHVtcGluZyBwYWNrZXRzIGludG8gdGhlIGRlY29kZXJcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXJFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlciA9IGF3YWl0IHRoaXMuX2NyZWF0ZURlY29kZXIoKHNhbXBsZSkgPT4ge1xuICAgICAgICAgICAgICAgIG9uUXVldWVEZXF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNhbXBsZS50aW1lc3RhbXAgPj0gZW5kVGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXN0U2FtcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzYW1wbGUudGltZXN0YW1wID4gc3RhcnRUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGtub3cgYWhlYWQgb2YgdGltZSB3aGF0IHRoZSBmaXJzdCBmaXJzdCBpcy4gVGhpcyBpcyBiZWNhdXNlIHRoZSBmaXJzdCBmaXJzdCBpcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxhc3QgZmlyc3Qgd2hvc2UgdGltZXN0YW1wIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3RhcnQgdGltZXN0YW1wLiBUaGVyZWZvcmUgd2UgbmVlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FpdCBmb3IgdGhlIGZpcnN0IGZpcnN0IGFmdGVyIHRoZSBzdGFydCB0aW1lc3RhbXAsIGFuZCB0aGVuIHdlJ2xsIGtub3cgdGhhdCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IHdhcyB0aGUgZmlyc3QgZmlyc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVRdWV1ZS5wdXNoKGxhc3RTYW1wbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RTYW1wbGVRdWV1ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFNhbXBsZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzYW1wbGUudGltZXN0YW1wID49IHN0YXJ0VGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZVF1ZXVlLnB1c2goc2FtcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RTYW1wbGVRdWV1ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0U2FtcGxlID0gZmlyc3RTYW1wbGVRdWV1ZWQgPyBudWxsIDogc2FtcGxlO1xuICAgICAgICAgICAgICAgIGlmIChzYW1wbGVRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uUXVldWVOb3RFbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICAoeyBwcm9taXNlOiBxdWV1ZU5vdEVtcHR5LCByZXNvbHZlOiBvblF1ZXVlTm90RW1wdHkgfSA9IHByb21pc2VXaXRoUmVzb2x2ZXJzKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghb3V0T2ZCYW5kRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBkZWNvZGVyRXJyb3Iuc3RhY2s7IC8vIFByb3ZpZGUgYSBtb3JlIHVzZWZ1bCBzdGFjayB0cmFjZVxuICAgICAgICAgICAgICAgICAgICBvdXRPZkJhbmRFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBvblF1ZXVlTm90RW1wdHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHBhY2tldFNpbmsgPSB0aGlzLl9jcmVhdGVQYWNrZXRTaW5rKCk7XG4gICAgICAgICAgICBjb25zdCBrZXlQYWNrZXQgPSBhd2FpdCBwYWNrZXRTaW5rLmdldEtleVBhY2tldChzdGFydFRpbWVzdGFtcCwgeyB2ZXJpZnlLZXlQYWNrZXRzOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgPz8gYXdhaXQgcGFja2V0U2luay5nZXRGaXJzdFBhY2tldCgpO1xuICAgICAgICAgICAgaWYgKCFrZXlQYWNrZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VycmVudFBhY2tldCA9IGtleVBhY2tldDtcbiAgICAgICAgICAgIGxldCBlbmRQYWNrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoZW5kVGltZXN0YW1wIDwgSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIGFuIGVuZCB0aW1lc3RhbXAgaXMgc2V0LCB3ZSBjYW5ub3Qgc2ltcGx5IHVzZSB0aGF0IGZvciB0aGUgcGFja2V0IGl0ZXJhdG9yIGR1ZSB0byBvdXQtb2Ytb3JkZXJcbiAgICAgICAgICAgICAgICAvLyBmcmFtZXMgKEItZnJhbWVzKS4gSW5zdGVhZCwgd2UnbGwgbmVlZCB0byBrZWVwIGRlY29kaW5nIHBhY2tldHMgdW50aWwgd2UgZ2V0IGEgZnJhbWUgdGhhdCBleGNlZWRzXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBlbmQgdGltZS4gSG93ZXZlciwgd2UgY2FuIHN0aWxsIHB1dCBhIGJvdW5kIG9uIGl0OiBTaW5jZSBrZXkgZnJhbWVzIGFyZSBieSBkZWZpbml0aW9uIG5ldmVyXG4gICAgICAgICAgICAgICAgLy8gb3V0IG9mIG9yZGVyLCB3ZSBjYW4gc3RvcCBhdCB0aGUgZmlyc3Qga2V5IGZyYW1lIGFmdGVyIHRoZSBlbmQgdGltZXN0YW1wLlxuICAgICAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IGF3YWl0IHBhY2tldFNpbmsuZ2V0UGFja2V0KGVuZFRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5UGFja2V0ID0gIXBhY2tldFxuICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiBwYWNrZXQudHlwZSA9PT0gJ2tleScgJiYgcGFja2V0LnRpbWVzdGFtcCA9PT0gZW5kVGltZXN0YW1wXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhY2tldFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBhd2FpdCBwYWNrZXRTaW5rLmdldE5leHRLZXlQYWNrZXQocGFja2V0LCB7IHZlcmlmeUtleVBhY2tldHM6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGtleVBhY2tldCkge1xuICAgICAgICAgICAgICAgICAgICBlbmRQYWNrZXQgPSBrZXlQYWNrZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFja2V0cyA9IHBhY2tldFNpbmsucGFja2V0cyhrZXlQYWNrZXQsIGVuZFBhY2tldCk7XG4gICAgICAgICAgICBhd2FpdCBwYWNrZXRzLm5leHQoKTsgLy8gU2tpcCB0aGUgc3RhcnQgcGFja2V0IGFzIHdlIGFscmVhZHkgaGF2ZSBpdFxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRQYWNrZXQgJiYgIWVuZGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4UXVldWVTaXplID0gY29tcHV0ZU1heFF1ZXVlU2l6ZShzYW1wbGVRdWV1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChzYW1wbGVRdWV1ZS5sZW5ndGggKyBkZWNvZGVyLmdldERlY29kZVF1ZXVlU2l6ZSgpID4gbWF4UXVldWVTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICh7IHByb21pc2U6IHF1ZXVlRGVxdWV1ZSwgcmVzb2x2ZTogb25RdWV1ZURlcXVldWUgfSA9IHByb21pc2VXaXRoUmVzb2x2ZXJzKCkpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBxdWV1ZURlcXVldWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWNvZGVyLmRlY29kZShjdXJyZW50UGFja2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWNrZXRSZXN1bHQgPSBhd2FpdCBwYWNrZXRzLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFja2V0UmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYWNrZXQgPSBwYWNrZXRSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBwYWNrZXRzLnJldHVybigpO1xuICAgICAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKVxuICAgICAgICAgICAgICAgIGF3YWl0IGRlY29kZXIuZmx1c2goKTtcbiAgICAgICAgICAgIGRlY29kZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIGlmICghZmlyc3RTYW1wbGVRdWV1ZWQgJiYgbGFzdFNhbXBsZSkge1xuICAgICAgICAgICAgICAgIHNhbXBsZVF1ZXVlLnB1c2gobGFzdFNhbXBsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVySXNGbHVzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG9uUXVldWVOb3RFbXB0eSgpOyAvLyBUbyB1bnN0dWNrIHRoZSBnZW5lcmF0b3JcbiAgICAgICAgfSkoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICghb3V0T2ZCYW5kRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvdXRPZkJhbmRFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIG9uUXVldWVOb3RFbXB0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvdXRPZkJhbmRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgb3V0T2ZCYW5kRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2FtcGxlUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzYW1wbGVRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25RdWV1ZURlcXVldWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFkZWNvZGVySXNGbHVzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBxdWV1ZU5vdEVtcHR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jIHJldHVybigpIHtcbiAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgb25RdWV1ZURlcXVldWUoKTtcbiAgICAgICAgICAgICAgICBvblF1ZXVlTm90RW1wdHkoKTtcbiAgICAgICAgICAgICAgICBsYXN0U2FtcGxlPy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2FtcGxlIG9mIHNhbXBsZVF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgdGhyb3coZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG1lZGlhU2FtcGxlc0F0VGltZXN0YW1wcyh0aW1lc3RhbXBzKSB7XG4gICAgICAgIHZhbGlkYXRlQW55SXRlcmFibGUodGltZXN0YW1wcyk7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcEl0ZXJhdG9yID0gdG9Bc3luY0l0ZXJhdG9yKHRpbWVzdGFtcHMpO1xuICAgICAgICBjb25zdCB0aW1lc3RhbXBzT2ZJbnRlcmVzdCA9IFtdO1xuICAgICAgICBjb25zdCBzYW1wbGVRdWV1ZSA9IFtdO1xuICAgICAgICBsZXQgeyBwcm9taXNlOiBxdWV1ZU5vdEVtcHR5LCByZXNvbHZlOiBvblF1ZXVlTm90RW1wdHkgfSA9IHByb21pc2VXaXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIGxldCB7IHByb21pc2U6IHF1ZXVlRGVxdWV1ZSwgcmVzb2x2ZTogb25RdWV1ZURlcXVldWUgfSA9IHByb21pc2VXaXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIGxldCBkZWNvZGVySXNGbHVzaGVkID0gZmFsc2U7XG4gICAgICAgIGxldCB0ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgICAgIC8vIFRoaXMgc3RvcmVzIGVycm9ycyB0aGF0IGFyZSBcIm91dCBvZiBiYW5kXCIgaW4gdGhlIHNlbnNlIHRoYXQgdGhleSBkaWRuJ3Qgb2NjdXIgaW4gdGhlIG5vcm1hbCBmbG93IG9mIHRoaXNcbiAgICAgICAgLy8gbWV0aG9kIGJ1dCBpbnN0ZWFkIGluIGEgZGlmZmVyZW50IGNvbnRleHQuIFRoaXMgZXJyb3Igc2hvdWxkIG5vdCBnbyB1bm5vdGljZWQgYW5kIG11c3QgYmUgYnViYmxlZCB1cCB0b1xuICAgICAgICAvLyB0aGUgY29uc3VtZXIuXG4gICAgICAgIGxldCBvdXRPZkJhbmRFcnJvciA9IG51bGw7XG4gICAgICAgIGNvbnN0IHB1c2hUb1F1ZXVlID0gKHNhbXBsZSkgPT4ge1xuICAgICAgICAgICAgc2FtcGxlUXVldWUucHVzaChzYW1wbGUpO1xuICAgICAgICAgICAgb25RdWV1ZU5vdEVtcHR5KCk7XG4gICAgICAgICAgICAoeyBwcm9taXNlOiBxdWV1ZU5vdEVtcHR5LCByZXNvbHZlOiBvblF1ZXVlTm90RW1wdHkgfSA9IHByb21pc2VXaXRoUmVzb2x2ZXJzKCkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGlzIHRoZSBcInB1bXBcIiBwcm9jZXNzIHRoYXQga2VlcHMgcHVtcGluZyBwYWNrZXRzIGludG8gdGhlIGRlY29kZXJcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXJFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlciA9IGF3YWl0IHRoaXMuX2NyZWF0ZURlY29kZXIoKHNhbXBsZSkgPT4ge1xuICAgICAgICAgICAgICAgIG9uUXVldWVEZXF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHNhbXBsZVVzZXMgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aW1lc3RhbXBzT2ZJbnRlcmVzdC5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgICYmIHNhbXBsZS50aW1lc3RhbXAgLSB0aW1lc3RhbXBzT2ZJbnRlcmVzdFswXSA+IC0xZS0xMCAvLyBHaXZlIGl0IGEgbGl0dGxlIGVwc2lsb25cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlVXNlcysrO1xuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXBzT2ZJbnRlcmVzdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2FtcGxlVXNlcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVVc2VzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsb25lIHRoZSBzYW1wbGUgaWYgd2UgbmVlZCB0byBlbWl0IGl0IG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoVG9RdWV1ZSgoaSA8IHNhbXBsZVVzZXMgLSAxID8gc2FtcGxlLmNsb25lKCkgOiBzYW1wbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFvdXRPZkJhbmRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5zdGFjayA9IGRlY29kZXJFcnJvci5zdGFjazsgLy8gUHJvdmlkZSBhIG1vcmUgdXNlZnVsIHN0YWNrIHRyYWNlXG4gICAgICAgICAgICAgICAgICAgIG91dE9mQmFuZEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIG9uUXVldWVOb3RFbXB0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcGFja2V0U2luayA9IHRoaXMuX2NyZWF0ZVBhY2tldFNpbmsoKTtcbiAgICAgICAgICAgIGxldCBsYXN0UGFja2V0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBsYXN0S2V5UGFja2V0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFRoZSBlbmQgc2VxdWVuY2UgbnVtYmVyIChpbmNsdXNpdmUpIGluIHRoZSBuZXh0IGJhdGNoIG9mIHBhY2tldHMgdGhhdCB3aWxsIGJlIGRlY29kZWQuIFRoZSBiYXRjaCBzdGFydHNcbiAgICAgICAgICAgIC8vIGF0IHRoZSBsYXN0IGtleSBmcmFtZSBhbmQgZ29lcyB1bnRpbCB0aGlzIHNlcXVlbmNlIG51bWJlci5cbiAgICAgICAgICAgIGxldCBtYXhTZXF1ZW5jZU51bWJlciA9IC0xO1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlUGFja2V0cyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnQobGFzdEtleVBhY2tldCk7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgYXQgdGhlIGN1cnJlbnQga2V5IHBhY2tldFxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50UGFja2V0ID0gbGFzdEtleVBhY2tldDtcbiAgICAgICAgICAgICAgICBkZWNvZGVyLmRlY29kZShjdXJyZW50UGFja2V0KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudFBhY2tldC5zZXF1ZW5jZU51bWJlciA8IG1heFNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heFF1ZXVlU2l6ZSA9IGNvbXB1dGVNYXhRdWV1ZVNpemUoc2FtcGxlUXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHNhbXBsZVF1ZXVlLmxlbmd0aCArIGRlY29kZXIuZ2V0RGVjb2RlUXVldWVTaXplKCkgPiBtYXhRdWV1ZVNpemUgJiYgIXRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICh7IHByb21pc2U6IHF1ZXVlRGVxdWV1ZSwgcmVzb2x2ZTogb25RdWV1ZURlcXVldWUgfSA9IHByb21pc2VXaXRoUmVzb2x2ZXJzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcXVldWVEZXF1ZXVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0UGFja2V0ID0gYXdhaXQgcGFja2V0U2luay5nZXROZXh0UGFja2V0KGN1cnJlbnRQYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQobmV4dFBhY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXIuZGVjb2RlKG5leHRQYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFja2V0ID0gbmV4dFBhY2tldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF4U2VxdWVuY2VOdW1iZXIgPSAtMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmbHVzaERlY29kZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGVjb2Rlci5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGV4cGVjdCB0aGlzIGxpc3QgdG8gaGF2ZSBhbnkgZWxlbWVudHMgaW4gaXQgYW55bW9yZSwgYnV0IGluIGNhc2UgaXQgZG9lcywgbGV0J3MgZW1pdFxuICAgICAgICAgICAgICAgIC8vIG51bGxzIGZvciBldmVyeSByZW1haW5pbmcgZWxlbWVudCwgdGhlbiBjbGVhciBpdC5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVzdGFtcHNPZkludGVyZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hUb1F1ZXVlKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aW1lc3RhbXBzT2ZJbnRlcmVzdC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgdGltZXN0YW1wIG9mIHRpbWVzdGFtcEl0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVUaW1lc3RhbXAodGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICBpZiAodGVybWluYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0UGFja2V0ID0gYXdhaXQgcGFja2V0U2luay5nZXRQYWNrZXQodGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlQYWNrZXQgPSB0YXJnZXRQYWNrZXQgJiYgYXdhaXQgcGFja2V0U2luay5nZXRLZXlQYWNrZXQodGltZXN0YW1wLCB7IHZlcmlmeUtleVBhY2tldHM6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXlQYWNrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heFNlcXVlbmNlTnVtYmVyICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVjb2RlUGFja2V0cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZmx1c2hEZWNvZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHVzaFRvUXVldWUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYWNrZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGtleSBwYWNrZXQgaGFzIGNoYW5nZWQgb3IgaWYgd2UncmUgZ29pbmcgYmFjayBpbiB0aW1lXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgJiYgKGtleVBhY2tldC5zZXF1ZW5jZU51bWJlciAhPT0gbGFzdEtleVBhY2tldC5zZXF1ZW5jZU51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgdGFyZ2V0UGFja2V0LnRpbWVzdGFtcCA8IGxhc3RQYWNrZXQudGltZXN0YW1wKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBkZWNvZGVQYWNrZXRzKCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGZsdXNoRGVjb2RlcigpOyAvLyBBbHdheXMgZmx1c2ggaGVyZSwgaW1wcm92ZXMgZGVjb2RlciBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcHNPZkludGVyZXN0LnB1c2godGFyZ2V0UGFja2V0LnRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgbWF4U2VxdWVuY2VOdW1iZXIgPSBNYXRoLm1heCh0YXJnZXRQYWNrZXQuc2VxdWVuY2VOdW1iZXIsIG1heFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICBsYXN0UGFja2V0ID0gdGFyZ2V0UGFja2V0O1xuICAgICAgICAgICAgICAgIGxhc3RLZXlQYWNrZXQgPSBrZXlQYWNrZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4U2VxdWVuY2VOdW1iZXIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHN0aWxsIG5lZWQgdG8gZGVjb2RlIHBhY2tldHNcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVjb2RlUGFja2V0cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBmbHVzaERlY29kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIGRlY29kZXJJc0ZsdXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgb25RdWV1ZU5vdEVtcHR5KCk7IC8vIFRvIHVuc3R1Y2sgdGhlIGdlbmVyYXRvclxuICAgICAgICB9KSgpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFvdXRPZkJhbmRFcnJvcikge1xuICAgICAgICAgICAgICAgIG91dE9mQmFuZEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgb25RdWV1ZU5vdEVtcHR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGVybWluYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG91dE9mQmFuZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBvdXRPZkJhbmRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzYW1wbGVRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHNhbXBsZVF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblF1ZXVlRGVxdWV1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRlY29kZXJJc0ZsdXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHF1ZXVlTm90RW1wdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgcmV0dXJuKCkge1xuICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG9uUXVldWVEZXF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgb25RdWV1ZU5vdEVtcHR5KCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzYW1wbGUgb2Ygc2FtcGxlUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlPy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgdGhyb3coZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5jb25zdCBjb21wdXRlTWF4UXVldWVTaXplID0gKGRlY29kZWRTYW1wbGVRdWV1ZVNpemUpID0+IHtcbiAgICAvLyBJZiB3ZSBoYXZlIGRlY29kZWQgc2FtcGxlcyBseWluZyBhcm91bmQsIGxpbWl0IHRoZSB0b3RhbCBxdWV1ZSBzaXplIHRvIGEgc21hbGwgdmFsdWUgKGRlY29kZWQgc2FtcGxlcyBjYW4gdXNlIHVwXG4gICAgLy8gYSBsb3Qgb2YgbWVtb3J5KS4gSWYgbm90LCB3ZSdyZSBmaW5lIHdpdGggYSBtdWNoIGJpZ2dlciBxdWV1ZSBvZiBlbmNvZGVkIHBhY2tldHMgd2FpdGluZyB0byBiZSBkZWNvZGVkLiBJbiBmYWN0LFxuICAgIC8vIHNvbWUgZGVjb2RlcnMgb25seSBzdGFydCBmbHVzaGluZyBvdXQgZGVjb2RlZCBjaHVua3Mgd2hlbiB0aGUgcGFja2V0IHF1ZXVlIGlzIGxhcmdlIGVub3VnaC5cbiAgICByZXR1cm4gZGVjb2RlZFNhbXBsZVF1ZXVlU2l6ZSA9PT0gMCA/IDQwIDogODtcbn07XG5jbGFzcyBWaWRlb0RlY29kZXJXcmFwcGVyIGV4dGVuZHMgRGVjb2RlcldyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKG9uU2FtcGxlLCBvbkVycm9yLCBjb2RlYywgZGVjb2RlckNvbmZpZywgcm90YXRpb24sIHRpbWVSZXNvbHV0aW9uKSB7XG4gICAgICAgIHN1cGVyKG9uU2FtcGxlLCBvbkVycm9yKTtcbiAgICAgICAgdGhpcy5jb2RlYyA9IGNvZGVjO1xuICAgICAgICB0aGlzLmRlY29kZXJDb25maWcgPSBkZWNvZGVyQ29uZmlnO1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgICAgIHRoaXMudGltZVJlc29sdXRpb24gPSB0aW1lUmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXN0b21EZWNvZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXN0b21EZWNvZGVyQ2FsbFNlcmlhbGl6ZXIgPSBuZXcgQ2FsbFNlcmlhbGl6ZXIoKTtcbiAgICAgICAgdGhpcy5jdXN0b21EZWNvZGVyUXVldWVTaXplID0gMDtcbiAgICAgICAgdGhpcy5pbnB1dFRpbWVzdGFtcHMgPSBbXTsgLy8gVGltZXN0YW1wcyBpbnB1dCBpbnRvIHRoZSBkZWNvZGVyLCBzb3J0ZWQuXG4gICAgICAgIHRoaXMuc2FtcGxlUXVldWUgPSBbXTsgLy8gU2FmYXJpLXNwZWNpZmljIHRoaW5nLCBjaGVjayB1c2FnZS5cbiAgICAgICAgdGhpcy5jdXJyZW50UGFja2V0SW5kZXggPSAwO1xuICAgICAgICB0aGlzLnJhc2xTa2lwcGVkID0gZmFsc2U7IC8vIEZvciBIRVZDIHN0dWZmXG4gICAgICAgIGNvbnN0IE1hdGNoaW5nQ3VzdG9tRGVjb2RlciA9IGN1c3RvbVZpZGVvRGVjb2RlcnMuZmluZCh4ID0+IHguc3VwcG9ydHMoY29kZWMsIGRlY29kZXJDb25maWcpKTtcbiAgICAgICAgaWYgKE1hdGNoaW5nQ3VzdG9tRGVjb2Rlcikge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBcIkNhbid0IGNyZWF0ZSBpbnN0YW5jZSBvZiBhYnN0cmFjdCBjbGFzcyDwn6STXCJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tRGVjb2RlciA9IG5ldyBNYXRjaGluZ0N1c3RvbURlY29kZXIoKTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSXQncyB0ZWNobmljYWxseSByZWFkb25seVxuICAgICAgICAgICAgdGhpcy5jdXN0b21EZWNvZGVyLmNvZGVjID0gY29kZWM7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEl0J3MgdGVjaG5pY2FsbHkgcmVhZG9ubHlcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tRGVjb2Rlci5jb25maWcgPSBkZWNvZGVyQ29uZmlnO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBJdCdzIHRlY2huaWNhbGx5IHJlYWRvbmx5XG4gICAgICAgICAgICB0aGlzLmN1c3RvbURlY29kZXIub25TYW1wbGUgPSAoc2FtcGxlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEoc2FtcGxlIGluc3RhbmNlb2YgVmlkZW9TYW1wbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBhcmd1bWVudCBwYXNzZWQgdG8gb25TYW1wbGUgbXVzdCBiZSBhIFZpZGVvU2FtcGxlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplQW5kRW1pdFNhbXBsZShzYW1wbGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZvaWQgdGhpcy5jdXN0b21EZWNvZGVyQ2FsbFNlcmlhbGl6ZXIuY2FsbCgoKSA9PiB0aGlzLmN1c3RvbURlY29kZXIuaW5pdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNwZWNpZmljIGhhbmRsZXIgZm9yIHRoZSBXZWJDb2RlY3MgVmlkZW9EZWNvZGVyIHRvIGlyb24gb3V0IGJyb3dzZXIgZGlmZmVyZW5jZXNcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUhhbmRsZXIgPSAoc2FtcGxlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGNvcnJlY3QgQi1mcmFtZSBoYW5kbGluZywgd2UgZG9uJ3QganVzdCBoYW5kIG92ZXIgdGhlIGZyYW1lcyBkaXJlY3RseSBidXQgaW5zdGVhZCBhZGQgdGhlbSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBhIHF1ZXVlLCBiZWNhdXNlIHdlIHdhbnQgdG8gZW5zdXJlIGZyYW1lcyBhcmUgZW1pdHRlZCBpbiBwcmVzZW50YXRpb24gb3JkZXIuIFdlIGZsdXNoIHRoZSBxdWV1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBlYWNoIHRpbWUgd2UgcmVjZWl2ZSBhIGZyYW1lIHdpdGggYSB0aW1lc3RhbXAgbGFyZ2VyIHRoYW4gdGhlIGhpZ2hlc3Qgd2UndmUgc2VlbiBzbyBmYXIsIGFzIHdlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbiBzdXJlIHRoYXQgaXMgbm90IGEgQi1mcmFtZS4gVHlwaWNhbGx5LCBXZWJDb2RlY3MgYXV0b21hdGljYWxseSBndWFyYW50ZWVzIHRoYXQgZnJhbWVzIGFyZVxuICAgICAgICAgICAgICAgICAgICAvLyBlbWl0dGVkIGluIHByZXNlbnRhdGlvbiBvcmRlciwgYnV0IFNhZmFyaSBkb2Vzbid0IGFsd2F5cyBmb2xsb3cgdGhpcyBydWxlLlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zYW1wbGVRdWV1ZS5sZW5ndGggPiAwICYmIChzYW1wbGUudGltZXN0YW1wID49IGxhc3QodGhpcy5zYW1wbGVRdWV1ZSkudGltZXN0YW1wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzYW1wbGUgb2YgdGhpcy5zYW1wbGVRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluYWxpemVBbmRFbWl0U2FtcGxlKHNhbXBsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZVF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0U29ydGVkKHRoaXMuc2FtcGxlUXVldWUsIHNhbXBsZSwgeCA9PiB4LnRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ24gaXQgdGhlIG5leHQgZWFybGllc3QgdGltZXN0YW1wIGZyb20gdGhlIGlucHV0LiBXZSBkbyB0aGlzIGJlY2F1c2UgYnJvd3NlcnMsIGJ5IHNwZWMsIGFyZVxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1aXJlZCB0byBlbWl0IGRlY29kZWQgZnJhbWVzIGluIHByZXNlbnRhdGlvbiBvcmRlciAqd2hpbGUqIHJldGFpbmluZyB0aGUgdGltZXN0YW1wIG9mIHRoZWlyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9yaWdpbmF0aW5nIEVuY29kZWRWaWRlb0NodW5rLiBGb3IgZmlsZXMgd2l0aCBCLWZyYW1lcyBidXQgbm8gb3V0LW9mLW9yZGVyIHRpbWVzdGFtcHMgKGxpa2UgYVxuICAgICAgICAgICAgICAgICAgICAvLyBtaXNzaW5nIGN0dHMgYm94LCBmb3IgZXhhbXBsZSksIHRoaXMgY2F1c2VzIGEgbWlzbWF0Y2guIFdlIHRoZXJlZm9yZSBmaXggdGhlIHRpbWVzdGFtcHMgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSB0aGV5IGFyZSBzb3J0ZWQgYnkgZG9pbmcgdGhpcy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gdGhpcy5pbnB1dFRpbWVzdGFtcHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUncyBubyB3YXkgd2UnZCBoYXZlIG1vcmUgZGVjb2RlZCBmcmFtZXMgdGhhbiBlbmNvZGVkIHBhY2tldHMgd2UgcGFzc2VkIGluLiBBY3R1YWxseSwgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmRlbmNlIHNob3VsZCBiZSAxOjEuXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCh0aW1lc3RhbXAgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZS5zZXRUaW1lc3RhbXAodGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZUFuZEVtaXRTYW1wbGUoc2FtcGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IFZpZGVvRGVjb2Rlcih7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiBmcmFtZSA9PiBzYW1wbGVIYW5kbGVyKG5ldyBWaWRlb1NhbXBsZShmcmFtZSkpLFxuICAgICAgICAgICAgICAgIGVycm9yOiBvbkVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZXIuY29uZmlndXJlKGRlY29kZXJDb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmFsaXplQW5kRW1pdFNhbXBsZShzYW1wbGUpIHtcbiAgICAgICAgLy8gUm91bmQgdGhlIHRpbWVzdGFtcHMgdG8gdGhlIHRpbWUgcmVzb2x1dGlvblxuICAgICAgICBzYW1wbGUuc2V0VGltZXN0YW1wKE1hdGgucm91bmQoc2FtcGxlLnRpbWVzdGFtcCAqIHRoaXMudGltZVJlc29sdXRpb24pIC8gdGhpcy50aW1lUmVzb2x1dGlvbik7XG4gICAgICAgIHNhbXBsZS5zZXREdXJhdGlvbihNYXRoLnJvdW5kKHNhbXBsZS5kdXJhdGlvbiAqIHRoaXMudGltZVJlc29sdXRpb24pIC8gdGhpcy50aW1lUmVzb2x1dGlvbik7XG4gICAgICAgIHNhbXBsZS5zZXRSb3RhdGlvbih0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgdGhpcy5vblNhbXBsZShzYW1wbGUpO1xuICAgIH1cbiAgICBnZXREZWNvZGVRdWV1ZVNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbURlY29kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbURlY29kZXJRdWV1ZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5kZWNvZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZXIuZGVjb2RlUXVldWVTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29kZShwYWNrZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29kZWMgPT09ICdoZXZjJyAmJiB0aGlzLmN1cnJlbnRQYWNrZXRJbmRleCA+IDAgJiYgIXRoaXMucmFzbFNraXBwZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIEhFVkMsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRvIHNraXAgYW55IFJBU0wgc2xpY2VzIHRoYXQgZm9sbG93IGEgbm9uLUlEUiBrZXkgZnJhbWUgc3VjaCBhc1xuICAgICAgICAgICAgLy8gQ1JBX05VVC4gVGhpcyBpcyBiZWNhdXNlIFJBU0wgc2xpY2VzIGNhbm5vdCBiZSBkZWNvZGVkIHdpdGhvdXQgZGF0YSBiZWZvcmUgdGhlIENSQV9OVVQuIEJyb3dzZXJzIGJlaGF2ZVxuICAgICAgICAgICAgLy8gZGlmZmVyZW50bHkgaGVyZTogQ2hyb21pdW0gZHJvcHMgdGhlIHBhY2tldHMsIFNhZmFyaSB0aHJvd3MgYSBkZWNvZGVyIGVycm9yLiBFaXRoZXIgd2F5LCBpdCdzIG5vdCBnb29kXG4gICAgICAgICAgICAvLyBhbmQgY2F1c2VzIGJ1Z3MgdXBzdHJlYW0uIFNvLCBsZXQncyB0YWtlIHRoZSBkcm9wcGluZyBpbnRvIG91ciBvd24gaGFuZHMuXG4gICAgICAgICAgICBjb25zdCBuYWxVbml0cyA9IGV4dHJhY3RIZXZjTmFsVW5pdHMocGFja2V0LmRhdGEsIHRoaXMuZGVjb2RlckNvbmZpZyk7XG4gICAgICAgICAgICBjb25zdCBoYXNSYXNsUGljdHVyZSA9IG5hbFVuaXRzLnNvbWUoKHgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gZXh0cmFjdE5hbFVuaXRUeXBlRm9ySGV2Yyh4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gSGV2Y05hbFVuaXRUeXBlLlJBU0xfTiB8fCB0eXBlID09PSBIZXZjTmFsVW5pdFR5cGUuUkFTTF9SO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaGFzUmFzbFBpY3R1cmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIERyb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmFzbFNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFBhY2tldEluZGV4Kys7XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbURlY29kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tRGVjb2RlclF1ZXVlU2l6ZSsrO1xuICAgICAgICAgICAgdm9pZCB0aGlzLmN1c3RvbURlY29kZXJDYWxsU2VyaWFsaXplclxuICAgICAgICAgICAgICAgIC5jYWxsKCgpID0+IHRoaXMuY3VzdG9tRGVjb2Rlci5kZWNvZGUocGFja2V0KSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLmN1c3RvbURlY29kZXJRdWV1ZVNpemUtLSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5kZWNvZGVyKTtcbiAgICAgICAgICAgIGlmICghaXNTYWZhcmkoKSkge1xuICAgICAgICAgICAgICAgIGluc2VydFNvcnRlZCh0aGlzLmlucHV0VGltZXN0YW1wcywgcGFja2V0LnRpbWVzdGFtcCwgeCA9PiB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVjb2Rlci5kZWNvZGUocGFja2V0LnRvRW5jb2RlZFZpZGVvQ2h1bmsoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbURlY29kZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3VzdG9tRGVjb2RlckNhbGxTZXJpYWxpemVyLmNhbGwoKCkgPT4gdGhpcy5jdXN0b21EZWNvZGVyLmZsdXNoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMuZGVjb2Rlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRlY29kZXIuZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTYWZhcmkoKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzYW1wbGUgb2YgdGhpcy5zYW1wbGVRdWV1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluYWxpemVBbmRFbWl0U2FtcGxlKHNhbXBsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNhbXBsZVF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50UGFja2V0SW5kZXggPSAwO1xuICAgICAgICB0aGlzLnJhc2xTa2lwcGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXN0b21EZWNvZGVyKSB7XG4gICAgICAgICAgICB2b2lkIHRoaXMuY3VzdG9tRGVjb2RlckNhbGxTZXJpYWxpemVyLmNhbGwoKCkgPT4gdGhpcy5jdXN0b21EZWNvZGVyLmNsb3NlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMuZGVjb2Rlcik7XG4gICAgICAgICAgICB0aGlzLmRlY29kZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHNhbXBsZSBvZiB0aGlzLnNhbXBsZVF1ZXVlKSB7XG4gICAgICAgICAgICBzYW1wbGUuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNhbXBsZVF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgfVxufVxuLyoqXG4gKiBBIHNpbmsgdGhhdCByZXRyaWV2ZXMgZGVjb2RlZCB2aWRlbyBzYW1wbGVzICh2aWRlbyBmcmFtZXMpIGZyb20gYSB2aWRlbyB0cmFjay5cbiAqIEBncm91cCBNZWRpYSBzaW5rc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgVmlkZW9TYW1wbGVTaW5rIGV4dGVuZHMgQmFzZU1lZGlhU2FtcGxlU2luayB7XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFZpZGVvU2FtcGxlU2lua30gZm9yIHRoZSBnaXZlbiB7QGxpbmsgSW5wdXRWaWRlb1RyYWNrfS4gKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWRlb1RyYWNrKSB7XG4gICAgICAgIGlmICghKHZpZGVvVHJhY2sgaW5zdGFuY2VvZiBJbnB1dFZpZGVvVHJhY2spKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2aWRlb1RyYWNrIG11c3QgYmUgYW4gSW5wdXRWaWRlb1RyYWNrLicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3ZpZGVvVHJhY2sgPSB2aWRlb1RyYWNrO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgYXN5bmMgX2NyZWF0ZURlY29kZXIob25TYW1wbGUsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fdmlkZW9UcmFjay5jYW5EZWNvZGUoKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB2aWRlbyB0cmFjayBjYW5ub3QgYmUgZGVjb2RlZCBieSB0aGlzIGJyb3dzZXIuIE1ha2Ugc3VyZSB0byBjaGVjayBkZWNvZGFiaWxpdHkgYmVmb3JlIHVzaW5nJ1xuICAgICAgICAgICAgICAgICsgJyBhIHRyYWNrLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGVjID0gdGhpcy5fdmlkZW9UcmFjay5jb2RlYztcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLl92aWRlb1RyYWNrLnJvdGF0aW9uO1xuICAgICAgICBjb25zdCBkZWNvZGVyQ29uZmlnID0gYXdhaXQgdGhpcy5fdmlkZW9UcmFjay5nZXREZWNvZGVyQ29uZmlnKCk7XG4gICAgICAgIGNvbnN0IHRpbWVSZXNvbHV0aW9uID0gdGhpcy5fdmlkZW9UcmFjay50aW1lUmVzb2x1dGlvbjtcbiAgICAgICAgYXNzZXJ0KGNvZGVjICYmIGRlY29kZXJDb25maWcpO1xuICAgICAgICByZXR1cm4gbmV3IFZpZGVvRGVjb2RlcldyYXBwZXIob25TYW1wbGUsIG9uRXJyb3IsIGNvZGVjLCBkZWNvZGVyQ29uZmlnLCByb3RhdGlvbiwgdGltZVJlc29sdXRpb24pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2NyZWF0ZVBhY2tldFNpbmsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW5jb2RlZFBhY2tldFNpbmsodGhpcy5fdmlkZW9UcmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmlkZW8gc2FtcGxlIChmcmFtZSkgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gdGltZXN0YW1wLCBpbiBzZWNvbmRzLiBNb3JlIHNwZWNpZmljYWxseSwgcmV0dXJuc1xuICAgICAqIHRoZSBsYXN0IHZpZGVvIHNhbXBsZSAoaW4gcHJlc2VudGF0aW9uIG9yZGVyKSB3aXRoIGEgc3RhcnQgdGltZXN0YW1wIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gdGltZXN0YW1wLlxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGUgdGltZXN0YW1wIGlzIGJlZm9yZSB0aGUgdHJhY2sncyBmaXJzdCB0aW1lc3RhbXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gVGhlIHRpbWVzdGFtcCB1c2VkIGZvciByZXRyaWV2YWwsIGluIHNlY29uZHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2FtcGxlKHRpbWVzdGFtcCkge1xuICAgICAgICB2YWxpZGF0ZVRpbWVzdGFtcCh0aW1lc3RhbXApO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHNhbXBsZSBvZiB0aGlzLm1lZGlhU2FtcGxlc0F0VGltZXN0YW1wcyhbdGltZXN0YW1wXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBlcnJvcjogSXRlcmF0b3IgcmV0dXJuZWQgbm90aGluZy4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhc3luYyBpdGVyYXRvciB0aGF0IHlpZWxkcyB0aGUgdmlkZW8gc2FtcGxlcyAoZnJhbWVzKSBvZiB0aGlzIHRyYWNrIGluIHByZXNlbnRhdGlvbiBvcmRlci4gVGhpcyBtZXRob2RcbiAgICAgKiB3aWxsIGludGVsbGlnZW50bHkgcHJlLWRlY29kZSBhIGZldyBmcmFtZXMgYWhlYWQgdG8gZW5hYmxlIGZhc3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0VGltZXN0YW1wIC0gVGhlIHRpbWVzdGFtcCBpbiBzZWNvbmRzIGF0IHdoaWNoIHRvIHN0YXJ0IHlpZWxkaW5nIHNhbXBsZXMgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIGVuZFRpbWVzdGFtcCAtIFRoZSB0aW1lc3RhbXAgaW4gc2Vjb25kcyBhdCB3aGljaCB0byBzdG9wIHlpZWxkaW5nIHNhbXBsZXMgKGV4Y2x1c2l2ZSkuXG4gICAgICovXG4gICAgc2FtcGxlcyhzdGFydFRpbWVzdGFtcCA9IDAsIGVuZFRpbWVzdGFtcCA9IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhU2FtcGxlc0luUmFuZ2Uoc3RhcnRUaW1lc3RhbXAsIGVuZFRpbWVzdGFtcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXN5bmMgaXRlcmF0b3IgdGhhdCB5aWVsZHMgYSB2aWRlbyBzYW1wbGUgKGZyYW1lKSBmb3IgZWFjaCB0aW1lc3RhbXAgaW4gdGhlIGFyZ3VtZW50LiBUaGlzIG1ldGhvZFxuICAgICAqIHVzZXMgYW4gb3B0aW1pemVkIGRlY29kaW5nIHBpcGVsaW5lIGlmIHRoZXNlIHRpbWVzdGFtcHMgYXJlIG1vbm90b25pY2FsbHkgc29ydGVkLCBkZWNvZGluZyBlYWNoIHBhY2tldCBhdCBtb3N0XG4gICAgICogb25jZSwgYW5kIGlzIHRoZXJlZm9yZSBtb3JlIGVmZmljaWVudCB0aGFuIG1hbnVhbGx5IGdldHRpbmcgdGhlIHNhbXBsZSBmb3IgZXZlcnkgdGltZXN0YW1wLiBUaGUgaXRlcmF0b3IgbWF5XG4gICAgICogeWllbGQgbnVsbCBpZiBubyBmcmFtZSBpcyBhdmFpbGFibGUgZm9yIGEgZ2l2ZW4gdGltZXN0YW1wLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRpbWVzdGFtcHMgLSBBbiBpdGVyYWJsZSBvciBhc3luYyBpdGVyYWJsZSBvZiB0aW1lc3RhbXBzIGluIHNlY29uZHMuXG4gICAgICovXG4gICAgc2FtcGxlc0F0VGltZXN0YW1wcyh0aW1lc3RhbXBzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhU2FtcGxlc0F0VGltZXN0YW1wcyh0aW1lc3RhbXBzKTtcbiAgICB9XG59XG4vKipcbiAqIEEgc2luayB0aGF0IHJlbmRlcnMgdmlkZW8gc2FtcGxlcyAoZnJhbWVzKSBvZiB0aGUgZ2l2ZW4gdmlkZW8gdHJhY2sgdG8gY2FudmFzZXMuIFRoaXMgaXMgb2Z0ZW4gbW9yZSB1c2VmdWwgdGhhblxuICogZGlyZWN0bHkgcmV0cmlldmluZyBmcmFtZXMsIGFzIGl0IGNvbWVzIHdpdGggY29tbW9uIHByZXByb2Nlc3Npbmcgc3RlcHMgc3VjaCBhcyByZXNpemluZyBvciBhcHBseWluZyByb3RhdGlvblxuICogbWV0YWRhdGEuXG4gKlxuICogVGhpcyBzaW5rIHdpbGwgeWllbGQgYEhUTUxDYW52YXNFbGVtZW50YHMgd2hlbiBpbiBhIERPTSBjb250ZXh0LCBhbmQgYE9mZnNjcmVlbkNhbnZhc2BlcyBvdGhlcndpc2UuXG4gKlxuICogQGdyb3VwIE1lZGlhIHNpbmtzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBDYW52YXNTaW5rIHtcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgQ2FudmFzU2lua30gZm9yIHRoZSBnaXZlbiB7QGxpbmsgSW5wdXRWaWRlb1RyYWNrfS4gKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWRlb1RyYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9uZXh0Q2FudmFzSW5kZXggPSAwO1xuICAgICAgICBpZiAoISh2aWRlb1RyYWNrIGluc3RhbmNlb2YgSW5wdXRWaWRlb1RyYWNrKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmlkZW9UcmFjayBtdXN0IGJlIGFuIElucHV0VmlkZW9UcmFjay4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggIT09IHVuZGVmaW5lZCAmJiAoIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy53aWR0aCkgfHwgb3B0aW9ucy53aWR0aCA8PSAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy53aWR0aCwgd2hlbiBkZWZpbmVkLCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCAmJiAoIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5oZWlnaHQpIHx8IG9wdGlvbnMuaGVpZ2h0IDw9IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLmhlaWdodCwgd2hlbiBkZWZpbmVkLCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5maXQgIT09IHVuZGVmaW5lZCAmJiAhWydmaWxsJywgJ2NvbnRhaW4nLCAnY292ZXInXS5pbmNsdWRlcyhvcHRpb25zLmZpdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuZml0LCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIG9uZSBvZiBcImZpbGxcIiwgXCJjb250YWluXCIsIG9yIFwiY292ZXJcIi4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAmJiBvcHRpb25zLmhlaWdodCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAmJiBvcHRpb25zLmZpdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaGVuIGJvdGggb3B0aW9ucy53aWR0aCBhbmQgb3B0aW9ucy5oZWlnaHQgYXJlIHByb3ZpZGVkLCBvcHRpb25zLmZpdCBtdXN0IGFsc28gYmUgcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucm90YXRpb24gIT09IHVuZGVmaW5lZCAmJiAhWzAsIDkwLCAxODAsIDI3MF0uaW5jbHVkZXMob3B0aW9ucy5yb3RhdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMucm90YXRpb24sIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgMCwgOTAsIDE4MCBvciAyNzAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucG9vbFNpemUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvcHRpb25zLnBvb2xTaXplICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLnBvb2xTaXplKSB8fCBvcHRpb25zLnBvb2xTaXplIDwgMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Bvb2xTaXplIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb24gPz8gdmlkZW9UcmFjay5yb3RhdGlvbjtcbiAgICAgICAgbGV0IFt3aWR0aCwgaGVpZ2h0XSA9IHJvdGF0aW9uICUgMTgwID09PSAwXG4gICAgICAgICAgICA/IFt2aWRlb1RyYWNrLmNvZGVkV2lkdGgsIHZpZGVvVHJhY2suY29kZWRIZWlnaHRdXG4gICAgICAgICAgICA6IFt2aWRlb1RyYWNrLmNvZGVkSGVpZ2h0LCB2aWRlb1RyYWNrLmNvZGVkV2lkdGhdO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEFzcGVjdFJhdGlvID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICAgIC8vIElmIHdpZHRoIGFuZCBoZWlnaHQgYXJlbid0IGRlZmluZWQgdG9nZXRoZXIsIGRlZHVjZSB0aGUgbWlzc2luZyB2YWx1ZSB1c2luZyB0aGUgYXNwZWN0IHJhdGlvXG4gICAgICAgIGlmIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5oZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5yb3VuZCh3aWR0aCAvIG9yaWdpbmFsQXNwZWN0UmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMud2lkdGggPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5yb3VuZChoZWlnaHQgKiBvcmlnaW5hbEFzcGVjdFJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlkZW9UcmFjayA9IHZpZGVvVHJhY2s7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fcm90YXRpb24gPSByb3RhdGlvbjtcbiAgICAgICAgdGhpcy5fZml0ID0gb3B0aW9ucy5maXQgPz8gJ2ZpbGwnO1xuICAgICAgICB0aGlzLl92aWRlb1NhbXBsZVNpbmsgPSBuZXcgVmlkZW9TYW1wbGVTaW5rKHZpZGVvVHJhY2spO1xuICAgICAgICB0aGlzLl9jYW52YXNQb29sID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogb3B0aW9ucy5wb29sU2l6ZSA/PyAwIH0sICgpID0+IG51bGwpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3ZpZGVvU2FtcGxlVG9XcmFwcGVkQ2FudmFzKHNhbXBsZSkge1xuICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5fY2FudmFzUG9vbFt0aGlzLl9uZXh0Q2FudmFzSW5kZXhdO1xuICAgICAgICBsZXQgY2FudmFzSXNOZXcgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJlZmVyIGFuIEhUTUxDYW52YXNFbGVtZW50XG4gICAgICAgICAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXModGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FudmFzUG9vbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzUG9vbFt0aGlzLl9uZXh0Q2FudmFzSW5kZXhdID0gY2FudmFzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FudmFzSXNOZXcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYW52YXNQb29sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX25leHRDYW52YXNJbmRleCA9ICh0aGlzLl9uZXh0Q2FudmFzSW5kZXggKyAxKSAlIHRoaXMuX2NhbnZhc1Bvb2wubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7IGFscGhhOiBmYWxzZSB9KTtcbiAgICAgICAgYXNzZXJ0KGNvbnRleHQpO1xuICAgICAgICBjb250ZXh0LnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgICAgIGlmICghY2FudmFzSXNOZXcpIHtcbiAgICAgICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHNhbXBsZS5kcmF3V2l0aEZpdChjb250ZXh0LCB7XG4gICAgICAgICAgICBmaXQ6IHRoaXMuX2ZpdCxcbiAgICAgICAgICAgIHJvdGF0aW9uOiB0aGlzLl9yb3RhdGlvbixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGNhbnZhcyxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogc2FtcGxlLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBzYW1wbGUuZHVyYXRpb24sXG4gICAgICAgIH07XG4gICAgICAgIHNhbXBsZS5jbG9zZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBjYW52YXMgd2l0aCB0aGUgdmlkZW8gZnJhbWUgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gdGltZXN0YW1wLCBpbiBzZWNvbmRzLiBNb3JlIHNwZWNpZmljYWxseSxcbiAgICAgKiByZXR1cm5zIHRoZSBsYXN0IHZpZGVvIGZyYW1lIChpbiBwcmVzZW50YXRpb24gb3JkZXIpIHdpdGggYSBzdGFydCB0aW1lc3RhbXAgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlblxuICAgICAqIHRpbWVzdGFtcC4gUmV0dXJucyBudWxsIGlmIHRoZSB0aW1lc3RhbXAgaXMgYmVmb3JlIHRoZSB0cmFjaydzIGZpcnN0IHRpbWVzdGFtcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lc3RhbXAgLSBUaGUgdGltZXN0YW1wIHVzZWQgZm9yIHJldHJpZXZhbCwgaW4gc2Vjb25kcy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDYW52YXModGltZXN0YW1wKSB7XG4gICAgICAgIHZhbGlkYXRlVGltZXN0YW1wKHRpbWVzdGFtcCk7XG4gICAgICAgIGNvbnN0IHNhbXBsZSA9IGF3YWl0IHRoaXMuX3ZpZGVvU2FtcGxlU2luay5nZXRTYW1wbGUodGltZXN0YW1wKTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZSAmJiB0aGlzLl92aWRlb1NhbXBsZVRvV3JhcHBlZENhbnZhcyhzYW1wbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFzeW5jIGl0ZXJhdG9yIHRoYXQgeWllbGRzIGNhbnZhc2VzIHdpdGggdGhlIHZpZGVvIGZyYW1lcyBvZiB0aGlzIHRyYWNrIGluIHByZXNlbnRhdGlvbiBvcmRlci4gVGhpc1xuICAgICAqIG1ldGhvZCB3aWxsIGludGVsbGlnZW50bHkgcHJlLWRlY29kZSBhIGZldyBmcmFtZXMgYWhlYWQgdG8gZW5hYmxlIGZhc3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0VGltZXN0YW1wIC0gVGhlIHRpbWVzdGFtcCBpbiBzZWNvbmRzIGF0IHdoaWNoIHRvIHN0YXJ0IHlpZWxkaW5nIGNhbnZhc2VzIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSBlbmRUaW1lc3RhbXAgLSBUaGUgdGltZXN0YW1wIGluIHNlY29uZHMgYXQgd2hpY2ggdG8gc3RvcCB5aWVsZGluZyBjYW52YXNlcyAoZXhjbHVzaXZlKS5cbiAgICAgKi9cbiAgICBjYW52YXNlcyhzdGFydFRpbWVzdGFtcCA9IDAsIGVuZFRpbWVzdGFtcCA9IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBtYXBBc3luY0dlbmVyYXRvcih0aGlzLl92aWRlb1NhbXBsZVNpbmsuc2FtcGxlcyhzdGFydFRpbWVzdGFtcCwgZW5kVGltZXN0YW1wKSwgc2FtcGxlID0+IHRoaXMuX3ZpZGVvU2FtcGxlVG9XcmFwcGVkQ2FudmFzKHNhbXBsZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFzeW5jIGl0ZXJhdG9yIHRoYXQgeWllbGRzIGEgY2FudmFzIGZvciBlYWNoIHRpbWVzdGFtcCBpbiB0aGUgYXJndW1lbnQuIFRoaXMgbWV0aG9kIHVzZXMgYW4gb3B0aW1pemVkXG4gICAgICogZGVjb2RpbmcgcGlwZWxpbmUgaWYgdGhlc2UgdGltZXN0YW1wcyBhcmUgbW9ub3RvbmljYWxseSBzb3J0ZWQsIGRlY29kaW5nIGVhY2ggcGFja2V0IGF0IG1vc3Qgb25jZSwgYW5kIGlzXG4gICAgICogdGhlcmVmb3JlIG1vcmUgZWZmaWNpZW50IHRoYW4gbWFudWFsbHkgZ2V0dGluZyB0aGUgY2FudmFzIGZvciBldmVyeSB0aW1lc3RhbXAuIFRoZSBpdGVyYXRvciBtYXkgeWllbGQgbnVsbCBpZlxuICAgICAqIG5vIGZyYW1lIGlzIGF2YWlsYWJsZSBmb3IgYSBnaXZlbiB0aW1lc3RhbXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGltZXN0YW1wcyAtIEFuIGl0ZXJhYmxlIG9yIGFzeW5jIGl0ZXJhYmxlIG9mIHRpbWVzdGFtcHMgaW4gc2Vjb25kcy5cbiAgICAgKi9cbiAgICBjYW52YXNlc0F0VGltZXN0YW1wcyh0aW1lc3RhbXBzKSB7XG4gICAgICAgIHJldHVybiBtYXBBc3luY0dlbmVyYXRvcih0aGlzLl92aWRlb1NhbXBsZVNpbmsuc2FtcGxlc0F0VGltZXN0YW1wcyh0aW1lc3RhbXBzKSwgc2FtcGxlID0+IHNhbXBsZSAmJiB0aGlzLl92aWRlb1NhbXBsZVRvV3JhcHBlZENhbnZhcyhzYW1wbGUpKTtcbiAgICB9XG59XG5jbGFzcyBBdWRpb0RlY29kZXJXcmFwcGVyIGV4dGVuZHMgRGVjb2RlcldyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKG9uU2FtcGxlLCBvbkVycm9yLCBjb2RlYywgZGVjb2RlckNvbmZpZykge1xuICAgICAgICBzdXBlcihvblNhbXBsZSwgb25FcnJvcik7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VzdG9tRGVjb2RlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VzdG9tRGVjb2RlckNhbGxTZXJpYWxpemVyID0gbmV3IENhbGxTZXJpYWxpemVyKCk7XG4gICAgICAgIHRoaXMuY3VzdG9tRGVjb2RlclF1ZXVlU2l6ZSA9IDA7XG4gICAgICAgIC8vIEludGVybmFsIHN0YXRlIHRvIGFjY3VtdWxhdGUgYSBwcmVjaXNlIGN1cnJlbnQgdGltZXN0YW1wIGJhc2VkIG9uIGF1ZGlvIGR1cmF0aW9ucywgbm90IHRoZSAocG90ZW50aWFsbHlcbiAgICAgICAgLy8gaW5hY2N1cmF0ZSkgcGFja2V0IHRpbWVzdGFtcHMuXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHNhbXBsZUhhbmRsZXIgPSAoc2FtcGxlKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50VGltZXN0YW1wID09PSBudWxsXG4gICAgICAgICAgICAgICAgfHwgTWF0aC5hYnMoc2FtcGxlLnRpbWVzdGFtcCAtIHRoaXMuY3VycmVudFRpbWVzdGFtcCkgPj0gc2FtcGxlLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBzeW5jIHdpdGggdGhlIHNhbXBsZSB0aW1lc3RhbXAgYWdhaW5cbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lc3RhbXAgPSBzYW1wbGUudGltZXN0YW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJlY2lzZVRpbWVzdGFtcCA9IHRoaXMuY3VycmVudFRpbWVzdGFtcDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWVzdGFtcCArPSBzYW1wbGUuZHVyYXRpb247XG4gICAgICAgICAgICBpZiAoc2FtcGxlLm51bWJlck9mRnJhbWVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2tpcCB6ZXJvLWRhdGEgKGVtcHR5KSBBdWRpb1NhbXBsZXMuIFRoZXNlIGFyZSBzb21ldGltZXMgZW1pdHRlZCwgZm9yIGV4YW1wbGUsIGJ5IEZpcmVmb3ggd2hlbiBpdFxuICAgICAgICAgICAgICAgIC8vIGRlY29kZXMgVm9yYmlzIChhdCB0aGUgc3RhcnQpLlxuICAgICAgICAgICAgICAgIHNhbXBsZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJvdW5kIHRoZSB0aW1lc3RhbXAgdG8gdGhlIHNhbXBsZSByYXRlXG4gICAgICAgICAgICBjb25zdCBzYW1wbGVSYXRlID0gZGVjb2RlckNvbmZpZy5zYW1wbGVSYXRlO1xuICAgICAgICAgICAgc2FtcGxlLnNldFRpbWVzdGFtcChNYXRoLnJvdW5kKHByZWNpc2VUaW1lc3RhbXAgKiBzYW1wbGVSYXRlKSAvIHNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgb25TYW1wbGUoc2FtcGxlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgTWF0Y2hpbmdDdXN0b21EZWNvZGVyID0gY3VzdG9tQXVkaW9EZWNvZGVycy5maW5kKHggPT4geC5zdXBwb3J0cyhjb2RlYywgZGVjb2RlckNvbmZpZykpO1xuICAgICAgICBpZiAoTWF0Y2hpbmdDdXN0b21EZWNvZGVyKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFwiQ2FuJ3QgY3JlYXRlIGluc3RhbmNlIG9mIGFic3RyYWN0IGNsYXNzIPCfpJNcIlxuICAgICAgICAgICAgdGhpcy5jdXN0b21EZWNvZGVyID0gbmV3IE1hdGNoaW5nQ3VzdG9tRGVjb2RlcigpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBJdCdzIHRlY2huaWNhbGx5IHJlYWRvbmx5XG4gICAgICAgICAgICB0aGlzLmN1c3RvbURlY29kZXIuY29kZWMgPSBjb2RlYztcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSXQncyB0ZWNobmljYWxseSByZWFkb25seVxuICAgICAgICAgICAgdGhpcy5jdXN0b21EZWNvZGVyLmNvbmZpZyA9IGRlY29kZXJDb25maWc7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEl0J3MgdGVjaG5pY2FsbHkgcmVhZG9ubHlcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tRGVjb2Rlci5vblNhbXBsZSA9IChzYW1wbGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIShzYW1wbGUgaW5zdGFuY2VvZiBBdWRpb1NhbXBsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGFyZ3VtZW50IHBhc3NlZCB0byBvblNhbXBsZSBtdXN0IGJlIGFuIEF1ZGlvU2FtcGxlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzYW1wbGVIYW5kbGVyKHNhbXBsZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdm9pZCB0aGlzLmN1c3RvbURlY29kZXJDYWxsU2VyaWFsaXplci5jYWxsKCgpID0+IHRoaXMuY3VzdG9tRGVjb2Rlci5pbml0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IEF1ZGlvRGVjb2Rlcih7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiBkYXRhID0+IHNhbXBsZUhhbmRsZXIobmV3IEF1ZGlvU2FtcGxlKGRhdGEpKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogb25FcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVyLmNvbmZpZ3VyZShkZWNvZGVyQ29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREZWNvZGVRdWV1ZVNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbURlY29kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbURlY29kZXJRdWV1ZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5kZWNvZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZXIuZGVjb2RlUXVldWVTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29kZShwYWNrZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tRGVjb2Rlcikge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21EZWNvZGVyUXVldWVTaXplKys7XG4gICAgICAgICAgICB2b2lkIHRoaXMuY3VzdG9tRGVjb2RlckNhbGxTZXJpYWxpemVyXG4gICAgICAgICAgICAgICAgLmNhbGwoKCkgPT4gdGhpcy5jdXN0b21EZWNvZGVyLmRlY29kZShwYWNrZXQpKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuY3VzdG9tRGVjb2RlclF1ZXVlU2l6ZS0tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLmRlY29kZXIpO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVyLmRlY29kZShwYWNrZXQudG9FbmNvZGVkQXVkaW9DaHVuaygpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tRGVjb2Rlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tRGVjb2RlckNhbGxTZXJpYWxpemVyLmNhbGwoKCkgPT4gdGhpcy5jdXN0b21EZWNvZGVyLmZsdXNoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMuZGVjb2Rlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVyLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbURlY29kZXIpIHtcbiAgICAgICAgICAgIHZvaWQgdGhpcy5jdXN0b21EZWNvZGVyQ2FsbFNlcmlhbGl6ZXIuY2FsbCgoKSA9PiB0aGlzLmN1c3RvbURlY29kZXIuY2xvc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5kZWNvZGVyKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2Rlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gVGhlcmUgYXJlIGEgbG90IG9mIFBDTSB2YXJpYW50cyBub3QgbmF0aXZlbHkgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyIGFuZCBieSBBdWRpb0RhdGEuIFRoZXJlZm9yZSB3ZSBuZWVkIGEgc2ltcGxlXG4vLyBkZWNvZGVyIHRoYXQgbWFwcyBhbnkgaW5wdXQgUENNIGZvcm1hdCBpbnRvIGEgUENNIGZvcm1hdCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuXG5jbGFzcyBQY21BdWRpb0RlY29kZXJXcmFwcGVyIGV4dGVuZHMgRGVjb2RlcldyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKG9uU2FtcGxlLCBvbkVycm9yLCBkZWNvZGVyQ29uZmlnKSB7XG4gICAgICAgIHN1cGVyKG9uU2FtcGxlLCBvbkVycm9yKTtcbiAgICAgICAgdGhpcy5kZWNvZGVyQ29uZmlnID0gZGVjb2RlckNvbmZpZztcbiAgICAgICAgLy8gSW50ZXJuYWwgc3RhdGUgdG8gYWNjdW11bGF0ZSBhIHByZWNpc2UgY3VycmVudCB0aW1lc3RhbXAgYmFzZWQgb24gYXVkaW8gZHVyYXRpb25zLCBub3QgdGhlIChwb3RlbnRpYWxseVxuICAgICAgICAvLyBpbmFjY3VyYXRlKSBwYWNrZXQgdGltZXN0YW1wcy5cbiAgICAgICAgdGhpcy5jdXJyZW50VGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgYXNzZXJ0KFBDTV9BVURJT19DT0RFQ1MuaW5jbHVkZXMoZGVjb2RlckNvbmZpZy5jb2RlYykpO1xuICAgICAgICB0aGlzLmNvZGVjID0gZGVjb2RlckNvbmZpZy5jb2RlYztcbiAgICAgICAgY29uc3QgeyBkYXRhVHlwZSwgc2FtcGxlU2l6ZSwgbGl0dGxlRW5kaWFuIH0gPSBwYXJzZVBjbUNvZGVjKHRoaXMuY29kZWMpO1xuICAgICAgICB0aGlzLmlucHV0U2FtcGxlU2l6ZSA9IHNhbXBsZVNpemU7XG4gICAgICAgIHN3aXRjaCAoc2FtcGxlU2l6ZSkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFUeXBlID09PSAndW5zaWduZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRJbnB1dFZhbHVlID0gKHZpZXcsIGJ5dGVPZmZzZXQpID0+IHZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCkgLSAyICoqIDc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVR5cGUgPT09ICdzaWduZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRJbnB1dFZhbHVlID0gKHZpZXcsIGJ5dGVPZmZzZXQpID0+IHZpZXcuZ2V0SW50OChieXRlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhVHlwZSA9PT0gJ3VsYXcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRJbnB1dFZhbHVlID0gKHZpZXcsIGJ5dGVPZmZzZXQpID0+IGZyb21VbGF3KHZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFUeXBlID09PSAnYWxhdycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZElucHV0VmFsdWUgPSAodmlldywgYnl0ZU9mZnNldCkgPT4gZnJvbUFsYXcodmlldy5nZXRVaW50OChieXRlT2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVHlwZSA9PT0gJ3Vuc2lnbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkSW5wdXRWYWx1ZSA9ICh2aWV3LCBieXRlT2Zmc2V0KSA9PiB2aWV3LmdldFVpbnQxNihieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIC0gMiAqKiAxNTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhVHlwZSA9PT0gJ3NpZ25lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZElucHV0VmFsdWUgPSAodmlldywgYnl0ZU9mZnNldCkgPT4gdmlldy5nZXRJbnQxNihieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVR5cGUgPT09ICd1bnNpZ25lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZElucHV0VmFsdWUgPSAodmlldywgYnl0ZU9mZnNldCkgPT4gZ2V0VWludDI0KHZpZXcsIGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikgLSAyICoqIDIzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFUeXBlID09PSAnc2lnbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkSW5wdXRWYWx1ZSA9ICh2aWV3LCBieXRlT2Zmc2V0KSA9PiBnZXRJbnQyNCh2aWV3LCBieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVR5cGUgPT09ICd1bnNpZ25lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZElucHV0VmFsdWUgPSAodmlldywgYnl0ZU9mZnNldCkgPT4gdmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSAtIDIgKiogMzE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVR5cGUgPT09ICdzaWduZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRJbnB1dFZhbHVlID0gKHZpZXcsIGJ5dGVPZmZzZXQpID0+IHZpZXcuZ2V0SW50MzIoYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhVHlwZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkSW5wdXRWYWx1ZSA9ICh2aWV3LCBieXRlT2Zmc2V0KSA9PiB2aWV3LmdldEZsb2F0MzIoYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFUeXBlID09PSAnZmxvYXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRJbnB1dFZhbHVlID0gKHZpZXcsIGJ5dGVPZmZzZXQpID0+IHZpZXcuZ2V0RmxvYXQ2NChieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TmV2ZXIoc2FtcGxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHNhbXBsZVNpemUpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVHlwZSA9PT0gJ3VsYXcnIHx8IGRhdGFUeXBlID09PSAnYWxhdycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U2FtcGxlU2l6ZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEZvcm1hdCA9ICdzMTYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZU91dHB1dFZhbHVlID0gKHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlKSA9PiB2aWV3LnNldEludDE2KGJ5dGVPZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U2FtcGxlU2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEZvcm1hdCA9ICd1OCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlT3V0cHV0VmFsdWUgPSAodmlldywgYnl0ZU9mZnNldCwgdmFsdWUpID0+IHZpZXcuc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUgKyAyICoqIDcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U2FtcGxlU2l6ZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0Rm9ybWF0ID0gJ3MxNic7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVPdXRwdXRWYWx1ZSA9ICh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSkgPT4gdmlldy5zZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U2FtcGxlU2l6ZSA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0Rm9ybWF0ID0gJ3MzMic7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZyb20gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmNvZGVjczpcbiAgICAgICAgICAgICAgICAgICAgLy8gQXVkaW9EYXRhIGNvbnRhaW5pbmcgMjQtYml0IHNhbXBsZXMgU0hPVUxEIHN0b3JlIHRob3NlIHNhbXBsZXMgaW4gczMyIG9yIGYzMi4gV2hlbiBzYW1wbGVzIGFyZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZWQgaW4gczMyLCBlYWNoIHNhbXBsZSBNVVNUIGJlIGxlZnQtc2hpZnRlZCBieSA4IGJpdHMuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVPdXRwdXRWYWx1ZSA9ICh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSkgPT4gdmlldy5zZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSA8PCA4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTYW1wbGVTaXplID0gNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFUeXBlID09PSAnZmxvYXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEZvcm1hdCA9ICdmMzInO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZU91dHB1dFZhbHVlID0gKHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlKSA9PiB2aWV3LnNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRGb3JtYXQgPSAnczMyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVPdXRwdXRWYWx1ZSA9ICh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSkgPT4gdmlldy5zZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTYW1wbGVTaXplID0gNDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRGb3JtYXQgPSAnZjMyJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZU91dHB1dFZhbHVlID0gKHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlKSA9PiB2aWV3LnNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TmV2ZXIoc2FtcGxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgfVxuICAgIGdldERlY29kZVF1ZXVlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGRlY29kZShwYWNrZXQpIHtcbiAgICAgICAgY29uc3QgaW5wdXRWaWV3ID0gdG9EYXRhVmlldyhwYWNrZXQuZGF0YSk7XG4gICAgICAgIGNvbnN0IG51bWJlck9mRnJhbWVzID0gcGFja2V0LmJ5dGVMZW5ndGggLyB0aGlzLmRlY29kZXJDb25maWcubnVtYmVyT2ZDaGFubmVscyAvIHRoaXMuaW5wdXRTYW1wbGVTaXplO1xuICAgICAgICBjb25zdCBvdXRwdXRCdWZmZXJTaXplID0gbnVtYmVyT2ZGcmFtZXMgKiB0aGlzLmRlY29kZXJDb25maWcubnVtYmVyT2ZDaGFubmVscyAqIHRoaXMub3V0cHV0U2FtcGxlU2l6ZTtcbiAgICAgICAgY29uc3Qgb3V0cHV0QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKG91dHB1dEJ1ZmZlclNpemUpO1xuICAgICAgICBjb25zdCBvdXRwdXRWaWV3ID0gbmV3IERhdGFWaWV3KG91dHB1dEJ1ZmZlcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZGcmFtZXMgKiB0aGlzLmRlY29kZXJDb25maWcubnVtYmVyT2ZDaGFubmVsczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dEluZGV4ID0gaSAqIHRoaXMuaW5wdXRTYW1wbGVTaXplO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0SW5kZXggPSBpICogdGhpcy5vdXRwdXRTYW1wbGVTaXplO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlYWRJbnB1dFZhbHVlKGlucHV0VmlldywgaW5wdXRJbmRleCk7XG4gICAgICAgICAgICB0aGlzLndyaXRlT3V0cHV0VmFsdWUob3V0cHV0Vmlldywgb3V0cHV0SW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVjaXNlRHVyYXRpb24gPSBudW1iZXJPZkZyYW1lcyAvIHRoaXMuZGVjb2RlckNvbmZpZy5zYW1wbGVSYXRlO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VGltZXN0YW1wID09PSBudWxsIHx8IE1hdGguYWJzKHBhY2tldC50aW1lc3RhbXAgLSB0aGlzLmN1cnJlbnRUaW1lc3RhbXApID49IHByZWNpc2VEdXJhdGlvbikge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBzeW5jIHdpdGggdGhlIHBhY2tldCB0aW1lc3RhbXAgYWdhaW5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWVzdGFtcCA9IHBhY2tldC50aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlY2lzZVRpbWVzdGFtcCA9IHRoaXMuY3VycmVudFRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZXN0YW1wICs9IHByZWNpc2VEdXJhdGlvbjtcbiAgICAgICAgY29uc3QgYXVkaW9TYW1wbGUgPSBuZXcgQXVkaW9TYW1wbGUoe1xuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLm91dHB1dEZvcm1hdCxcbiAgICAgICAgICAgIGRhdGE6IG91dHB1dEJ1ZmZlcixcbiAgICAgICAgICAgIG51bWJlck9mQ2hhbm5lbHM6IHRoaXMuZGVjb2RlckNvbmZpZy5udW1iZXJPZkNoYW5uZWxzLFxuICAgICAgICAgICAgc2FtcGxlUmF0ZTogdGhpcy5kZWNvZGVyQ29uZmlnLnNhbXBsZVJhdGUsXG4gICAgICAgICAgICBudW1iZXJPZkZyYW1lcyxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogcHJlY2lzZVRpbWVzdGFtcCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25TYW1wbGUoYXVkaW9TYW1wbGUpO1xuICAgIH1cbiAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgIH1cbn1cbi8qKlxuICogU2luayBmb3IgcmV0cmlldmluZyBkZWNvZGVkIGF1ZGlvIHNhbXBsZXMgZnJvbSBhbiBhdWRpbyB0cmFjay5cbiAqIEBncm91cCBNZWRpYSBzaW5rc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQXVkaW9TYW1wbGVTaW5rIGV4dGVuZHMgQmFzZU1lZGlhU2FtcGxlU2luayB7XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcge0BsaW5rIEF1ZGlvU2FtcGxlU2lua30gZm9yIHRoZSBnaXZlbiB7QGxpbmsgSW5wdXRBdWRpb1RyYWNrfS4gKi9cbiAgICBjb25zdHJ1Y3RvcihhdWRpb1RyYWNrKSB7XG4gICAgICAgIGlmICghKGF1ZGlvVHJhY2sgaW5zdGFuY2VvZiBJbnB1dEF1ZGlvVHJhY2spKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdWRpb1RyYWNrIG11c3QgYmUgYW4gSW5wdXRBdWRpb1RyYWNrLicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSBhdWRpb1RyYWNrO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgYXN5bmMgX2NyZWF0ZURlY29kZXIob25TYW1wbGUsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fYXVkaW9UcmFjay5jYW5EZWNvZGUoKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBhdWRpbyB0cmFjayBjYW5ub3QgYmUgZGVjb2RlZCBieSB0aGlzIGJyb3dzZXIuIE1ha2Ugc3VyZSB0byBjaGVjayBkZWNvZGFiaWxpdHkgYmVmb3JlIHVzaW5nJ1xuICAgICAgICAgICAgICAgICsgJyBhIHRyYWNrLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGVjID0gdGhpcy5fYXVkaW9UcmFjay5jb2RlYztcbiAgICAgICAgY29uc3QgZGVjb2RlckNvbmZpZyA9IGF3YWl0IHRoaXMuX2F1ZGlvVHJhY2suZ2V0RGVjb2RlckNvbmZpZygpO1xuICAgICAgICBhc3NlcnQoY29kZWMgJiYgZGVjb2RlckNvbmZpZyk7XG4gICAgICAgIGlmIChQQ01fQVVESU9fQ09ERUNTLmluY2x1ZGVzKGRlY29kZXJDb25maWcuY29kZWMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBjbUF1ZGlvRGVjb2RlcldyYXBwZXIob25TYW1wbGUsIG9uRXJyb3IsIGRlY29kZXJDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBdWRpb0RlY29kZXJXcmFwcGVyKG9uU2FtcGxlLCBvbkVycm9yLCBjb2RlYywgZGVjb2RlckNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jcmVhdGVQYWNrZXRTaW5rKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVuY29kZWRQYWNrZXRTaW5rKHRoaXMuX2F1ZGlvVHJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGF1ZGlvIHNhbXBsZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiB0aW1lc3RhbXAsIGluIHNlY29uZHMuIE1vcmUgc3BlY2lmaWNhbGx5LCByZXR1cm5zXG4gICAgICogdGhlIGxhc3QgYXVkaW8gc2FtcGxlIChpbiBwcmVzZW50YXRpb24gb3JkZXIpIHdpdGggYSBzdGFydCB0aW1lc3RhbXAgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiB0aW1lc3RhbXAuXG4gICAgICogUmV0dXJucyBudWxsIGlmIHRoZSB0aW1lc3RhbXAgaXMgYmVmb3JlIHRoZSB0cmFjaydzIGZpcnN0IHRpbWVzdGFtcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lc3RhbXAgLSBUaGUgdGltZXN0YW1wIHVzZWQgZm9yIHJldHJpZXZhbCwgaW4gc2Vjb25kcy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTYW1wbGUodGltZXN0YW1wKSB7XG4gICAgICAgIHZhbGlkYXRlVGltZXN0YW1wKHRpbWVzdGFtcCk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3Qgc2FtcGxlIG9mIHRoaXMubWVkaWFTYW1wbGVzQXRUaW1lc3RhbXBzKFt0aW1lc3RhbXBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIGVycm9yOiBJdGVyYXRvciByZXR1cm5lZCBub3RoaW5nLicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFzeW5jIGl0ZXJhdG9yIHRoYXQgeWllbGRzIHRoZSBhdWRpbyBzYW1wbGVzIG9mIHRoaXMgdHJhY2sgaW4gcHJlc2VudGF0aW9uIG9yZGVyLiBUaGlzIG1ldGhvZFxuICAgICAqIHdpbGwgaW50ZWxsaWdlbnRseSBwcmUtZGVjb2RlIGEgZmV3IHNhbXBsZXMgYWhlYWQgdG8gZW5hYmxlIGZhc3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0VGltZXN0YW1wIC0gVGhlIHRpbWVzdGFtcCBpbiBzZWNvbmRzIGF0IHdoaWNoIHRvIHN0YXJ0IHlpZWxkaW5nIHNhbXBsZXMgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIGVuZFRpbWVzdGFtcCAtIFRoZSB0aW1lc3RhbXAgaW4gc2Vjb25kcyBhdCB3aGljaCB0byBzdG9wIHlpZWxkaW5nIHNhbXBsZXMgKGV4Y2x1c2l2ZSkuXG4gICAgICovXG4gICAgc2FtcGxlcyhzdGFydFRpbWVzdGFtcCA9IDAsIGVuZFRpbWVzdGFtcCA9IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhU2FtcGxlc0luUmFuZ2Uoc3RhcnRUaW1lc3RhbXAsIGVuZFRpbWVzdGFtcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXN5bmMgaXRlcmF0b3IgdGhhdCB5aWVsZHMgYW4gYXVkaW8gc2FtcGxlIGZvciBlYWNoIHRpbWVzdGFtcCBpbiB0aGUgYXJndW1lbnQuIFRoaXMgbWV0aG9kXG4gICAgICogdXNlcyBhbiBvcHRpbWl6ZWQgZGVjb2RpbmcgcGlwZWxpbmUgaWYgdGhlc2UgdGltZXN0YW1wcyBhcmUgbW9ub3RvbmljYWxseSBzb3J0ZWQsIGRlY29kaW5nIGVhY2ggcGFja2V0IGF0IG1vc3RcbiAgICAgKiBvbmNlLCBhbmQgaXMgdGhlcmVmb3JlIG1vcmUgZWZmaWNpZW50IHRoYW4gbWFudWFsbHkgZ2V0dGluZyB0aGUgc2FtcGxlIGZvciBldmVyeSB0aW1lc3RhbXAuIFRoZSBpdGVyYXRvciBtYXlcbiAgICAgKiB5aWVsZCBudWxsIGlmIG5vIHNhbXBsZSBpcyBhdmFpbGFibGUgZm9yIGEgZ2l2ZW4gdGltZXN0YW1wLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRpbWVzdGFtcHMgLSBBbiBpdGVyYWJsZSBvciBhc3luYyBpdGVyYWJsZSBvZiB0aW1lc3RhbXBzIGluIHNlY29uZHMuXG4gICAgICovXG4gICAgc2FtcGxlc0F0VGltZXN0YW1wcyh0aW1lc3RhbXBzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhU2FtcGxlc0F0VGltZXN0YW1wcyh0aW1lc3RhbXBzKTtcbiAgICB9XG59XG4vKipcbiAqIEEgc2luayB0aGF0IHJldHJpZXZlcyBkZWNvZGVkIGF1ZGlvIHNhbXBsZXMgZnJvbSBhbiBhdWRpbyB0cmFjayBhbmQgY29udmVydHMgdGhlbSB0byBgQXVkaW9CdWZmZXJgIGluc3RhbmNlcy4gVGhpcyBpc1xuICogb2Z0ZW4gbW9yZSB1c2VmdWwgdGhhbiBkaXJlY3RseSByZXRyaWV2aW5nIGF1ZGlvIHNhbXBsZXMsIGFzIGF1ZGlvIGJ1ZmZlcnMgY2FuIGJlIGRpcmVjdGx5IHVzZWQgd2l0aCB0aGVcbiAqIFdlYiBBdWRpbyBBUEkuXG4gKiBAZ3JvdXAgTWVkaWEgc2lua3NcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEF1ZGlvQnVmZmVyU2luayB7XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcge0BsaW5rIEF1ZGlvQnVmZmVyU2lua30gZm9yIHRoZSBnaXZlbiB7QGxpbmsgSW5wdXRBdWRpb1RyYWNrfS4gKi9cbiAgICBjb25zdHJ1Y3RvcihhdWRpb1RyYWNrKSB7XG4gICAgICAgIGlmICghKGF1ZGlvVHJhY2sgaW5zdGFuY2VvZiBJbnB1dEF1ZGlvVHJhY2spKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdWRpb1RyYWNrIG11c3QgYmUgYW4gSW5wdXRBdWRpb1RyYWNrLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2F1ZGlvU2FtcGxlU2luayA9IG5ldyBBdWRpb1NhbXBsZVNpbmsoYXVkaW9UcmFjayk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfYXVkaW9TYW1wbGVUb1dyYXBwZWRBcnJheUJ1ZmZlcihzYW1wbGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ1ZmZlcjogc2FtcGxlLnRvQXVkaW9CdWZmZXIoKSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogc2FtcGxlLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBzYW1wbGUuZHVyYXRpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgYXVkaW8gYnVmZmVyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIHRpbWVzdGFtcCwgaW4gc2Vjb25kcy4gTW9yZSBzcGVjaWZpY2FsbHksIHJldHVybnNcbiAgICAgKiB0aGUgbGFzdCBhdWRpbyBidWZmZXIgKGluIHByZXNlbnRhdGlvbiBvcmRlcikgd2l0aCBhIHN0YXJ0IHRpbWVzdGFtcCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIHRpbWVzdGFtcC5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIHRpbWVzdGFtcCBpcyBiZWZvcmUgdGhlIHRyYWNrJ3MgZmlyc3QgdGltZXN0YW1wLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRpbWVzdGFtcCAtIFRoZSB0aW1lc3RhbXAgdXNlZCBmb3IgcmV0cmlldmFsLCBpbiBzZWNvbmRzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ1ZmZlcih0aW1lc3RhbXApIHtcbiAgICAgICAgdmFsaWRhdGVUaW1lc3RhbXAodGltZXN0YW1wKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX2F1ZGlvU2FtcGxlU2luay5nZXRTYW1wbGUodGltZXN0YW1wKTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgdGhpcy5fYXVkaW9TYW1wbGVUb1dyYXBwZWRBcnJheUJ1ZmZlcihkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhc3luYyBpdGVyYXRvciB0aGF0IHlpZWxkcyBhdWRpbyBidWZmZXJzIG9mIHRoaXMgdHJhY2sgaW4gcHJlc2VudGF0aW9uIG9yZGVyLiBUaGlzIG1ldGhvZFxuICAgICAqIHdpbGwgaW50ZWxsaWdlbnRseSBwcmUtZGVjb2RlIGEgZmV3IGJ1ZmZlcnMgYWhlYWQgdG8gZW5hYmxlIGZhc3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0VGltZXN0YW1wIC0gVGhlIHRpbWVzdGFtcCBpbiBzZWNvbmRzIGF0IHdoaWNoIHRvIHN0YXJ0IHlpZWxkaW5nIGJ1ZmZlcnMgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIGVuZFRpbWVzdGFtcCAtIFRoZSB0aW1lc3RhbXAgaW4gc2Vjb25kcyBhdCB3aGljaCB0byBzdG9wIHlpZWxkaW5nIGJ1ZmZlcnMgKGV4Y2x1c2l2ZSkuXG4gICAgICovXG4gICAgYnVmZmVycyhzdGFydFRpbWVzdGFtcCA9IDAsIGVuZFRpbWVzdGFtcCA9IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBtYXBBc3luY0dlbmVyYXRvcih0aGlzLl9hdWRpb1NhbXBsZVNpbmsuc2FtcGxlcyhzdGFydFRpbWVzdGFtcCwgZW5kVGltZXN0YW1wKSwgZGF0YSA9PiB0aGlzLl9hdWRpb1NhbXBsZVRvV3JhcHBlZEFycmF5QnVmZmVyKGRhdGEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhc3luYyBpdGVyYXRvciB0aGF0IHlpZWxkcyBhbiBhdWRpbyBidWZmZXIgZm9yIGVhY2ggdGltZXN0YW1wIGluIHRoZSBhcmd1bWVudC4gVGhpcyBtZXRob2RcbiAgICAgKiB1c2VzIGFuIG9wdGltaXplZCBkZWNvZGluZyBwaXBlbGluZSBpZiB0aGVzZSB0aW1lc3RhbXBzIGFyZSBtb25vdG9uaWNhbGx5IHNvcnRlZCwgZGVjb2RpbmcgZWFjaCBwYWNrZXQgYXQgbW9zdFxuICAgICAqIG9uY2UsIGFuZCBpcyB0aGVyZWZvcmUgbW9yZSBlZmZpY2llbnQgdGhhbiBtYW51YWxseSBnZXR0aW5nIHRoZSBidWZmZXIgZm9yIGV2ZXJ5IHRpbWVzdGFtcC4gVGhlIGl0ZXJhdG9yIG1heVxuICAgICAqIHlpZWxkIG51bGwgaWYgbm8gYnVmZmVyIGlzIGF2YWlsYWJsZSBmb3IgYSBnaXZlbiB0aW1lc3RhbXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGltZXN0YW1wcyAtIEFuIGl0ZXJhYmxlIG9yIGFzeW5jIGl0ZXJhYmxlIG9mIHRpbWVzdGFtcHMgaW4gc2Vjb25kcy5cbiAgICAgKi9cbiAgICBidWZmZXJzQXRUaW1lc3RhbXBzKHRpbWVzdGFtcHMpIHtcbiAgICAgICAgcmV0dXJuIG1hcEFzeW5jR2VuZXJhdG9yKHRoaXMuX2F1ZGlvU2FtcGxlU2luay5zYW1wbGVzQXRUaW1lc3RhbXBzKHRpbWVzdGFtcHMpLCBkYXRhID0+IGRhdGEgJiYgdGhpcy5fYXVkaW9TYW1wbGVUb1dyYXBwZWRBcnJheUJ1ZmZlcihkYXRhKSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/media-sink.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/media-source.js":
/*!******************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/media-source.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioBufferSource: () => (/* binding */ AudioBufferSource),\n/* harmony export */   AudioSampleSource: () => (/* binding */ AudioSampleSource),\n/* harmony export */   AudioSource: () => (/* binding */ AudioSource),\n/* harmony export */   CanvasSource: () => (/* binding */ CanvasSource),\n/* harmony export */   EncodedAudioPacketSource: () => (/* binding */ EncodedAudioPacketSource),\n/* harmony export */   EncodedVideoPacketSource: () => (/* binding */ EncodedVideoPacketSource),\n/* harmony export */   MediaSource: () => (/* binding */ MediaSource),\n/* harmony export */   MediaStreamAudioTrackSource: () => (/* binding */ MediaStreamAudioTrackSource),\n/* harmony export */   MediaStreamVideoTrackSource: () => (/* binding */ MediaStreamVideoTrackSource),\n/* harmony export */   SubtitleSource: () => (/* binding */ SubtitleSource),\n/* harmony export */   TextSubtitleSource: () => (/* binding */ TextSubtitleSource),\n/* harmony export */   VideoSampleSource: () => (/* binding */ VideoSampleSource),\n/* harmony export */   VideoSource: () => (/* binding */ VideoSource)\n/* harmony export */ });\n/* harmony import */ var _codec_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./codec.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/* harmony import */ var _subtitles_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./subtitles.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/subtitles.js\");\n/* harmony import */ var _pcm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pcm.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/pcm.js\");\n/* harmony import */ var _custom_coder_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./custom-coder.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/custom-coder.js\");\n/* harmony import */ var _packet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packet.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/packet.js\");\n/* harmony import */ var _sample_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sample.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/sample.js\");\n/* harmony import */ var _encode_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./encode.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/encode.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n\n\n\n/**\n * Base class for media sources. Media sources are used to add media samples to an output file.\n * @group Media sources\n * @public\n */\nclass MediaSource {\n    constructor() {\n        /** @internal */\n        this._connectedTrack = null;\n        /** @internal */\n        this._closingPromise = null;\n        /** @internal */\n        this._closed = false;\n        /**\n         * @internal\n         * A time offset in seconds that is added to all timestamps generated by this source.\n         */\n        this._timestampOffset = 0;\n    }\n    /** @internal */\n    _ensureValidAdd() {\n        if (!this._connectedTrack) {\n            throw new Error('Source is not connected to an output track.');\n        }\n        if (this._connectedTrack.output.state === 'canceled') {\n            throw new Error('Output has been canceled.');\n        }\n        if (this._connectedTrack.output.state === 'finalizing' || this._connectedTrack.output.state === 'finalized') {\n            throw new Error('Output has been finalized.');\n        }\n        if (this._connectedTrack.output.state === 'pending') {\n            throw new Error('Output has not started.');\n        }\n        if (this._closed) {\n            throw new Error('Source is closed.');\n        }\n    }\n    /** @internal */\n    async _start() { }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async _flushAndClose(forceClose) { }\n    /**\n     * Closes this source. This prevents future samples from being added and signals to the output file that no further\n     * samples will come in for this track. Calling `.close()` is optional but recommended after adding the\n     * last sample - for improved performance and reduced memory usage.\n     */\n    close() {\n        if (this._closingPromise) {\n            return;\n        }\n        const connectedTrack = this._connectedTrack;\n        if (!connectedTrack) {\n            throw new Error('Cannot call close without connecting the source to an output track.');\n        }\n        if (connectedTrack.output.state === 'pending') {\n            throw new Error('Cannot call close before output has been started.');\n        }\n        this._closingPromise = (async () => {\n            await this._flushAndClose(false);\n            this._closed = true;\n            if (connectedTrack.output.state === 'finalizing' || connectedTrack.output.state === 'finalized') {\n                return;\n            }\n            connectedTrack.output._muxer.onTrackClose(connectedTrack);\n        })();\n    }\n    /** @internal */\n    async _flushOrWaitForOngoingClose(forceClose) {\n        if (this._closingPromise) {\n            // Since closing also flushes, we don't want to do it twice\n            return this._closingPromise;\n        }\n        else {\n            return this._flushAndClose(forceClose);\n        }\n    }\n}\n/**\n * Base class for video sources - sources for video tracks.\n * @group Media sources\n * @public\n */\nclass VideoSource extends MediaSource {\n    /** Internal constructor. */\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!_codec_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid video codec '${codec}'. Must be one of: ${_codec_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * The most basic video source; can be used to directly pipe encoded packets into the output file.\n * @group Media sources\n * @public\n */\nclass EncodedVideoPacketSource extends VideoSource {\n    /** Creates a new {@link EncodedVideoPacketSource} whose packets are encoded using `codec`. */\n    constructor(codec) {\n        super(codec);\n    }\n    /**\n     * Adds an encoded packet to the output video track. Packets must be added in *decode order*, while a packet's\n     * timestamp must be its *presentation timestamp*. B-frames are handled automatically.\n     *\n     * @param meta - Additional metadata from the encoder. You should pass this for the first call, including a valid\n     * decoder config.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(packet, meta) {\n        if (!(packet instanceof _packet_js__WEBPACK_IMPORTED_MODULE_1__.EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (packet.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be added.');\n        }\n        if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n            throw new TypeError('meta, when provided, must be an object.');\n        }\n        this._ensureValidAdd();\n        return this._connectedTrack.output._muxer.addEncodedVideoPacket(this._connectedTrack, packet, meta);\n    }\n}\nclass VideoEncoderWrapper {\n    constructor(source, encodingConfig) {\n        this.source = source;\n        this.encodingConfig = encodingConfig;\n        this.ensureEncoderPromise = null;\n        this.encoderInitialized = false;\n        this.encoder = null;\n        this.muxer = null;\n        this.lastMultipleOfKeyFrameInterval = -1;\n        this.codedWidth = null;\n        this.codedHeight = null;\n        this.resizeCanvas = null;\n        this.customEncoder = null;\n        this.customEncoderCallSerializer = new _misc_js__WEBPACK_IMPORTED_MODULE_2__.CallSerializer();\n        this.customEncoderQueueSize = 0;\n        /**\n         * Encoders typically throw their errors \"out of band\", meaning asynchronously in some other execution context.\n         * However, we want to surface these errors to the user within the normal control flow, so they don't go uncaught.\n         * So, we keep track of the encoder error and throw it as soon as we get the chance.\n         */\n        this.encoderError = null;\n    }\n    async add(videoSample, shouldClose, encodeOptions) {\n        try {\n            this.checkForEncoderError();\n            this.source._ensureValidAdd();\n            // Ensure video sample size remains constant\n            if (this.codedWidth !== null && this.codedHeight !== null) {\n                if (videoSample.codedWidth !== this.codedWidth || videoSample.codedHeight !== this.codedHeight) {\n                    const sizeChangeBehavior = this.encodingConfig.sizeChangeBehavior ?? 'deny';\n                    if (sizeChangeBehavior === 'passThrough') {\n                        // Do nada\n                    }\n                    else if (sizeChangeBehavior === 'deny') {\n                        throw new Error(`Video sample size must remain constant. Expected ${this.codedWidth}x${this.codedHeight},`\n                            + ` got ${videoSample.codedWidth}x${videoSample.codedHeight}. To allow the sample size to`\n                            + ` change over time, set \\`sizeChangeBehavior\\` to a value other than 'strict' in the`\n                            + ` encoding options.`);\n                    }\n                    else {\n                        let canvasIsNew = false;\n                        if (!this.resizeCanvas) {\n                            if (typeof document !== 'undefined') {\n                                // Prefer an HTMLCanvasElement\n                                this.resizeCanvas = document.createElement('canvas');\n                                this.resizeCanvas.width = this.codedWidth;\n                                this.resizeCanvas.height = this.codedHeight;\n                            }\n                            else {\n                                this.resizeCanvas = new OffscreenCanvas(this.codedWidth, this.codedHeight);\n                            }\n                            canvasIsNew = true;\n                        }\n                        const context = this.resizeCanvas.getContext('2d', { alpha: false });\n                        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(context);\n                        if (!canvasIsNew) {\n                            context.clearRect(0, 0, this.codedWidth, this.codedHeight);\n                        }\n                        videoSample.drawWithFit(context, { fit: sizeChangeBehavior });\n                        if (shouldClose) {\n                            videoSample.close();\n                        }\n                        videoSample = new _sample_js__WEBPACK_IMPORTED_MODULE_3__.VideoSample(this.resizeCanvas, {\n                            timestamp: videoSample.timestamp,\n                            duration: videoSample.duration,\n                            rotation: videoSample.rotation,\n                        });\n                        shouldClose = true;\n                    }\n                }\n            }\n            else {\n                this.codedWidth = videoSample.codedWidth;\n                this.codedHeight = videoSample.codedHeight;\n            }\n            if (!this.encoderInitialized) {\n                if (!this.ensureEncoderPromise) {\n                    void this.ensureEncoder(videoSample);\n                }\n                // No, this \"if\" statement is not useless. Sometimes, the above call to `ensureEncoder` might have\n                // synchronously completed and the encoder is already initialized. In this case, we don't need to await\n                // the promise anymore. This also fixes nasty async race condition bugs when multiple code paths are\n                // calling this method: It's important that the call that initialized the encoder go through this\n                // code first.\n                if (!this.encoderInitialized) {\n                    await this.ensureEncoderPromise;\n                }\n            }\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.encoderInitialized);\n            const keyFrameInterval = this.encodingConfig.keyFrameInterval ?? 5;\n            const multipleOfKeyFrameInterval = Math.floor(videoSample.timestamp / keyFrameInterval);\n            // Ensure a key frame every keyFrameInterval seconds. It is important that all video tracks follow the same\n            // \"key frame\" rhythm, because aligned key frames are required to start new fragments in ISOBMFF or clusters\n            // in Matroska (or at least desirable).\n            const finalEncodeOptions = {\n                ...encodeOptions,\n                keyFrame: encodeOptions?.keyFrame\n                    || keyFrameInterval === 0\n                    || multipleOfKeyFrameInterval !== this.lastMultipleOfKeyFrameInterval,\n            };\n            this.lastMultipleOfKeyFrameInterval = multipleOfKeyFrameInterval;\n            if (this.customEncoder) {\n                this.customEncoderQueueSize++;\n                // We clone the sample so it cannot be closed on us from the outside before it reaches the encoder\n                const clonedSample = videoSample.clone();\n                const promise = this.customEncoderCallSerializer\n                    .call(() => this.customEncoder.encode(clonedSample, finalEncodeOptions))\n                    .then(() => this.customEncoderQueueSize--)\n                    .catch((error) => this.encoderError ??= error)\n                    .finally(() => {\n                    clonedSample.close();\n                    // `videoSample` gets closed in the finally block at the end of the method\n                });\n                if (this.customEncoderQueueSize >= 4) {\n                    await promise;\n                }\n            }\n            else {\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.encoder);\n                const videoFrame = videoSample.toVideoFrame();\n                this.encoder.encode(videoFrame, finalEncodeOptions);\n                videoFrame.close();\n                if (shouldClose) {\n                    videoSample.close();\n                }\n                // We need to do this after sending the frame to the encoder as the frame otherwise might be closed\n                if (this.encoder.encodeQueueSize >= 4) {\n                    await new Promise(resolve => this.encoder.addEventListener('dequeue', resolve, { once: true }));\n                }\n            }\n            await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n        }\n        finally {\n            if (shouldClose) {\n                // Make sure it's always closed, even if there was an error\n                videoSample.close();\n            }\n        }\n    }\n    async ensureEncoder(videoSample) {\n        if (this.encoder) {\n            return;\n        }\n        const encoderError = new Error();\n        return this.ensureEncoderPromise = (async () => {\n            const encoderConfig = (0,_encode_js__WEBPACK_IMPORTED_MODULE_4__.buildVideoEncoderConfig)({\n                width: videoSample.codedWidth,\n                height: videoSample.codedHeight,\n                ...this.encodingConfig,\n                framerate: this.source._connectedTrack?.metadata.frameRate,\n            });\n            this.encodingConfig.onEncoderConfig?.(encoderConfig);\n            const MatchingCustomEncoder = _custom_coder_js__WEBPACK_IMPORTED_MODULE_5__.customVideoEncoders.find(x => x.supports(this.encodingConfig.codec, encoderConfig));\n            if (MatchingCustomEncoder) {\n                // @ts-expect-error \"Can't create instance of abstract class 🤓\"\n                this.customEncoder = new MatchingCustomEncoder();\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.codec = this.encodingConfig.codec;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.config = encoderConfig;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.onPacket = (packet, meta) => {\n                    if (!(packet instanceof _packet_js__WEBPACK_IMPORTED_MODULE_1__.EncodedPacket)) {\n                        throw new TypeError('The first argument passed to onPacket must be an EncodedPacket.');\n                    }\n                    if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n                        throw new TypeError('The second argument passed to onPacket must be an object or undefined.');\n                    }\n                    this.encodingConfig.onEncodedPacket?.(packet, meta);\n                    void this.muxer.addEncodedVideoPacket(this.source._connectedTrack, packet, meta);\n                };\n                await this.customEncoder.init();\n            }\n            else {\n                if (typeof VideoEncoder === 'undefined') {\n                    throw new Error('VideoEncoder is not supported by this browser.');\n                }\n                const support = await VideoEncoder.isConfigSupported(encoderConfig);\n                if (!support.supported) {\n                    throw new Error(`This specific encoder configuration (${encoderConfig.codec}, ${encoderConfig.bitrate} bps,`\n                        + ` ${encoderConfig.width}x${encoderConfig.height}, hardware acceleration:`\n                        + ` ${encoderConfig.hardwareAcceleration ?? 'no-preference'}) is not supported by this browser.`\n                        + ` Consider using another codec or changing your video parameters.`);\n                }\n                this.encoder = new VideoEncoder({\n                    output: (chunk, meta) => {\n                        const packet = _packet_js__WEBPACK_IMPORTED_MODULE_1__.EncodedPacket.fromEncodedChunk(chunk);\n                        this.encodingConfig.onEncodedPacket?.(packet, meta);\n                        void this.muxer.addEncodedVideoPacket(this.source._connectedTrack, packet, meta);\n                    },\n                    error: (error) => {\n                        error.stack = encoderError.stack; // Provide a more useful stack trace\n                        this.encoderError ??= error;\n                    },\n                });\n                this.encoder.configure(encoderConfig);\n            }\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.source._connectedTrack);\n            this.muxer = this.source._connectedTrack.output._muxer;\n            this.encoderInitialized = true;\n        })();\n    }\n    async flushAndClose(forceClose) {\n        if (!forceClose)\n            this.checkForEncoderError();\n        if (this.customEncoder) {\n            if (!forceClose) {\n                void this.customEncoderCallSerializer.call(() => this.customEncoder.flush());\n            }\n            await this.customEncoderCallSerializer.call(() => this.customEncoder.close());\n        }\n        else if (this.encoder) {\n            if (!forceClose) {\n                await this.encoder.flush();\n            }\n            if (this.encoder.state !== 'closed') {\n                this.encoder.close();\n            }\n        }\n        if (!forceClose)\n            this.checkForEncoderError();\n    }\n    getQueueSize() {\n        if (this.customEncoder) {\n            return this.customEncoderQueueSize;\n        }\n        else {\n            return this.encoder?.encodeQueueSize ?? 0;\n        }\n    }\n    checkForEncoderError() {\n        if (this.encoderError) {\n            this.encoderError.stack = new Error().stack; // Provide an even more useful stack trace\n            throw this.encoderError;\n        }\n    }\n}\n/**\n * This source can be used to add raw, unencoded video samples (frames) to an output video track. These frames will\n * automatically be encoded and then piped into the output.\n * @group Media sources\n * @public\n */\nclass VideoSampleSource extends VideoSource {\n    /**\n     * Creates a new {@link VideoSampleSource} whose samples are encoded according to the specified\n     * {@link VideoEncodingConfig}.\n     */\n    constructor(encodingConfig) {\n        (0,_encode_js__WEBPACK_IMPORTED_MODULE_4__.validateVideoEncodingConfig)(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Encodes a video sample (frame) and then adds it to the output.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(videoSample, encodeOptions) {\n        if (!(videoSample instanceof _sample_js__WEBPACK_IMPORTED_MODULE_3__.VideoSample)) {\n            throw new TypeError('videoSample must be a VideoSample.');\n        }\n        return this._encoder.add(videoSample, false, encodeOptions);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * This source can be used to add video frames to the output track from a fixed canvas element. Since canvases are often\n * used for rendering, this source provides a convenient wrapper around {@link VideoSampleSource}.\n * @group Media sources\n * @public\n */\nclass CanvasSource extends VideoSource {\n    /**\n     * Creates a new {@link CanvasSource} from a canvas element or `OffscreenCanvas` whose samples are encoded\n     * according to the specified {@link VideoEncodingConfig}.\n     */\n    constructor(canvas, encodingConfig) {\n        if (!(typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement)\n            && !(typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n            throw new TypeError('canvas must be an HTMLCanvasElement or OffscreenCanvas.');\n        }\n        (0,_encode_js__WEBPACK_IMPORTED_MODULE_4__.validateVideoEncodingConfig)(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n        this._canvas = canvas;\n    }\n    /**\n     * Captures the current canvas state as a video sample (frame), encodes it and adds it to the output.\n     *\n     * @param timestamp - The timestamp of the sample, in seconds.\n     * @param duration - The duration of the sample, in seconds.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(timestamp, duration = 0, encodeOptions) {\n        if (!Number.isFinite(timestamp) || timestamp < 0) {\n            throw new TypeError('timestamp must be a non-negative number.');\n        }\n        if (!Number.isFinite(duration) || duration < 0) {\n            throw new TypeError('duration must be a non-negative number.');\n        }\n        const sample = new _sample_js__WEBPACK_IMPORTED_MODULE_3__.VideoSample(this._canvas, { timestamp, duration });\n        return this._encoder.add(sample, true, encodeOptions);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Video source that encodes the frames of a\n * [`MediaStreamVideoTrack`](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) and pipes them into the\n * output. This is useful for capturing live or real-time data such as webcams or screen captures. Frames will\n * automatically start being captured once the connected {@link Output} is started, and will keep being captured until\n * the {@link Output} is finalized or this source is closed.\n * @group Media sources\n * @public\n */\nclass MediaStreamVideoTrackSource extends VideoSource {\n    /** A promise that rejects upon any error within this source. This promise never resolves. */\n    get errorPromise() {\n        this._errorPromiseAccessed = true;\n        return this._promiseWithResolvers.promise;\n    }\n    /**\n     * Creates a new {@link MediaStreamVideoTrackSource} from a\n     * [`MediaStreamVideoTrack`](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack), which will pull\n     * video samples from the stream in real time and encode them according to {@link VideoEncodingConfig}.\n     */\n    constructor(track, encodingConfig) {\n        if (!(track instanceof MediaStreamTrack) || track.kind !== 'video') {\n            throw new TypeError('track must be a video MediaStreamTrack.');\n        }\n        (0,_encode_js__WEBPACK_IMPORTED_MODULE_4__.validateVideoEncodingConfig)(encodingConfig);\n        encodingConfig = {\n            ...encodingConfig,\n            latencyMode: 'realtime',\n        };\n        super(encodingConfig.codec);\n        /** @internal */\n        this._abortController = null;\n        /** @internal */\n        this._workerTrackId = null;\n        /** @internal */\n        this._workerListener = null;\n        /** @internal */\n        this._promiseWithResolvers = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.promiseWithResolvers)();\n        /** @internal */\n        this._errorPromiseAccessed = false;\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n        this._track = track;\n    }\n    /** @internal */\n    async _start() {\n        if (!this._errorPromiseAccessed) {\n            console.warn('Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal'\n                + ' errors get bubbled up properly.');\n        }\n        this._abortController = new AbortController();\n        let firstVideoFrameTimestamp = null;\n        let errored = false;\n        const onVideoFrame = (videoFrame) => {\n            if (errored) {\n                videoFrame.close();\n                return;\n            }\n            if (firstVideoFrameTimestamp === null) {\n                firstVideoFrameTimestamp = videoFrame.timestamp / 1e6;\n                const muxer = this._connectedTrack.output._muxer;\n                if (muxer.firstMediaStreamTimestamp === null) {\n                    muxer.firstMediaStreamTimestamp = performance.now() / 1000;\n                    this._timestampOffset = -firstVideoFrameTimestamp;\n                }\n                else {\n                    this._timestampOffset = (performance.now() / 1000 - muxer.firstMediaStreamTimestamp)\n                        - firstVideoFrameTimestamp;\n                }\n            }\n            if (this._encoder.getQueueSize() >= 4) {\n                // Drop frames if the encoder is overloaded\n                videoFrame.close();\n                return;\n            }\n            void this._encoder.add(new _sample_js__WEBPACK_IMPORTED_MODULE_3__.VideoSample(videoFrame), true)\n                .catch((error) => {\n                errored = true;\n                this._abortController?.abort();\n                this._promiseWithResolvers.reject(error);\n                if (this._workerTrackId !== null) {\n                    // Tell the worker to stop the track\n                    sendMessageToMediaStreamTrackProcessorWorker({\n                        type: 'stopTrack',\n                        trackId: this._workerTrackId,\n                    });\n                }\n            });\n        };\n        if (typeof MediaStreamTrackProcessor !== 'undefined') {\n            // We can do it here directly, perfect\n            const processor = new MediaStreamTrackProcessor({ track: this._track });\n            const consumer = new WritableStream({ write: onVideoFrame });\n            processor.readable.pipeTo(consumer, {\n                signal: this._abortController.signal,\n            }).catch((error) => {\n                // Handle AbortError silently\n                if (error instanceof DOMException && error.name === 'AbortError')\n                    return;\n                this._promiseWithResolvers.reject(error);\n            });\n        }\n        else {\n            // It might still be supported in a worker, so let's check that\n            const supportedInWorker = await mediaStreamTrackProcessorIsSupportedInWorker();\n            if (supportedInWorker) {\n                this._workerTrackId = nextMediaStreamTrackProcessorWorkerId++;\n                sendMessageToMediaStreamTrackProcessorWorker({\n                    type: 'videoTrack',\n                    trackId: this._workerTrackId,\n                    track: this._track,\n                }, [this._track]);\n                this._workerListener = (event) => {\n                    const message = event.data;\n                    if (message.type === 'videoFrame' && message.trackId === this._workerTrackId) {\n                        onVideoFrame(message.videoFrame);\n                    }\n                    else if (message.type === 'error' && message.trackId === this._workerTrackId) {\n                        this._promiseWithResolvers.reject(message.error);\n                    }\n                };\n                mediaStreamTrackProcessorWorker.addEventListener('message', this._workerListener);\n            }\n            else {\n                throw new Error('MediaStreamTrackProcessor is required but not supported by this browser.');\n            }\n        }\n    }\n    /** @internal */\n    async _flushAndClose(forceClose) {\n        if (this._abortController) {\n            this._abortController.abort();\n            this._abortController = null;\n        }\n        if (this._workerTrackId !== null) {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this._workerListener);\n            sendMessageToMediaStreamTrackProcessorWorker({\n                type: 'stopTrack',\n                trackId: this._workerTrackId,\n            });\n            // Wait for the worker to stop the track\n            await new Promise((resolve) => {\n                const listener = (event) => {\n                    const message = event.data;\n                    if (message.type === 'trackStopped' && message.trackId === this._workerTrackId) {\n                        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this._workerListener);\n                        mediaStreamTrackProcessorWorker.removeEventListener('message', this._workerListener);\n                        mediaStreamTrackProcessorWorker.removeEventListener('message', listener);\n                        resolve();\n                    }\n                };\n                mediaStreamTrackProcessorWorker.addEventListener('message', listener);\n            });\n        }\n        await this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Base class for audio sources - sources for audio tracks.\n * @group Media sources\n * @public\n */\nclass AudioSource extends MediaSource {\n    /** Internal constructor. */\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!_codec_js__WEBPACK_IMPORTED_MODULE_0__.AUDIO_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid audio codec '${codec}'. Must be one of: ${_codec_js__WEBPACK_IMPORTED_MODULE_0__.AUDIO_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * The most basic audio source; can be used to directly pipe encoded packets into the output file.\n * @group Media sources\n * @public\n */\nclass EncodedAudioPacketSource extends AudioSource {\n    /** Creates a new {@link EncodedAudioPacketSource} whose packets are encoded using `codec`. */\n    constructor(codec) {\n        super(codec);\n    }\n    /**\n     * Adds an encoded packet to the output audio track. Packets must be added in *decode order*.\n     *\n     * @param meta - Additional metadata from the encoder. You should pass this for the first call, including a valid\n     * decoder config.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(packet, meta) {\n        if (!(packet instanceof _packet_js__WEBPACK_IMPORTED_MODULE_1__.EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (packet.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be added.');\n        }\n        if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n            throw new TypeError('meta, when provided, must be an object.');\n        }\n        this._ensureValidAdd();\n        return this._connectedTrack.output._muxer.addEncodedAudioPacket(this._connectedTrack, packet, meta);\n    }\n}\nclass AudioEncoderWrapper {\n    constructor(source, encodingConfig) {\n        this.source = source;\n        this.encodingConfig = encodingConfig;\n        this.ensureEncoderPromise = null;\n        this.encoderInitialized = false;\n        this.encoder = null;\n        this.muxer = null;\n        this.lastNumberOfChannels = null;\n        this.lastSampleRate = null;\n        this.isPcmEncoder = false;\n        this.outputSampleSize = null;\n        this.writeOutputValue = null;\n        this.customEncoder = null;\n        this.customEncoderCallSerializer = new _misc_js__WEBPACK_IMPORTED_MODULE_2__.CallSerializer();\n        this.customEncoderQueueSize = 0;\n        /**\n         * Encoders typically throw their errors \"out of band\", meaning asynchronously in some other execution context.\n         * However, we want to surface these errors to the user within the normal control flow, so they don't go uncaught.\n         * So, we keep track of the encoder error and throw it as soon as we get the chance.\n         */\n        this.encoderError = null;\n    }\n    async add(audioSample, shouldClose) {\n        try {\n            this.checkForEncoderError();\n            this.source._ensureValidAdd();\n            // Ensure audio parameters remain constant\n            if (this.lastNumberOfChannels !== null && this.lastSampleRate !== null) {\n                if (audioSample.numberOfChannels !== this.lastNumberOfChannels\n                    || audioSample.sampleRate !== this.lastSampleRate) {\n                    throw new Error(`Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at`\n                        + ` ${this.lastSampleRate} Hz, got ${audioSample.numberOfChannels} channels at`\n                        + ` ${audioSample.sampleRate} Hz.`);\n                }\n            }\n            else {\n                this.lastNumberOfChannels = audioSample.numberOfChannels;\n                this.lastSampleRate = audioSample.sampleRate;\n            }\n            if (!this.encoderInitialized) {\n                if (!this.ensureEncoderPromise) {\n                    void this.ensureEncoder(audioSample);\n                }\n                // No, this \"if\" statement is not useless. Sometimes, the above call to `ensureEncoder` might have\n                // synchronously completed and the encoder is already initialized. In this case, we don't need to await\n                // the promise anymore. This also fixes nasty async race condition bugs when multiple code paths are\n                // calling this method: It's important that the call that initialized the encoder go through this\n                // code first.\n                if (!this.encoderInitialized) {\n                    await this.ensureEncoderPromise;\n                }\n            }\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.encoderInitialized);\n            if (this.customEncoder) {\n                this.customEncoderQueueSize++;\n                // We clone the sample so it cannot be closed on us from the outside before it reaches the encoder\n                const clonedSample = audioSample.clone();\n                const promise = this.customEncoderCallSerializer\n                    .call(() => this.customEncoder.encode(clonedSample))\n                    .then(() => this.customEncoderQueueSize--)\n                    .catch((error) => this.encoderError ??= error)\n                    .finally(() => {\n                    clonedSample.close();\n                    // `audioSample` gets closed in the finally block at the end of the method\n                });\n                if (this.customEncoderQueueSize >= 4) {\n                    await promise;\n                }\n                await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n            }\n            else if (this.isPcmEncoder) {\n                await this.doPcmEncoding(audioSample, shouldClose);\n            }\n            else {\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.encoder);\n                const audioData = audioSample.toAudioData();\n                this.encoder.encode(audioData);\n                audioData.close();\n                if (shouldClose) {\n                    audioSample.close();\n                }\n                if (this.encoder.encodeQueueSize >= 4) {\n                    await new Promise(resolve => this.encoder.addEventListener('dequeue', resolve, { once: true }));\n                }\n                await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n            }\n        }\n        finally {\n            if (shouldClose) {\n                // Make sure it's always closed, even if there was an error\n                audioSample.close();\n            }\n        }\n    }\n    async doPcmEncoding(audioSample, shouldClose) {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.outputSampleSize);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.writeOutputValue);\n        // Need to extract data from the audio data before we close it\n        const { numberOfChannels, numberOfFrames, sampleRate, timestamp } = audioSample;\n        const CHUNK_SIZE = 2048;\n        const outputs = [];\n        // Prepare all of the output buffers, each being bounded by CHUNK_SIZE so we don't generate huge packets\n        for (let frame = 0; frame < numberOfFrames; frame += CHUNK_SIZE) {\n            const frameCount = Math.min(CHUNK_SIZE, audioSample.numberOfFrames - frame);\n            const outputSize = frameCount * numberOfChannels * this.outputSampleSize;\n            const outputBuffer = new ArrayBuffer(outputSize);\n            const outputView = new DataView(outputBuffer);\n            outputs.push({ frameCount, view: outputView });\n        }\n        const allocationSize = audioSample.allocationSize(({ planeIndex: 0, format: 'f32-planar' }));\n        const floats = new Float32Array(allocationSize / Float32Array.BYTES_PER_ELEMENT);\n        for (let i = 0; i < numberOfChannels; i++) {\n            audioSample.copyTo(floats, { planeIndex: i, format: 'f32-planar' });\n            for (let j = 0; j < outputs.length; j++) {\n                const { frameCount, view } = outputs[j];\n                for (let k = 0; k < frameCount; k++) {\n                    this.writeOutputValue(view, (k * numberOfChannels + i) * this.outputSampleSize, floats[j * CHUNK_SIZE + k]);\n                }\n            }\n        }\n        if (shouldClose) {\n            audioSample.close();\n        }\n        const meta = {\n            decoderConfig: {\n                codec: this.encodingConfig.codec,\n                numberOfChannels,\n                sampleRate,\n            },\n        };\n        for (let i = 0; i < outputs.length; i++) {\n            const { frameCount, view } = outputs[i];\n            const outputBuffer = view.buffer;\n            const startFrame = i * CHUNK_SIZE;\n            const packet = new _packet_js__WEBPACK_IMPORTED_MODULE_1__.EncodedPacket(new Uint8Array(outputBuffer), 'key', timestamp + startFrame / sampleRate, frameCount / sampleRate);\n            this.encodingConfig.onEncodedPacket?.(packet, meta);\n            await this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta); // With backpressure\n        }\n    }\n    ensureEncoder(audioSample) {\n        if (this.encoderInitialized) {\n            return;\n        }\n        const encoderError = new Error();\n        return this.ensureEncoderPromise = (async () => {\n            const { numberOfChannels, sampleRate } = audioSample;\n            const encoderConfig = (0,_encode_js__WEBPACK_IMPORTED_MODULE_4__.buildAudioEncoderConfig)({\n                numberOfChannels,\n                sampleRate,\n                ...this.encodingConfig,\n            });\n            this.encodingConfig.onEncoderConfig?.(encoderConfig);\n            const MatchingCustomEncoder = _custom_coder_js__WEBPACK_IMPORTED_MODULE_5__.customAudioEncoders.find(x => x.supports(this.encodingConfig.codec, encoderConfig));\n            if (MatchingCustomEncoder) {\n                // @ts-expect-error \"Can't create instance of abstract class 🤓\"\n                this.customEncoder = new MatchingCustomEncoder();\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.codec = this.encodingConfig.codec;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.config = encoderConfig;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.onPacket = (packet, meta) => {\n                    if (!(packet instanceof _packet_js__WEBPACK_IMPORTED_MODULE_1__.EncodedPacket)) {\n                        throw new TypeError('The first argument passed to onPacket must be an EncodedPacket.');\n                    }\n                    if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n                        throw new TypeError('The second argument passed to onPacket must be an object or undefined.');\n                    }\n                    this.encodingConfig.onEncodedPacket?.(packet, meta);\n                    void this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta);\n                };\n                await this.customEncoder.init();\n            }\n            else if (_codec_js__WEBPACK_IMPORTED_MODULE_0__.PCM_AUDIO_CODECS.includes(this.encodingConfig.codec)) {\n                this.initPcmEncoder();\n            }\n            else {\n                if (typeof AudioEncoder === 'undefined') {\n                    throw new Error('AudioEncoder is not supported by this browser.');\n                }\n                const support = await AudioEncoder.isConfigSupported(encoderConfig);\n                if (!support.supported) {\n                    throw new Error(`This specific encoder configuration (${encoderConfig.codec}, ${encoderConfig.bitrate} bps,`\n                        + ` ${encoderConfig.numberOfChannels} channels, ${encoderConfig.sampleRate} Hz) is not`\n                        + ` supported by this browser. Consider using another codec or changing your audio parameters.`);\n                }\n                this.encoder = new AudioEncoder({\n                    output: (chunk, meta) => {\n                        const packet = _packet_js__WEBPACK_IMPORTED_MODULE_1__.EncodedPacket.fromEncodedChunk(chunk);\n                        this.encodingConfig.onEncodedPacket?.(packet, meta);\n                        void this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta);\n                    },\n                    error: (error) => {\n                        error.stack = encoderError.stack; // Provide a more useful stack trace\n                        this.encoderError ??= error;\n                    },\n                });\n                this.encoder.configure(encoderConfig);\n            }\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.source._connectedTrack);\n            this.muxer = this.source._connectedTrack.output._muxer;\n            this.encoderInitialized = true;\n        })();\n    }\n    initPcmEncoder() {\n        this.isPcmEncoder = true;\n        const codec = this.encodingConfig.codec;\n        const { dataType, sampleSize, littleEndian } = (0,_codec_js__WEBPACK_IMPORTED_MODULE_0__.parsePcmCodec)(codec);\n        this.outputSampleSize = sampleSize;\n        // All these functions receive a float sample as input and map it into the desired format\n        switch (sampleSize) {\n            case 1:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint8(byteOffset, (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.clamp)((value + 1) * 127.5, 0, 255));\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            view.setInt8(byteOffset, (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(Math.round(value * 128), -128, 127));\n                        };\n                    }\n                    else if (dataType === 'ulaw') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            const int16 = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(Math.floor(value * 32767), -32768, 32767);\n                            view.setUint8(byteOffset, (0,_pcm_js__WEBPACK_IMPORTED_MODULE_6__.toUlaw)(int16));\n                        };\n                    }\n                    else if (dataType === 'alaw') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            const int16 = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(Math.floor(value * 32767), -32768, 32767);\n                            view.setUint8(byteOffset, (0,_pcm_js__WEBPACK_IMPORTED_MODULE_6__.toAlaw)(int16));\n                        };\n                    }\n                    else {\n                        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false);\n                    }\n                }\n                ;\n                break;\n            case 2:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint16(byteOffset, (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.clamp)((value + 1) * 32767.5, 0, 65535), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt16(byteOffset, (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(Math.round(value * 32767), -32768, 32767), littleEndian);\n                    }\n                    else {\n                        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false);\n                    }\n                }\n                ;\n                break;\n            case 3:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.setUint24)(view, byteOffset, (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.clamp)((value + 1) * 8388607.5, 0, 16777215), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.setInt24)(view, byteOffset, (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(Math.round(value * 8388607), -8388608, 8388607), littleEndian);\n                    }\n                    else {\n                        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false);\n                    }\n                }\n                ;\n                break;\n            case 4:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint32(byteOffset, (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.clamp)((value + 1) * 2147483647.5, 0, 4294967295), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt32(byteOffset, (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(Math.round(value * 2147483647), -2147483648, 2147483647), littleEndian);\n                    }\n                    else if (dataType === 'float') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setFloat32(byteOffset, value, littleEndian);\n                    }\n                    else {\n                        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false);\n                    }\n                }\n                ;\n                break;\n            case 8:\n                {\n                    if (dataType === 'float') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setFloat64(byteOffset, value, littleEndian);\n                    }\n                    else {\n                        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false);\n                    }\n                }\n                ;\n                break;\n            default:\n                {\n                    (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assertNever)(sampleSize);\n                    (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false);\n                }\n                ;\n        }\n    }\n    async flushAndClose(forceClose) {\n        if (!forceClose)\n            this.checkForEncoderError();\n        if (this.customEncoder) {\n            if (!forceClose) {\n                void this.customEncoderCallSerializer.call(() => this.customEncoder.flush());\n            }\n            await this.customEncoderCallSerializer.call(() => this.customEncoder.close());\n        }\n        else if (this.encoder) {\n            if (!forceClose) {\n                await this.encoder.flush();\n            }\n            if (this.encoder.state !== 'closed') {\n                this.encoder.close();\n            }\n        }\n        if (!forceClose)\n            this.checkForEncoderError();\n    }\n    getQueueSize() {\n        if (this.customEncoder) {\n            return this.customEncoderQueueSize;\n        }\n        else if (this.isPcmEncoder) {\n            return 0;\n        }\n        else {\n            return this.encoder?.encodeQueueSize ?? 0;\n        }\n    }\n    checkForEncoderError() {\n        if (this.encoderError) {\n            this.encoderError.stack = new Error().stack; // Provide an even more useful stack trace\n            throw this.encoderError;\n        }\n    }\n}\n/**\n * This source can be used to add raw, unencoded audio samples to an output audio track. These samples will\n * automatically be encoded and then piped into the output.\n * @group Media sources\n * @public\n */\nclass AudioSampleSource extends AudioSource {\n    /**\n     * Creates a new {@link AudioSampleSource} whose samples are encoded according to the specified\n     * {@link AudioEncodingConfig}.\n     */\n    constructor(encodingConfig) {\n        (0,_encode_js__WEBPACK_IMPORTED_MODULE_4__.validateAudioEncodingConfig)(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Encodes an audio sample and then adds it to the output.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(audioSample) {\n        if (!(audioSample instanceof _sample_js__WEBPACK_IMPORTED_MODULE_3__.AudioSample)) {\n            throw new TypeError('audioSample must be an AudioSample.');\n        }\n        return this._encoder.add(audioSample, false);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * This source can be used to add audio data from an AudioBuffer to the output track. This is useful when working with\n * the Web Audio API.\n * @group Media sources\n * @public\n */\nclass AudioBufferSource extends AudioSource {\n    /**\n     * Creates a new {@link AudioBufferSource} whose `AudioBuffer` instances are encoded according to the specified\n     * {@link AudioEncodingConfig}.\n     */\n    constructor(encodingConfig) {\n        (0,_encode_js__WEBPACK_IMPORTED_MODULE_4__.validateAudioEncodingConfig)(encodingConfig);\n        super(encodingConfig.codec);\n        /** @internal */\n        this._accumulatedTime = 0;\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Converts an AudioBuffer to audio samples, encodes them and adds them to the output. The first AudioBuffer will\n     * be played at timestamp 0, and any subsequent AudioBuffer will have a timestamp equal to the total duration of\n     * all previous AudioBuffers.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    async add(audioBuffer) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const iterator = _sample_js__WEBPACK_IMPORTED_MODULE_3__.AudioSample._fromAudioBuffer(audioBuffer, this._accumulatedTime);\n        this._accumulatedTime += audioBuffer.duration;\n        for (const audioSample of iterator) {\n            await this._encoder.add(audioSample, true);\n        }\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Audio source that encodes the data of a\n * [`MediaStreamAudioTrack`](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) and pipes it into the\n * output. This is useful for capturing live or real-time audio such as microphones or audio from other media elements.\n * Audio will automatically start being captured once the connected {@link Output} is started, and will keep being\n * captured until the {@link Output} is finalized or this source is closed.\n * @group Media sources\n * @public\n */\nclass MediaStreamAudioTrackSource extends AudioSource {\n    /** A promise that rejects upon any error within this source. This promise never resolves. */\n    get errorPromise() {\n        this._errorPromiseAccessed = true;\n        return this._promiseWithResolvers.promise;\n    }\n    /**\n     * Creates a new {@link MediaStreamAudioTrackSource} from a `MediaStreamAudioTrack`, which will pull audio samples\n     * from the stream in real time and encode them according to {@link AudioEncodingConfig}.\n     */\n    constructor(track, encodingConfig) {\n        if (!(track instanceof MediaStreamTrack) || track.kind !== 'audio') {\n            throw new TypeError('track must be an audio MediaStreamTrack.');\n        }\n        (0,_encode_js__WEBPACK_IMPORTED_MODULE_4__.validateAudioEncodingConfig)(encodingConfig);\n        super(encodingConfig.codec);\n        /** @internal */\n        this._abortController = null;\n        /** @internal */\n        this._audioContext = null;\n        /** @internal */\n        this._scriptProcessorNode = null; // Deprecated but goated\n        /** @internal */\n        this._promiseWithResolvers = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.promiseWithResolvers)();\n        /** @internal */\n        this._errorPromiseAccessed = false;\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n        this._track = track;\n    }\n    /** @internal */\n    async _start() {\n        if (!this._errorPromiseAccessed) {\n            console.warn('Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal'\n                + ' errors get bubbled up properly.');\n        }\n        this._abortController = new AbortController();\n        if (typeof MediaStreamTrackProcessor !== 'undefined') {\n            // Great, MediaStreamTrackProcessor is supported, this is the preferred way of doing things\n            let firstAudioDataTimestamp = null;\n            const processor = new MediaStreamTrackProcessor({ track: this._track });\n            const consumer = new WritableStream({\n                write: (audioData) => {\n                    if (firstAudioDataTimestamp === null) {\n                        firstAudioDataTimestamp = audioData.timestamp / 1e6;\n                        const muxer = this._connectedTrack.output._muxer;\n                        if (muxer.firstMediaStreamTimestamp === null) {\n                            muxer.firstMediaStreamTimestamp = performance.now() / 1000;\n                            this._timestampOffset = -firstAudioDataTimestamp;\n                        }\n                        else {\n                            this._timestampOffset = (performance.now() / 1000 - muxer.firstMediaStreamTimestamp)\n                                - firstAudioDataTimestamp;\n                        }\n                    }\n                    if (this._encoder.getQueueSize() >= 4) {\n                        // Drop data if the encoder is overloaded\n                        audioData.close();\n                        return;\n                    }\n                    void this._encoder.add(new _sample_js__WEBPACK_IMPORTED_MODULE_3__.AudioSample(audioData), true)\n                        .catch((error) => {\n                        this._abortController?.abort();\n                        this._promiseWithResolvers.reject(error);\n                    });\n                },\n            });\n            processor.readable.pipeTo(consumer, {\n                signal: this._abortController.signal,\n            }).catch((error) => {\n                // Handle AbortError silently\n                if (error instanceof DOMException && error.name === 'AbortError')\n                    return;\n                this._promiseWithResolvers.reject(error);\n            });\n        }\n        else {\n            // Let's fall back to an AudioContext approach\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n            const AudioContext = window.AudioContext || window.webkitAudioContext;\n            this._audioContext = new AudioContext({ sampleRate: this._track.getSettings().sampleRate });\n            const sourceNode = this._audioContext.createMediaStreamSource(new MediaStream([this._track]));\n            this._scriptProcessorNode = this._audioContext.createScriptProcessor(4096);\n            if (this._audioContext.state === 'suspended') {\n                await this._audioContext.resume();\n            }\n            sourceNode.connect(this._scriptProcessorNode);\n            this._scriptProcessorNode.connect(this._audioContext.destination);\n            let audioReceived = false;\n            let totalDuration = 0;\n            this._scriptProcessorNode.onaudioprocess = (event) => {\n                const iterator = _sample_js__WEBPACK_IMPORTED_MODULE_3__.AudioSample._fromAudioBuffer(event.inputBuffer, totalDuration);\n                totalDuration += event.inputBuffer.duration;\n                for (const audioSample of iterator) {\n                    if (!audioReceived) {\n                        audioReceived = true;\n                        const muxer = this._connectedTrack.output._muxer;\n                        if (muxer.firstMediaStreamTimestamp === null) {\n                            muxer.firstMediaStreamTimestamp = performance.now() / 1000;\n                        }\n                        else {\n                            this._timestampOffset = performance.now() / 1000 - muxer.firstMediaStreamTimestamp;\n                        }\n                    }\n                    if (this._encoder.getQueueSize() >= 4) {\n                        // Drop data if the encoder is overloaded\n                        audioSample.close();\n                        continue;\n                    }\n                    void this._encoder.add(audioSample, true)\n                        .catch((error) => {\n                        void this._audioContext.suspend();\n                        this._promiseWithResolvers.reject(error);\n                    });\n                }\n            };\n        }\n    }\n    /** @internal */\n    async _flushAndClose(forceClose) {\n        if (this._abortController) {\n            this._abortController.abort();\n            this._abortController = null;\n        }\n        if (this._audioContext) {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this._scriptProcessorNode);\n            this._scriptProcessorNode.disconnect();\n            await this._audioContext.suspend();\n        }\n        await this._encoder.flushAndClose(forceClose);\n    }\n}\nconst mediaStreamTrackProcessorWorkerCode = () => {\n    const sendMessage = (message, transfer) => {\n        if (transfer) {\n            self.postMessage(message, { transfer });\n        }\n        else {\n            self.postMessage(message);\n        }\n    };\n    // Immediately send a message to the main thread, letting them know of the support\n    sendMessage({\n        type: 'support',\n        supported: typeof MediaStreamTrackProcessor !== 'undefined',\n    });\n    const abortControllers = new Map();\n    const stoppedTracks = new Set();\n    self.addEventListener('message', (event) => {\n        const message = event.data;\n        switch (message.type) {\n            case 'videoTrack':\n                {\n                    const processor = new MediaStreamTrackProcessor({ track: message.track });\n                    const consumer = new WritableStream({\n                        write: (videoFrame) => {\n                            if (stoppedTracks.has(message.trackId)) {\n                                videoFrame.close();\n                                return;\n                            }\n                            // Send it to the main thread\n                            sendMessage({\n                                type: 'videoFrame',\n                                trackId: message.trackId,\n                                videoFrame,\n                            }, [videoFrame]);\n                        },\n                    });\n                    const abortController = new AbortController();\n                    abortControllers.set(message.trackId, abortController);\n                    processor.readable.pipeTo(consumer, {\n                        signal: abortController.signal,\n                    }).catch((error) => {\n                        // Handle AbortError silently\n                        if (error instanceof DOMException && error.name === 'AbortError')\n                            return;\n                        sendMessage({\n                            type: 'error',\n                            trackId: message.trackId,\n                            error,\n                        });\n                    });\n                }\n                ;\n                break;\n            case 'stopTrack':\n                {\n                    const abortController = abortControllers.get(message.trackId);\n                    if (abortController) {\n                        abortController.abort();\n                        abortControllers.delete(message.trackId);\n                    }\n                    stoppedTracks.add(message.trackId);\n                    sendMessage({\n                        type: 'trackStopped',\n                        trackId: message.trackId,\n                    });\n                }\n                ;\n                break;\n            default: (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assertNever)(message);\n        }\n    });\n};\nlet nextMediaStreamTrackProcessorWorkerId = 0;\nlet mediaStreamTrackProcessorWorker = null;\nconst initMediaStreamTrackProcessorWorker = () => {\n    const blob = new Blob([`(${mediaStreamTrackProcessorWorkerCode.toString()})()`], { type: 'application/javascript' });\n    const url = URL.createObjectURL(blob);\n    mediaStreamTrackProcessorWorker = new Worker(url);\n};\nlet mediaStreamTrackProcessorIsSupportedInWorkerCache = null;\nconst mediaStreamTrackProcessorIsSupportedInWorker = async () => {\n    if (mediaStreamTrackProcessorIsSupportedInWorkerCache !== null) {\n        return mediaStreamTrackProcessorIsSupportedInWorkerCache;\n    }\n    if (!mediaStreamTrackProcessorWorker) {\n        initMediaStreamTrackProcessorWorker();\n    }\n    return new Promise((resolve) => {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(mediaStreamTrackProcessorWorker);\n        const listener = (event) => {\n            const message = event.data;\n            if (message.type === 'support') {\n                mediaStreamTrackProcessorIsSupportedInWorkerCache = message.supported;\n                mediaStreamTrackProcessorWorker.removeEventListener('message', listener);\n                resolve(message.supported);\n            }\n        };\n        mediaStreamTrackProcessorWorker.addEventListener('message', listener);\n    });\n};\nconst sendMessageToMediaStreamTrackProcessorWorker = (message, transfer) => {\n    (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.assert)(mediaStreamTrackProcessorWorker);\n    if (transfer) {\n        mediaStreamTrackProcessorWorker.postMessage(message, transfer);\n    }\n    else {\n        mediaStreamTrackProcessorWorker.postMessage(message);\n    }\n};\n/**\n * Base class for subtitle sources - sources for subtitle tracks.\n * @group Media sources\n * @public\n */\nclass SubtitleSource extends MediaSource {\n    /** Internal constructor. */\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!_codec_js__WEBPACK_IMPORTED_MODULE_0__.SUBTITLE_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid subtitle codec '${codec}'. Must be one of: ${_codec_js__WEBPACK_IMPORTED_MODULE_0__.SUBTITLE_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * This source can be used to add subtitles from a subtitle text file.\n * @group Media sources\n * @public\n */\nclass TextSubtitleSource extends SubtitleSource {\n    /** Creates a new {@link TextSubtitleSource} where added text chunks are in the specified `codec`. */\n    constructor(codec) {\n        super(codec);\n        this._parser = new _subtitles_js__WEBPACK_IMPORTED_MODULE_7__.SubtitleParser({\n            codec,\n            output: (cue, metadata) => this._connectedTrack?.output._muxer.addSubtitleCue(this._connectedTrack, cue, metadata),\n        });\n    }\n    /**\n     * Parses the subtitle text according to the specified codec and adds it to the output track. You don't have to\n     * add the entire subtitle file at once here; you can provide it in chunks.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(text) {\n        if (typeof text !== 'string') {\n            throw new TypeError('text must be a string.');\n        }\n        this._ensureValidAdd();\n        this._parser.parse(text);\n        return this._connectedTrack.output._muxer.mutex.currentPromise;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL21lZGlhLXNvdXJjZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyRztBQUNPO0FBQ2xFO0FBQ047QUFDb0M7QUFDbEM7QUFDVztBQUNtRjtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFZO0FBQ3pCLHdEQUF3RCxNQUFNLHFCQUFxQixtREFBWSxZQUFZO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ087QUFDUCx1QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscURBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBZTtBQUM1QiwyREFBMkQsTUFBTSxxQkFBcUIsc0RBQWUsWUFBWTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBLDJCQUEyQix5REFBYztBQUN6QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGNoLWN1dC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL21lZGlhLXNvdXJjZS5qcz9kOGY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDI1LXByZXNlbnQsIFZhbmlsYWd5IGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgQVVESU9fQ09ERUNTLCBwYXJzZVBjbUNvZGVjLCBQQ01fQVVESU9fQ09ERUNTLCBTVUJUSVRMRV9DT0RFQ1MsIFZJREVPX0NPREVDUywgfSBmcm9tICcuL2NvZGVjLmpzJztcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0TmV2ZXIsIENhbGxTZXJpYWxpemVyLCBjbGFtcCwgcHJvbWlzZVdpdGhSZXNvbHZlcnMsIHNldEludDI0LCBzZXRVaW50MjQgfSBmcm9tICcuL21pc2MuanMnO1xuaW1wb3J0IHsgU3VidGl0bGVQYXJzZXIgfSBmcm9tICcuL3N1YnRpdGxlcy5qcyc7XG5pbXBvcnQgeyB0b0FsYXcsIHRvVWxhdyB9IGZyb20gJy4vcGNtLmpzJztcbmltcG9ydCB7IGN1c3RvbVZpZGVvRW5jb2RlcnMsIGN1c3RvbUF1ZGlvRW5jb2RlcnMsIH0gZnJvbSAnLi9jdXN0b20tY29kZXIuanMnO1xuaW1wb3J0IHsgRW5jb2RlZFBhY2tldCB9IGZyb20gJy4vcGFja2V0LmpzJztcbmltcG9ydCB7IEF1ZGlvU2FtcGxlLCBWaWRlb1NhbXBsZSB9IGZyb20gJy4vc2FtcGxlLmpzJztcbmltcG9ydCB7IGJ1aWxkQXVkaW9FbmNvZGVyQ29uZmlnLCBidWlsZFZpZGVvRW5jb2RlckNvbmZpZywgdmFsaWRhdGVBdWRpb0VuY29kaW5nQ29uZmlnLCB2YWxpZGF0ZVZpZGVvRW5jb2RpbmdDb25maWcsIH0gZnJvbSAnLi9lbmNvZGUuanMnO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBtZWRpYSBzb3VyY2VzLiBNZWRpYSBzb3VyY2VzIGFyZSB1c2VkIHRvIGFkZCBtZWRpYSBzYW1wbGVzIHRvIGFuIG91dHB1dCBmaWxlLlxuICogQGdyb3VwIE1lZGlhIHNvdXJjZXNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIE1lZGlhU291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWRUcmFjayA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fY2xvc2luZ1Byb21pc2UgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEEgdGltZSBvZmZzZXQgaW4gc2Vjb25kcyB0aGF0IGlzIGFkZGVkIHRvIGFsbCB0aW1lc3RhbXBzIGdlbmVyYXRlZCBieSB0aGlzIHNvdXJjZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RpbWVzdGFtcE9mZnNldCA9IDA7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZW5zdXJlVmFsaWRBZGQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkVHJhY2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU291cmNlIGlzIG5vdCBjb25uZWN0ZWQgdG8gYW4gb3V0cHV0IHRyYWNrLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWRUcmFjay5vdXRwdXQuc3RhdGUgPT09ICdjYW5jZWxlZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3V0cHV0IGhhcyBiZWVuIGNhbmNlbGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWRUcmFjay5vdXRwdXQuc3RhdGUgPT09ICdmaW5hbGl6aW5nJyB8fCB0aGlzLl9jb25uZWN0ZWRUcmFjay5vdXRwdXQuc3RhdGUgPT09ICdmaW5hbGl6ZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dHB1dCBoYXMgYmVlbiBmaW5hbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZFRyYWNrLm91dHB1dC5zdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dHB1dCBoYXMgbm90IHN0YXJ0ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgaXMgY2xvc2VkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBhc3luYyBfc3RhcnQoKSB7IH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIF9mbHVzaEFuZENsb3NlKGZvcmNlQ2xvc2UpIHsgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGlzIHNvdXJjZS4gVGhpcyBwcmV2ZW50cyBmdXR1cmUgc2FtcGxlcyBmcm9tIGJlaW5nIGFkZGVkIGFuZCBzaWduYWxzIHRvIHRoZSBvdXRwdXQgZmlsZSB0aGF0IG5vIGZ1cnRoZXJcbiAgICAgKiBzYW1wbGVzIHdpbGwgY29tZSBpbiBmb3IgdGhpcyB0cmFjay4gQ2FsbGluZyBgLmNsb3NlKClgIGlzIG9wdGlvbmFsIGJ1dCByZWNvbW1lbmRlZCBhZnRlciBhZGRpbmcgdGhlXG4gICAgICogbGFzdCBzYW1wbGUgLSBmb3IgaW1wcm92ZWQgcGVyZm9ybWFuY2UgYW5kIHJlZHVjZWQgbWVtb3J5IHVzYWdlLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2luZ1Byb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0ZWRUcmFjayA9IHRoaXMuX2Nvbm5lY3RlZFRyYWNrO1xuICAgICAgICBpZiAoIWNvbm5lY3RlZFRyYWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIGNsb3NlIHdpdGhvdXQgY29ubmVjdGluZyB0aGUgc291cmNlIHRvIGFuIG91dHB1dCB0cmFjay4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGVkVHJhY2sub3V0cHV0LnN0YXRlID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgY2xvc2UgYmVmb3JlIG91dHB1dCBoYXMgYmVlbiBzdGFydGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Nsb3NpbmdQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2ZsdXNoQW5kQ2xvc2UoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0ZWRUcmFjay5vdXRwdXQuc3RhdGUgPT09ICdmaW5hbGl6aW5nJyB8fCBjb25uZWN0ZWRUcmFjay5vdXRwdXQuc3RhdGUgPT09ICdmaW5hbGl6ZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ubmVjdGVkVHJhY2sub3V0cHV0Ll9tdXhlci5vblRyYWNrQ2xvc2UoY29ubmVjdGVkVHJhY2spO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgYXN5bmMgX2ZsdXNoT3JXYWl0Rm9yT25nb2luZ0Nsb3NlKGZvcmNlQ2xvc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NpbmdQcm9taXNlKSB7XG4gICAgICAgICAgICAvLyBTaW5jZSBjbG9zaW5nIGFsc28gZmx1c2hlcywgd2UgZG9uJ3Qgd2FudCB0byBkbyBpdCB0d2ljZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NpbmdQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZsdXNoQW5kQ2xvc2UoZm9yY2VDbG9zZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHZpZGVvIHNvdXJjZXMgLSBzb3VyY2VzIGZvciB2aWRlbyB0cmFja3MuXG4gKiBAZ3JvdXAgTWVkaWEgc291cmNlc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgVmlkZW9Tb3VyY2UgZXh0ZW5kcyBNZWRpYVNvdXJjZSB7XG4gICAgLyoqIEludGVybmFsIGNvbnN0cnVjdG9yLiAqL1xuICAgIGNvbnN0cnVjdG9yKGNvZGVjKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fY29ubmVjdGVkVHJhY2sgPSBudWxsO1xuICAgICAgICBpZiAoIVZJREVPX0NPREVDUy5pbmNsdWRlcyhjb2RlYykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgdmlkZW8gY29kZWMgJyR7Y29kZWN9Jy4gTXVzdCBiZSBvbmUgb2Y6ICR7VklERU9fQ09ERUNTLmpvaW4oJywgJyl9LmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvZGVjID0gY29kZWM7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgbW9zdCBiYXNpYyB2aWRlbyBzb3VyY2U7IGNhbiBiZSB1c2VkIHRvIGRpcmVjdGx5IHBpcGUgZW5jb2RlZCBwYWNrZXRzIGludG8gdGhlIG91dHB1dCBmaWxlLlxuICogQGdyb3VwIE1lZGlhIHNvdXJjZXNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEVuY29kZWRWaWRlb1BhY2tldFNvdXJjZSBleHRlbmRzIFZpZGVvU291cmNlIHtcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgRW5jb2RlZFZpZGVvUGFja2V0U291cmNlfSB3aG9zZSBwYWNrZXRzIGFyZSBlbmNvZGVkIHVzaW5nIGBjb2RlY2AuICovXG4gICAgY29uc3RydWN0b3IoY29kZWMpIHtcbiAgICAgICAgc3VwZXIoY29kZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGVuY29kZWQgcGFja2V0IHRvIHRoZSBvdXRwdXQgdmlkZW8gdHJhY2suIFBhY2tldHMgbXVzdCBiZSBhZGRlZCBpbiAqZGVjb2RlIG9yZGVyKiwgd2hpbGUgYSBwYWNrZXQnc1xuICAgICAqIHRpbWVzdGFtcCBtdXN0IGJlIGl0cyAqcHJlc2VudGF0aW9uIHRpbWVzdGFtcCouIEItZnJhbWVzIGFyZSBoYW5kbGVkIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWV0YSAtIEFkZGl0aW9uYWwgbWV0YWRhdGEgZnJvbSB0aGUgZW5jb2Rlci4gWW91IHNob3VsZCBwYXNzIHRoaXMgZm9yIHRoZSBmaXJzdCBjYWxsLCBpbmNsdWRpbmcgYSB2YWxpZFxuICAgICAqIGRlY29kZXIgY29uZmlnLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgb3V0cHV0IGlzIHJlYWR5IHRvIHJlY2VpdmUgbW9yZSBzYW1wbGVzLiBZb3Ugc2hvdWxkIGF3YWl0IHRoaXMgUHJvbWlzZVxuICAgICAqIHRvIHJlc3BlY3Qgd3JpdGVyIGFuZCBlbmNvZGVyIGJhY2twcmVzc3VyZS5cbiAgICAgKi9cbiAgICBhZGQocGFja2V0LCBtZXRhKSB7XG4gICAgICAgIGlmICghKHBhY2tldCBpbnN0YW5jZW9mIEVuY29kZWRQYWNrZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYWNrZXQgbXVzdCBiZSBhbiBFbmNvZGVkUGFja2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWNrZXQuaXNNZXRhZGF0YU9ubHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01ldGFkYXRhLW9ubHkgcGFja2V0cyBjYW5ub3QgYmUgYWRkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEgIT09IHVuZGVmaW5lZCAmJiAoIW1ldGEgfHwgdHlwZW9mIG1ldGEgIT09ICdvYmplY3QnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWV0YSwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW5zdXJlVmFsaWRBZGQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RlZFRyYWNrLm91dHB1dC5fbXV4ZXIuYWRkRW5jb2RlZFZpZGVvUGFja2V0KHRoaXMuX2Nvbm5lY3RlZFRyYWNrLCBwYWNrZXQsIG1ldGEpO1xuICAgIH1cbn1cbmNsYXNzIFZpZGVvRW5jb2RlcldyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZW5jb2RpbmdDb25maWcpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZW5jb2RpbmdDb25maWcgPSBlbmNvZGluZ0NvbmZpZztcbiAgICAgICAgdGhpcy5lbnN1cmVFbmNvZGVyUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZW5jb2RlckluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IG51bGw7XG4gICAgICAgIHRoaXMubXV4ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RNdWx0aXBsZU9mS2V5RnJhbWVJbnRlcnZhbCA9IC0xO1xuICAgICAgICB0aGlzLmNvZGVkV2lkdGggPSBudWxsO1xuICAgICAgICB0aGlzLmNvZGVkSGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNpemVDYW52YXMgPSBudWxsO1xuICAgICAgICB0aGlzLmN1c3RvbUVuY29kZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmN1c3RvbUVuY29kZXJDYWxsU2VyaWFsaXplciA9IG5ldyBDYWxsU2VyaWFsaXplcigpO1xuICAgICAgICB0aGlzLmN1c3RvbUVuY29kZXJRdWV1ZVNpemUgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcnMgdHlwaWNhbGx5IHRocm93IHRoZWlyIGVycm9ycyBcIm91dCBvZiBiYW5kXCIsIG1lYW5pbmcgYXN5bmNocm9ub3VzbHkgaW4gc29tZSBvdGhlciBleGVjdXRpb24gY29udGV4dC5cbiAgICAgICAgICogSG93ZXZlciwgd2Ugd2FudCB0byBzdXJmYWNlIHRoZXNlIGVycm9ycyB0byB0aGUgdXNlciB3aXRoaW4gdGhlIG5vcm1hbCBjb250cm9sIGZsb3csIHNvIHRoZXkgZG9uJ3QgZ28gdW5jYXVnaHQuXG4gICAgICAgICAqIFNvLCB3ZSBrZWVwIHRyYWNrIG9mIHRoZSBlbmNvZGVyIGVycm9yIGFuZCB0aHJvdyBpdCBhcyBzb29uIGFzIHdlIGdldCB0aGUgY2hhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbmNvZGVyRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBhc3luYyBhZGQodmlkZW9TYW1wbGUsIHNob3VsZENsb3NlLCBlbmNvZGVPcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRm9yRW5jb2RlckVycm9yKCk7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5fZW5zdXJlVmFsaWRBZGQoKTtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB2aWRlbyBzYW1wbGUgc2l6ZSByZW1haW5zIGNvbnN0YW50XG4gICAgICAgICAgICBpZiAodGhpcy5jb2RlZFdpZHRoICE9PSBudWxsICYmIHRoaXMuY29kZWRIZWlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW9TYW1wbGUuY29kZWRXaWR0aCAhPT0gdGhpcy5jb2RlZFdpZHRoIHx8IHZpZGVvU2FtcGxlLmNvZGVkSGVpZ2h0ICE9PSB0aGlzLmNvZGVkSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpemVDaGFuZ2VCZWhhdmlvciA9IHRoaXMuZW5jb2RpbmdDb25maWcuc2l6ZUNoYW5nZUJlaGF2aW9yID8/ICdkZW55JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemVDaGFuZ2VCZWhhdmlvciA9PT0gJ3Bhc3NUaHJvdWdoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbmFkYVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpemVDaGFuZ2VCZWhhdmlvciA9PT0gJ2RlbnknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZpZGVvIHNhbXBsZSBzaXplIG11c3QgcmVtYWluIGNvbnN0YW50LiBFeHBlY3RlZCAke3RoaXMuY29kZWRXaWR0aH14JHt0aGlzLmNvZGVkSGVpZ2h0fSxgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBgIGdvdCAke3ZpZGVvU2FtcGxlLmNvZGVkV2lkdGh9eCR7dmlkZW9TYW1wbGUuY29kZWRIZWlnaHR9LiBUbyBhbGxvdyB0aGUgc2FtcGxlIHNpemUgdG9gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBgIGNoYW5nZSBvdmVyIHRpbWUsIHNldCBcXGBzaXplQ2hhbmdlQmVoYXZpb3JcXGAgdG8gYSB2YWx1ZSBvdGhlciB0aGFuICdzdHJpY3QnIGluIHRoZWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGAgZW5jb2Rpbmcgb3B0aW9ucy5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYW52YXNJc05ldyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2l6ZUNhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZWZlciBhbiBIVE1MQ2FudmFzRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZUNhbnZhcy53aWR0aCA9IHRoaXMuY29kZWRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemVDYW52YXMuaGVpZ2h0ID0gdGhpcy5jb2RlZEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXplQ2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh0aGlzLmNvZGVkV2lkdGgsIHRoaXMuY29kZWRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNJc05ldyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5yZXNpemVDYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7IGFscGhhOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FudmFzSXNOZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNvZGVkV2lkdGgsIHRoaXMuY29kZWRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9TYW1wbGUuZHJhd1dpdGhGaXQoY29udGV4dCwgeyBmaXQ6IHNpemVDaGFuZ2VCZWhhdmlvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRDbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvU2FtcGxlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWRlb1NhbXBsZSA9IG5ldyBWaWRlb1NhbXBsZSh0aGlzLnJlc2l6ZUNhbnZhcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdmlkZW9TYW1wbGUudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB2aWRlb1NhbXBsZS5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogdmlkZW9TYW1wbGUucm90YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZENsb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29kZWRXaWR0aCA9IHZpZGVvU2FtcGxlLmNvZGVkV2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2RlZEhlaWdodCA9IHZpZGVvU2FtcGxlLmNvZGVkSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmVuY29kZXJJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5lbnN1cmVFbmNvZGVyUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuZW5zdXJlRW5jb2Rlcih2aWRlb1NhbXBsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vLCB0aGlzIFwiaWZcIiBzdGF0ZW1lbnQgaXMgbm90IHVzZWxlc3MuIFNvbWV0aW1lcywgdGhlIGFib3ZlIGNhbGwgdG8gYGVuc3VyZUVuY29kZXJgIG1pZ2h0IGhhdmVcbiAgICAgICAgICAgICAgICAvLyBzeW5jaHJvbm91c2x5IGNvbXBsZXRlZCBhbmQgdGhlIGVuY29kZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4gSW4gdGhpcyBjYXNlLCB3ZSBkb24ndCBuZWVkIHRvIGF3YWl0XG4gICAgICAgICAgICAgICAgLy8gdGhlIHByb21pc2UgYW55bW9yZS4gVGhpcyBhbHNvIGZpeGVzIG5hc3R5IGFzeW5jIHJhY2UgY29uZGl0aW9uIGJ1Z3Mgd2hlbiBtdWx0aXBsZSBjb2RlIHBhdGhzIGFyZVxuICAgICAgICAgICAgICAgIC8vIGNhbGxpbmcgdGhpcyBtZXRob2Q6IEl0J3MgaW1wb3J0YW50IHRoYXQgdGhlIGNhbGwgdGhhdCBpbml0aWFsaXplZCB0aGUgZW5jb2RlciBnbyB0aHJvdWdoIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBjb2RlIGZpcnN0LlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5lbmNvZGVySW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVFbmNvZGVyUHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5lbmNvZGVySW5pdGlhbGl6ZWQpO1xuICAgICAgICAgICAgY29uc3Qga2V5RnJhbWVJbnRlcnZhbCA9IHRoaXMuZW5jb2RpbmdDb25maWcua2V5RnJhbWVJbnRlcnZhbCA/PyA1O1xuICAgICAgICAgICAgY29uc3QgbXVsdGlwbGVPZktleUZyYW1lSW50ZXJ2YWwgPSBNYXRoLmZsb29yKHZpZGVvU2FtcGxlLnRpbWVzdGFtcCAvIGtleUZyYW1lSW50ZXJ2YWwpO1xuICAgICAgICAgICAgLy8gRW5zdXJlIGEga2V5IGZyYW1lIGV2ZXJ5IGtleUZyYW1lSW50ZXJ2YWwgc2Vjb25kcy4gSXQgaXMgaW1wb3J0YW50IHRoYXQgYWxsIHZpZGVvIHRyYWNrcyBmb2xsb3cgdGhlIHNhbWVcbiAgICAgICAgICAgIC8vIFwia2V5IGZyYW1lXCIgcmh5dGhtLCBiZWNhdXNlIGFsaWduZWQga2V5IGZyYW1lcyBhcmUgcmVxdWlyZWQgdG8gc3RhcnQgbmV3IGZyYWdtZW50cyBpbiBJU09CTUZGIG9yIGNsdXN0ZXJzXG4gICAgICAgICAgICAvLyBpbiBNYXRyb3NrYSAob3IgYXQgbGVhc3QgZGVzaXJhYmxlKS5cbiAgICAgICAgICAgIGNvbnN0IGZpbmFsRW5jb2RlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAuLi5lbmNvZGVPcHRpb25zLFxuICAgICAgICAgICAgICAgIGtleUZyYW1lOiBlbmNvZGVPcHRpb25zPy5rZXlGcmFtZVxuICAgICAgICAgICAgICAgICAgICB8fCBrZXlGcmFtZUludGVydmFsID09PSAwXG4gICAgICAgICAgICAgICAgICAgIHx8IG11bHRpcGxlT2ZLZXlGcmFtZUludGVydmFsICE9PSB0aGlzLmxhc3RNdWx0aXBsZU9mS2V5RnJhbWVJbnRlcnZhbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmxhc3RNdWx0aXBsZU9mS2V5RnJhbWVJbnRlcnZhbCA9IG11bHRpcGxlT2ZLZXlGcmFtZUludGVydmFsO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VzdG9tRW5jb2Rlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tRW5jb2RlclF1ZXVlU2l6ZSsrO1xuICAgICAgICAgICAgICAgIC8vIFdlIGNsb25lIHRoZSBzYW1wbGUgc28gaXQgY2Fubm90IGJlIGNsb3NlZCBvbiB1cyBmcm9tIHRoZSBvdXRzaWRlIGJlZm9yZSBpdCByZWFjaGVzIHRoZSBlbmNvZGVyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkU2FtcGxlID0gdmlkZW9TYW1wbGUuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5jdXN0b21FbmNvZGVyQ2FsbFNlcmlhbGl6ZXJcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoKCkgPT4gdGhpcy5jdXN0b21FbmNvZGVyLmVuY29kZShjbG9uZWRTYW1wbGUsIGZpbmFsRW5jb2RlT3B0aW9ucykpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuY3VzdG9tRW5jb2RlclF1ZXVlU2l6ZS0tKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB0aGlzLmVuY29kZXJFcnJvciA/Pz0gZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkU2FtcGxlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGB2aWRlb1NhbXBsZWAgZ2V0cyBjbG9zZWQgaW4gdGhlIGZpbmFsbHkgYmxvY2sgYXQgdGhlIGVuZCBvZiB0aGUgbWV0aG9kXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VzdG9tRW5jb2RlclF1ZXVlU2l6ZSA+PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHRoaXMuZW5jb2Rlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlkZW9GcmFtZSA9IHZpZGVvU2FtcGxlLnRvVmlkZW9GcmFtZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUodmlkZW9GcmFtZSwgZmluYWxFbmNvZGVPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB2aWRlb0ZyYW1lLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZENsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvU2FtcGxlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZG8gdGhpcyBhZnRlciBzZW5kaW5nIHRoZSBmcmFtZSB0byB0aGUgZW5jb2RlciBhcyB0aGUgZnJhbWUgb3RoZXJ3aXNlIG1pZ2h0IGJlIGNsb3NlZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuY29kZXIuZW5jb2RlUXVldWVTaXplID49IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB0aGlzLmVuY29kZXIuYWRkRXZlbnRMaXN0ZW5lcignZGVxdWV1ZScsIHJlc29sdmUsIHsgb25jZTogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5tdXhlci5tdXRleC5jdXJyZW50UHJvbWlzZTsgLy8gQWxsb3cgdGhlIHdyaXRlciB0byBhcHBseSBiYWNrcHJlc3N1cmVcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRDbG9zZSkge1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBpdCdzIGFsd2F5cyBjbG9zZWQsIGV2ZW4gaWYgdGhlcmUgd2FzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgdmlkZW9TYW1wbGUuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBlbnN1cmVFbmNvZGVyKHZpZGVvU2FtcGxlKSB7XG4gICAgICAgIGlmICh0aGlzLmVuY29kZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGVyRXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlRW5jb2RlclByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlckNvbmZpZyA9IGJ1aWxkVmlkZW9FbmNvZGVyQ29uZmlnKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdmlkZW9TYW1wbGUuY29kZWRXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHZpZGVvU2FtcGxlLmNvZGVkSGVpZ2h0LFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZW5jb2RpbmdDb25maWcsXG4gICAgICAgICAgICAgICAgZnJhbWVyYXRlOiB0aGlzLnNvdXJjZS5fY29ubmVjdGVkVHJhY2s/Lm1ldGFkYXRhLmZyYW1lUmF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbmNvZGluZ0NvbmZpZy5vbkVuY29kZXJDb25maWc/LihlbmNvZGVyQ29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IE1hdGNoaW5nQ3VzdG9tRW5jb2RlciA9IGN1c3RvbVZpZGVvRW5jb2RlcnMuZmluZCh4ID0+IHguc3VwcG9ydHModGhpcy5lbmNvZGluZ0NvbmZpZy5jb2RlYywgZW5jb2RlckNvbmZpZykpO1xuICAgICAgICAgICAgaWYgKE1hdGNoaW5nQ3VzdG9tRW5jb2Rlcikge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgXCJDYW4ndCBjcmVhdGUgaW5zdGFuY2Ugb2YgYWJzdHJhY3QgY2xhc3Mg8J+kk1wiXG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b21FbmNvZGVyID0gbmV3IE1hdGNoaW5nQ3VzdG9tRW5jb2RlcigpO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSXQncyB0ZWNobmljYWxseSByZWFkb25seVxuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tRW5jb2Rlci5jb2RlYyA9IHRoaXMuZW5jb2RpbmdDb25maWcuY29kZWM7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBJdCdzIHRlY2huaWNhbGx5IHJlYWRvbmx5XG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b21FbmNvZGVyLmNvbmZpZyA9IGVuY29kZXJDb25maWc7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBJdCdzIHRlY2huaWNhbGx5IHJlYWRvbmx5XG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b21FbmNvZGVyLm9uUGFja2V0ID0gKHBhY2tldCwgbWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYWNrZXQgaW5zdGFuY2VvZiBFbmNvZGVkUGFja2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBvblBhY2tldCBtdXN0IGJlIGFuIEVuY29kZWRQYWNrZXQuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGEgIT09IHVuZGVmaW5lZCAmJiAoIW1ldGEgfHwgdHlwZW9mIG1ldGEgIT09ICdvYmplY3QnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHNlY29uZCBhcmd1bWVudCBwYXNzZWQgdG8gb25QYWNrZXQgbXVzdCBiZSBhbiBvYmplY3Qgb3IgdW5kZWZpbmVkLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5jb2RpbmdDb25maWcub25FbmNvZGVkUGFja2V0Py4ocGFja2V0LCBtZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLm11eGVyLmFkZEVuY29kZWRWaWRlb1BhY2tldCh0aGlzLnNvdXJjZS5fY29ubmVjdGVkVHJhY2ssIHBhY2tldCwgbWV0YSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmN1c3RvbUVuY29kZXIuaW5pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBWaWRlb0VuY29kZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmlkZW9FbmNvZGVyIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzdXBwb3J0ID0gYXdhaXQgVmlkZW9FbmNvZGVyLmlzQ29uZmlnU3VwcG9ydGVkKGVuY29kZXJDb25maWcpO1xuICAgICAgICAgICAgICAgIGlmICghc3VwcG9ydC5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIHNwZWNpZmljIGVuY29kZXIgY29uZmlndXJhdGlvbiAoJHtlbmNvZGVyQ29uZmlnLmNvZGVjfSwgJHtlbmNvZGVyQ29uZmlnLmJpdHJhdGV9IGJwcyxgXG4gICAgICAgICAgICAgICAgICAgICAgICArIGAgJHtlbmNvZGVyQ29uZmlnLndpZHRofXgke2VuY29kZXJDb25maWcuaGVpZ2h0fSwgaGFyZHdhcmUgYWNjZWxlcmF0aW9uOmBcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYCAke2VuY29kZXJDb25maWcuaGFyZHdhcmVBY2NlbGVyYXRpb24gPz8gJ25vLXByZWZlcmVuY2UnfSkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuYFxuICAgICAgICAgICAgICAgICAgICAgICAgKyBgIENvbnNpZGVyIHVzaW5nIGFub3RoZXIgY29kZWMgb3IgY2hhbmdpbmcgeW91ciB2aWRlbyBwYXJhbWV0ZXJzLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVuY29kZXIgPSBuZXcgVmlkZW9FbmNvZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoY2h1bmssIG1ldGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IEVuY29kZWRQYWNrZXQuZnJvbUVuY29kZWRDaHVuayhjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuY29kaW5nQ29uZmlnLm9uRW5jb2RlZFBhY2tldD8uKHBhY2tldCwgbWV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMubXV4ZXIuYWRkRW5jb2RlZFZpZGVvUGFja2V0KHRoaXMuc291cmNlLl9jb25uZWN0ZWRUcmFjaywgcGFja2V0LCBtZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBlbmNvZGVyRXJyb3Iuc3RhY2s7IC8vIFByb3ZpZGUgYSBtb3JlIHVzZWZ1bCBzdGFjayB0cmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmNvZGVyRXJyb3IgPz89IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5jb2Rlci5jb25maWd1cmUoZW5jb2RlckNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5zb3VyY2UuX2Nvbm5lY3RlZFRyYWNrKTtcbiAgICAgICAgICAgIHRoaXMubXV4ZXIgPSB0aGlzLnNvdXJjZS5fY29ubmVjdGVkVHJhY2sub3V0cHV0Ll9tdXhlcjtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgYXN5bmMgZmx1c2hBbmRDbG9zZShmb3JjZUNsb3NlKSB7XG4gICAgICAgIGlmICghZm9yY2VDbG9zZSlcbiAgICAgICAgICAgIHRoaXMuY2hlY2tGb3JFbmNvZGVyRXJyb3IoKTtcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tRW5jb2Rlcikge1xuICAgICAgICAgICAgaWYgKCFmb3JjZUNsb3NlKSB7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLmN1c3RvbUVuY29kZXJDYWxsU2VyaWFsaXplci5jYWxsKCgpID0+IHRoaXMuY3VzdG9tRW5jb2Rlci5mbHVzaCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3VzdG9tRW5jb2RlckNhbGxTZXJpYWxpemVyLmNhbGwoKCkgPT4gdGhpcy5jdXN0b21FbmNvZGVyLmNsb3NlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZW5jb2Rlcikge1xuICAgICAgICAgICAgaWYgKCFmb3JjZUNsb3NlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbmNvZGVyLmZsdXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lbmNvZGVyLnN0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5jb2Rlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZm9yY2VDbG9zZSlcbiAgICAgICAgICAgIHRoaXMuY2hlY2tGb3JFbmNvZGVyRXJyb3IoKTtcbiAgICB9XG4gICAgZ2V0UXVldWVTaXplKCkge1xuICAgICAgICBpZiAodGhpcy5jdXN0b21FbmNvZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21FbmNvZGVyUXVldWVTaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2Rlcj8uZW5jb2RlUXVldWVTaXplID8/IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tGb3JFbmNvZGVyRXJyb3IoKSB7XG4gICAgICAgIGlmICh0aGlzLmVuY29kZXJFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVyRXJyb3Iuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjazsgLy8gUHJvdmlkZSBhbiBldmVuIG1vcmUgdXNlZnVsIHN0YWNrIHRyYWNlXG4gICAgICAgICAgICB0aHJvdyB0aGlzLmVuY29kZXJFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVGhpcyBzb3VyY2UgY2FuIGJlIHVzZWQgdG8gYWRkIHJhdywgdW5lbmNvZGVkIHZpZGVvIHNhbXBsZXMgKGZyYW1lcykgdG8gYW4gb3V0cHV0IHZpZGVvIHRyYWNrLiBUaGVzZSBmcmFtZXMgd2lsbFxuICogYXV0b21hdGljYWxseSBiZSBlbmNvZGVkIGFuZCB0aGVuIHBpcGVkIGludG8gdGhlIG91dHB1dC5cbiAqIEBncm91cCBNZWRpYSBzb3VyY2VzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBWaWRlb1NhbXBsZVNvdXJjZSBleHRlbmRzIFZpZGVvU291cmNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBWaWRlb1NhbXBsZVNvdXJjZX0gd2hvc2Ugc2FtcGxlcyBhcmUgZW5jb2RlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZFxuICAgICAqIHtAbGluayBWaWRlb0VuY29kaW5nQ29uZmlnfS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbmNvZGluZ0NvbmZpZykge1xuICAgICAgICB2YWxpZGF0ZVZpZGVvRW5jb2RpbmdDb25maWcoZW5jb2RpbmdDb25maWcpO1xuICAgICAgICBzdXBlcihlbmNvZGluZ0NvbmZpZy5jb2RlYyk7XG4gICAgICAgIHRoaXMuX2VuY29kZXIgPSBuZXcgVmlkZW9FbmNvZGVyV3JhcHBlcih0aGlzLCBlbmNvZGluZ0NvbmZpZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgYSB2aWRlbyBzYW1wbGUgKGZyYW1lKSBhbmQgdGhlbiBhZGRzIGl0IHRvIHRoZSBvdXRwdXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIHRoZSBvdXRwdXQgaXMgcmVhZHkgdG8gcmVjZWl2ZSBtb3JlIHNhbXBsZXMuIFlvdSBzaG91bGQgYXdhaXQgdGhpcyBQcm9taXNlXG4gICAgICogdG8gcmVzcGVjdCB3cml0ZXIgYW5kIGVuY29kZXIgYmFja3ByZXNzdXJlLlxuICAgICAqL1xuICAgIGFkZCh2aWRlb1NhbXBsZSwgZW5jb2RlT3B0aW9ucykge1xuICAgICAgICBpZiAoISh2aWRlb1NhbXBsZSBpbnN0YW5jZW9mIFZpZGVvU2FtcGxlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmlkZW9TYW1wbGUgbXVzdCBiZSBhIFZpZGVvU2FtcGxlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVyLmFkZCh2aWRlb1NhbXBsZSwgZmFsc2UsIGVuY29kZU9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2ZsdXNoQW5kQ2xvc2UoZm9yY2VDbG9zZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2Rlci5mbHVzaEFuZENsb3NlKGZvcmNlQ2xvc2UpO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBzb3VyY2UgY2FuIGJlIHVzZWQgdG8gYWRkIHZpZGVvIGZyYW1lcyB0byB0aGUgb3V0cHV0IHRyYWNrIGZyb20gYSBmaXhlZCBjYW52YXMgZWxlbWVudC4gU2luY2UgY2FudmFzZXMgYXJlIG9mdGVuXG4gKiB1c2VkIGZvciByZW5kZXJpbmcsIHRoaXMgc291cmNlIHByb3ZpZGVzIGEgY29udmVuaWVudCB3cmFwcGVyIGFyb3VuZCB7QGxpbmsgVmlkZW9TYW1wbGVTb3VyY2V9LlxuICogQGdyb3VwIE1lZGlhIHNvdXJjZXNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIENhbnZhc1NvdXJjZSBleHRlbmRzIFZpZGVvU291cmNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBDYW52YXNTb3VyY2V9IGZyb20gYSBjYW52YXMgZWxlbWVudCBvciBgT2Zmc2NyZWVuQ2FudmFzYCB3aG9zZSBzYW1wbGVzIGFyZSBlbmNvZGVkXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQge0BsaW5rIFZpZGVvRW5jb2RpbmdDb25maWd9LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNhbnZhcywgZW5jb2RpbmdDb25maWcpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudClcbiAgICAgICAgICAgICYmICEodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FudmFzIG11c3QgYmUgYW4gSFRNTENhbnZhc0VsZW1lbnQgb3IgT2Zmc2NyZWVuQ2FudmFzLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlVmlkZW9FbmNvZGluZ0NvbmZpZyhlbmNvZGluZ0NvbmZpZyk7XG4gICAgICAgIHN1cGVyKGVuY29kaW5nQ29uZmlnLmNvZGVjKTtcbiAgICAgICAgdGhpcy5fZW5jb2RlciA9IG5ldyBWaWRlb0VuY29kZXJXcmFwcGVyKHRoaXMsIGVuY29kaW5nQ29uZmlnKTtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYXB0dXJlcyB0aGUgY3VycmVudCBjYW52YXMgc3RhdGUgYXMgYSB2aWRlbyBzYW1wbGUgKGZyYW1lKSwgZW5jb2RlcyBpdCBhbmQgYWRkcyBpdCB0byB0aGUgb3V0cHV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRpbWVzdGFtcCAtIFRoZSB0aW1lc3RhbXAgb2YgdGhlIHNhbXBsZSwgaW4gc2Vjb25kcy5cbiAgICAgKiBAcGFyYW0gZHVyYXRpb24gLSBUaGUgZHVyYXRpb24gb2YgdGhlIHNhbXBsZSwgaW4gc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIG91dHB1dCBpcyByZWFkeSB0byByZWNlaXZlIG1vcmUgc2FtcGxlcy4gWW91IHNob3VsZCBhd2FpdCB0aGlzIFByb21pc2VcbiAgICAgKiB0byByZXNwZWN0IHdyaXRlciBhbmQgZW5jb2RlciBiYWNrcHJlc3N1cmUuXG4gICAgICovXG4gICAgYWRkKHRpbWVzdGFtcCwgZHVyYXRpb24gPSAwLCBlbmNvZGVPcHRpb25zKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHRpbWVzdGFtcCkgfHwgdGltZXN0YW1wIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGltZXN0YW1wIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uKSB8fCBkdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2R1cmF0aW9uIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNhbXBsZSA9IG5ldyBWaWRlb1NhbXBsZSh0aGlzLl9jYW52YXMsIHsgdGltZXN0YW1wLCBkdXJhdGlvbiB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZXIuYWRkKHNhbXBsZSwgdHJ1ZSwgZW5jb2RlT3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZmx1c2hBbmRDbG9zZShmb3JjZUNsb3NlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVyLmZsdXNoQW5kQ2xvc2UoZm9yY2VDbG9zZSk7XG4gICAgfVxufVxuLyoqXG4gKiBWaWRlbyBzb3VyY2UgdGhhdCBlbmNvZGVzIHRoZSBmcmFtZXMgb2YgYVxuICogW2BNZWRpYVN0cmVhbVZpZGVvVHJhY2tgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFTdHJlYW1UcmFjaykgYW5kIHBpcGVzIHRoZW0gaW50byB0aGVcbiAqIG91dHB1dC4gVGhpcyBpcyB1c2VmdWwgZm9yIGNhcHR1cmluZyBsaXZlIG9yIHJlYWwtdGltZSBkYXRhIHN1Y2ggYXMgd2ViY2FtcyBvciBzY3JlZW4gY2FwdHVyZXMuIEZyYW1lcyB3aWxsXG4gKiBhdXRvbWF0aWNhbGx5IHN0YXJ0IGJlaW5nIGNhcHR1cmVkIG9uY2UgdGhlIGNvbm5lY3RlZCB7QGxpbmsgT3V0cHV0fSBpcyBzdGFydGVkLCBhbmQgd2lsbCBrZWVwIGJlaW5nIGNhcHR1cmVkIHVudGlsXG4gKiB0aGUge0BsaW5rIE91dHB1dH0gaXMgZmluYWxpemVkIG9yIHRoaXMgc291cmNlIGlzIGNsb3NlZC5cbiAqIEBncm91cCBNZWRpYSBzb3VyY2VzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBNZWRpYVN0cmVhbVZpZGVvVHJhY2tTb3VyY2UgZXh0ZW5kcyBWaWRlb1NvdXJjZSB7XG4gICAgLyoqIEEgcHJvbWlzZSB0aGF0IHJlamVjdHMgdXBvbiBhbnkgZXJyb3Igd2l0aGluIHRoaXMgc291cmNlLiBUaGlzIHByb21pc2UgbmV2ZXIgcmVzb2x2ZXMuICovXG4gICAgZ2V0IGVycm9yUHJvbWlzZSgpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JQcm9taXNlQWNjZXNzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZVdpdGhSZXNvbHZlcnMucHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgTWVkaWFTdHJlYW1WaWRlb1RyYWNrU291cmNlfSBmcm9tIGFcbiAgICAgKiBbYE1lZGlhU3RyZWFtVmlkZW9UcmFja2BdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVN0cmVhbVRyYWNrKSwgd2hpY2ggd2lsbCBwdWxsXG4gICAgICogdmlkZW8gc2FtcGxlcyBmcm9tIHRoZSBzdHJlYW0gaW4gcmVhbCB0aW1lIGFuZCBlbmNvZGUgdGhlbSBhY2NvcmRpbmcgdG8ge0BsaW5rIFZpZGVvRW5jb2RpbmdDb25maWd9LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRyYWNrLCBlbmNvZGluZ0NvbmZpZykge1xuICAgICAgICBpZiAoISh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spIHx8IHRyYWNrLmtpbmQgIT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RyYWNrIG11c3QgYmUgYSB2aWRlbyBNZWRpYVN0cmVhbVRyYWNrLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlVmlkZW9FbmNvZGluZ0NvbmZpZyhlbmNvZGluZ0NvbmZpZyk7XG4gICAgICAgIGVuY29kaW5nQ29uZmlnID0ge1xuICAgICAgICAgICAgLi4uZW5jb2RpbmdDb25maWcsXG4gICAgICAgICAgICBsYXRlbmN5TW9kZTogJ3JlYWx0aW1lJyxcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIoZW5jb2RpbmdDb25maWcuY29kZWMpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fd29ya2VyVHJhY2tJZCA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fd29ya2VyTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3Byb21pc2VXaXRoUmVzb2x2ZXJzID0gcHJvbWlzZVdpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9lcnJvclByb21pc2VBY2Nlc3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbmNvZGVyID0gbmV3IFZpZGVvRW5jb2RlcldyYXBwZXIodGhpcywgZW5jb2RpbmdDb25maWcpO1xuICAgICAgICB0aGlzLl90cmFjayA9IHRyYWNrO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgYXN5bmMgX3N0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2Vycm9yUHJvbWlzZUFjY2Vzc2VkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ01ha2Ugc3VyZSBub3QgdG8gaWdub3JlIHRoZSBgZXJyb3JQcm9taXNlYCBmaWVsZCBvbiBNZWRpYVN0cmVhbVZpZGVvVHJhY2tTb3VyY2UsIHNvIHRoYXQgYW55IGludGVybmFsJ1xuICAgICAgICAgICAgICAgICsgJyBlcnJvcnMgZ2V0IGJ1YmJsZWQgdXAgcHJvcGVybHkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBsZXQgZmlyc3RWaWRlb0ZyYW1lVGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgbGV0IGVycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgb25WaWRlb0ZyYW1lID0gKHZpZGVvRnJhbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgdmlkZW9GcmFtZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFZpZGVvRnJhbWVUaW1lc3RhbXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFZpZGVvRnJhbWVUaW1lc3RhbXAgPSB2aWRlb0ZyYW1lLnRpbWVzdGFtcCAvIDFlNjtcbiAgICAgICAgICAgICAgICBjb25zdCBtdXhlciA9IHRoaXMuX2Nvbm5lY3RlZFRyYWNrLm91dHB1dC5fbXV4ZXI7XG4gICAgICAgICAgICAgICAgaWYgKG11eGVyLmZpcnN0TWVkaWFTdHJlYW1UaW1lc3RhbXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV4ZXIuZmlyc3RNZWRpYVN0cmVhbVRpbWVzdGFtcCA9IHBlcmZvcm1hbmNlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZXN0YW1wT2Zmc2V0ID0gLWZpcnN0VmlkZW9GcmFtZVRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVzdGFtcE9mZnNldCA9IChwZXJmb3JtYW5jZS5ub3coKSAvIDEwMDAgLSBtdXhlci5maXJzdE1lZGlhU3RyZWFtVGltZXN0YW1wKVxuICAgICAgICAgICAgICAgICAgICAgICAgLSBmaXJzdFZpZGVvRnJhbWVUaW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2VuY29kZXIuZ2V0UXVldWVTaXplKCkgPj0gNCkge1xuICAgICAgICAgICAgICAgIC8vIERyb3AgZnJhbWVzIGlmIHRoZSBlbmNvZGVyIGlzIG92ZXJsb2FkZWRcbiAgICAgICAgICAgICAgICB2aWRlb0ZyYW1lLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm9pZCB0aGlzLl9lbmNvZGVyLmFkZChuZXcgVmlkZW9TYW1wbGUodmlkZW9GcmFtZSksIHRydWUpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlcj8uYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlV2l0aFJlc29sdmVycy5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl93b3JrZXJUcmFja0lkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRlbGwgdGhlIHdvcmtlciB0byBzdG9wIHRoZSB0cmFja1xuICAgICAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZVRvTWVkaWFTdHJlYW1UcmFja1Byb2Nlc3Nvcldvcmtlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RvcFRyYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrSWQ6IHRoaXMuX3dvcmtlclRyYWNrSWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIE1lZGlhU3RyZWFtVHJhY2tQcm9jZXNzb3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBXZSBjYW4gZG8gaXQgaGVyZSBkaXJlY3RseSwgcGVyZmVjdFxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29yID0gbmV3IE1lZGlhU3RyZWFtVHJhY2tQcm9jZXNzb3IoeyB0cmFjazogdGhpcy5fdHJhY2sgfSk7XG4gICAgICAgICAgICBjb25zdCBjb25zdW1lciA9IG5ldyBXcml0YWJsZVN0cmVhbSh7IHdyaXRlOiBvblZpZGVvRnJhbWUgfSk7XG4gICAgICAgICAgICBwcm9jZXNzb3IucmVhZGFibGUucGlwZVRvKGNvbnN1bWVyLCB7XG4gICAgICAgICAgICAgICAgc2lnbmFsOiB0aGlzLl9hYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIEFib3J0RXJyb3Igc2lsZW50bHlcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBET01FeGNlcHRpb24gJiYgZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZVdpdGhSZXNvbHZlcnMucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSXQgbWlnaHQgc3RpbGwgYmUgc3VwcG9ydGVkIGluIGEgd29ya2VyLCBzbyBsZXQncyBjaGVjayB0aGF0XG4gICAgICAgICAgICBjb25zdCBzdXBwb3J0ZWRJbldvcmtlciA9IGF3YWl0IG1lZGlhU3RyZWFtVHJhY2tQcm9jZXNzb3JJc1N1cHBvcnRlZEluV29ya2VyKCk7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydGVkSW5Xb3JrZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JrZXJUcmFja0lkID0gbmV4dE1lZGlhU3RyZWFtVHJhY2tQcm9jZXNzb3JXb3JrZXJJZCsrO1xuICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlVG9NZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29yV29ya2VyKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3ZpZGVvVHJhY2snLFxuICAgICAgICAgICAgICAgICAgICB0cmFja0lkOiB0aGlzLl93b3JrZXJUcmFja0lkLFxuICAgICAgICAgICAgICAgICAgICB0cmFjazogdGhpcy5fdHJhY2ssXG4gICAgICAgICAgICAgICAgfSwgW3RoaXMuX3RyYWNrXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2VyTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICd2aWRlb0ZyYW1lJyAmJiBtZXNzYWdlLnRyYWNrSWQgPT09IHRoaXMuX3dvcmtlclRyYWNrSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVmlkZW9GcmFtZShtZXNzYWdlLnZpZGVvRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ2Vycm9yJyAmJiBtZXNzYWdlLnRyYWNrSWQgPT09IHRoaXMuX3dvcmtlclRyYWNrSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2VXaXRoUmVzb2x2ZXJzLnJlamVjdChtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWVkaWFTdHJlYW1UcmFja1Byb2Nlc3Nvcldvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fd29ya2VyTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29yIGlzIHJlcXVpcmVkIGJ1dCBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgYXN5bmMgX2ZsdXNoQW5kQ2xvc2UoZm9yY2VDbG9zZSkge1xuICAgICAgICBpZiAodGhpcy5fYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3dvcmtlclRyYWNrSWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLl93b3JrZXJMaXN0ZW5lcik7XG4gICAgICAgICAgICBzZW5kTWVzc2FnZVRvTWVkaWFTdHJlYW1UcmFja1Byb2Nlc3Nvcldvcmtlcih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3N0b3BUcmFjaycsXG4gICAgICAgICAgICAgICAgdHJhY2tJZDogdGhpcy5fd29ya2VyVHJhY2tJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHdvcmtlciB0byBzdG9wIHRoZSB0cmFja1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ3RyYWNrU3RvcHBlZCcgJiYgbWVzc2FnZS50cmFja0lkID09PSB0aGlzLl93b3JrZXJUcmFja0lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQodGhpcy5fd29ya2VyTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFTdHJlYW1UcmFja1Byb2Nlc3Nvcldvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fd29ya2VyTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFTdHJlYW1UcmFja1Byb2Nlc3Nvcldvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29yV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9lbmNvZGVyLmZsdXNoQW5kQ2xvc2UoZm9yY2VDbG9zZSk7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhdWRpbyBzb3VyY2VzIC0gc291cmNlcyBmb3IgYXVkaW8gdHJhY2tzLlxuICogQGdyb3VwIE1lZGlhIHNvdXJjZXNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEF1ZGlvU291cmNlIGV4dGVuZHMgTWVkaWFTb3VyY2Uge1xuICAgIC8qKiBJbnRlcm5hbCBjb25zdHJ1Y3Rvci4gKi9cbiAgICBjb25zdHJ1Y3Rvcihjb2RlYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZFRyYWNrID0gbnVsbDtcbiAgICAgICAgaWYgKCFBVURJT19DT0RFQ1MuaW5jbHVkZXMoY29kZWMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGF1ZGlvIGNvZGVjICcke2NvZGVjfScuIE11c3QgYmUgb25lIG9mOiAke0FVRElPX0NPREVDUy5qb2luKCcsICcpfS5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb2RlYyA9IGNvZGVjO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIG1vc3QgYmFzaWMgYXVkaW8gc291cmNlOyBjYW4gYmUgdXNlZCB0byBkaXJlY3RseSBwaXBlIGVuY29kZWQgcGFja2V0cyBpbnRvIHRoZSBvdXRwdXQgZmlsZS5cbiAqIEBncm91cCBNZWRpYSBzb3VyY2VzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBFbmNvZGVkQXVkaW9QYWNrZXRTb3VyY2UgZXh0ZW5kcyBBdWRpb1NvdXJjZSB7XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcge0BsaW5rIEVuY29kZWRBdWRpb1BhY2tldFNvdXJjZX0gd2hvc2UgcGFja2V0cyBhcmUgZW5jb2RlZCB1c2luZyBgY29kZWNgLiAqL1xuICAgIGNvbnN0cnVjdG9yKGNvZGVjKSB7XG4gICAgICAgIHN1cGVyKGNvZGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBlbmNvZGVkIHBhY2tldCB0byB0aGUgb3V0cHV0IGF1ZGlvIHRyYWNrLiBQYWNrZXRzIG11c3QgYmUgYWRkZWQgaW4gKmRlY29kZSBvcmRlciouXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWV0YSAtIEFkZGl0aW9uYWwgbWV0YWRhdGEgZnJvbSB0aGUgZW5jb2Rlci4gWW91IHNob3VsZCBwYXNzIHRoaXMgZm9yIHRoZSBmaXJzdCBjYWxsLCBpbmNsdWRpbmcgYSB2YWxpZFxuICAgICAqIGRlY29kZXIgY29uZmlnLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgb3V0cHV0IGlzIHJlYWR5IHRvIHJlY2VpdmUgbW9yZSBzYW1wbGVzLiBZb3Ugc2hvdWxkIGF3YWl0IHRoaXMgUHJvbWlzZVxuICAgICAqIHRvIHJlc3BlY3Qgd3JpdGVyIGFuZCBlbmNvZGVyIGJhY2twcmVzc3VyZS5cbiAgICAgKi9cbiAgICBhZGQocGFja2V0LCBtZXRhKSB7XG4gICAgICAgIGlmICghKHBhY2tldCBpbnN0YW5jZW9mIEVuY29kZWRQYWNrZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYWNrZXQgbXVzdCBiZSBhbiBFbmNvZGVkUGFja2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWNrZXQuaXNNZXRhZGF0YU9ubHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01ldGFkYXRhLW9ubHkgcGFja2V0cyBjYW5ub3QgYmUgYWRkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEgIT09IHVuZGVmaW5lZCAmJiAoIW1ldGEgfHwgdHlwZW9mIG1ldGEgIT09ICdvYmplY3QnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWV0YSwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW5zdXJlVmFsaWRBZGQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RlZFRyYWNrLm91dHB1dC5fbXV4ZXIuYWRkRW5jb2RlZEF1ZGlvUGFja2V0KHRoaXMuX2Nvbm5lY3RlZFRyYWNrLCBwYWNrZXQsIG1ldGEpO1xuICAgIH1cbn1cbmNsYXNzIEF1ZGlvRW5jb2RlcldyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZW5jb2RpbmdDb25maWcpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZW5jb2RpbmdDb25maWcgPSBlbmNvZGluZ0NvbmZpZztcbiAgICAgICAgdGhpcy5lbnN1cmVFbmNvZGVyUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZW5jb2RlckluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IG51bGw7XG4gICAgICAgIHRoaXMubXV4ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3ROdW1iZXJPZkNoYW5uZWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2FtcGxlUmF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNQY21FbmNvZGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3V0cHV0U2FtcGxlU2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMud3JpdGVPdXRwdXRWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VzdG9tRW5jb2RlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VzdG9tRW5jb2RlckNhbGxTZXJpYWxpemVyID0gbmV3IENhbGxTZXJpYWxpemVyKCk7XG4gICAgICAgIHRoaXMuY3VzdG9tRW5jb2RlclF1ZXVlU2l6ZSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVycyB0eXBpY2FsbHkgdGhyb3cgdGhlaXIgZXJyb3JzIFwib3V0IG9mIGJhbmRcIiwgbWVhbmluZyBhc3luY2hyb25vdXNseSBpbiBzb21lIG90aGVyIGV4ZWN1dGlvbiBjb250ZXh0LlxuICAgICAgICAgKiBIb3dldmVyLCB3ZSB3YW50IHRvIHN1cmZhY2UgdGhlc2UgZXJyb3JzIHRvIHRoZSB1c2VyIHdpdGhpbiB0aGUgbm9ybWFsIGNvbnRyb2wgZmxvdywgc28gdGhleSBkb24ndCBnbyB1bmNhdWdodC5cbiAgICAgICAgICogU28sIHdlIGtlZXAgdHJhY2sgb2YgdGhlIGVuY29kZXIgZXJyb3IgYW5kIHRocm93IGl0IGFzIHNvb24gYXMgd2UgZ2V0IHRoZSBjaGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVuY29kZXJFcnJvciA9IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGFkZChhdWRpb1NhbXBsZSwgc2hvdWxkQ2xvc2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tGb3JFbmNvZGVyRXJyb3IoKTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlLl9lbnN1cmVWYWxpZEFkZCgpO1xuICAgICAgICAgICAgLy8gRW5zdXJlIGF1ZGlvIHBhcmFtZXRlcnMgcmVtYWluIGNvbnN0YW50XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0TnVtYmVyT2ZDaGFubmVscyAhPT0gbnVsbCAmJiB0aGlzLmxhc3RTYW1wbGVSYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF1ZGlvU2FtcGxlLm51bWJlck9mQ2hhbm5lbHMgIT09IHRoaXMubGFzdE51bWJlck9mQ2hhbm5lbHNcbiAgICAgICAgICAgICAgICAgICAgfHwgYXVkaW9TYW1wbGUuc2FtcGxlUmF0ZSAhPT0gdGhpcy5sYXN0U2FtcGxlUmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1ZGlvIHBhcmFtZXRlcnMgbXVzdCByZW1haW4gY29uc3RhbnQuIEV4cGVjdGVkICR7dGhpcy5sYXN0TnVtYmVyT2ZDaGFubmVsc30gY2hhbm5lbHMgYXRgXG4gICAgICAgICAgICAgICAgICAgICAgICArIGAgJHt0aGlzLmxhc3RTYW1wbGVSYXRlfSBIeiwgZ290ICR7YXVkaW9TYW1wbGUubnVtYmVyT2ZDaGFubmVsc30gY2hhbm5lbHMgYXRgXG4gICAgICAgICAgICAgICAgICAgICAgICArIGAgJHthdWRpb1NhbXBsZS5zYW1wbGVSYXRlfSBIei5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3ROdW1iZXJPZkNoYW5uZWxzID0gYXVkaW9TYW1wbGUubnVtYmVyT2ZDaGFubmVscztcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RTYW1wbGVSYXRlID0gYXVkaW9TYW1wbGUuc2FtcGxlUmF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5lbmNvZGVySW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZW5zdXJlRW5jb2RlclByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLmVuc3VyZUVuY29kZXIoYXVkaW9TYW1wbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBObywgdGhpcyBcImlmXCIgc3RhdGVtZW50IGlzIG5vdCB1c2VsZXNzLiBTb21ldGltZXMsIHRoZSBhYm92ZSBjYWxsIHRvIGBlbnN1cmVFbmNvZGVyYCBtaWdodCBoYXZlXG4gICAgICAgICAgICAgICAgLy8gc3luY2hyb25vdXNseSBjb21wbGV0ZWQgYW5kIHRoZSBlbmNvZGVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuIEluIHRoaXMgY2FzZSwgd2UgZG9uJ3QgbmVlZCB0byBhd2FpdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBwcm9taXNlIGFueW1vcmUuIFRoaXMgYWxzbyBmaXhlcyBuYXN0eSBhc3luYyByYWNlIGNvbmRpdGlvbiBidWdzIHdoZW4gbXVsdGlwbGUgY29kZSBwYXRocyBhcmVcbiAgICAgICAgICAgICAgICAvLyBjYWxsaW5nIHRoaXMgbWV0aG9kOiBJdCdzIGltcG9ydGFudCB0aGF0IHRoZSBjYWxsIHRoYXQgaW5pdGlhbGl6ZWQgdGhlIGVuY29kZXIgZ28gdGhyb3VnaCB0aGlzXG4gICAgICAgICAgICAgICAgLy8gY29kZSBmaXJzdC5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZW5jb2RlckluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRW5jb2RlclByb21pc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KHRoaXMuZW5jb2RlckluaXRpYWxpemVkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1c3RvbUVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbUVuY29kZXJRdWV1ZVNpemUrKztcbiAgICAgICAgICAgICAgICAvLyBXZSBjbG9uZSB0aGUgc2FtcGxlIHNvIGl0IGNhbm5vdCBiZSBjbG9zZWQgb24gdXMgZnJvbSB0aGUgb3V0c2lkZSBiZWZvcmUgaXQgcmVhY2hlcyB0aGUgZW5jb2RlclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lZFNhbXBsZSA9IGF1ZGlvU2FtcGxlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuY3VzdG9tRW5jb2RlckNhbGxTZXJpYWxpemVyXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKCgpID0+IHRoaXMuY3VzdG9tRW5jb2Rlci5lbmNvZGUoY2xvbmVkU2FtcGxlKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5jdXN0b21FbmNvZGVyUXVldWVTaXplLS0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHRoaXMuZW5jb2RlckVycm9yID8/PSBlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZWRTYW1wbGUuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYGF1ZGlvU2FtcGxlYCBnZXRzIGNsb3NlZCBpbiB0aGUgZmluYWxseSBibG9jayBhdCB0aGUgZW5kIG9mIHRoZSBtZXRob2RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXN0b21FbmNvZGVyUXVldWVTaXplID49IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tdXhlci5tdXRleC5jdXJyZW50UHJvbWlzZTsgLy8gQWxsb3cgdGhlIHdyaXRlciB0byBhcHBseSBiYWNrcHJlc3N1cmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNQY21FbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kb1BjbUVuY29kaW5nKGF1ZGlvU2FtcGxlLCBzaG91bGRDbG9zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQodGhpcy5lbmNvZGVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhdWRpb0RhdGEgPSBhdWRpb1NhbXBsZS50b0F1ZGlvRGF0YSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUoYXVkaW9EYXRhKTtcbiAgICAgICAgICAgICAgICBhdWRpb0RhdGEuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW9TYW1wbGUuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5jb2Rlci5lbmNvZGVRdWV1ZVNpemUgPj0gNCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHRoaXMuZW5jb2Rlci5hZGRFdmVudExpc3RlbmVyKCdkZXF1ZXVlJywgcmVzb2x2ZSwgeyBvbmNlOiB0cnVlIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tdXhlci5tdXRleC5jdXJyZW50UHJvbWlzZTsgLy8gQWxsb3cgdGhlIHdyaXRlciB0byBhcHBseSBiYWNrcHJlc3N1cmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRDbG9zZSkge1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBpdCdzIGFsd2F5cyBjbG9zZWQsIGV2ZW4gaWYgdGhlcmUgd2FzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgYXVkaW9TYW1wbGUuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkb1BjbUVuY29kaW5nKGF1ZGlvU2FtcGxlLCBzaG91bGRDbG9zZSkge1xuICAgICAgICBhc3NlcnQodGhpcy5vdXRwdXRTYW1wbGVTaXplKTtcbiAgICAgICAgYXNzZXJ0KHRoaXMud3JpdGVPdXRwdXRWYWx1ZSk7XG4gICAgICAgIC8vIE5lZWQgdG8gZXh0cmFjdCBkYXRhIGZyb20gdGhlIGF1ZGlvIGRhdGEgYmVmb3JlIHdlIGNsb3NlIGl0XG4gICAgICAgIGNvbnN0IHsgbnVtYmVyT2ZDaGFubmVscywgbnVtYmVyT2ZGcmFtZXMsIHNhbXBsZVJhdGUsIHRpbWVzdGFtcCB9ID0gYXVkaW9TYW1wbGU7XG4gICAgICAgIGNvbnN0IENIVU5LX1NJWkUgPSAyMDQ4O1xuICAgICAgICBjb25zdCBvdXRwdXRzID0gW107XG4gICAgICAgIC8vIFByZXBhcmUgYWxsIG9mIHRoZSBvdXRwdXQgYnVmZmVycywgZWFjaCBiZWluZyBib3VuZGVkIGJ5IENIVU5LX1NJWkUgc28gd2UgZG9uJ3QgZ2VuZXJhdGUgaHVnZSBwYWNrZXRzXG4gICAgICAgIGZvciAobGV0IGZyYW1lID0gMDsgZnJhbWUgPCBudW1iZXJPZkZyYW1lczsgZnJhbWUgKz0gQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgY29uc3QgZnJhbWVDb3VudCA9IE1hdGgubWluKENIVU5LX1NJWkUsIGF1ZGlvU2FtcGxlLm51bWJlck9mRnJhbWVzIC0gZnJhbWUpO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IGZyYW1lQ291bnQgKiBudW1iZXJPZkNoYW5uZWxzICogdGhpcy5vdXRwdXRTYW1wbGVTaXplO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKG91dHB1dFNpemUpO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0VmlldyA9IG5ldyBEYXRhVmlldyhvdXRwdXRCdWZmZXIpO1xuICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHsgZnJhbWVDb3VudCwgdmlldzogb3V0cHV0VmlldyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGxvY2F0aW9uU2l6ZSA9IGF1ZGlvU2FtcGxlLmFsbG9jYXRpb25TaXplKCh7IHBsYW5lSW5kZXg6IDAsIGZvcm1hdDogJ2YzMi1wbGFuYXInIH0pKTtcbiAgICAgICAgY29uc3QgZmxvYXRzID0gbmV3IEZsb2F0MzJBcnJheShhbGxvY2F0aW9uU2l6ZSAvIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDaGFubmVsczsgaSsrKSB7XG4gICAgICAgICAgICBhdWRpb1NhbXBsZS5jb3B5VG8oZmxvYXRzLCB7IHBsYW5lSW5kZXg6IGksIGZvcm1hdDogJ2YzMi1wbGFuYXInIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvdXRwdXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmcmFtZUNvdW50LCB2aWV3IH0gPSBvdXRwdXRzW2pdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZnJhbWVDb3VudDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVPdXRwdXRWYWx1ZSh2aWV3LCAoayAqIG51bWJlck9mQ2hhbm5lbHMgKyBpKSAqIHRoaXMub3V0cHV0U2FtcGxlU2l6ZSwgZmxvYXRzW2ogKiBDSFVOS19TSVpFICsga10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkQ2xvc2UpIHtcbiAgICAgICAgICAgIGF1ZGlvU2FtcGxlLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIGRlY29kZXJDb25maWc6IHtcbiAgICAgICAgICAgICAgICBjb2RlYzogdGhpcy5lbmNvZGluZ0NvbmZpZy5jb2RlYyxcbiAgICAgICAgICAgICAgICBudW1iZXJPZkNoYW5uZWxzLFxuICAgICAgICAgICAgICAgIHNhbXBsZVJhdGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZnJhbWVDb3VudCwgdmlldyB9ID0gb3V0cHV0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dEJ1ZmZlciA9IHZpZXcuYnVmZmVyO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRGcmFtZSA9IGkgKiBDSFVOS19TSVpFO1xuICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gbmV3IEVuY29kZWRQYWNrZXQobmV3IFVpbnQ4QXJyYXkob3V0cHV0QnVmZmVyKSwgJ2tleScsIHRpbWVzdGFtcCArIHN0YXJ0RnJhbWUgLyBzYW1wbGVSYXRlLCBmcmFtZUNvdW50IC8gc2FtcGxlUmF0ZSk7XG4gICAgICAgICAgICB0aGlzLmVuY29kaW5nQ29uZmlnLm9uRW5jb2RlZFBhY2tldD8uKHBhY2tldCwgbWV0YSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm11eGVyLmFkZEVuY29kZWRBdWRpb1BhY2tldCh0aGlzLnNvdXJjZS5fY29ubmVjdGVkVHJhY2ssIHBhY2tldCwgbWV0YSk7IC8vIFdpdGggYmFja3ByZXNzdXJlXG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5zdXJlRW5jb2RlcihhdWRpb1NhbXBsZSkge1xuICAgICAgICBpZiAodGhpcy5lbmNvZGVySW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGVyRXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlRW5jb2RlclByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBudW1iZXJPZkNoYW5uZWxzLCBzYW1wbGVSYXRlIH0gPSBhdWRpb1NhbXBsZTtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXJDb25maWcgPSBidWlsZEF1ZGlvRW5jb2RlckNvbmZpZyh7XG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZDaGFubmVscyxcbiAgICAgICAgICAgICAgICBzYW1wbGVSYXRlLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZW5jb2RpbmdDb25maWcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RpbmdDb25maWcub25FbmNvZGVyQ29uZmlnPy4oZW5jb2RlckNvbmZpZyk7XG4gICAgICAgICAgICBjb25zdCBNYXRjaGluZ0N1c3RvbUVuY29kZXIgPSBjdXN0b21BdWRpb0VuY29kZXJzLmZpbmQoeCA9PiB4LnN1cHBvcnRzKHRoaXMuZW5jb2RpbmdDb25maWcuY29kZWMsIGVuY29kZXJDb25maWcpKTtcbiAgICAgICAgICAgIGlmIChNYXRjaGluZ0N1c3RvbUVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFwiQ2FuJ3QgY3JlYXRlIGluc3RhbmNlIG9mIGFic3RyYWN0IGNsYXNzIPCfpJNcIlxuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tRW5jb2RlciA9IG5ldyBNYXRjaGluZ0N1c3RvbUVuY29kZXIoKTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEl0J3MgdGVjaG5pY2FsbHkgcmVhZG9ubHlcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbUVuY29kZXIuY29kZWMgPSB0aGlzLmVuY29kaW5nQ29uZmlnLmNvZGVjO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSXQncyB0ZWNobmljYWxseSByZWFkb25seVxuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tRW5jb2Rlci5jb25maWcgPSBlbmNvZGVyQ29uZmlnO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSXQncyB0ZWNobmljYWxseSByZWFkb25seVxuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tRW5jb2Rlci5vblBhY2tldCA9IChwYWNrZXQsIG1ldGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFja2V0IGluc3RhbmNlb2YgRW5jb2RlZFBhY2tldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gb25QYWNrZXQgbXVzdCBiZSBhbiBFbmNvZGVkUGFja2V0LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhICE9PSB1bmRlZmluZWQgJiYgKCFtZXRhIHx8IHR5cGVvZiBtZXRhICE9PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzZWNvbmQgYXJndW1lbnQgcGFzc2VkIHRvIG9uUGFja2V0IG11c3QgYmUgYW4gb2JqZWN0IG9yIHVuZGVmaW5lZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuY29kaW5nQ29uZmlnLm9uRW5jb2RlZFBhY2tldD8uKHBhY2tldCwgbWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5tdXhlci5hZGRFbmNvZGVkQXVkaW9QYWNrZXQodGhpcy5zb3VyY2UuX2Nvbm5lY3RlZFRyYWNrLCBwYWNrZXQsIG1ldGEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jdXN0b21FbmNvZGVyLmluaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFBDTV9BVURJT19DT0RFQ1MuaW5jbHVkZXModGhpcy5lbmNvZGluZ0NvbmZpZy5jb2RlYykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRQY21FbmNvZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEF1ZGlvRW5jb2RlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdWRpb0VuY29kZXIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN1cHBvcnQgPSBhd2FpdCBBdWRpb0VuY29kZXIuaXNDb25maWdTdXBwb3J0ZWQoZW5jb2RlckNvbmZpZyk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0LnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgc3BlY2lmaWMgZW5jb2RlciBjb25maWd1cmF0aW9uICgke2VuY29kZXJDb25maWcuY29kZWN9LCAke2VuY29kZXJDb25maWcuYml0cmF0ZX0gYnBzLGBcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYCAke2VuY29kZXJDb25maWcubnVtYmVyT2ZDaGFubmVsc30gY2hhbm5lbHMsICR7ZW5jb2RlckNvbmZpZy5zYW1wbGVSYXRlfSBIeikgaXMgbm90YFxuICAgICAgICAgICAgICAgICAgICAgICAgKyBgIHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuIENvbnNpZGVyIHVzaW5nIGFub3RoZXIgY29kZWMgb3IgY2hhbmdpbmcgeW91ciBhdWRpbyBwYXJhbWV0ZXJzLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVuY29kZXIgPSBuZXcgQXVkaW9FbmNvZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoY2h1bmssIG1ldGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IEVuY29kZWRQYWNrZXQuZnJvbUVuY29kZWRDaHVuayhjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuY29kaW5nQ29uZmlnLm9uRW5jb2RlZFBhY2tldD8uKHBhY2tldCwgbWV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMubXV4ZXIuYWRkRW5jb2RlZEF1ZGlvUGFja2V0KHRoaXMuc291cmNlLl9jb25uZWN0ZWRUcmFjaywgcGFja2V0LCBtZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBlbmNvZGVyRXJyb3Iuc3RhY2s7IC8vIFByb3ZpZGUgYSBtb3JlIHVzZWZ1bCBzdGFjayB0cmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmNvZGVyRXJyb3IgPz89IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5jb2Rlci5jb25maWd1cmUoZW5jb2RlckNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5zb3VyY2UuX2Nvbm5lY3RlZFRyYWNrKTtcbiAgICAgICAgICAgIHRoaXMubXV4ZXIgPSB0aGlzLnNvdXJjZS5fY29ubmVjdGVkVHJhY2sub3V0cHV0Ll9tdXhlcjtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgaW5pdFBjbUVuY29kZXIoKSB7XG4gICAgICAgIHRoaXMuaXNQY21FbmNvZGVyID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgY29kZWMgPSB0aGlzLmVuY29kaW5nQ29uZmlnLmNvZGVjO1xuICAgICAgICBjb25zdCB7IGRhdGFUeXBlLCBzYW1wbGVTaXplLCBsaXR0bGVFbmRpYW4gfSA9IHBhcnNlUGNtQ29kZWMoY29kZWMpO1xuICAgICAgICB0aGlzLm91dHB1dFNhbXBsZVNpemUgPSBzYW1wbGVTaXplO1xuICAgICAgICAvLyBBbGwgdGhlc2UgZnVuY3Rpb25zIHJlY2VpdmUgYSBmbG9hdCBzYW1wbGUgYXMgaW5wdXQgYW5kIG1hcCBpdCBpbnRvIHRoZSBkZXNpcmVkIGZvcm1hdFxuICAgICAgICBzd2l0Y2ggKHNhbXBsZVNpemUpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVHlwZSA9PT0gJ3Vuc2lnbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZU91dHB1dFZhbHVlID0gKHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlKSA9PiB2aWV3LnNldFVpbnQ4KGJ5dGVPZmZzZXQsIGNsYW1wKCh2YWx1ZSArIDEpICogMTI3LjUsIDAsIDI1NSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFUeXBlID09PSAnc2lnbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZU91dHB1dFZhbHVlID0gKHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5zZXRJbnQ4KGJ5dGVPZmZzZXQsIGNsYW1wKE1hdGgucm91bmQodmFsdWUgKiAxMjgpLCAtMTI4LCAxMjcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVR5cGUgPT09ICd1bGF3Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZU91dHB1dFZhbHVlID0gKHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50MTYgPSBjbGFtcChNYXRoLmZsb29yKHZhbHVlICogMzI3NjcpLCAtMzI3NjgsIDMyNzY3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KGJ5dGVPZmZzZXQsIHRvVWxhdyhpbnQxNikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhVHlwZSA9PT0gJ2FsYXcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlT3V0cHV0VmFsdWUgPSAodmlldywgYnl0ZU9mZnNldCwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnQxNiA9IGNsYW1wKE1hdGguZmxvb3IodmFsdWUgKiAzMjc2NyksIC0zMjc2OCwgMzI3NjcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgoYnl0ZU9mZnNldCwgdG9BbGF3KGludDE2KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVR5cGUgPT09ICd1bnNpZ25lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVPdXRwdXRWYWx1ZSA9ICh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSkgPT4gdmlldy5zZXRVaW50MTYoYnl0ZU9mZnNldCwgY2xhbXAoKHZhbHVlICsgMSkgKiAzMjc2Ny41LCAwLCA2NTUzNSksIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVR5cGUgPT09ICdzaWduZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlT3V0cHV0VmFsdWUgPSAodmlldywgYnl0ZU9mZnNldCwgdmFsdWUpID0+IHZpZXcuc2V0SW50MTYoYnl0ZU9mZnNldCwgY2xhbXAoTWF0aC5yb3VuZCh2YWx1ZSAqIDMyNzY3KSwgLTMyNzY4LCAzMjc2NyksIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVHlwZSA9PT0gJ3Vuc2lnbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZU91dHB1dFZhbHVlID0gKHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlKSA9PiBzZXRVaW50MjQodmlldywgYnl0ZU9mZnNldCwgY2xhbXAoKHZhbHVlICsgMSkgKiA4Mzg4NjA3LjUsIDAsIDE2Nzc3MjE1KSwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhVHlwZSA9PT0gJ3NpZ25lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVPdXRwdXRWYWx1ZSA9ICh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSkgPT4gc2V0SW50MjQodmlldywgYnl0ZU9mZnNldCwgY2xhbXAoTWF0aC5yb3VuZCh2YWx1ZSAqIDgzODg2MDcpLCAtODM4ODYwOCwgODM4ODYwNyksIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVHlwZSA9PT0gJ3Vuc2lnbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZU91dHB1dFZhbHVlID0gKHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlKSA9PiB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0LCBjbGFtcCgodmFsdWUgKyAxKSAqIDIxNDc0ODM2NDcuNSwgMCwgNDI5NDk2NzI5NSksIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVR5cGUgPT09ICdzaWduZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlT3V0cHV0VmFsdWUgPSAodmlldywgYnl0ZU9mZnNldCwgdmFsdWUpID0+IHZpZXcuc2V0SW50MzIoYnl0ZU9mZnNldCwgY2xhbXAoTWF0aC5yb3VuZCh2YWx1ZSAqIDIxNDc0ODM2NDcpLCAtMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0NyksIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVR5cGUgPT09ICdmbG9hdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVPdXRwdXRWYWx1ZSA9ICh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSkgPT4gdmlldy5zZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVR5cGUgPT09ICdmbG9hdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVPdXRwdXRWYWx1ZSA9ICh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSkgPT4gdmlldy5zZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TmV2ZXIoc2FtcGxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmbHVzaEFuZENsb3NlKGZvcmNlQ2xvc2UpIHtcbiAgICAgICAgaWYgKCFmb3JjZUNsb3NlKVxuICAgICAgICAgICAgdGhpcy5jaGVja0ZvckVuY29kZXJFcnJvcigpO1xuICAgICAgICBpZiAodGhpcy5jdXN0b21FbmNvZGVyKSB7XG4gICAgICAgICAgICBpZiAoIWZvcmNlQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuY3VzdG9tRW5jb2RlckNhbGxTZXJpYWxpemVyLmNhbGwoKCkgPT4gdGhpcy5jdXN0b21FbmNvZGVyLmZsdXNoKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jdXN0b21FbmNvZGVyQ2FsbFNlcmlhbGl6ZXIuY2FsbCgoKSA9PiB0aGlzLmN1c3RvbUVuY29kZXIuY2xvc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5lbmNvZGVyKSB7XG4gICAgICAgICAgICBpZiAoIWZvcmNlQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmVuY29kZXIuZmx1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmVuY29kZXIuc3RhdGUgIT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmNvZGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmb3JjZUNsb3NlKVxuICAgICAgICAgICAgdGhpcy5jaGVja0ZvckVuY29kZXJFcnJvcigpO1xuICAgIH1cbiAgICBnZXRRdWV1ZVNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbUVuY29kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbUVuY29kZXJRdWV1ZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1BjbUVuY29kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2Rlcj8uZW5jb2RlUXVldWVTaXplID8/IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tGb3JFbmNvZGVyRXJyb3IoKSB7XG4gICAgICAgIGlmICh0aGlzLmVuY29kZXJFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVyRXJyb3Iuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjazsgLy8gUHJvdmlkZSBhbiBldmVuIG1vcmUgdXNlZnVsIHN0YWNrIHRyYWNlXG4gICAgICAgICAgICB0aHJvdyB0aGlzLmVuY29kZXJFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVGhpcyBzb3VyY2UgY2FuIGJlIHVzZWQgdG8gYWRkIHJhdywgdW5lbmNvZGVkIGF1ZGlvIHNhbXBsZXMgdG8gYW4gb3V0cHV0IGF1ZGlvIHRyYWNrLiBUaGVzZSBzYW1wbGVzIHdpbGxcbiAqIGF1dG9tYXRpY2FsbHkgYmUgZW5jb2RlZCBhbmQgdGhlbiBwaXBlZCBpbnRvIHRoZSBvdXRwdXQuXG4gKiBAZ3JvdXAgTWVkaWEgc291cmNlc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQXVkaW9TYW1wbGVTb3VyY2UgZXh0ZW5kcyBBdWRpb1NvdXJjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgQXVkaW9TYW1wbGVTb3VyY2V9IHdob3NlIHNhbXBsZXMgYXJlIGVuY29kZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWRcbiAgICAgKiB7QGxpbmsgQXVkaW9FbmNvZGluZ0NvbmZpZ30uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZW5jb2RpbmdDb25maWcpIHtcbiAgICAgICAgdmFsaWRhdGVBdWRpb0VuY29kaW5nQ29uZmlnKGVuY29kaW5nQ29uZmlnKTtcbiAgICAgICAgc3VwZXIoZW5jb2RpbmdDb25maWcuY29kZWMpO1xuICAgICAgICB0aGlzLl9lbmNvZGVyID0gbmV3IEF1ZGlvRW5jb2RlcldyYXBwZXIodGhpcywgZW5jb2RpbmdDb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGFuIGF1ZGlvIHNhbXBsZSBhbmQgdGhlbiBhZGRzIGl0IHRvIHRoZSBvdXRwdXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIHRoZSBvdXRwdXQgaXMgcmVhZHkgdG8gcmVjZWl2ZSBtb3JlIHNhbXBsZXMuIFlvdSBzaG91bGQgYXdhaXQgdGhpcyBQcm9taXNlXG4gICAgICogdG8gcmVzcGVjdCB3cml0ZXIgYW5kIGVuY29kZXIgYmFja3ByZXNzdXJlLlxuICAgICAqL1xuICAgIGFkZChhdWRpb1NhbXBsZSkge1xuICAgICAgICBpZiAoIShhdWRpb1NhbXBsZSBpbnN0YW5jZW9mIEF1ZGlvU2FtcGxlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXVkaW9TYW1wbGUgbXVzdCBiZSBhbiBBdWRpb1NhbXBsZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2Rlci5hZGQoYXVkaW9TYW1wbGUsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9mbHVzaEFuZENsb3NlKGZvcmNlQ2xvc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZXIuZmx1c2hBbmRDbG9zZShmb3JjZUNsb3NlKTtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgc291cmNlIGNhbiBiZSB1c2VkIHRvIGFkZCBhdWRpbyBkYXRhIGZyb20gYW4gQXVkaW9CdWZmZXIgdG8gdGhlIG91dHB1dCB0cmFjay4gVGhpcyBpcyB1c2VmdWwgd2hlbiB3b3JraW5nIHdpdGhcbiAqIHRoZSBXZWIgQXVkaW8gQVBJLlxuICogQGdyb3VwIE1lZGlhIHNvdXJjZXNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEF1ZGlvQnVmZmVyU291cmNlIGV4dGVuZHMgQXVkaW9Tb3VyY2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIEF1ZGlvQnVmZmVyU291cmNlfSB3aG9zZSBgQXVkaW9CdWZmZXJgIGluc3RhbmNlcyBhcmUgZW5jb2RlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZFxuICAgICAqIHtAbGluayBBdWRpb0VuY29kaW5nQ29uZmlnfS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbmNvZGluZ0NvbmZpZykge1xuICAgICAgICB2YWxpZGF0ZUF1ZGlvRW5jb2RpbmdDb25maWcoZW5jb2RpbmdDb25maWcpO1xuICAgICAgICBzdXBlcihlbmNvZGluZ0NvbmZpZy5jb2RlYyk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fYWNjdW11bGF0ZWRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5fZW5jb2RlciA9IG5ldyBBdWRpb0VuY29kZXJXcmFwcGVyKHRoaXMsIGVuY29kaW5nQ29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gQXVkaW9CdWZmZXIgdG8gYXVkaW8gc2FtcGxlcywgZW5jb2RlcyB0aGVtIGFuZCBhZGRzIHRoZW0gdG8gdGhlIG91dHB1dC4gVGhlIGZpcnN0IEF1ZGlvQnVmZmVyIHdpbGxcbiAgICAgKiBiZSBwbGF5ZWQgYXQgdGltZXN0YW1wIDAsIGFuZCBhbnkgc3Vic2VxdWVudCBBdWRpb0J1ZmZlciB3aWxsIGhhdmUgYSB0aW1lc3RhbXAgZXF1YWwgdG8gdGhlIHRvdGFsIGR1cmF0aW9uIG9mXG4gICAgICogYWxsIHByZXZpb3VzIEF1ZGlvQnVmZmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIG91dHB1dCBpcyByZWFkeSB0byByZWNlaXZlIG1vcmUgc2FtcGxlcy4gWW91IHNob3VsZCBhd2FpdCB0aGlzIFByb21pc2VcbiAgICAgKiB0byByZXNwZWN0IHdyaXRlciBhbmQgZW5jb2RlciBiYWNrcHJlc3N1cmUuXG4gICAgICovXG4gICAgYXN5bmMgYWRkKGF1ZGlvQnVmZmVyKSB7XG4gICAgICAgIGlmICghKGF1ZGlvQnVmZmVyIGluc3RhbmNlb2YgQXVkaW9CdWZmZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdWRpb0J1ZmZlciBtdXN0IGJlIGFuIEF1ZGlvQnVmZmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gQXVkaW9TYW1wbGUuX2Zyb21BdWRpb0J1ZmZlcihhdWRpb0J1ZmZlciwgdGhpcy5fYWNjdW11bGF0ZWRUaW1lKTtcbiAgICAgICAgdGhpcy5fYWNjdW11bGF0ZWRUaW1lICs9IGF1ZGlvQnVmZmVyLmR1cmF0aW9uO1xuICAgICAgICBmb3IgKGNvbnN0IGF1ZGlvU2FtcGxlIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9lbmNvZGVyLmFkZChhdWRpb1NhbXBsZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9mbHVzaEFuZENsb3NlKGZvcmNlQ2xvc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZXIuZmx1c2hBbmRDbG9zZShmb3JjZUNsb3NlKTtcbiAgICB9XG59XG4vKipcbiAqIEF1ZGlvIHNvdXJjZSB0aGF0IGVuY29kZXMgdGhlIGRhdGEgb2YgYVxuICogW2BNZWRpYVN0cmVhbUF1ZGlvVHJhY2tgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFTdHJlYW1UcmFjaykgYW5kIHBpcGVzIGl0IGludG8gdGhlXG4gKiBvdXRwdXQuIFRoaXMgaXMgdXNlZnVsIGZvciBjYXB0dXJpbmcgbGl2ZSBvciByZWFsLXRpbWUgYXVkaW8gc3VjaCBhcyBtaWNyb3Bob25lcyBvciBhdWRpbyBmcm9tIG90aGVyIG1lZGlhIGVsZW1lbnRzLlxuICogQXVkaW8gd2lsbCBhdXRvbWF0aWNhbGx5IHN0YXJ0IGJlaW5nIGNhcHR1cmVkIG9uY2UgdGhlIGNvbm5lY3RlZCB7QGxpbmsgT3V0cHV0fSBpcyBzdGFydGVkLCBhbmQgd2lsbCBrZWVwIGJlaW5nXG4gKiBjYXB0dXJlZCB1bnRpbCB0aGUge0BsaW5rIE91dHB1dH0gaXMgZmluYWxpemVkIG9yIHRoaXMgc291cmNlIGlzIGNsb3NlZC5cbiAqIEBncm91cCBNZWRpYSBzb3VyY2VzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBNZWRpYVN0cmVhbUF1ZGlvVHJhY2tTb3VyY2UgZXh0ZW5kcyBBdWRpb1NvdXJjZSB7XG4gICAgLyoqIEEgcHJvbWlzZSB0aGF0IHJlamVjdHMgdXBvbiBhbnkgZXJyb3Igd2l0aGluIHRoaXMgc291cmNlLiBUaGlzIHByb21pc2UgbmV2ZXIgcmVzb2x2ZXMuICovXG4gICAgZ2V0IGVycm9yUHJvbWlzZSgpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JQcm9taXNlQWNjZXNzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZVdpdGhSZXNvbHZlcnMucHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgTWVkaWFTdHJlYW1BdWRpb1RyYWNrU291cmNlfSBmcm9tIGEgYE1lZGlhU3RyZWFtQXVkaW9UcmFja2AsIHdoaWNoIHdpbGwgcHVsbCBhdWRpbyBzYW1wbGVzXG4gICAgICogZnJvbSB0aGUgc3RyZWFtIGluIHJlYWwgdGltZSBhbmQgZW5jb2RlIHRoZW0gYWNjb3JkaW5nIHRvIHtAbGluayBBdWRpb0VuY29kaW5nQ29uZmlnfS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0cmFjaywgZW5jb2RpbmdDb25maWcpIHtcbiAgICAgICAgaWYgKCEodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSB8fCB0cmFjay5raW5kICE9PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0cmFjayBtdXN0IGJlIGFuIGF1ZGlvIE1lZGlhU3RyZWFtVHJhY2suJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVBdWRpb0VuY29kaW5nQ29uZmlnKGVuY29kaW5nQ29uZmlnKTtcbiAgICAgICAgc3VwZXIoZW5jb2RpbmdDb25maWcuY29kZWMpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fYXVkaW9Db250ZXh0ID0gbnVsbDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9zY3JpcHRQcm9jZXNzb3JOb2RlID0gbnVsbDsgLy8gRGVwcmVjYXRlZCBidXQgZ29hdGVkXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fcHJvbWlzZVdpdGhSZXNvbHZlcnMgPSBwcm9taXNlV2l0aFJlc29sdmVycygpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2Vycm9yUHJvbWlzZUFjY2Vzc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2VuY29kZXIgPSBuZXcgQXVkaW9FbmNvZGVyV3JhcHBlcih0aGlzLCBlbmNvZGluZ0NvbmZpZyk7XG4gICAgICAgIHRoaXMuX3RyYWNrID0gdHJhY2s7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBhc3luYyBfc3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXJyb3JQcm9taXNlQWNjZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTWFrZSBzdXJlIG5vdCB0byBpZ25vcmUgdGhlIGBlcnJvclByb21pc2VgIGZpZWxkIG9uIE1lZGlhU3RyZWFtVmlkZW9UcmFja1NvdXJjZSwgc28gdGhhdCBhbnkgaW50ZXJuYWwnXG4gICAgICAgICAgICAgICAgKyAnIGVycm9ycyBnZXQgYnViYmxlZCB1cCBwcm9wZXJseS4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGlmICh0eXBlb2YgTWVkaWFTdHJlYW1UcmFja1Byb2Nlc3NvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIEdyZWF0LCBNZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29yIGlzIHN1cHBvcnRlZCwgdGhpcyBpcyB0aGUgcHJlZmVycmVkIHdheSBvZiBkb2luZyB0aGluZ3NcbiAgICAgICAgICAgIGxldCBmaXJzdEF1ZGlvRGF0YVRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzb3IgPSBuZXcgTWVkaWFTdHJlYW1UcmFja1Byb2Nlc3Nvcih7IHRyYWNrOiB0aGlzLl90cmFjayB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnN1bWVyID0gbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgICAgICB3cml0ZTogKGF1ZGlvRGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RBdWRpb0RhdGFUaW1lc3RhbXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0QXVkaW9EYXRhVGltZXN0YW1wID0gYXVkaW9EYXRhLnRpbWVzdGFtcCAvIDFlNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG11eGVyID0gdGhpcy5fY29ubmVjdGVkVHJhY2sub3V0cHV0Ll9tdXhlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdXhlci5maXJzdE1lZGlhU3RyZWFtVGltZXN0YW1wID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV4ZXIuZmlyc3RNZWRpYVN0cmVhbVRpbWVzdGFtcCA9IHBlcmZvcm1hbmNlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lc3RhbXBPZmZzZXQgPSAtZmlyc3RBdWRpb0RhdGFUaW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lc3RhbXBPZmZzZXQgPSAocGVyZm9ybWFuY2Uubm93KCkgLyAxMDAwIC0gbXV4ZXIuZmlyc3RNZWRpYVN0cmVhbVRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBmaXJzdEF1ZGlvRGF0YVRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW5jb2Rlci5nZXRRdWV1ZVNpemUoKSA+PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEcm9wIGRhdGEgaWYgdGhlIGVuY29kZXIgaXMgb3ZlcmxvYWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9EYXRhLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLl9lbmNvZGVyLmFkZChuZXcgQXVkaW9TYW1wbGUoYXVkaW9EYXRhKSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlcj8uYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2VXaXRoUmVzb2x2ZXJzLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb2Nlc3Nvci5yZWFkYWJsZS5waXBlVG8oY29uc3VtZXIsIHtcbiAgICAgICAgICAgICAgICBzaWduYWw6IHRoaXMuX2Fib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgQWJvcnRFcnJvciBzaWxlbnRseVxuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlV2l0aFJlc29sdmVycy5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBMZXQncyBmYWxsIGJhY2sgdG8gYW4gQXVkaW9Db250ZXh0IGFwcHJvYWNoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICBjb25zdCBBdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLl9hdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KHsgc2FtcGxlUmF0ZTogdGhpcy5fdHJhY2suZ2V0U2V0dGluZ3MoKS5zYW1wbGVSYXRlIH0pO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlTm9kZSA9IHRoaXMuX2F1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShuZXcgTWVkaWFTdHJlYW0oW3RoaXMuX3RyYWNrXSkpO1xuICAgICAgICAgICAgdGhpcy5fc2NyaXB0UHJvY2Vzc29yTm9kZSA9IHRoaXMuX2F1ZGlvQ29udGV4dC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoNDA5Nik7XG4gICAgICAgICAgICBpZiAodGhpcy5fYXVkaW9Db250ZXh0LnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2F1ZGlvQ29udGV4dC5yZXN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZU5vZGUuY29ubmVjdCh0aGlzLl9zY3JpcHRQcm9jZXNzb3JOb2RlKTtcbiAgICAgICAgICAgIHRoaXMuX3NjcmlwdFByb2Nlc3Nvck5vZGUuY29ubmVjdCh0aGlzLl9hdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgbGV0IGF1ZGlvUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCB0b3RhbER1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3NjcmlwdFByb2Nlc3Nvck5vZGUub25hdWRpb3Byb2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVyYXRvciA9IEF1ZGlvU2FtcGxlLl9mcm9tQXVkaW9CdWZmZXIoZXZlbnQuaW5wdXRCdWZmZXIsIHRvdGFsRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIHRvdGFsRHVyYXRpb24gKz0gZXZlbnQuaW5wdXRCdWZmZXIuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhdWRpb1NhbXBsZSBvZiBpdGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWF1ZGlvUmVjZWl2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvUmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXV4ZXIgPSB0aGlzLl9jb25uZWN0ZWRUcmFjay5vdXRwdXQuX211eGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11eGVyLmZpcnN0TWVkaWFTdHJlYW1UaW1lc3RhbXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXhlci5maXJzdE1lZGlhU3RyZWFtVGltZXN0YW1wID0gcGVyZm9ybWFuY2Uubm93KCkgLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZXN0YW1wT2Zmc2V0ID0gcGVyZm9ybWFuY2Uubm93KCkgLyAxMDAwIC0gbXV4ZXIuZmlyc3RNZWRpYVN0cmVhbVRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW5jb2Rlci5nZXRRdWV1ZVNpemUoKSA+PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEcm9wIGRhdGEgaWYgdGhlIGVuY29kZXIgaXMgb3ZlcmxvYWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9TYW1wbGUuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5fZW5jb2Rlci5hZGQoYXVkaW9TYW1wbGUsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuX2F1ZGlvQ29udGV4dC5zdXNwZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlV2l0aFJlc29sdmVycy5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBhc3luYyBfZmx1c2hBbmRDbG9zZShmb3JjZUNsb3NlKSB7XG4gICAgICAgIGlmICh0aGlzLl9hYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5fc2NyaXB0UHJvY2Vzc29yTm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9zY3JpcHRQcm9jZXNzb3JOb2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2F1ZGlvQ29udGV4dC5zdXNwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fZW5jb2Rlci5mbHVzaEFuZENsb3NlKGZvcmNlQ2xvc2UpO1xuICAgIH1cbn1cbmNvbnN0IG1lZGlhU3RyZWFtVHJhY2tQcm9jZXNzb3JXb3JrZXJDb2RlID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbmRNZXNzYWdlID0gKG1lc3NhZ2UsIHRyYW5zZmVyKSA9PiB7XG4gICAgICAgIGlmICh0cmFuc2Zlcikge1xuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShtZXNzYWdlLCB7IHRyYW5zZmVyIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSW1tZWRpYXRlbHkgc2VuZCBhIG1lc3NhZ2UgdG8gdGhlIG1haW4gdGhyZWFkLCBsZXR0aW5nIHRoZW0ga25vdyBvZiB0aGUgc3VwcG9ydFxuICAgIHNlbmRNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogJ3N1cHBvcnQnLFxuICAgICAgICBzdXBwb3J0ZWQ6IHR5cGVvZiBNZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29yICE9PSAndW5kZWZpbmVkJyxcbiAgICB9KTtcbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXJzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHN0b3BwZWRUcmFja3MgPSBuZXcgU2V0KCk7XG4gICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAndmlkZW9UcmFjayc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzb3IgPSBuZXcgTWVkaWFTdHJlYW1UcmFja1Byb2Nlc3Nvcih7IHRyYWNrOiBtZXNzYWdlLnRyYWNrIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25zdW1lciA9IG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZTogKHZpZGVvRnJhbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcHBlZFRyYWNrcy5oYXMobWVzc2FnZS50cmFja0lkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0ZyYW1lLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VuZCBpdCB0byB0aGUgbWFpbiB0aHJlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd2aWRlb0ZyYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tJZDogbWVzc2FnZS50cmFja0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0ZyYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFt2aWRlb0ZyYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJzLnNldChtZXNzYWdlLnRyYWNrSWQsIGFib3J0Q29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3Nvci5yZWFkYWJsZS5waXBlVG8oY29uc3VtZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgQWJvcnRFcnJvciBzaWxlbnRseVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja0lkOiBtZXNzYWdlLnRyYWNrSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3N0b3BUcmFjayc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXJzLmdldChtZXNzYWdlLnRyYWNrSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcnMuZGVsZXRlKG1lc3NhZ2UudHJhY2tJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRyYWNrcy5hZGQobWVzc2FnZS50cmFja0lkKTtcbiAgICAgICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RyYWNrU3RvcHBlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja0lkOiBtZXNzYWdlLnRyYWNrSWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiBhc3NlcnROZXZlcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmxldCBuZXh0TWVkaWFTdHJlYW1UcmFja1Byb2Nlc3NvcldvcmtlcklkID0gMDtcbmxldCBtZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29yV29ya2VyID0gbnVsbDtcbmNvbnN0IGluaXRNZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29yV29ya2VyID0gKCkgPT4ge1xuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYCgke21lZGlhU3RyZWFtVHJhY2tQcm9jZXNzb3JXb3JrZXJDb2RlLnRvU3RyaW5nKCl9KSgpYF0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnIH0pO1xuICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgbWVkaWFTdHJlYW1UcmFja1Byb2Nlc3NvcldvcmtlciA9IG5ldyBXb3JrZXIodXJsKTtcbn07XG5sZXQgbWVkaWFTdHJlYW1UcmFja1Byb2Nlc3NvcklzU3VwcG9ydGVkSW5Xb3JrZXJDYWNoZSA9IG51bGw7XG5jb25zdCBtZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29ySXNTdXBwb3J0ZWRJbldvcmtlciA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAobWVkaWFTdHJlYW1UcmFja1Byb2Nlc3NvcklzU3VwcG9ydGVkSW5Xb3JrZXJDYWNoZSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbWVkaWFTdHJlYW1UcmFja1Byb2Nlc3NvcklzU3VwcG9ydGVkSW5Xb3JrZXJDYWNoZTtcbiAgICB9XG4gICAgaWYgKCFtZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29yV29ya2VyKSB7XG4gICAgICAgIGluaXRNZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29yV29ya2VyKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBhc3NlcnQobWVkaWFTdHJlYW1UcmFja1Byb2Nlc3Nvcldvcmtlcik7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdzdXBwb3J0Jykge1xuICAgICAgICAgICAgICAgIG1lZGlhU3RyZWFtVHJhY2tQcm9jZXNzb3JJc1N1cHBvcnRlZEluV29ya2VyQ2FjaGUgPSBtZXNzYWdlLnN1cHBvcnRlZDtcbiAgICAgICAgICAgICAgICBtZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29yV29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtZXNzYWdlLnN1cHBvcnRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG1lZGlhU3RyZWFtVHJhY2tQcm9jZXNzb3JXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyKTtcbiAgICB9KTtcbn07XG5jb25zdCBzZW5kTWVzc2FnZVRvTWVkaWFTdHJlYW1UcmFja1Byb2Nlc3NvcldvcmtlciA9IChtZXNzYWdlLCB0cmFuc2ZlcikgPT4ge1xuICAgIGFzc2VydChtZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29yV29ya2VyKTtcbiAgICBpZiAodHJhbnNmZXIpIHtcbiAgICAgICAgbWVkaWFTdHJlYW1UcmFja1Byb2Nlc3Nvcldvcmtlci5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2Zlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29yV29ya2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cbn07XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHN1YnRpdGxlIHNvdXJjZXMgLSBzb3VyY2VzIGZvciBzdWJ0aXRsZSB0cmFja3MuXG4gKiBAZ3JvdXAgTWVkaWEgc291cmNlc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgU3VidGl0bGVTb3VyY2UgZXh0ZW5kcyBNZWRpYVNvdXJjZSB7XG4gICAgLyoqIEludGVybmFsIGNvbnN0cnVjdG9yLiAqL1xuICAgIGNvbnN0cnVjdG9yKGNvZGVjKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fY29ubmVjdGVkVHJhY2sgPSBudWxsO1xuICAgICAgICBpZiAoIVNVQlRJVExFX0NPREVDUy5pbmNsdWRlcyhjb2RlYykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc3VidGl0bGUgY29kZWMgJyR7Y29kZWN9Jy4gTXVzdCBiZSBvbmUgb2Y6ICR7U1VCVElUTEVfQ09ERUNTLmpvaW4oJywgJyl9LmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvZGVjID0gY29kZWM7XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIHNvdXJjZSBjYW4gYmUgdXNlZCB0byBhZGQgc3VidGl0bGVzIGZyb20gYSBzdWJ0aXRsZSB0ZXh0IGZpbGUuXG4gKiBAZ3JvdXAgTWVkaWEgc291cmNlc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgVGV4dFN1YnRpdGxlU291cmNlIGV4dGVuZHMgU3VidGl0bGVTb3VyY2Uge1xuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHtAbGluayBUZXh0U3VidGl0bGVTb3VyY2V9IHdoZXJlIGFkZGVkIHRleHQgY2h1bmtzIGFyZSBpbiB0aGUgc3BlY2lmaWVkIGBjb2RlY2AuICovXG4gICAgY29uc3RydWN0b3IoY29kZWMpIHtcbiAgICAgICAgc3VwZXIoY29kZWMpO1xuICAgICAgICB0aGlzLl9wYXJzZXIgPSBuZXcgU3VidGl0bGVQYXJzZXIoe1xuICAgICAgICAgICAgY29kZWMsXG4gICAgICAgICAgICBvdXRwdXQ6IChjdWUsIG1ldGFkYXRhKSA9PiB0aGlzLl9jb25uZWN0ZWRUcmFjaz8ub3V0cHV0Ll9tdXhlci5hZGRTdWJ0aXRsZUN1ZSh0aGlzLl9jb25uZWN0ZWRUcmFjaywgY3VlLCBtZXRhZGF0YSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIHN1YnRpdGxlIHRleHQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgY29kZWMgYW5kIGFkZHMgaXQgdG8gdGhlIG91dHB1dCB0cmFjay4gWW91IGRvbid0IGhhdmUgdG9cbiAgICAgKiBhZGQgdGhlIGVudGlyZSBzdWJ0aXRsZSBmaWxlIGF0IG9uY2UgaGVyZTsgeW91IGNhbiBwcm92aWRlIGl0IGluIGNodW5rcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIG91dHB1dCBpcyByZWFkeSB0byByZWNlaXZlIG1vcmUgc2FtcGxlcy4gWW91IHNob3VsZCBhd2FpdCB0aGlzIFByb21pc2VcbiAgICAgKiB0byByZXNwZWN0IHdyaXRlciBhbmQgZW5jb2RlciBiYWNrcHJlc3N1cmUuXG4gICAgICovXG4gICAgYWRkKHRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGV4dCBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vuc3VyZVZhbGlkQWRkKCk7XG4gICAgICAgIHRoaXMuX3BhcnNlci5wYXJzZSh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RlZFRyYWNrLm91dHB1dC5fbXV4ZXIubXV0ZXguY3VycmVudFByb21pc2U7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/media-source.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js":
/*!**********************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/misc.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncMutex: () => (/* binding */ AsyncMutex),\n/* harmony export */   Bitstream: () => (/* binding */ Bitstream),\n/* harmony export */   COLOR_PRIMARIES_MAP: () => (/* binding */ COLOR_PRIMARIES_MAP),\n/* harmony export */   COLOR_PRIMARIES_MAP_INVERSE: () => (/* binding */ COLOR_PRIMARIES_MAP_INVERSE),\n/* harmony export */   CallSerializer: () => (/* binding */ CallSerializer),\n/* harmony export */   MATRIX_COEFFICIENTS_MAP: () => (/* binding */ MATRIX_COEFFICIENTS_MAP),\n/* harmony export */   MATRIX_COEFFICIENTS_MAP_INVERSE: () => (/* binding */ MATRIX_COEFFICIENTS_MAP_INVERSE),\n/* harmony export */   SECOND_TO_MICROSECOND_FACTOR: () => (/* binding */ SECOND_TO_MICROSECOND_FACTOR),\n/* harmony export */   TRANSFER_CHARACTERISTICS_MAP: () => (/* binding */ TRANSFER_CHARACTERISTICS_MAP),\n/* harmony export */   TRANSFER_CHARACTERISTICS_MAP_INVERSE: () => (/* binding */ TRANSFER_CHARACTERISTICS_MAP_INVERSE),\n/* harmony export */   UNDETERMINED_LANGUAGE: () => (/* binding */ UNDETERMINED_LANGUAGE),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   base64ToBytes: () => (/* binding */ base64ToBytes),\n/* harmony export */   binarySearchExact: () => (/* binding */ binarySearchExact),\n/* harmony export */   binarySearchLessOrEqual: () => (/* binding */ binarySearchLessOrEqual),\n/* harmony export */   bytesToBase64: () => (/* binding */ bytesToBase64),\n/* harmony export */   bytesToHexString: () => (/* binding */ bytesToHexString),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   closedIntervalsOverlap: () => (/* binding */ closedIntervalsOverlap),\n/* harmony export */   coalesceIndex: () => (/* binding */ coalesceIndex),\n/* harmony export */   colorSpaceIsComplete: () => (/* binding */ colorSpaceIsComplete),\n/* harmony export */   computeRationalApproximation: () => (/* binding */ computeRationalApproximation),\n/* harmony export */   findLast: () => (/* binding */ findLast),\n/* harmony export */   findLastIndex: () => (/* binding */ findLastIndex),\n/* harmony export */   getInt24: () => (/* binding */ getInt24),\n/* harmony export */   getUint24: () => (/* binding */ getUint24),\n/* harmony export */   ilog: () => (/* binding */ ilog),\n/* harmony export */   imageMimeTypeToExtension: () => (/* binding */ imageMimeTypeToExtension),\n/* harmony export */   insertSorted: () => (/* binding */ insertSorted),\n/* harmony export */   isAllowSharedBufferSource: () => (/* binding */ isAllowSharedBufferSource),\n/* harmony export */   isIso639Dash2LanguageCode: () => (/* binding */ isIso639Dash2LanguageCode),\n/* harmony export */   isIso88591Compatible: () => (/* binding */ isIso88591Compatible),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isU32: () => (/* binding */ isU32),\n/* harmony export */   keyValueIterator: () => (/* binding */ keyValueIterator),\n/* harmony export */   last: () => (/* binding */ last),\n/* harmony export */   mapAsyncGenerator: () => (/* binding */ mapAsyncGenerator),\n/* harmony export */   mergeObjectsDeeply: () => (/* binding */ mergeObjectsDeeply),\n/* harmony export */   normalizeRotation: () => (/* binding */ normalizeRotation),\n/* harmony export */   promiseWithResolvers: () => (/* binding */ promiseWithResolvers),\n/* harmony export */   readExpGolomb: () => (/* binding */ readExpGolomb),\n/* harmony export */   readSignedExpGolomb: () => (/* binding */ readSignedExpGolomb),\n/* harmony export */   removeItem: () => (/* binding */ removeItem),\n/* harmony export */   retriedFetch: () => (/* binding */ retriedFetch),\n/* harmony export */   reverseBitsU32: () => (/* binding */ reverseBitsU32),\n/* harmony export */   roundToMultiple: () => (/* binding */ roundToMultiple),\n/* harmony export */   roundToPrecision: () => (/* binding */ roundToPrecision),\n/* harmony export */   setInt24: () => (/* binding */ setInt24),\n/* harmony export */   setInt64: () => (/* binding */ setInt64),\n/* harmony export */   setUint24: () => (/* binding */ setUint24),\n/* harmony export */   textDecoder: () => (/* binding */ textDecoder),\n/* harmony export */   textEncoder: () => (/* binding */ textEncoder),\n/* harmony export */   toAsyncIterator: () => (/* binding */ toAsyncIterator),\n/* harmony export */   toDataView: () => (/* binding */ toDataView),\n/* harmony export */   toUint8Array: () => (/* binding */ toUint8Array),\n/* harmony export */   validateAnyIterable: () => (/* binding */ validateAnyIterable),\n/* harmony export */   writeBits: () => (/* binding */ writeBits)\n/* harmony export */ });\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nfunction assert(x) {\n    if (!x) {\n        throw new Error('Assertion failed.');\n    }\n}\nconst normalizeRotation = (rotation) => {\n    const mappedRotation = (rotation % 360 + 360) % 360;\n    if (mappedRotation === 0 || mappedRotation === 90 || mappedRotation === 180 || mappedRotation === 270) {\n        return mappedRotation;\n    }\n    else {\n        throw new Error(`Invalid rotation ${rotation}.`);\n    }\n};\nconst last = (arr) => {\n    return arr && arr[arr.length - 1];\n};\nconst isU32 = (value) => {\n    return value >= 0 && value < 2 ** 32;\n};\nclass Bitstream {\n    constructor(bytes) {\n        this.bytes = bytes;\n        /** Current offset in bits. */\n        this.pos = 0;\n    }\n    seekToByte(byteOffset) {\n        this.pos = 8 * byteOffset;\n    }\n    readBit() {\n        const byteIndex = Math.floor(this.pos / 8);\n        const byte = this.bytes[byteIndex] ?? 0;\n        const bitIndex = 0b111 - (this.pos & 0b111);\n        const bit = (byte & (1 << bitIndex)) >> bitIndex;\n        this.pos++;\n        return bit;\n    }\n    readBits(n) {\n        if (n === 1) {\n            return this.readBit();\n        }\n        let result = 0;\n        for (let i = 0; i < n; i++) {\n            result <<= 1;\n            result |= this.readBit();\n        }\n        return result;\n    }\n    writeBits(n, value) {\n        const end = this.pos + n;\n        for (let i = this.pos; i < end; i++) {\n            const byteIndex = Math.floor(i / 8);\n            let byte = this.bytes[byteIndex];\n            const bitIndex = 0b111 - (i & 0b111);\n            byte &= ~(1 << bitIndex);\n            byte |= ((value & (1 << (end - i - 1))) >> (end - i - 1)) << bitIndex;\n            this.bytes[byteIndex] = byte;\n        }\n        this.pos = end;\n    }\n    ;\n    readAlignedByte() {\n        // Ensure we're byte-aligned\n        if (this.pos % 8 !== 0) {\n            throw new Error('Bitstream is not byte-aligned.');\n        }\n        const byteIndex = this.pos / 8;\n        const byte = this.bytes[byteIndex] ?? 0;\n        this.pos += 8;\n        return byte;\n    }\n    skipBits(n) {\n        this.pos += n;\n    }\n    getBitsLeft() {\n        return this.bytes.length * 8 - this.pos;\n    }\n    clone() {\n        const clone = new Bitstream(this.bytes);\n        clone.pos = this.pos;\n        return clone;\n    }\n}\n/** Reads an exponential-Golomb universal code from a Bitstream.  */\nconst readExpGolomb = (bitstream) => {\n    let leadingZeroBits = 0;\n    while (bitstream.readBits(1) === 0 && leadingZeroBits < 32) {\n        leadingZeroBits++;\n    }\n    if (leadingZeroBits >= 32) {\n        throw new Error('Invalid exponential-Golomb code.');\n    }\n    const result = (1 << leadingZeroBits) - 1 + bitstream.readBits(leadingZeroBits);\n    return result;\n};\n/** Reads a signed exponential-Golomb universal code from a Bitstream. */\nconst readSignedExpGolomb = (bitstream) => {\n    const codeNum = readExpGolomb(bitstream);\n    return ((codeNum & 1) === 0)\n        ? -(codeNum >> 1)\n        : ((codeNum + 1) >> 1);\n};\nconst writeBits = (bytes, start, end, value) => {\n    for (let i = start; i < end; i++) {\n        const byteIndex = Math.floor(i / 8);\n        let byte = bytes[byteIndex];\n        const bitIndex = 0b111 - (i & 0b111);\n        byte &= ~(1 << bitIndex);\n        byte |= ((value & (1 << (end - i - 1))) >> (end - i - 1)) << bitIndex;\n        bytes[byteIndex] = byte;\n    }\n};\nconst toUint8Array = (source) => {\n    if (source instanceof Uint8Array) {\n        return source;\n    }\n    else if (source instanceof ArrayBuffer) {\n        return new Uint8Array(source);\n    }\n    else {\n        return new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    }\n};\nconst toDataView = (source) => {\n    if (source instanceof DataView) {\n        return source;\n    }\n    else if (source instanceof ArrayBuffer) {\n        return new DataView(source);\n    }\n    else {\n        return new DataView(source.buffer, source.byteOffset, source.byteLength);\n    }\n};\nconst textDecoder = new TextDecoder();\nconst textEncoder = new TextEncoder();\nconst isIso88591Compatible = (text) => {\n    for (let i = 0; i < text.length; i++) {\n        const code = text.charCodeAt(i);\n        if (code > 255) {\n            return false;\n        }\n    }\n    return true;\n};\nconst invertObject = (object) => {\n    return Object.fromEntries(Object.entries(object).map(([key, value]) => [value, key]));\n};\n// For the color space mappings, see Rec. ITU-T H.273.\nconst COLOR_PRIMARIES_MAP = {\n    bt709: 1, // ITU-R BT.709\n    bt470bg: 5, // ITU-R BT.470BG\n    smpte170m: 6, // ITU-R BT.601 525 - SMPTE 170M\n    bt2020: 9, // ITU-R BT.202\n    smpte432: 12, // SMPTE EG 432-1\n};\nconst COLOR_PRIMARIES_MAP_INVERSE = invertObject(COLOR_PRIMARIES_MAP);\nconst TRANSFER_CHARACTERISTICS_MAP = {\n    'bt709': 1, // ITU-R BT.709\n    'smpte170m': 6, // SMPTE 170M\n    'linear': 8, // Linear transfer characteristics\n    'iec61966-2-1': 13, // IEC 61966-2-1\n    'pg': 16, // Rec. ITU-R BT.2100-2 perceptual quantization (PQ) system\n    'hlg': 18, // Rec. ITU-R BT.2100-2 hybrid loggamma (HLG) system\n};\nconst TRANSFER_CHARACTERISTICS_MAP_INVERSE = invertObject(TRANSFER_CHARACTERISTICS_MAP);\nconst MATRIX_COEFFICIENTS_MAP = {\n    'rgb': 0, // Identity\n    'bt709': 1, // ITU-R BT.709\n    'bt470bg': 5, // ITU-R BT.470BG\n    'smpte170m': 6, // SMPTE 170M\n    'bt2020-ncl': 9, // ITU-R BT.2020-2 (non-constant luminance)\n};\nconst MATRIX_COEFFICIENTS_MAP_INVERSE = invertObject(MATRIX_COEFFICIENTS_MAP);\nconst colorSpaceIsComplete = (colorSpace) => {\n    return (!!colorSpace\n        && !!colorSpace.primaries\n        && !!colorSpace.transfer\n        && !!colorSpace.matrix\n        && colorSpace.fullRange !== undefined);\n};\nconst isAllowSharedBufferSource = (x) => {\n    return (x instanceof ArrayBuffer\n        || (typeof SharedArrayBuffer !== 'undefined' && x instanceof SharedArrayBuffer)\n        || ArrayBuffer.isView(x));\n};\nclass AsyncMutex {\n    constructor() {\n        this.currentPromise = Promise.resolve();\n    }\n    async acquire() {\n        let resolver;\n        const nextPromise = new Promise((resolve) => {\n            resolver = resolve;\n        });\n        const currentPromiseAlias = this.currentPromise;\n        this.currentPromise = nextPromise;\n        await currentPromiseAlias;\n        return resolver;\n    }\n}\nconst bytesToHexString = (bytes) => {\n    return [...bytes].map(x => x.toString(16).padStart(2, '0')).join('');\n};\nconst reverseBitsU32 = (x) => {\n    x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);\n    x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);\n    x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);\n    x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);\n    x = ((x >> 16) & 0x0000ffff) | ((x & 0x0000ffff) << 16);\n    return x >>> 0; // Ensure it's treated as an unsigned 32-bit integer\n};\n/** Returns the smallest index i such that val[i] === key, or -1 if no such index exists. */\nconst binarySearchExact = (arr, key, valueGetter) => {\n    let low = 0;\n    let high = arr.length - 1;\n    let ans = -1;\n    while (low <= high) {\n        const mid = (low + high) >> 1;\n        const midVal = valueGetter(arr[mid]);\n        if (midVal === key) {\n            ans = mid;\n            high = mid - 1; // Continue searching left to find the lowest index\n        }\n        else if (midVal < key) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    return ans;\n};\n/** Returns the largest index i such that val[i] <= key, or -1 if no such index exists. */\nconst binarySearchLessOrEqual = (arr, key, valueGetter) => {\n    let low = 0;\n    let high = arr.length - 1;\n    let ans = -1;\n    while (low <= high) {\n        const mid = (low + (high - low + 1) / 2) | 0;\n        const midVal = valueGetter(arr[mid]);\n        if (midVal <= key) {\n            ans = mid;\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    return ans;\n};\n/** Assumes the array is already sorted. */\nconst insertSorted = (arr, item, valueGetter) => {\n    const insertionIndex = binarySearchLessOrEqual(arr, valueGetter(item), valueGetter);\n    arr.splice(insertionIndex + 1, 0, item); // This even behaves correctly for the -1 case\n};\nconst promiseWithResolvers = () => {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve: resolve, reject: reject };\n};\nconst removeItem = (arr, item) => {\n    const index = arr.indexOf(item);\n    if (index !== -1) {\n        arr.splice(index, 1);\n    }\n};\nconst findLast = (arr, predicate) => {\n    for (let i = arr.length - 1; i >= 0; i--) {\n        if (predicate(arr[i])) {\n            return arr[i];\n        }\n    }\n    return undefined;\n};\nconst findLastIndex = (arr, predicate) => {\n    for (let i = arr.length - 1; i >= 0; i--) {\n        if (predicate(arr[i])) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst toAsyncIterator = async function* (source) {\n    if (Symbol.iterator in source) {\n        // @ts-expect-error Trust me\n        yield* source[Symbol.iterator]();\n    }\n    else {\n        // @ts-expect-error Trust me\n        yield* source[Symbol.asyncIterator]();\n    }\n};\nconst validateAnyIterable = (iterable) => {\n    if (!(Symbol.iterator in iterable) && !(Symbol.asyncIterator in iterable)) {\n        throw new TypeError('Argument must be an iterable or async iterable.');\n    }\n};\nconst assertNever = (x) => {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new Error(`Unexpected value: ${x}`);\n};\nconst getUint24 = (view, byteOffset, littleEndian) => {\n    const byte1 = view.getUint8(byteOffset);\n    const byte2 = view.getUint8(byteOffset + 1);\n    const byte3 = view.getUint8(byteOffset + 2);\n    if (littleEndian) {\n        return byte1 | (byte2 << 8) | (byte3 << 16);\n    }\n    else {\n        return (byte1 << 16) | (byte2 << 8) | byte3;\n    }\n};\nconst getInt24 = (view, byteOffset, littleEndian) => {\n    // The left shift pushes the most significant bit into the sign bit region, and the subsequent right shift\n    // then correctly interprets the sign bit.\n    return getUint24(view, byteOffset, littleEndian) << 8 >> 8;\n};\nconst setUint24 = (view, byteOffset, value, littleEndian) => {\n    // Ensure the value is within 24-bit unsigned range (0 to 16777215)\n    value = value >>> 0; // Convert to unsigned 32-bit\n    value = value & 0xFFFFFF; // Mask to 24 bits\n    if (littleEndian) {\n        view.setUint8(byteOffset, value & 0xFF);\n        view.setUint8(byteOffset + 1, (value >>> 8) & 0xFF);\n        view.setUint8(byteOffset + 2, (value >>> 16) & 0xFF);\n    }\n    else {\n        view.setUint8(byteOffset, (value >>> 16) & 0xFF);\n        view.setUint8(byteOffset + 1, (value >>> 8) & 0xFF);\n        view.setUint8(byteOffset + 2, value & 0xFF);\n    }\n};\nconst setInt24 = (view, byteOffset, value, littleEndian) => {\n    // Ensure the value is within 24-bit signed range (-8388608 to 8388607)\n    value = clamp(value, -8388608, 8388607);\n    // Convert negative values to their 24-bit representation\n    if (value < 0) {\n        value = (value + 0x1000000) & 0xFFFFFF;\n    }\n    setUint24(view, byteOffset, value, littleEndian);\n};\nconst setInt64 = (view, byteOffset, value, littleEndian) => {\n    if (littleEndian) {\n        view.setUint32(byteOffset + 0, value, true);\n        view.setInt32(byteOffset + 4, Math.floor(value / 2 ** 32), true);\n    }\n    else {\n        view.setInt32(byteOffset + 0, Math.floor(value / 2 ** 32), true);\n        view.setUint32(byteOffset + 4, value, true);\n    }\n};\n/**\n * Calls a function on each value spat out by an async generator. The reason for writing this manually instead of\n * using a generator function is that the generator function queues return() calls - here, we forward them immediately.\n */\nconst mapAsyncGenerator = (generator, map) => {\n    return {\n        async next() {\n            const result = await generator.next();\n            if (result.done) {\n                return { value: undefined, done: true };\n            }\n            else {\n                return { value: map(result.value), done: false };\n            }\n        },\n        return() {\n            return generator.return();\n        },\n        throw(error) {\n            return generator.throw(error);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n};\nconst clamp = (value, min, max) => {\n    return Math.max(min, Math.min(max, value));\n};\nconst UNDETERMINED_LANGUAGE = 'und';\nconst roundToPrecision = (value, digits) => {\n    const factor = 10 ** digits;\n    return Math.round(value * factor) / factor;\n};\nconst roundToMultiple = (value, multiple) => {\n    return Math.round(value / multiple) * multiple;\n};\nconst ilog = (x) => {\n    let ret = 0;\n    while (x) {\n        ret++;\n        x >>= 1;\n    }\n    return ret;\n};\nconst ISO_639_2_REGEX = /^[a-z]{3}$/;\nconst isIso639Dash2LanguageCode = (x) => {\n    return ISO_639_2_REGEX.test(x);\n};\n// Since the result will be truncated, add a bit of eps to compensate for floating point errors\nconst SECOND_TO_MICROSECOND_FACTOR = 1e6 * (1 + Number.EPSILON);\nconst mergeObjectsDeeply = (a, b) => {\n    const result = { ...a };\n    for (const key in b) {\n        if (typeof a[key] === 'object'\n            && a[key] !== null\n            && typeof b[key] === 'object'\n            && b[key] !== null) {\n            result[key] = mergeObjectsDeeply(a[key], b[key]);\n        }\n        else {\n            result[key] = b[key];\n        }\n    }\n    return result;\n};\nconst retriedFetch = async (url, requestInit, getRetryDelay) => {\n    let attempts = 0;\n    while (true) {\n        try {\n            return await fetch(url, requestInit);\n        }\n        catch (error) {\n            attempts++;\n            const retryDelayInSeconds = getRetryDelay(attempts);\n            if (retryDelayInSeconds === null) {\n                throw error;\n            }\n            console.error('Retrying failed fetch. Error:', error);\n            if (!Number.isFinite(retryDelayInSeconds) || retryDelayInSeconds < 0) {\n                throw new TypeError('Retry delay must be a non-negative finite number.');\n            }\n            if (retryDelayInSeconds > 0) {\n                await new Promise(resolve => setTimeout(resolve, 1000 * retryDelayInSeconds));\n            }\n        }\n    }\n};\nconst computeRationalApproximation = (x, maxDenominator) => {\n    // Handle negative numbers\n    const sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n    let prevNumerator = 0, prevDenominator = 1;\n    let currNumerator = 1, currDenominator = 0;\n    // Continued fraction algorithm\n    let remainder = x;\n    while (true) {\n        const integer = Math.floor(remainder);\n        // Calculate next convergent\n        const nextNumerator = integer * currNumerator + prevNumerator;\n        const nextDenominator = integer * currDenominator + prevDenominator;\n        if (nextDenominator > maxDenominator) {\n            return {\n                numerator: sign * currNumerator,\n                denominator: currDenominator,\n            };\n        }\n        prevNumerator = currNumerator;\n        prevDenominator = currDenominator;\n        currNumerator = nextNumerator;\n        currDenominator = nextDenominator;\n        remainder = 1 / (remainder - integer);\n        // Guard against precision issues\n        if (!isFinite(remainder)) {\n            break;\n        }\n    }\n    return {\n        numerator: sign * currNumerator,\n        denominator: currDenominator,\n    };\n};\nclass CallSerializer {\n    constructor() {\n        this.currentPromise = Promise.resolve();\n    }\n    call(fn) {\n        return this.currentPromise = this.currentPromise.then(fn);\n    }\n}\nlet isSafariCache = null;\nconst isSafari = () => {\n    if (isSafariCache !== null) {\n        return isSafariCache;\n    }\n    const result = !!(typeof navigator !== 'undefined'\n        && navigator.vendor?.match(/apple/i)\n        && !navigator.userAgent?.match(/crios/i)\n        && !navigator.userAgent?.match(/fxios/i)\n        && !navigator.userAgent?.match(/Opera|OPT\\//));\n    isSafariCache = result;\n    return result;\n};\n/** Acts like `??` except the condition is -1 and not null/undefined. */\nconst coalesceIndex = (a, b) => {\n    return a !== -1 ? a : b;\n};\nconst closedIntervalsOverlap = (startA, endA, startB, endB) => {\n    return startA <= endB && startB <= endA;\n};\nconst keyValueIterator = function* (object) {\n    for (const key in object) {\n        const value = object[key];\n        if (value === undefined) {\n            continue;\n        }\n        yield { key, value };\n    }\n};\nconst imageMimeTypeToExtension = (mimeType) => {\n    switch (mimeType.toLowerCase()) {\n        case 'image/jpeg':\n        case 'image/jpg':\n            return '.jpg';\n        case 'image/png':\n            return '.png';\n        case 'image/gif':\n            return '.gif';\n        case 'image/webp':\n            return '.webp';\n        case 'image/bmp':\n            return '.bmp';\n        case 'image/svg+xml':\n            return '.svg';\n        case 'image/tiff':\n            return '.tiff';\n        case 'image/avif':\n            return '.avif';\n        case 'image/x-icon':\n        case 'image/vnd.microsoft.icon':\n            return '.ico';\n        default:\n            return null;\n    }\n};\nconst base64ToBytes = (base64) => {\n    const decoded = atob(base64);\n    const bytes = new Uint8Array(decoded.length);\n    for (let i = 0; i < decoded.length; i++) {\n        bytes[i] = decoded.charCodeAt(i);\n    }\n    return bytes;\n};\nconst bytesToBase64 = (bytes) => {\n    let string = '';\n    for (let i = 0; i < bytes.length; i++) {\n        string += String.fromCharCode(bytes[i]);\n    }\n    return btoa(string);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL21pc2MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWF0Y2gtY3V0LWdlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9tZWRpYWJ1bm55L2Rpc3QvbW9kdWxlcy9zcmMvbWlzYy5qcz9mYTQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDI1LXByZXNlbnQsIFZhbmlsYWd5IGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydCh4KSB7XG4gICAgaWYgKCF4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXNzZXJ0aW9uIGZhaWxlZC4nKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgbm9ybWFsaXplUm90YXRpb24gPSAocm90YXRpb24pID0+IHtcbiAgICBjb25zdCBtYXBwZWRSb3RhdGlvbiA9IChyb3RhdGlvbiAlIDM2MCArIDM2MCkgJSAzNjA7XG4gICAgaWYgKG1hcHBlZFJvdGF0aW9uID09PSAwIHx8IG1hcHBlZFJvdGF0aW9uID09PSA5MCB8fCBtYXBwZWRSb3RhdGlvbiA9PT0gMTgwIHx8IG1hcHBlZFJvdGF0aW9uID09PSAyNzApIHtcbiAgICAgICAgcmV0dXJuIG1hcHBlZFJvdGF0aW9uO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJvdGF0aW9uICR7cm90YXRpb259LmApO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgbGFzdCA9IChhcnIpID0+IHtcbiAgICByZXR1cm4gYXJyICYmIGFyclthcnIubGVuZ3RoIC0gMV07XG59O1xuZXhwb3J0IGNvbnN0IGlzVTMyID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPCAyICoqIDMyO1xufTtcbmV4cG9ydCBjbGFzcyBCaXRzdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgICAgICAgLyoqIEN1cnJlbnQgb2Zmc2V0IGluIGJpdHMuICovXG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgc2Vla1RvQnl0ZShieXRlT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMucG9zID0gOCAqIGJ5dGVPZmZzZXQ7XG4gICAgfVxuICAgIHJlYWRCaXQoKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVJbmRleCA9IE1hdGguZmxvb3IodGhpcy5wb3MgLyA4KTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IHRoaXMuYnl0ZXNbYnl0ZUluZGV4XSA/PyAwO1xuICAgICAgICBjb25zdCBiaXRJbmRleCA9IDBiMTExIC0gKHRoaXMucG9zICYgMGIxMTEpO1xuICAgICAgICBjb25zdCBiaXQgPSAoYnl0ZSAmICgxIDw8IGJpdEluZGV4KSkgPj4gYml0SW5kZXg7XG4gICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgIHJldHVybiBiaXQ7XG4gICAgfVxuICAgIHJlYWRCaXRzKG4pIHtcbiAgICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRCaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA8PD0gMTtcbiAgICAgICAgICAgIHJlc3VsdCB8PSB0aGlzLnJlYWRCaXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB3cml0ZUJpdHMobiwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5wb3MgKyBuO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5wb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYnl0ZUluZGV4ID0gTWF0aC5mbG9vcihpIC8gOCk7XG4gICAgICAgICAgICBsZXQgYnl0ZSA9IHRoaXMuYnl0ZXNbYnl0ZUluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGJpdEluZGV4ID0gMGIxMTEgLSAoaSAmIDBiMTExKTtcbiAgICAgICAgICAgIGJ5dGUgJj0gfigxIDw8IGJpdEluZGV4KTtcbiAgICAgICAgICAgIGJ5dGUgfD0gKCh2YWx1ZSAmICgxIDw8IChlbmQgLSBpIC0gMSkpKSA+PiAoZW5kIC0gaSAtIDEpKSA8PCBiaXRJbmRleDtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNbYnl0ZUluZGV4XSA9IGJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgfVxuICAgIDtcbiAgICByZWFkQWxpZ25lZEJ5dGUoKSB7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSdyZSBieXRlLWFsaWduZWRcbiAgICAgICAgaWYgKHRoaXMucG9zICUgOCAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaXRzdHJlYW0gaXMgbm90IGJ5dGUtYWxpZ25lZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlSW5kZXggPSB0aGlzLnBvcyAvIDg7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSB0aGlzLmJ5dGVzW2J5dGVJbmRleF0gPz8gMDtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICAgICAgcmV0dXJuIGJ5dGU7XG4gICAgfVxuICAgIHNraXBCaXRzKG4pIHtcbiAgICAgICAgdGhpcy5wb3MgKz0gbjtcbiAgICB9XG4gICAgZ2V0Qml0c0xlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmxlbmd0aCAqIDggLSB0aGlzLnBvcztcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IEJpdHN0cmVhbSh0aGlzLmJ5dGVzKTtcbiAgICAgICAgY2xvbmUucG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG59XG4vKiogUmVhZHMgYW4gZXhwb25lbnRpYWwtR29sb21iIHVuaXZlcnNhbCBjb2RlIGZyb20gYSBCaXRzdHJlYW0uICAqL1xuZXhwb3J0IGNvbnN0IHJlYWRFeHBHb2xvbWIgPSAoYml0c3RyZWFtKSA9PiB7XG4gICAgbGV0IGxlYWRpbmdaZXJvQml0cyA9IDA7XG4gICAgd2hpbGUgKGJpdHN0cmVhbS5yZWFkQml0cygxKSA9PT0gMCAmJiBsZWFkaW5nWmVyb0JpdHMgPCAzMikge1xuICAgICAgICBsZWFkaW5nWmVyb0JpdHMrKztcbiAgICB9XG4gICAgaWYgKGxlYWRpbmdaZXJvQml0cyA+PSAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZXhwb25lbnRpYWwtR29sb21iIGNvZGUuJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9ICgxIDw8IGxlYWRpbmdaZXJvQml0cykgLSAxICsgYml0c3RyZWFtLnJlYWRCaXRzKGxlYWRpbmdaZXJvQml0cyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKiogUmVhZHMgYSBzaWduZWQgZXhwb25lbnRpYWwtR29sb21iIHVuaXZlcnNhbCBjb2RlIGZyb20gYSBCaXRzdHJlYW0uICovXG5leHBvcnQgY29uc3QgcmVhZFNpZ25lZEV4cEdvbG9tYiA9IChiaXRzdHJlYW0pID0+IHtcbiAgICBjb25zdCBjb2RlTnVtID0gcmVhZEV4cEdvbG9tYihiaXRzdHJlYW0pO1xuICAgIHJldHVybiAoKGNvZGVOdW0gJiAxKSA9PT0gMClcbiAgICAgICAgPyAtKGNvZGVOdW0gPj4gMSlcbiAgICAgICAgOiAoKGNvZGVOdW0gKyAxKSA+PiAxKTtcbn07XG5leHBvcnQgY29uc3Qgd3JpdGVCaXRzID0gKGJ5dGVzLCBzdGFydCwgZW5kLCB2YWx1ZSkgPT4ge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVJbmRleCA9IE1hdGguZmxvb3IoaSAvIDgpO1xuICAgICAgICBsZXQgYnl0ZSA9IGJ5dGVzW2J5dGVJbmRleF07XG4gICAgICAgIGNvbnN0IGJpdEluZGV4ID0gMGIxMTEgLSAoaSAmIDBiMTExKTtcbiAgICAgICAgYnl0ZSAmPSB+KDEgPDwgYml0SW5kZXgpO1xuICAgICAgICBieXRlIHw9ICgodmFsdWUgJiAoMSA8PCAoZW5kIC0gaSAtIDEpKSkgPj4gKGVuZCAtIGkgLSAxKSkgPDwgYml0SW5kZXg7XG4gICAgICAgIGJ5dGVzW2J5dGVJbmRleF0gPSBieXRlO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgdG9VaW50OEFycmF5ID0gKHNvdXJjZSkgPT4ge1xuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShzb3VyY2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aCk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCB0b0RhdGFWaWV3ID0gKHNvdXJjZSkgPT4ge1xuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbmV3IERhdGFWaWV3KHNvdXJjZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IERhdGFWaWV3KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aCk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuZXhwb3J0IGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5leHBvcnQgY29uc3QgaXNJc284ODU5MUNvbXBhdGlibGUgPSAodGV4dCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA+IDI1NSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGludmVydE9iamVjdCA9IChvYmplY3QpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG9iamVjdCkubWFwKChba2V5LCB2YWx1ZV0pID0+IFt2YWx1ZSwga2V5XSkpO1xufTtcbi8vIEZvciB0aGUgY29sb3Igc3BhY2UgbWFwcGluZ3MsIHNlZSBSZWMuIElUVS1UIEguMjczLlxuZXhwb3J0IGNvbnN0IENPTE9SX1BSSU1BUklFU19NQVAgPSB7XG4gICAgYnQ3MDk6IDEsIC8vIElUVS1SIEJULjcwOVxuICAgIGJ0NDcwYmc6IDUsIC8vIElUVS1SIEJULjQ3MEJHXG4gICAgc21wdGUxNzBtOiA2LCAvLyBJVFUtUiBCVC42MDEgNTI1IC0gU01QVEUgMTcwTVxuICAgIGJ0MjAyMDogOSwgLy8gSVRVLVIgQlQuMjAyXG4gICAgc21wdGU0MzI6IDEyLCAvLyBTTVBURSBFRyA0MzItMVxufTtcbmV4cG9ydCBjb25zdCBDT0xPUl9QUklNQVJJRVNfTUFQX0lOVkVSU0UgPSBpbnZlcnRPYmplY3QoQ09MT1JfUFJJTUFSSUVTX01BUCk7XG5leHBvcnQgY29uc3QgVFJBTlNGRVJfQ0hBUkFDVEVSSVNUSUNTX01BUCA9IHtcbiAgICAnYnQ3MDknOiAxLCAvLyBJVFUtUiBCVC43MDlcbiAgICAnc21wdGUxNzBtJzogNiwgLy8gU01QVEUgMTcwTVxuICAgICdsaW5lYXInOiA4LCAvLyBMaW5lYXIgdHJhbnNmZXIgY2hhcmFjdGVyaXN0aWNzXG4gICAgJ2llYzYxOTY2LTItMSc6IDEzLCAvLyBJRUMgNjE5NjYtMi0xXG4gICAgJ3BnJzogMTYsIC8vIFJlYy4gSVRVLVIgQlQuMjEwMC0yIHBlcmNlcHR1YWwgcXVhbnRpemF0aW9uIChQUSkgc3lzdGVtXG4gICAgJ2hsZyc6IDE4LCAvLyBSZWMuIElUVS1SIEJULjIxMDAtMiBoeWJyaWQgbG9nZ2FtbWEgKEhMRykgc3lzdGVtXG59O1xuZXhwb3J0IGNvbnN0IFRSQU5TRkVSX0NIQVJBQ1RFUklTVElDU19NQVBfSU5WRVJTRSA9IGludmVydE9iamVjdChUUkFOU0ZFUl9DSEFSQUNURVJJU1RJQ1NfTUFQKTtcbmV4cG9ydCBjb25zdCBNQVRSSVhfQ09FRkZJQ0lFTlRTX01BUCA9IHtcbiAgICAncmdiJzogMCwgLy8gSWRlbnRpdHlcbiAgICAnYnQ3MDknOiAxLCAvLyBJVFUtUiBCVC43MDlcbiAgICAnYnQ0NzBiZyc6IDUsIC8vIElUVS1SIEJULjQ3MEJHXG4gICAgJ3NtcHRlMTcwbSc6IDYsIC8vIFNNUFRFIDE3ME1cbiAgICAnYnQyMDIwLW5jbCc6IDksIC8vIElUVS1SIEJULjIwMjAtMiAobm9uLWNvbnN0YW50IGx1bWluYW5jZSlcbn07XG5leHBvcnQgY29uc3QgTUFUUklYX0NPRUZGSUNJRU5UU19NQVBfSU5WRVJTRSA9IGludmVydE9iamVjdChNQVRSSVhfQ09FRkZJQ0lFTlRTX01BUCk7XG5leHBvcnQgY29uc3QgY29sb3JTcGFjZUlzQ29tcGxldGUgPSAoY29sb3JTcGFjZSkgPT4ge1xuICAgIHJldHVybiAoISFjb2xvclNwYWNlXG4gICAgICAgICYmICEhY29sb3JTcGFjZS5wcmltYXJpZXNcbiAgICAgICAgJiYgISFjb2xvclNwYWNlLnRyYW5zZmVyXG4gICAgICAgICYmICEhY29sb3JTcGFjZS5tYXRyaXhcbiAgICAgICAgJiYgY29sb3JTcGFjZS5mdWxsUmFuZ2UgIT09IHVuZGVmaW5lZCk7XG59O1xuZXhwb3J0IGNvbnN0IGlzQWxsb3dTaGFyZWRCdWZmZXJTb3VyY2UgPSAoeCkgPT4ge1xuICAgIHJldHVybiAoeCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyXG4gICAgICAgIHx8ICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcilcbiAgICAgICAgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHgpKTtcbn07XG5leHBvcnQgY2xhc3MgQXN5bmNNdXRleCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgYXN5bmMgYWNxdWlyZSgpIHtcbiAgICAgICAgbGV0IHJlc29sdmVyO1xuICAgICAgICBjb25zdCBuZXh0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjdXJyZW50UHJvbWlzZUFsaWFzID0gdGhpcy5jdXJyZW50UHJvbWlzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvbWlzZSA9IG5leHRQcm9taXNlO1xuICAgICAgICBhd2FpdCBjdXJyZW50UHJvbWlzZUFsaWFzO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZXI7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IGJ5dGVzVG9IZXhTdHJpbmcgPSAoYnl0ZXMpID0+IHtcbiAgICByZXR1cm4gWy4uLmJ5dGVzXS5tYXAoeCA9PiB4LnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbn07XG5leHBvcnQgY29uc3QgcmV2ZXJzZUJpdHNVMzIgPSAoeCkgPT4ge1xuICAgIHggPSAoKHggPj4gMSkgJiAweDU1NTU1NTU1KSB8ICgoeCAmIDB4NTU1NTU1NTUpIDw8IDEpO1xuICAgIHggPSAoKHggPj4gMikgJiAweDMzMzMzMzMzKSB8ICgoeCAmIDB4MzMzMzMzMzMpIDw8IDIpO1xuICAgIHggPSAoKHggPj4gNCkgJiAweDBmMGYwZjBmKSB8ICgoeCAmIDB4MGYwZjBmMGYpIDw8IDQpO1xuICAgIHggPSAoKHggPj4gOCkgJiAweDAwZmYwMGZmKSB8ICgoeCAmIDB4MDBmZjAwZmYpIDw8IDgpO1xuICAgIHggPSAoKHggPj4gMTYpICYgMHgwMDAwZmZmZikgfCAoKHggJiAweDAwMDBmZmZmKSA8PCAxNik7XG4gICAgcmV0dXJuIHggPj4+IDA7IC8vIEVuc3VyZSBpdCdzIHRyZWF0ZWQgYXMgYW4gdW5zaWduZWQgMzItYml0IGludGVnZXJcbn07XG4vKiogUmV0dXJucyB0aGUgc21hbGxlc3QgaW5kZXggaSBzdWNoIHRoYXQgdmFsW2ldID09PSBrZXksIG9yIC0xIGlmIG5vIHN1Y2ggaW5kZXggZXhpc3RzLiAqL1xuZXhwb3J0IGNvbnN0IGJpbmFyeVNlYXJjaEV4YWN0ID0gKGFyciwga2V5LCB2YWx1ZUdldHRlcikgPT4ge1xuICAgIGxldCBsb3cgPSAwO1xuICAgIGxldCBoaWdoID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgbGV0IGFucyA9IC0xO1xuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgICBjb25zdCBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTtcbiAgICAgICAgY29uc3QgbWlkVmFsID0gdmFsdWVHZXR0ZXIoYXJyW21pZF0pO1xuICAgICAgICBpZiAobWlkVmFsID09PSBrZXkpIHtcbiAgICAgICAgICAgIGFucyA9IG1pZDtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQgLSAxOyAvLyBDb250aW51ZSBzZWFyY2hpbmcgbGVmdCB0byBmaW5kIHRoZSBsb3dlc3QgaW5kZXhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtaWRWYWwgPCBrZXkpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW5zO1xufTtcbi8qKiBSZXR1cm5zIHRoZSBsYXJnZXN0IGluZGV4IGkgc3VjaCB0aGF0IHZhbFtpXSA8PSBrZXksIG9yIC0xIGlmIG5vIHN1Y2ggaW5kZXggZXhpc3RzLiAqL1xuZXhwb3J0IGNvbnN0IGJpbmFyeVNlYXJjaExlc3NPckVxdWFsID0gKGFyciwga2V5LCB2YWx1ZUdldHRlcikgPT4ge1xuICAgIGxldCBsb3cgPSAwO1xuICAgIGxldCBoaWdoID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgbGV0IGFucyA9IC0xO1xuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgICBjb25zdCBtaWQgPSAobG93ICsgKGhpZ2ggLSBsb3cgKyAxKSAvIDIpIHwgMDtcbiAgICAgICAgY29uc3QgbWlkVmFsID0gdmFsdWVHZXR0ZXIoYXJyW21pZF0pO1xuICAgICAgICBpZiAobWlkVmFsIDw9IGtleSkge1xuICAgICAgICAgICAgYW5zID0gbWlkO1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQgLSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbnM7XG59O1xuLyoqIEFzc3VtZXMgdGhlIGFycmF5IGlzIGFscmVhZHkgc29ydGVkLiAqL1xuZXhwb3J0IGNvbnN0IGluc2VydFNvcnRlZCA9IChhcnIsIGl0ZW0sIHZhbHVlR2V0dGVyKSA9PiB7XG4gICAgY29uc3QgaW5zZXJ0aW9uSW5kZXggPSBiaW5hcnlTZWFyY2hMZXNzT3JFcXVhbChhcnIsIHZhbHVlR2V0dGVyKGl0ZW0pLCB2YWx1ZUdldHRlcik7XG4gICAgYXJyLnNwbGljZShpbnNlcnRpb25JbmRleCArIDEsIDAsIGl0ZW0pOyAvLyBUaGlzIGV2ZW4gYmVoYXZlcyBjb3JyZWN0bHkgZm9yIHRoZSAtMSBjYXNlXG59O1xuZXhwb3J0IGNvbnN0IHByb21pc2VXaXRoUmVzb2x2ZXJzID0gKCkgPT4ge1xuICAgIGxldCByZXNvbHZlO1xuICAgIGxldCByZWplY3Q7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICByZWplY3QgPSByZWo7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZTogcmVzb2x2ZSwgcmVqZWN0OiByZWplY3QgfTtcbn07XG5leHBvcnQgY29uc3QgcmVtb3ZlSXRlbSA9IChhcnIsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgYXJyLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBmaW5kTGFzdCA9IChhcnIsIHByZWRpY2F0ZSkgPT4ge1xuICAgIGZvciAobGV0IGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuZXhwb3J0IGNvbnN0IGZpbmRMYXN0SW5kZXggPSAoYXJyLCBwcmVkaWNhdGUpID0+IHtcbiAgICBmb3IgKGxldCBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcbmV4cG9ydCBjb25zdCB0b0FzeW5jSXRlcmF0b3IgPSBhc3luYyBmdW5jdGlvbiogKHNvdXJjZSkge1xuICAgIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gc291cmNlKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVHJ1c3QgbWVcbiAgICAgICAgeWllbGQqIHNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRydXN0IG1lXG4gICAgICAgIHlpZWxkKiBzb3VyY2VbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUFueUl0ZXJhYmxlID0gKGl0ZXJhYmxlKSA9PiB7XG4gICAgaWYgKCEoU3ltYm9sLml0ZXJhdG9yIGluIGl0ZXJhYmxlKSAmJiAhKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIGl0ZXJhYmxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGFuIGl0ZXJhYmxlIG9yIGFzeW5jIGl0ZXJhYmxlLicpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgYXNzZXJ0TmV2ZXIgPSAoeCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdmFsdWU6ICR7eH1gKTtcbn07XG5leHBvcnQgY29uc3QgZ2V0VWludDI0ID0gKHZpZXcsIGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikgPT4ge1xuICAgIGNvbnN0IGJ5dGUxID0gdmlldy5nZXRVaW50OChieXRlT2Zmc2V0KTtcbiAgICBjb25zdCBieXRlMiA9IHZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCArIDEpO1xuICAgIGNvbnN0IGJ5dGUzID0gdmlldy5nZXRVaW50OChieXRlT2Zmc2V0ICsgMik7XG4gICAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgICAgICByZXR1cm4gYnl0ZTEgfCAoYnl0ZTIgPDwgOCkgfCAoYnl0ZTMgPDwgMTYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChieXRlMSA8PCAxNikgfCAoYnl0ZTIgPDwgOCkgfCBieXRlMztcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGdldEludDI0ID0gKHZpZXcsIGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikgPT4ge1xuICAgIC8vIFRoZSBsZWZ0IHNoaWZ0IHB1c2hlcyB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgaW50byB0aGUgc2lnbiBiaXQgcmVnaW9uLCBhbmQgdGhlIHN1YnNlcXVlbnQgcmlnaHQgc2hpZnRcbiAgICAvLyB0aGVuIGNvcnJlY3RseSBpbnRlcnByZXRzIHRoZSBzaWduIGJpdC5cbiAgICByZXR1cm4gZ2V0VWludDI0KHZpZXcsIGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikgPDwgOCA+PiA4O1xufTtcbmV4cG9ydCBjb25zdCBzZXRVaW50MjQgPSAodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbikgPT4ge1xuICAgIC8vIEVuc3VyZSB0aGUgdmFsdWUgaXMgd2l0aGluIDI0LWJpdCB1bnNpZ25lZCByYW5nZSAoMCB0byAxNjc3NzIxNSlcbiAgICB2YWx1ZSA9IHZhbHVlID4+PiAwOyAvLyBDb252ZXJ0IHRvIHVuc2lnbmVkIDMyLWJpdFxuICAgIHZhbHVlID0gdmFsdWUgJiAweEZGRkZGRjsgLy8gTWFzayB0byAyNCBiaXRzXG4gICAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgICAgICB2aWV3LnNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlICYgMHhGRik7XG4gICAgICAgIHZpZXcuc2V0VWludDgoYnl0ZU9mZnNldCArIDEsICh2YWx1ZSA+Pj4gOCkgJiAweEZGKTtcbiAgICAgICAgdmlldy5zZXRVaW50OChieXRlT2Zmc2V0ICsgMiwgKHZhbHVlID4+PiAxNikgJiAweEZGKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuc2V0VWludDgoYnl0ZU9mZnNldCwgKHZhbHVlID4+PiAxNikgJiAweEZGKTtcbiAgICAgICAgdmlldy5zZXRVaW50OChieXRlT2Zmc2V0ICsgMSwgKHZhbHVlID4+PiA4KSAmIDB4RkYpO1xuICAgICAgICB2aWV3LnNldFVpbnQ4KGJ5dGVPZmZzZXQgKyAyLCB2YWx1ZSAmIDB4RkYpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3Qgc2V0SW50MjQgPSAodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbikgPT4ge1xuICAgIC8vIEVuc3VyZSB0aGUgdmFsdWUgaXMgd2l0aGluIDI0LWJpdCBzaWduZWQgcmFuZ2UgKC04Mzg4NjA4IHRvIDgzODg2MDcpXG4gICAgdmFsdWUgPSBjbGFtcCh2YWx1ZSwgLTgzODg2MDgsIDgzODg2MDcpO1xuICAgIC8vIENvbnZlcnQgbmVnYXRpdmUgdmFsdWVzIHRvIHRoZWlyIDI0LWJpdCByZXByZXNlbnRhdGlvblxuICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgKyAweDEwMDAwMDApICYgMHhGRkZGRkY7XG4gICAgfVxuICAgIHNldFVpbnQyNCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKTtcbn07XG5leHBvcnQgY29uc3Qgc2V0SW50NjQgPSAodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbikgPT4ge1xuICAgIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMihieXRlT2Zmc2V0ICsgNCwgTWF0aC5mbG9vcih2YWx1ZSAvIDIgKiogMzIpLCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoYnl0ZU9mZnNldCArIDAsIE1hdGguZmxvb3IodmFsdWUgLyAyICoqIDMyKSwgdHJ1ZSk7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyA0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxufTtcbi8qKlxuICogQ2FsbHMgYSBmdW5jdGlvbiBvbiBlYWNoIHZhbHVlIHNwYXQgb3V0IGJ5IGFuIGFzeW5jIGdlbmVyYXRvci4gVGhlIHJlYXNvbiBmb3Igd3JpdGluZyB0aGlzIG1hbnVhbGx5IGluc3RlYWQgb2ZcbiAqIHVzaW5nIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIGlzIHRoYXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBxdWV1ZXMgcmV0dXJuKCkgY2FsbHMgLSBoZXJlLCB3ZSBmb3J3YXJkIHRoZW0gaW1tZWRpYXRlbHkuXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBBc3luY0dlbmVyYXRvciA9IChnZW5lcmF0b3IsIG1hcCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZW5lcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG1hcChyZXN1bHQudmFsdWUpLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXR1cm4oKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdG9yLnJldHVybigpO1xuICAgICAgICB9LFxuICAgICAgICB0aHJvdyhlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRvci50aHJvdyhlcnJvcik7XG4gICAgICAgIH0sXG4gICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBjbGFtcCA9ICh2YWx1ZSwgbWluLCBtYXgpID0+IHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59O1xuZXhwb3J0IGNvbnN0IFVOREVURVJNSU5FRF9MQU5HVUFHRSA9ICd1bmQnO1xuZXhwb3J0IGNvbnN0IHJvdW5kVG9QcmVjaXNpb24gPSAodmFsdWUsIGRpZ2l0cykgPT4ge1xuICAgIGNvbnN0IGZhY3RvciA9IDEwICoqIGRpZ2l0cztcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIGZhY3RvcikgLyBmYWN0b3I7XG59O1xuZXhwb3J0IGNvbnN0IHJvdW5kVG9NdWx0aXBsZSA9ICh2YWx1ZSwgbXVsdGlwbGUpID0+IHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAvIG11bHRpcGxlKSAqIG11bHRpcGxlO1xufTtcbmV4cG9ydCBjb25zdCBpbG9nID0gKHgpID0+IHtcbiAgICBsZXQgcmV0ID0gMDtcbiAgICB3aGlsZSAoeCkge1xuICAgICAgICByZXQrKztcbiAgICAgICAgeCA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5jb25zdCBJU09fNjM5XzJfUkVHRVggPSAvXlthLXpdezN9JC87XG5leHBvcnQgY29uc3QgaXNJc282MzlEYXNoMkxhbmd1YWdlQ29kZSA9ICh4KSA9PiB7XG4gICAgcmV0dXJuIElTT182MzlfMl9SRUdFWC50ZXN0KHgpO1xufTtcbi8vIFNpbmNlIHRoZSByZXN1bHQgd2lsbCBiZSB0cnVuY2F0ZWQsIGFkZCBhIGJpdCBvZiBlcHMgdG8gY29tcGVuc2F0ZSBmb3IgZmxvYXRpbmcgcG9pbnQgZXJyb3JzXG5leHBvcnQgY29uc3QgU0VDT05EX1RPX01JQ1JPU0VDT05EX0ZBQ1RPUiA9IDFlNiAqICgxICsgTnVtYmVyLkVQU0lMT04pO1xuZXhwb3J0IGNvbnN0IG1lcmdlT2JqZWN0c0RlZXBseSA9IChhLCBiKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0geyAuLi5hIH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYikge1xuICAgICAgICBpZiAodHlwZW9mIGFba2V5XSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICYmIGFba2V5XSAhPT0gbnVsbFxuICAgICAgICAgICAgJiYgdHlwZW9mIGJba2V5XSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICYmIGJba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZU9iamVjdHNEZWVwbHkoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBiW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnQgY29uc3QgcmV0cmllZEZldGNoID0gYXN5bmMgKHVybCwgcmVxdWVzdEluaXQsIGdldFJldHJ5RGVsYXkpID0+IHtcbiAgICBsZXQgYXR0ZW1wdHMgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZmV0Y2godXJsLCByZXF1ZXN0SW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhdHRlbXB0cysrO1xuICAgICAgICAgICAgY29uc3QgcmV0cnlEZWxheUluU2Vjb25kcyA9IGdldFJldHJ5RGVsYXkoYXR0ZW1wdHMpO1xuICAgICAgICAgICAgaWYgKHJldHJ5RGVsYXlJblNlY29uZHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1JldHJ5aW5nIGZhaWxlZCBmZXRjaC4gRXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocmV0cnlEZWxheUluU2Vjb25kcykgfHwgcmV0cnlEZWxheUluU2Vjb25kcyA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZXRyeSBkZWxheSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGZpbml0ZSBudW1iZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV0cnlEZWxheUluU2Vjb25kcyA+IDApIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCAqIHJldHJ5RGVsYXlJblNlY29uZHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgY29tcHV0ZVJhdGlvbmFsQXBwcm94aW1hdGlvbiA9ICh4LCBtYXhEZW5vbWluYXRvcikgPT4ge1xuICAgIC8vIEhhbmRsZSBuZWdhdGl2ZSBudW1iZXJzXG4gICAgY29uc3Qgc2lnbiA9IHggPCAwID8gLTEgOiAxO1xuICAgIHggPSBNYXRoLmFicyh4KTtcbiAgICBsZXQgcHJldk51bWVyYXRvciA9IDAsIHByZXZEZW5vbWluYXRvciA9IDE7XG4gICAgbGV0IGN1cnJOdW1lcmF0b3IgPSAxLCBjdXJyRGVub21pbmF0b3IgPSAwO1xuICAgIC8vIENvbnRpbnVlZCBmcmFjdGlvbiBhbGdvcml0aG1cbiAgICBsZXQgcmVtYWluZGVyID0geDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBpbnRlZ2VyID0gTWF0aC5mbG9vcihyZW1haW5kZXIpO1xuICAgICAgICAvLyBDYWxjdWxhdGUgbmV4dCBjb252ZXJnZW50XG4gICAgICAgIGNvbnN0IG5leHROdW1lcmF0b3IgPSBpbnRlZ2VyICogY3Vyck51bWVyYXRvciArIHByZXZOdW1lcmF0b3I7XG4gICAgICAgIGNvbnN0IG5leHREZW5vbWluYXRvciA9IGludGVnZXIgKiBjdXJyRGVub21pbmF0b3IgKyBwcmV2RGVub21pbmF0b3I7XG4gICAgICAgIGlmIChuZXh0RGVub21pbmF0b3IgPiBtYXhEZW5vbWluYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBudW1lcmF0b3I6IHNpZ24gKiBjdXJyTnVtZXJhdG9yLFxuICAgICAgICAgICAgICAgIGRlbm9taW5hdG9yOiBjdXJyRGVub21pbmF0b3IsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHByZXZOdW1lcmF0b3IgPSBjdXJyTnVtZXJhdG9yO1xuICAgICAgICBwcmV2RGVub21pbmF0b3IgPSBjdXJyRGVub21pbmF0b3I7XG4gICAgICAgIGN1cnJOdW1lcmF0b3IgPSBuZXh0TnVtZXJhdG9yO1xuICAgICAgICBjdXJyRGVub21pbmF0b3IgPSBuZXh0RGVub21pbmF0b3I7XG4gICAgICAgIHJlbWFpbmRlciA9IDEgLyAocmVtYWluZGVyIC0gaW50ZWdlcik7XG4gICAgICAgIC8vIEd1YXJkIGFnYWluc3QgcHJlY2lzaW9uIGlzc3Vlc1xuICAgICAgICBpZiAoIWlzRmluaXRlKHJlbWFpbmRlcikpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG51bWVyYXRvcjogc2lnbiAqIGN1cnJOdW1lcmF0b3IsXG4gICAgICAgIGRlbm9taW5hdG9yOiBjdXJyRGVub21pbmF0b3IsXG4gICAgfTtcbn07XG5leHBvcnQgY2xhc3MgQ2FsbFNlcmlhbGl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNhbGwoZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFByb21pc2UgPSB0aGlzLmN1cnJlbnRQcm9taXNlLnRoZW4oZm4pO1xuICAgIH1cbn1cbmxldCBpc1NhZmFyaUNhY2hlID0gbnVsbDtcbmV4cG9ydCBjb25zdCBpc1NhZmFyaSA9ICgpID0+IHtcbiAgICBpZiAoaXNTYWZhcmlDYWNoZSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaXNTYWZhcmlDYWNoZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gISEodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgJiYgbmF2aWdhdG9yLnZlbmRvcj8ubWF0Y2goL2FwcGxlL2kpXG4gICAgICAgICYmICFuYXZpZ2F0b3IudXNlckFnZW50Py5tYXRjaCgvY3Jpb3MvaSlcbiAgICAgICAgJiYgIW5hdmlnYXRvci51c2VyQWdlbnQ/Lm1hdGNoKC9meGlvcy9pKVxuICAgICAgICAmJiAhbmF2aWdhdG9yLnVzZXJBZ2VudD8ubWF0Y2goL09wZXJhfE9QVFxcLy8pKTtcbiAgICBpc1NhZmFyaUNhY2hlID0gcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqIEFjdHMgbGlrZSBgPz9gIGV4Y2VwdCB0aGUgY29uZGl0aW9uIGlzIC0xIGFuZCBub3QgbnVsbC91bmRlZmluZWQuICovXG5leHBvcnQgY29uc3QgY29hbGVzY2VJbmRleCA9IChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIGEgIT09IC0xID8gYSA6IGI7XG59O1xuZXhwb3J0IGNvbnN0IGNsb3NlZEludGVydmFsc092ZXJsYXAgPSAoc3RhcnRBLCBlbmRBLCBzdGFydEIsIGVuZEIpID0+IHtcbiAgICByZXR1cm4gc3RhcnRBIDw9IGVuZEIgJiYgc3RhcnRCIDw9IGVuZEE7XG59O1xuZXhwb3J0IGNvbnN0IGtleVZhbHVlSXRlcmF0b3IgPSBmdW5jdGlvbiogKG9iamVjdCkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgeyBrZXksIHZhbHVlIH07XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBpbWFnZU1pbWVUeXBlVG9FeHRlbnNpb24gPSAobWltZVR5cGUpID0+IHtcbiAgICBzd2l0Y2ggKG1pbWVUeXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnaW1hZ2UvanBlZyc6XG4gICAgICAgIGNhc2UgJ2ltYWdlL2pwZyc6XG4gICAgICAgICAgICByZXR1cm4gJy5qcGcnO1xuICAgICAgICBjYXNlICdpbWFnZS9wbmcnOlxuICAgICAgICAgICAgcmV0dXJuICcucG5nJztcbiAgICAgICAgY2FzZSAnaW1hZ2UvZ2lmJzpcbiAgICAgICAgICAgIHJldHVybiAnLmdpZic7XG4gICAgICAgIGNhc2UgJ2ltYWdlL3dlYnAnOlxuICAgICAgICAgICAgcmV0dXJuICcud2VicCc7XG4gICAgICAgIGNhc2UgJ2ltYWdlL2JtcCc6XG4gICAgICAgICAgICByZXR1cm4gJy5ibXAnO1xuICAgICAgICBjYXNlICdpbWFnZS9zdmcreG1sJzpcbiAgICAgICAgICAgIHJldHVybiAnLnN2Zyc7XG4gICAgICAgIGNhc2UgJ2ltYWdlL3RpZmYnOlxuICAgICAgICAgICAgcmV0dXJuICcudGlmZic7XG4gICAgICAgIGNhc2UgJ2ltYWdlL2F2aWYnOlxuICAgICAgICAgICAgcmV0dXJuICcuYXZpZic7XG4gICAgICAgIGNhc2UgJ2ltYWdlL3gtaWNvbic6XG4gICAgICAgIGNhc2UgJ2ltYWdlL3ZuZC5taWNyb3NvZnQuaWNvbic6XG4gICAgICAgICAgICByZXR1cm4gJy5pY28nO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBiYXNlNjRUb0J5dGVzID0gKGJhc2U2NCkgPT4ge1xuICAgIGNvbnN0IGRlY29kZWQgPSBhdG9iKGJhc2U2NCk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShkZWNvZGVkLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ5dGVzW2ldID0gZGVjb2RlZC5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59O1xuZXhwb3J0IGNvbnN0IGJ5dGVzVG9CYXNlNjQgPSAoYnl0ZXMpID0+IHtcbiAgICBsZXQgc3RyaW5nID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBidG9hKHN0cmluZyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/mp3/mp3-muxer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/mp3/mp3-muxer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mp3Muxer: () => (/* binding */ Mp3Muxer)\n/* harmony export */ });\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/* harmony import */ var _tags_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tags.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/tags.js\");\n/* harmony import */ var _muxer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../muxer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/muxer.js\");\n/* harmony import */ var _shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/mp3-misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/shared/mp3-misc.js\");\n/* harmony import */ var _mp3_writer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mp3-writer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/mp3/mp3-writer.js\");\n/* harmony import */ var _mp3_reader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mp3-reader.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/mp3/mp3-reader.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n\nclass Mp3Muxer extends _muxer_js__WEBPACK_IMPORTED_MODULE_0__.Muxer {\n    constructor(output, format) {\n        super(output);\n        this.xingFrameData = null;\n        this.frameCount = 0;\n        this.framePositions = [];\n        this.xingFramePos = null;\n        this.format = format;\n        this.writer = output._writer;\n        this.mp3Writer = new _mp3_writer_js__WEBPACK_IMPORTED_MODULE_1__.Mp3Writer(output._writer);\n    }\n    async start() {\n        if (!(0,_tags_js__WEBPACK_IMPORTED_MODULE_2__.metadataTagsAreEmpty)(this.output._metadataTags)) {\n            this.writeId3v2Tag(this.output._metadataTags);\n        }\n    }\n    async getMimeType() {\n        return 'audio/mpeg';\n    }\n    async addEncodedVideoPacket() {\n        throw new Error('MP3 does not support video.');\n    }\n    async addEncodedAudioPacket(track, packet) {\n        const release = await this.mutex.acquire();\n        try {\n            const writeXingHeader = this.format._options.xingHeader !== false;\n            if (!this.xingFrameData && writeXingHeader) {\n                const view = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.toDataView)(packet.data);\n                if (view.byteLength < 4) {\n                    throw new Error('Invalid MP3 header in sample.');\n                }\n                const word = view.getUint32(0, false);\n                const header = (0,_shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_4__.readFrameHeader)(word, null).header;\n                if (!header) {\n                    throw new Error('Invalid MP3 header in sample.');\n                }\n                const xingOffset = (0,_shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_4__.getXingOffset)(header.mpegVersionId, header.channel);\n                if (view.byteLength >= xingOffset + 4) {\n                    const word = view.getUint32(xingOffset, false);\n                    const isXing = word === _shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_4__.XING || word === _shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_4__.INFO;\n                    if (isXing) {\n                        // This is not a data frame, so let's completely ignore this sample\n                        return;\n                    }\n                }\n                this.xingFrameData = {\n                    mpegVersionId: header.mpegVersionId,\n                    layer: header.layer,\n                    frequencyIndex: header.frequencyIndex,\n                    channel: header.channel,\n                    modeExtension: header.modeExtension,\n                    copyright: header.copyright,\n                    original: header.original,\n                    emphasis: header.emphasis,\n                    frameCount: null,\n                    fileSize: null,\n                    toc: null,\n                };\n                // Write a Xing frame because this muxer doesn't make any bitrate constraints, meaning we don't know if\n                // this will be a constant or variable bitrate file. Therefore, always write the Xing frame.\n                this.xingFramePos = this.writer.getPos();\n                this.mp3Writer.writeXingFrame(this.xingFrameData);\n                this.frameCount++;\n            }\n            this.validateAndNormalizeTimestamp(track, packet.timestamp, packet.type === 'key');\n            this.writer.write(packet.data);\n            this.frameCount++;\n            await this.writer.flush();\n            if (writeXingHeader) {\n                this.framePositions.push(this.writer.getPos());\n            }\n        }\n        finally {\n            release();\n        }\n    }\n    async addSubtitleCue() {\n        throw new Error('MP3 does not support subtitles.');\n    }\n    writeId3v2Tag(tags) {\n        this.mp3Writer.writeAscii('ID3');\n        this.mp3Writer.writeU8(0x04); // Version 2.4\n        this.mp3Writer.writeU8(0x00); // Revision 0\n        this.mp3Writer.writeU8(0x00); // Flags\n        this.mp3Writer.writeSynchsafeU32(0); // Size placeholder\n        const startPos = this.writer.getPos();\n        const writtenTags = new Set();\n        for (const { key, value } of (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.keyValueIterator)(tags)) {\n            switch (key) {\n                case 'title':\n                    {\n                        this.mp3Writer.writeId3V2TextFrame('TIT2', value);\n                        writtenTags.add('TIT2');\n                    }\n                    ;\n                    break;\n                case 'description':\n                    {\n                        this.mp3Writer.writeId3V2TextFrame('TIT3', value);\n                        writtenTags.add('TIT3');\n                    }\n                    ;\n                    break;\n                case 'artist':\n                    {\n                        this.mp3Writer.writeId3V2TextFrame('TPE1', value);\n                        writtenTags.add('TPE1');\n                    }\n                    ;\n                    break;\n                case 'album':\n                    {\n                        this.mp3Writer.writeId3V2TextFrame('TALB', value);\n                        writtenTags.add('TALB');\n                    }\n                    ;\n                    break;\n                case 'albumArtist':\n                    {\n                        this.mp3Writer.writeId3V2TextFrame('TPE2', value);\n                        writtenTags.add('TPE2');\n                    }\n                    ;\n                    break;\n                case 'trackNumber':\n                    {\n                        const string = tags.tracksTotal !== undefined\n                            ? `${value}/${tags.tracksTotal}`\n                            : value.toString();\n                        this.mp3Writer.writeId3V2TextFrame('TRCK', string);\n                        writtenTags.add('TRCK');\n                    }\n                    ;\n                    break;\n                case 'discNumber':\n                    {\n                        const string = tags.discsTotal !== undefined\n                            ? `${value}/${tags.discsTotal}`\n                            : value.toString();\n                        this.mp3Writer.writeId3V2TextFrame('TPOS', string);\n                        writtenTags.add('TPOS');\n                    }\n                    ;\n                    break;\n                case 'genre':\n                    {\n                        this.mp3Writer.writeId3V2TextFrame('TCON', value);\n                        writtenTags.add('TCON');\n                    }\n                    ;\n                    break;\n                case 'date':\n                    {\n                        this.mp3Writer.writeId3V2TextFrame('TDRC', value.toISOString().slice(0, 10));\n                        writtenTags.add('TDRC');\n                    }\n                    ;\n                    break;\n                case 'lyrics':\n                    {\n                        this.mp3Writer.writeId3V2LyricsFrame(value);\n                        writtenTags.add('USLT');\n                    }\n                    ;\n                    break;\n                case 'comment':\n                    {\n                        this.mp3Writer.writeId3V2CommentFrame(value);\n                        writtenTags.add('COMM');\n                    }\n                    ;\n                    break;\n                case 'images':\n                    {\n                        const pictureTypeMap = { coverFront: 0x03, coverBack: 0x04, unknown: 0x00 };\n                        for (const image of value) {\n                            const pictureType = pictureTypeMap[image.kind];\n                            const description = image.description ?? '';\n                            this.mp3Writer.writeId3V2ApicFrame(image.mimeType, pictureType, description, image.data);\n                        }\n                    }\n                    ;\n                    break;\n                case 'tracksTotal':\n                case 'discsTotal':\n                    {\n                        // Handled with trackNumber and discNumber respectively\n                    }\n                    ;\n                    break;\n                case 'raw':\n                    {\n                        // Handled later\n                    }\n                    ;\n                    break;\n                default: (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assertNever)(key);\n            }\n        }\n        if (tags.raw) {\n            for (const key in tags.raw) {\n                const value = tags.raw[key];\n                if (value == null || key.length !== 4 || writtenTags.has(key)) {\n                    continue;\n                }\n                let bytes;\n                if (typeof value === 'string') {\n                    const encoded = _misc_js__WEBPACK_IMPORTED_MODULE_3__.textEncoder.encode(value);\n                    bytes = new Uint8Array(encoded.byteLength + 2);\n                    bytes[0] = _mp3_reader_js__WEBPACK_IMPORTED_MODULE_5__.Id3V2TextEncoding.UTF_8;\n                    bytes.set(encoded, 1);\n                    // Last byte is the null terminator\n                }\n                else if (value instanceof Uint8Array) {\n                    bytes = value;\n                }\n                else {\n                    continue;\n                }\n                this.mp3Writer.writeAscii(key);\n                this.mp3Writer.writeSynchsafeU32(bytes.byteLength);\n                this.mp3Writer.writeU16(0x0000);\n                this.writer.write(bytes);\n            }\n        }\n        const endPos = this.writer.getPos();\n        const framesSize = endPos - startPos;\n        this.writer.seek(6);\n        this.mp3Writer.writeSynchsafeU32(framesSize);\n        this.writer.seek(endPos);\n    }\n    async finalize() {\n        if (!this.xingFrameData || this.xingFramePos === null) {\n            return;\n        }\n        const release = await this.mutex.acquire();\n        const endPos = this.writer.getPos();\n        this.writer.seek(this.xingFramePos);\n        const toc = new Uint8Array(100);\n        for (let i = 0; i < 100; i++) {\n            const index = Math.floor(this.framePositions.length * (i / 100));\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(index !== -1 && index < this.framePositions.length);\n            const byteOffset = this.framePositions[index];\n            toc[i] = 256 * (byteOffset / endPos);\n        }\n        this.xingFrameData.frameCount = this.frameCount;\n        this.xingFrameData.fileSize = endPos;\n        this.xingFrameData.toc = toc;\n        if (this.format._options.onXingFrame) {\n            this.writer.startTrackingWrites();\n        }\n        this.mp3Writer.writeXingFrame(this.xingFrameData);\n        if (this.format._options.onXingFrame) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onXingFrame(data, start);\n        }\n        this.writer.seek(endPos);\n        release();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL21wMy9tcDMtbXV4ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRGO0FBQzFDO0FBQ2Q7QUFDa0Q7QUFDMUM7QUFDUTtBQUM3Qyx1QkFBdUIsNENBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxREFBUztBQUN0QztBQUNBO0FBQ0EsYUFBYSw4REFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvREFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvRUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0VBQWE7QUFDaEQ7QUFDQTtBQUNBLDRDQUE0QyxxREFBSSxhQUFhLHFEQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0Qyw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLHFCQUFxQixhQUFhLEdBQUcsMERBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNLEdBQUcsaUJBQWlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNLEdBQUcsZ0JBQWdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscURBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaURBQVc7QUFDL0M7QUFDQSwrQkFBK0IsNkRBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBLFlBQVksZ0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGNoLWN1dC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL21wMy9tcDMtbXV4ZXIuanM/ZGJhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAyNS1wcmVzZW50LCBWYW5pbGFneSBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0TmV2ZXIsIGtleVZhbHVlSXRlcmF0b3IsIHRleHRFbmNvZGVyLCB0b0RhdGFWaWV3IH0gZnJvbSAnLi4vbWlzYy5qcyc7XG5pbXBvcnQgeyBtZXRhZGF0YVRhZ3NBcmVFbXB0eSB9IGZyb20gJy4uL3RhZ3MuanMnO1xuaW1wb3J0IHsgTXV4ZXIgfSBmcm9tICcuLi9tdXhlci5qcyc7XG5pbXBvcnQgeyBnZXRYaW5nT2Zmc2V0LCBJTkZPLCByZWFkRnJhbWVIZWFkZXIsIFhJTkcgfSBmcm9tICcuLi8uLi9zaGFyZWQvbXAzLW1pc2MuanMnO1xuaW1wb3J0IHsgTXAzV3JpdGVyIH0gZnJvbSAnLi9tcDMtd3JpdGVyLmpzJztcbmltcG9ydCB7IElkM1YyVGV4dEVuY29kaW5nIH0gZnJvbSAnLi9tcDMtcmVhZGVyLmpzJztcbmV4cG9ydCBjbGFzcyBNcDNNdXhlciBleHRlbmRzIE11eGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvdXRwdXQsIGZvcm1hdCkge1xuICAgICAgICBzdXBlcihvdXRwdXQpO1xuICAgICAgICB0aGlzLnhpbmdGcmFtZURhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLmZyYW1lQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmZyYW1lUG9zaXRpb25zID0gW107XG4gICAgICAgIHRoaXMueGluZ0ZyYW1lUG9zID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHRoaXMud3JpdGVyID0gb3V0cHV0Ll93cml0ZXI7XG4gICAgICAgIHRoaXMubXAzV3JpdGVyID0gbmV3IE1wM1dyaXRlcihvdXRwdXQuX3dyaXRlcik7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIW1ldGFkYXRhVGFnc0FyZUVtcHR5KHRoaXMub3V0cHV0Ll9tZXRhZGF0YVRhZ3MpKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlSWQzdjJUYWcodGhpcy5vdXRwdXQuX21ldGFkYXRhVGFncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TWltZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnYXVkaW8vbXBlZyc7XG4gICAgfVxuICAgIGFzeW5jIGFkZEVuY29kZWRWaWRlb1BhY2tldCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNUDMgZG9lcyBub3Qgc3VwcG9ydCB2aWRlby4nKTtcbiAgICB9XG4gICAgYXN5bmMgYWRkRW5jb2RlZEF1ZGlvUGFja2V0KHRyYWNrLCBwYWNrZXQpIHtcbiAgICAgICAgY29uc3QgcmVsZWFzZSA9IGF3YWl0IHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgd3JpdGVYaW5nSGVhZGVyID0gdGhpcy5mb3JtYXQuX29wdGlvbnMueGluZ0hlYWRlciAhPT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXRoaXMueGluZ0ZyYW1lRGF0YSAmJiB3cml0ZVhpbmdIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gdG9EYXRhVmlldyhwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIE1QMyBoZWFkZXIgaW4gc2FtcGxlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB3b3JkID0gdmlldy5nZXRVaW50MzIoMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IHJlYWRGcmFtZUhlYWRlcih3b3JkLCBudWxsKS5oZWFkZXI7XG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIE1QMyBoZWFkZXIgaW4gc2FtcGxlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB4aW5nT2Zmc2V0ID0gZ2V0WGluZ09mZnNldChoZWFkZXIubXBlZ1ZlcnNpb25JZCwgaGVhZGVyLmNoYW5uZWwpO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggPj0geGluZ09mZnNldCArIDQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd29yZCA9IHZpZXcuZ2V0VWludDMyKHhpbmdPZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNYaW5nID0gd29yZCA9PT0gWElORyB8fCB3b3JkID09PSBJTkZPO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNYaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIG5vdCBhIGRhdGEgZnJhbWUsIHNvIGxldCdzIGNvbXBsZXRlbHkgaWdub3JlIHRoaXMgc2FtcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy54aW5nRnJhbWVEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBtcGVnVmVyc2lvbklkOiBoZWFkZXIubXBlZ1ZlcnNpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IGhlYWRlci5sYXllcixcbiAgICAgICAgICAgICAgICAgICAgZnJlcXVlbmN5SW5kZXg6IGhlYWRlci5mcmVxdWVuY3lJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogaGVhZGVyLmNoYW5uZWwsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVFeHRlbnNpb246IGhlYWRlci5tb2RlRXh0ZW5zaW9uLFxuICAgICAgICAgICAgICAgICAgICBjb3B5cmlnaHQ6IGhlYWRlci5jb3B5cmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsOiBoZWFkZXIub3JpZ2luYWwsXG4gICAgICAgICAgICAgICAgICAgIGVtcGhhc2lzOiBoZWFkZXIuZW1waGFzaXMsXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ291bnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVTaXplOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0b2M6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBXcml0ZSBhIFhpbmcgZnJhbWUgYmVjYXVzZSB0aGlzIG11eGVyIGRvZXNuJ3QgbWFrZSBhbnkgYml0cmF0ZSBjb25zdHJhaW50cywgbWVhbmluZyB3ZSBkb24ndCBrbm93IGlmXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGJlIGEgY29uc3RhbnQgb3IgdmFyaWFibGUgYml0cmF0ZSBmaWxlLiBUaGVyZWZvcmUsIGFsd2F5cyB3cml0ZSB0aGUgWGluZyBmcmFtZS5cbiAgICAgICAgICAgICAgICB0aGlzLnhpbmdGcmFtZVBvcyA9IHRoaXMud3JpdGVyLmdldFBvcygpO1xuICAgICAgICAgICAgICAgIHRoaXMubXAzV3JpdGVyLndyaXRlWGluZ0ZyYW1lKHRoaXMueGluZ0ZyYW1lRGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZUNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQW5kTm9ybWFsaXplVGltZXN0YW1wKHRyYWNrLCBwYWNrZXQudGltZXN0YW1wLCBwYWNrZXQudHlwZSA9PT0gJ2tleScpO1xuICAgICAgICAgICAgdGhpcy53cml0ZXIud3JpdGUocGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5mcmFtZUNvdW50Kys7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci5mbHVzaCgpO1xuICAgICAgICAgICAgaWYgKHdyaXRlWGluZ0hlYWRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVQb3NpdGlvbnMucHVzaCh0aGlzLndyaXRlci5nZXRQb3MoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgYWRkU3VidGl0bGVDdWUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTVAzIGRvZXMgbm90IHN1cHBvcnQgc3VidGl0bGVzLicpO1xuICAgIH1cbiAgICB3cml0ZUlkM3YyVGFnKHRhZ3MpIHtcbiAgICAgICAgdGhpcy5tcDNXcml0ZXIud3JpdGVBc2NpaSgnSUQzJyk7XG4gICAgICAgIHRoaXMubXAzV3JpdGVyLndyaXRlVTgoMHgwNCk7IC8vIFZlcnNpb24gMi40XG4gICAgICAgIHRoaXMubXAzV3JpdGVyLndyaXRlVTgoMHgwMCk7IC8vIFJldmlzaW9uIDBcbiAgICAgICAgdGhpcy5tcDNXcml0ZXIud3JpdGVVOCgweDAwKTsgLy8gRmxhZ3NcbiAgICAgICAgdGhpcy5tcDNXcml0ZXIud3JpdGVTeW5jaHNhZmVVMzIoMCk7IC8vIFNpemUgcGxhY2Vob2xkZXJcbiAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSB0aGlzLndyaXRlci5nZXRQb3MoKTtcbiAgICAgICAgY29uc3Qgd3JpdHRlblRhZ3MgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgeyBrZXksIHZhbHVlIH0gb2Yga2V5VmFsdWVJdGVyYXRvcih0YWdzKSkge1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0aXRsZSc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXAzV3JpdGVyLndyaXRlSWQzVjJUZXh0RnJhbWUoJ1RJVDInLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0dGVuVGFncy5hZGQoJ1RJVDInKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tcDNXcml0ZXIud3JpdGVJZDNWMlRleHRGcmFtZSgnVElUMycsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXR0ZW5UYWdzLmFkZCgnVElUMycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYXJ0aXN0JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tcDNXcml0ZXIud3JpdGVJZDNWMlRleHRGcmFtZSgnVFBFMScsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXR0ZW5UYWdzLmFkZCgnVFBFMScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYWxidW0nOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1wM1dyaXRlci53cml0ZUlkM1YyVGV4dEZyYW1lKCdUQUxCJywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlblRhZ3MuYWRkKCdUQUxCJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdhbGJ1bUFydGlzdCc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXAzV3JpdGVyLndyaXRlSWQzVjJUZXh0RnJhbWUoJ1RQRTInLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0dGVuVGFncy5hZGQoJ1RQRTInKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYWNrTnVtYmVyJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nID0gdGFncy50cmFja3NUb3RhbCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHt2YWx1ZX0vJHt0YWdzLnRyYWNrc1RvdGFsfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1wM1dyaXRlci53cml0ZUlkM1YyVGV4dEZyYW1lKCdUUkNLJywgc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXR0ZW5UYWdzLmFkZCgnVFJDSycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY051bWJlcic6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZyA9IHRhZ3MuZGlzY3NUb3RhbCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHt2YWx1ZX0vJHt0YWdzLmRpc2NzVG90YWx9YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXAzV3JpdGVyLndyaXRlSWQzVjJUZXh0RnJhbWUoJ1RQT1MnLCBzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlblRhZ3MuYWRkKCdUUE9TJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnZW5yZSc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXAzV3JpdGVyLndyaXRlSWQzVjJUZXh0RnJhbWUoJ1RDT04nLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0dGVuVGFncy5hZGQoJ1RDT04nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1wM1dyaXRlci53cml0ZUlkM1YyVGV4dEZyYW1lKCdURFJDJywgdmFsdWUudG9JU09TdHJpbmcoKS5zbGljZSgwLCAxMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlblRhZ3MuYWRkKCdURFJDJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdseXJpY3MnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1wM1dyaXRlci53cml0ZUlkM1YyTHlyaWNzRnJhbWUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlblRhZ3MuYWRkKCdVU0xUJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tcDNXcml0ZXIud3JpdGVJZDNWMkNvbW1lbnRGcmFtZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0dGVuVGFncy5hZGQoJ0NPTU0nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ltYWdlcyc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpY3R1cmVUeXBlTWFwID0geyBjb3ZlckZyb250OiAweDAzLCBjb3ZlckJhY2s6IDB4MDQsIHVua25vd246IDB4MDAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW1hZ2Ugb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwaWN0dXJlVHlwZSA9IHBpY3R1cmVUeXBlTWFwW2ltYWdlLmtpbmRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gaW1hZ2UuZGVzY3JpcHRpb24gPz8gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tcDNXcml0ZXIud3JpdGVJZDNWMkFwaWNGcmFtZShpbWFnZS5taW1lVHlwZSwgcGljdHVyZVR5cGUsIGRlc2NyaXB0aW9uLCBpbWFnZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYWNrc1RvdGFsJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkaXNjc1RvdGFsJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlZCB3aXRoIHRyYWNrTnVtYmVyIGFuZCBkaXNjTnVtYmVyIHJlc3BlY3RpdmVseVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmF3JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlZCBsYXRlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogYXNzZXJ0TmV2ZXIoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGFncy5yYXcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRhZ3MucmF3KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0YWdzLnJhd1trZXldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IGtleS5sZW5ndGggIT09IDQgfHwgd3JpdHRlblRhZ3MuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBieXRlcztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVkID0gdGV4dEVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmJ5dGVMZW5ndGggKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNbMF0gPSBJZDNWMlRleHRFbmNvZGluZy5VVEZfODtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMuc2V0KGVuY29kZWQsIDEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBMYXN0IGJ5dGUgaXMgdGhlIG51bGwgdGVybWluYXRvclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1wM1dyaXRlci53cml0ZUFzY2lpKGtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tcDNXcml0ZXIud3JpdGVTeW5jaHNhZmVVMzIoYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tcDNXcml0ZXIud3JpdGVVMTYoMHgwMDAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlci53cml0ZShieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5kUG9zID0gdGhpcy53cml0ZXIuZ2V0UG9zKCk7XG4gICAgICAgIGNvbnN0IGZyYW1lc1NpemUgPSBlbmRQb3MgLSBzdGFydFBvcztcbiAgICAgICAgdGhpcy53cml0ZXIuc2Vlayg2KTtcbiAgICAgICAgdGhpcy5tcDNXcml0ZXIud3JpdGVTeW5jaHNhZmVVMzIoZnJhbWVzU2l6ZSk7XG4gICAgICAgIHRoaXMud3JpdGVyLnNlZWsoZW5kUG9zKTtcbiAgICB9XG4gICAgYXN5bmMgZmluYWxpemUoKSB7XG4gICAgICAgIGlmICghdGhpcy54aW5nRnJhbWVEYXRhIHx8IHRoaXMueGluZ0ZyYW1lUG9zID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVsZWFzZSA9IGF3YWl0IHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICBjb25zdCBlbmRQb3MgPSB0aGlzLndyaXRlci5nZXRQb3MoKTtcbiAgICAgICAgdGhpcy53cml0ZXIuc2Vlayh0aGlzLnhpbmdGcmFtZVBvcyk7XG4gICAgICAgIGNvbnN0IHRvYyA9IG5ldyBVaW50OEFycmF5KDEwMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gTWF0aC5mbG9vcih0aGlzLmZyYW1lUG9zaXRpb25zLmxlbmd0aCAqIChpIC8gMTAwKSk7XG4gICAgICAgICAgICBhc3NlcnQoaW5kZXggIT09IC0xICYmIGluZGV4IDwgdGhpcy5mcmFtZVBvc2l0aW9ucy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IHRoaXMuZnJhbWVQb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgdG9jW2ldID0gMjU2ICogKGJ5dGVPZmZzZXQgLyBlbmRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueGluZ0ZyYW1lRGF0YS5mcmFtZUNvdW50ID0gdGhpcy5mcmFtZUNvdW50O1xuICAgICAgICB0aGlzLnhpbmdGcmFtZURhdGEuZmlsZVNpemUgPSBlbmRQb3M7XG4gICAgICAgIHRoaXMueGluZ0ZyYW1lRGF0YS50b2MgPSB0b2M7XG4gICAgICAgIGlmICh0aGlzLmZvcm1hdC5fb3B0aW9ucy5vblhpbmdGcmFtZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZXIuc3RhcnRUcmFja2luZ1dyaXRlcygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXAzV3JpdGVyLndyaXRlWGluZ0ZyYW1lKHRoaXMueGluZ0ZyYW1lRGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmZvcm1hdC5fb3B0aW9ucy5vblhpbmdGcmFtZSkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBzdGFydCB9ID0gdGhpcy53cml0ZXIuc3RvcFRyYWNraW5nV3JpdGVzKCk7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdC5fb3B0aW9ucy5vblhpbmdGcmFtZShkYXRhLCBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZXIuc2VlayhlbmRQb3MpO1xuICAgICAgICByZWxlYXNlKCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/mp3/mp3-muxer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/mp3/mp3-reader.js":
/*!********************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/mp3/mp3-reader.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ID3_V1_GENRES: () => (/* binding */ ID3_V1_GENRES),\n/* harmony export */   ID3_V1_TAG_SIZE: () => (/* binding */ ID3_V1_TAG_SIZE),\n/* harmony export */   ID3_V2_HEADER_SIZE: () => (/* binding */ ID3_V2_HEADER_SIZE),\n/* harmony export */   Id3V2HeaderFlags: () => (/* binding */ Id3V2HeaderFlags),\n/* harmony export */   Id3V2Reader: () => (/* binding */ Id3V2Reader),\n/* harmony export */   Id3V2TextEncoding: () => (/* binding */ Id3V2TextEncoding),\n/* harmony export */   parseId3V1Tag: () => (/* binding */ parseId3V1Tag),\n/* harmony export */   parseId3V2Tag: () => (/* binding */ parseId3V2Tag),\n/* harmony export */   readId3V1String: () => (/* binding */ readId3V1String),\n/* harmony export */   readId3V2Header: () => (/* binding */ readId3V2Header),\n/* harmony export */   readNextFrameHeader: () => (/* binding */ readNextFrameHeader)\n/* harmony export */ });\n/* harmony import */ var _shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/mp3-misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/shared/mp3-misc.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/* harmony import */ var _reader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../reader.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/reader.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\nvar Id3V2HeaderFlags;\n(function (Id3V2HeaderFlags) {\n    Id3V2HeaderFlags[Id3V2HeaderFlags[\"Unsynchronisation\"] = 128] = \"Unsynchronisation\";\n    Id3V2HeaderFlags[Id3V2HeaderFlags[\"ExtendedHeader\"] = 64] = \"ExtendedHeader\";\n    Id3V2HeaderFlags[Id3V2HeaderFlags[\"ExperimentalIndicator\"] = 32] = \"ExperimentalIndicator\";\n    Id3V2HeaderFlags[Id3V2HeaderFlags[\"Footer\"] = 16] = \"Footer\";\n})(Id3V2HeaderFlags || (Id3V2HeaderFlags = {}));\nvar Id3V2TextEncoding;\n(function (Id3V2TextEncoding) {\n    Id3V2TextEncoding[Id3V2TextEncoding[\"ISO_8859_1\"] = 0] = \"ISO_8859_1\";\n    Id3V2TextEncoding[Id3V2TextEncoding[\"UTF_16_WITH_BOM\"] = 1] = \"UTF_16_WITH_BOM\";\n    Id3V2TextEncoding[Id3V2TextEncoding[\"UTF_16_BE_NO_BOM\"] = 2] = \"UTF_16_BE_NO_BOM\";\n    Id3V2TextEncoding[Id3V2TextEncoding[\"UTF_8\"] = 3] = \"UTF_8\";\n})(Id3V2TextEncoding || (Id3V2TextEncoding = {}));\nconst ID3_V1_TAG_SIZE = 128;\nconst ID3_V2_HEADER_SIZE = 10;\nconst ID3_V1_GENRES = [\n    'Blues', 'Classic rock', 'Country', 'Dance', 'Disco', 'Funk', 'Grunge', 'Hip-hop', 'Jazz',\n    'Metal', 'New age', 'Oldies', 'Other', 'Pop', 'Rhythm and blues', 'Rap', 'Reggae', 'Rock',\n    'Techno', 'Industrial', 'Alternative', 'Ska', 'Death metal', 'Pranks', 'Soundtrack',\n    'Euro-techno', 'Ambient', 'Trip-hop', 'Vocal', 'Jazz & funk', 'Fusion', 'Trance', 'Classical',\n    'Instrumental', 'Acid', 'House', 'Game', 'Sound clip', 'Gospel', 'Noise', 'Alternative rock',\n    'Bass', 'Soul', 'Punk', 'Space', 'Meditative', 'Instrumental pop', 'Instrumental rock',\n    'Ethnic', 'Gothic', 'Darkwave', 'Techno-industrial', 'Electronic', 'Pop-folk', 'Eurodance',\n    'Dream', 'Southern rock', 'Comedy', 'Cult', 'Gangsta', 'Top 40', 'Christian rap', 'Pop/funk',\n    'Jungle music', 'Native US', 'Cabaret', 'New wave', 'Psychedelic', 'Rave', 'Showtunes',\n    'Trailer', 'Lo-fi', 'Tribal', 'Acid punk', 'Acid jazz', 'Polka', 'Retro', 'Musical',\n    'Rock \\'n\\' roll', 'Hard rock', 'Folk', 'Folk rock', 'National folk', 'Swing', 'Fast fusion',\n    'Bebop', 'Latin', 'Revival', 'Celtic', 'Bluegrass', 'Avantgarde', 'Gothic rock',\n    'Progressive rock', 'Psychedelic rock', 'Symphonic rock', 'Slow rock', 'Big band', 'Chorus',\n    'Easy listening', 'Acoustic', 'Humour', 'Speech', 'Chanson', 'Opera', 'Chamber music',\n    'Sonata', 'Symphony', 'Booty bass', 'Primus', 'Porn groove', 'Satire', 'Slow jam', 'Club',\n    'Tango', 'Samba', 'Folklore', 'Ballad', 'Power ballad', 'Rhythmic Soul', 'Freestyle', 'Duet',\n    'Punk rock', 'Drum solo', 'A cappella', 'Euro-house', 'Dance hall', 'Goa music', 'Drum & bass',\n    'Club-house', 'Hardcore techno', 'Terror', 'Indie', 'Britpop', 'Negerpunk', 'Polsk punk',\n    'Beat', 'Christian gangsta rap', 'Heavy metal', 'Black metal', 'Crossover',\n    'Contemporary Christian', 'Christian rock', 'Merengue', 'Salsa', 'Thrash metal', 'Anime',\n    'Jpop', 'Synthpop', 'Christmas', 'Art rock', 'Baroque', 'Bhangra', 'Big beat', 'Breakbeat',\n    'Chillout', 'Downtempo', 'Dub', 'EBM', 'Eclectic', 'Electro', 'Electroclash', 'Emo',\n    'Experimental', 'Garage', 'Global', 'IDM', 'Illbient', 'Industro-Goth', 'Jam Band',\n    'Krautrock', 'Leftfield', 'Lounge', 'Math rock', 'New romantic', 'Nu-breakz', 'Post-punk',\n    'Post-rock', 'Psytrance', 'Shoegaze', 'Space rock', 'Trop rock', 'World music', 'Neoclassical',\n    'Audiobook', 'Audio theatre', 'Neue Deutsche Welle', 'Podcast', 'Indie rock', 'G-Funk',\n    'Dubstep', 'Garage rock', 'Psybient',\n];\nconst readNextFrameHeader = async (reader, startPos, until) => {\n    let currentPos = startPos;\n    while (until === null || currentPos < until) {\n        let slice = reader.requestSlice(currentPos, _shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_0__.FRAME_HEADER_SIZE);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            break;\n        const word = (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readU32Be)(slice);\n        const result = (0,_shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_0__.readFrameHeader)(word, reader.fileSize !== null ? reader.fileSize - currentPos : null);\n        if (result.header) {\n            return { header: result.header, startPos: currentPos };\n        }\n        currentPos += result.bytesAdvanced;\n    }\n    return null;\n};\nconst parseId3V1Tag = (slice, tags) => {\n    const startPos = slice.filePos;\n    tags.raw ??= {};\n    tags.raw['TAG'] ??= (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readBytes)(slice, ID3_V1_TAG_SIZE - 3); // Dump the whole tag into the raw metadata\n    slice.filePos = startPos;\n    const title = readId3V1String(slice, 30);\n    if (title)\n        tags.title ??= title;\n    const artist = readId3V1String(slice, 30);\n    if (artist)\n        tags.artist ??= artist;\n    const album = readId3V1String(slice, 30);\n    if (album)\n        tags.album ??= album;\n    const yearText = readId3V1String(slice, 4);\n    const year = Number.parseInt(yearText, 10);\n    if (Number.isInteger(year) && year > 0) {\n        tags.date ??= new Date(year, 0, 1);\n    }\n    const commentBytes = (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readBytes)(slice, 30);\n    let comment;\n    // Check for the ID3v1.1 track number format:\n    // The 29th byte (index 28) is a null terminator, and the 30th byte is the track number.\n    if (commentBytes[28] === 0 && commentBytes[29] !== 0) {\n        const trackNum = commentBytes[29];\n        if (trackNum > 0) {\n            tags.trackNumber ??= trackNum;\n        }\n        slice.skip(-30);\n        comment = readId3V1String(slice, 28);\n        slice.skip(2);\n    }\n    else {\n        slice.skip(-30);\n        comment = readId3V1String(slice, 30);\n    }\n    if (comment)\n        tags.comment ??= comment;\n    const genreIndex = (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readU8)(slice);\n    if (genreIndex < ID3_V1_GENRES.length) {\n        tags.genre ??= ID3_V1_GENRES[genreIndex];\n    }\n};\nconst readId3V1String = (slice, length) => {\n    const bytes = (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readBytes)(slice, length);\n    const endIndex = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.coalesceIndex)(bytes.indexOf(0), bytes.length);\n    const relevantBytes = bytes.subarray(0, endIndex);\n    // Decode as ISO-8859-1\n    let str = '';\n    for (let i = 0; i < relevantBytes.length; i++) {\n        str += String.fromCharCode(relevantBytes[i]);\n    }\n    return str.trimEnd(); // String also may be padded with spaces\n};\nconst readId3V2Header = (slice) => {\n    const startPos = slice.filePos;\n    const tag = (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readAscii)(slice, 3);\n    const majorVersion = (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readU8)(slice);\n    const revision = (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readU8)(slice);\n    const flags = (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readU8)(slice);\n    const sizeRaw = (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readU32Be)(slice);\n    if (tag !== 'ID3' || majorVersion === 0xff || revision === 0xff || (sizeRaw & 0x80808080) !== 0) {\n        slice.filePos = startPos;\n        return null;\n    }\n    const size = (0,_shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_0__.decodeSynchsafe)(sizeRaw);\n    return { majorVersion, revision, flags, size };\n};\nconst parseId3V2Tag = (slice, header, tags) => {\n    // https://id3.org/id3v2.3.0\n    if (![2, 3, 4].includes(header.majorVersion)) {\n        console.warn(`Unsupported ID3v2 major version: ${header.majorVersion}`);\n        return;\n    }\n    const bytes = (0,_reader_js__WEBPACK_IMPORTED_MODULE_1__.readBytes)(slice, header.size);\n    const reader = new Id3V2Reader(header, bytes);\n    if (header.flags & Id3V2HeaderFlags.Footer) {\n        reader.removeFooter();\n    }\n    if ((header.flags & Id3V2HeaderFlags.Unsynchronisation) && header.majorVersion === 3) {\n        reader.ununsynchronizeAll();\n    }\n    if (header.flags & Id3V2HeaderFlags.ExtendedHeader) {\n        const extendedHeaderSize = reader.readU32();\n        if (header.majorVersion === 3) {\n            reader.pos += extendedHeaderSize; // The extended header size excludes itself\n        }\n        else {\n            reader.pos += extendedHeaderSize - 4; // The extended header size includes itself\n        }\n    }\n    while (reader.pos <= reader.bytes.length - reader.frameHeaderSize()) {\n        const frame = reader.readId3V2Frame();\n        if (!frame) {\n            break;\n        }\n        const frameStartPos = reader.pos;\n        const frameEndPos = reader.pos + frame.size;\n        let frameEncrypted = false;\n        let frameCompressed = false;\n        let frameUnsynchronized = false;\n        if (header.majorVersion === 3) {\n            frameEncrypted = !!(frame.flags & (1 << 6));\n            frameCompressed = !!(frame.flags & (1 << 7));\n        }\n        else if (header.majorVersion === 4) {\n            frameEncrypted = !!(frame.flags & (1 << 2));\n            frameCompressed = !!(frame.flags & (1 << 3));\n            frameUnsynchronized = !!(frame.flags & (1 << 1))\n                || !!(header.flags & Id3V2HeaderFlags.Unsynchronisation);\n        }\n        if (frameEncrypted) {\n            console.warn(`Skipping encrypted ID3v2 frame ${frame.id}`);\n            reader.pos = frameEndPos;\n            continue;\n        }\n        if (frameCompressed) {\n            console.warn(`Skipping compressed ID3v2 frame ${frame.id}`); // Maybe someday? Idk\n            reader.pos = frameEndPos;\n            continue;\n        }\n        if (frameUnsynchronized) {\n            reader.ununsynchronizeRegion(reader.pos, frameEndPos);\n        }\n        tags.raw ??= {};\n        if (frame.id[0] === 'T') {\n            // It's a text frame, let's decode as text\n            tags.raw[frame.id] ??= reader.readId3V2EncodingAndText(frameEndPos);\n        }\n        else {\n            // For the others, let's just get the bytes\n            tags.raw[frame.id] ??= reader.readBytes(frame.size);\n        }\n        reader.pos = frameStartPos;\n        switch (frame.id) {\n            case 'TIT2':\n            case 'TT2':\n                {\n                    tags.title ??= reader.readId3V2EncodingAndText(frameEndPos);\n                }\n                ;\n                break;\n            case 'TIT3':\n            case 'TT3':\n                {\n                    tags.description ??= reader.readId3V2EncodingAndText(frameEndPos);\n                }\n                ;\n                break;\n            case 'TPE1':\n            case 'TP1':\n                {\n                    tags.artist ??= reader.readId3V2EncodingAndText(frameEndPos);\n                }\n                ;\n                break;\n            case 'TALB':\n            case 'TAL':\n                {\n                    tags.album ??= reader.readId3V2EncodingAndText(frameEndPos);\n                }\n                ;\n                break;\n            case 'TPE2':\n            case 'TP2':\n                {\n                    tags.albumArtist ??= reader.readId3V2EncodingAndText(frameEndPos);\n                }\n                ;\n                break;\n            case 'TRCK':\n            case 'TRK':\n                {\n                    const trackText = reader.readId3V2EncodingAndText(frameEndPos);\n                    const parts = trackText.split('/');\n                    const trackNum = Number.parseInt(parts[0], 10);\n                    const tracksTotal = parts[1] && Number.parseInt(parts[1], 10);\n                    if (Number.isInteger(trackNum) && trackNum > 0) {\n                        tags.trackNumber ??= trackNum;\n                    }\n                    if (tracksTotal && Number.isInteger(tracksTotal) && tracksTotal > 0) {\n                        tags.tracksTotal ??= tracksTotal;\n                    }\n                }\n                ;\n                break;\n            case 'TPOS':\n            case 'TPA':\n                {\n                    const discText = reader.readId3V2EncodingAndText(frameEndPos);\n                    const parts = discText.split('/');\n                    const discNum = Number.parseInt(parts[0], 10);\n                    const discsTotal = parts[1] && Number.parseInt(parts[1], 10);\n                    if (Number.isInteger(discNum) && discNum > 0) {\n                        tags.discNumber ??= discNum;\n                    }\n                    if (discsTotal && Number.isInteger(discsTotal) && discsTotal > 0) {\n                        tags.discsTotal ??= discsTotal;\n                    }\n                }\n                ;\n                break;\n            case 'TCON':\n            case 'TCO':\n                {\n                    const genreText = reader.readId3V2EncodingAndText(frameEndPos);\n                    let match = /^\\((\\d+)\\)/.exec(genreText);\n                    if (match) {\n                        const genreNumber = Number.parseInt(match[1]);\n                        if (ID3_V1_GENRES[genreNumber] !== undefined) {\n                            tags.genre ??= ID3_V1_GENRES[genreNumber];\n                            break;\n                        }\n                    }\n                    match = /^\\d+$/.exec(genreText);\n                    if (match) {\n                        const genreNumber = Number.parseInt(match[0]);\n                        if (ID3_V1_GENRES[genreNumber] !== undefined) {\n                            tags.genre ??= ID3_V1_GENRES[genreNumber];\n                            break;\n                        }\n                    }\n                    tags.genre ??= genreText;\n                }\n                ;\n                break;\n            case 'TDRC':\n            case 'TDAT':\n                {\n                    const dateText = reader.readId3V2EncodingAndText(frameEndPos);\n                    const date = new Date(dateText);\n                    if (!Number.isNaN(date.getTime())) {\n                        tags.date ??= date;\n                    }\n                }\n                ;\n                break;\n            case 'TYER':\n            case 'TYE':\n                {\n                    const yearText = reader.readId3V2EncodingAndText(frameEndPos);\n                    const year = Number.parseInt(yearText, 10);\n                    if (Number.isInteger(year)) {\n                        tags.date ??= new Date(year, 0, 1);\n                    }\n                }\n                ;\n                break;\n            case 'USLT':\n            case 'ULT':\n                {\n                    const encoding = reader.readU8();\n                    reader.pos += 3; // Skip language\n                    reader.readId3V2Text(encoding, frameEndPos); // Short content description\n                    tags.lyrics ??= reader.readId3V2Text(encoding, frameEndPos);\n                }\n                ;\n                break;\n            case 'COMM':\n            case 'COM':\n                {\n                    const encoding = reader.readU8();\n                    reader.pos += 3; // Skip language\n                    reader.readId3V2Text(encoding, frameEndPos); // Short content description\n                    tags.comment ??= reader.readId3V2Text(encoding, frameEndPos);\n                }\n                ;\n                break;\n            case 'APIC':\n            case 'PIC':\n                {\n                    const encoding = reader.readId3V2TextEncoding();\n                    let mimeType;\n                    if (header.majorVersion === 2) {\n                        const imageFormat = reader.readAscii(3);\n                        mimeType = imageFormat === 'PNG'\n                            ? 'image/png'\n                            : imageFormat === 'JPG'\n                                ? 'image/jpeg'\n                                : 'image/*';\n                    }\n                    else {\n                        mimeType = reader.readId3V2Text(encoding, frameEndPos);\n                    }\n                    const pictureType = reader.readU8();\n                    const description = reader.readId3V2Text(encoding, frameEndPos).trimEnd(); // Trim ending spaces\n                    const imageDataSize = frameEndPos - reader.pos;\n                    if (imageDataSize >= 0) {\n                        const imageData = reader.readBytes(imageDataSize);\n                        if (!tags.images)\n                            tags.images = [];\n                        tags.images.push({\n                            data: imageData,\n                            mimeType,\n                            kind: pictureType === 3\n                                ? 'coverFront'\n                                : pictureType === 4\n                                    ? 'coverBack'\n                                    : 'unknown',\n                            description,\n                        });\n                    }\n                }\n                ;\n                break;\n            default:\n                {\n                    reader.pos += frame.size;\n                }\n                ;\n                break;\n        }\n        reader.pos = frameEndPos;\n    }\n};\n// https://id3.org/id3v2.3.0\nclass Id3V2Reader {\n    constructor(header, bytes) {\n        this.header = header;\n        this.bytes = bytes;\n        this.pos = 0;\n        this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    }\n    frameHeaderSize() {\n        return this.header.majorVersion === 2 ? 6 : 10;\n    }\n    ununsynchronizeAll() {\n        const newBytes = [];\n        for (let i = 0; i < this.bytes.length; i++) {\n            const value1 = this.bytes[i];\n            newBytes.push(value1);\n            if (value1 === 0xff && i !== this.bytes.length - 1) {\n                const value2 = this.bytes[i];\n                if (value2 === 0x00) {\n                    i++;\n                }\n            }\n        }\n        this.bytes = new Uint8Array(newBytes);\n        this.view = new DataView(this.bytes.buffer);\n    }\n    ununsynchronizeRegion(start, end) {\n        const newBytes = [];\n        for (let i = start; i < end; i++) {\n            const value1 = this.bytes[i];\n            newBytes.push(value1);\n            if (value1 === 0xff && i !== end - 1) {\n                const value2 = this.bytes[i + 1];\n                if (value2 === 0x00) {\n                    i++;\n                }\n            }\n        }\n        const before = this.bytes.subarray(0, start);\n        const after = this.bytes.subarray(end);\n        this.bytes = new Uint8Array(before.length + newBytes.length + after.length);\n        this.bytes.set(before, 0);\n        this.bytes.set(newBytes, before.length);\n        this.bytes.set(after, before.length + newBytes.length);\n        this.view = new DataView(this.bytes.buffer);\n    }\n    removeFooter() {\n        this.bytes = this.bytes.subarray(0, this.bytes.length - ID3_V2_HEADER_SIZE);\n        this.view = new DataView(this.bytes.buffer);\n    }\n    readBytes(length) {\n        const slice = this.bytes.subarray(this.pos, this.pos + length);\n        this.pos += length;\n        return slice;\n    }\n    readU8() {\n        const value = this.view.getUint8(this.pos);\n        this.pos += 1;\n        return value;\n    }\n    readU16() {\n        const value = this.view.getUint16(this.pos, false);\n        this.pos += 2;\n        return value;\n    }\n    readU24() {\n        const high = this.view.getUint16(this.pos, false);\n        const low = this.view.getUint8(this.pos + 1);\n        this.pos += 3;\n        return high * 0x100 + low;\n    }\n    readU32() {\n        const value = this.view.getUint32(this.pos, false);\n        this.pos += 4;\n        return value;\n    }\n    readAscii(length) {\n        let str = '';\n        for (let i = 0; i < length; i++) {\n            str += String.fromCharCode(this.view.getUint8(this.pos + i));\n        }\n        this.pos += length;\n        return str;\n    }\n    readId3V2Frame() {\n        if (this.header.majorVersion === 2) {\n            const id = this.readAscii(3);\n            if (id === '\\x00\\x00\\x00') {\n                return null;\n            }\n            const size = this.readU24();\n            return { id, size, flags: 0 };\n        }\n        else {\n            const id = this.readAscii(4);\n            if (id === '\\x00\\x00\\x00\\x00') {\n                // We've landed in the padding section\n                return null;\n            }\n            const sizeRaw = this.readU32();\n            let size = this.header.majorVersion === 4\n                ? (0,_shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_0__.decodeSynchsafe)(sizeRaw)\n                : sizeRaw;\n            const flags = this.readU16();\n            const headerEndPos = this.pos;\n            // Some files may have incorrectly synchsafed/unsynchsafed sizes. To validate which interpretation is valid,\n            // we validate a size by skipping ahead and seeing if we land at a valid frame header (or at the end of the\n            // tag.\n            const isSizeValid = (size) => {\n                const nextPos = this.pos + size;\n                if (nextPos > this.bytes.length) {\n                    return false;\n                }\n                if (nextPos <= this.bytes.length - this.frameHeaderSize()) {\n                    this.pos += size;\n                    const nextId = this.readAscii(4);\n                    if (nextId !== '\\x00\\x00\\x00\\x00' && !/[0-9A-Z]{4}/.test(nextId)) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            if (!isSizeValid(size)) {\n                // Flip the synchsafing, and try if this one makes more sense\n                const otherSize = this.header.majorVersion === 4\n                    ? sizeRaw\n                    : (0,_shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_0__.decodeSynchsafe)(sizeRaw);\n                if (isSizeValid(otherSize)) {\n                    size = otherSize;\n                }\n            }\n            this.pos = headerEndPos;\n            return { id, size, flags };\n        }\n    }\n    readId3V2TextEncoding() {\n        const number = this.readU8();\n        if (number > 3) {\n            throw new Error(`Unsupported text encoding: ${number}`);\n        }\n        return number;\n    }\n    readId3V2Text(encoding, until) {\n        const startPos = this.pos;\n        const data = this.readBytes(until);\n        switch (encoding) {\n            case Id3V2TextEncoding.ISO_8859_1: {\n                let str = '';\n                for (let i = 0; i < data.length; i++) {\n                    const value = data[i];\n                    if (value === 0) {\n                        this.pos = startPos + i + 1;\n                        break;\n                    }\n                    str += String.fromCharCode(value);\n                }\n                return str;\n            }\n            case Id3V2TextEncoding.UTF_16_WITH_BOM: {\n                if (data[0] === 0xff && data[1] === 0xfe) {\n                    const decoder = new TextDecoder('utf-16le');\n                    const endIndex = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.coalesceIndex)(data.findIndex((x, i) => x === 0 && data[i + 1] === 0 && i % 2 === 0), data.length);\n                    this.pos = startPos + Math.min(endIndex + 2, data.length);\n                    return decoder.decode(data.subarray(2, endIndex));\n                }\n                else if (data[0] === 0xfe && data[1] === 0xff) {\n                    const decoder = new TextDecoder('utf-16be');\n                    const endIndex = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.coalesceIndex)(data.findIndex((x, i) => x === 0 && data[i + 1] === 0 && i % 2 === 0), data.length);\n                    this.pos = startPos + Math.min(endIndex + 2, data.length);\n                    return decoder.decode(data.subarray(2, endIndex));\n                }\n                else {\n                    // Treat it like UTF-8, some files do this\n                    const endIndex = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.coalesceIndex)(data.findIndex(x => x === 0), data.length);\n                    this.pos = startPos + Math.min(endIndex + 1, data.length);\n                    return _misc_js__WEBPACK_IMPORTED_MODULE_2__.textDecoder.decode(data.subarray(0, endIndex));\n                }\n            }\n            case Id3V2TextEncoding.UTF_16_BE_NO_BOM: {\n                const decoder = new TextDecoder('utf-16be');\n                const endIndex = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.coalesceIndex)(data.findIndex((x, i) => x === 0 && data[i + 1] === 0 && i % 2 === 0), data.length);\n                this.pos = startPos + Math.min(endIndex + 2, data.length);\n                return decoder.decode(data.subarray(0, endIndex));\n            }\n            case Id3V2TextEncoding.UTF_8: {\n                const endIndex = (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.coalesceIndex)(data.findIndex(x => x === 0), data.length);\n                this.pos = startPos + Math.min(endIndex + 1, data.length);\n                return _misc_js__WEBPACK_IMPORTED_MODULE_2__.textDecoder.decode(data.subarray(0, endIndex));\n            }\n        }\n    }\n    readId3V2EncodingAndText(until) {\n        if (this.pos >= until) {\n            return '';\n        }\n        const encoding = this.readId3V2TextEncoding();\n        return this.readId3V2Text(encoding, until);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL21wMy9tcDMtcmVhZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0Y7QUFDdkM7QUFDZTtBQUNoRTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUN0QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUN4QztBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG9EQUFvRCxrRUFBaUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscURBQVM7QUFDOUIsdUJBQXVCLG9FQUFlO0FBQ3RDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx3QkFBd0IscURBQVMsOEJBQThCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0RBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGtCQUFrQixxREFBUztBQUMzQixxQkFBcUIsdURBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtB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dUIsaURBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGNoLWN1dC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL21wMy9tcDMtcmVhZGVyLmpzPzM0NGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjUtcHJlc2VudCwgVmFuaWxhZ3kgYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgeyBkZWNvZGVTeW5jaHNhZmUsIEZSQU1FX0hFQURFUl9TSVpFLCByZWFkRnJhbWVIZWFkZXIgfSBmcm9tICcuLi8uLi9zaGFyZWQvbXAzLW1pc2MuanMnO1xuaW1wb3J0IHsgY29hbGVzY2VJbmRleCwgdGV4dERlY29kZXIgfSBmcm9tICcuLi9taXNjLmpzJztcbmltcG9ydCB7IHJlYWRBc2NpaSwgcmVhZEJ5dGVzLCByZWFkVTMyQmUsIHJlYWRVOCB9IGZyb20gJy4uL3JlYWRlci5qcyc7XG5leHBvcnQgdmFyIElkM1YySGVhZGVyRmxhZ3M7XG4oZnVuY3Rpb24gKElkM1YySGVhZGVyRmxhZ3MpIHtcbiAgICBJZDNWMkhlYWRlckZsYWdzW0lkM1YySGVhZGVyRmxhZ3NbXCJVbnN5bmNocm9uaXNhdGlvblwiXSA9IDEyOF0gPSBcIlVuc3luY2hyb25pc2F0aW9uXCI7XG4gICAgSWQzVjJIZWFkZXJGbGFnc1tJZDNWMkhlYWRlckZsYWdzW1wiRXh0ZW5kZWRIZWFkZXJcIl0gPSA2NF0gPSBcIkV4dGVuZGVkSGVhZGVyXCI7XG4gICAgSWQzVjJIZWFkZXJGbGFnc1tJZDNWMkhlYWRlckZsYWdzW1wiRXhwZXJpbWVudGFsSW5kaWNhdG9yXCJdID0gMzJdID0gXCJFeHBlcmltZW50YWxJbmRpY2F0b3JcIjtcbiAgICBJZDNWMkhlYWRlckZsYWdzW0lkM1YySGVhZGVyRmxhZ3NbXCJGb290ZXJcIl0gPSAxNl0gPSBcIkZvb3RlclwiO1xufSkoSWQzVjJIZWFkZXJGbGFncyB8fCAoSWQzVjJIZWFkZXJGbGFncyA9IHt9KSk7XG5leHBvcnQgdmFyIElkM1YyVGV4dEVuY29kaW5nO1xuKGZ1bmN0aW9uIChJZDNWMlRleHRFbmNvZGluZykge1xuICAgIElkM1YyVGV4dEVuY29kaW5nW0lkM1YyVGV4dEVuY29kaW5nW1wiSVNPXzg4NTlfMVwiXSA9IDBdID0gXCJJU09fODg1OV8xXCI7XG4gICAgSWQzVjJUZXh0RW5jb2RpbmdbSWQzVjJUZXh0RW5jb2RpbmdbXCJVVEZfMTZfV0lUSF9CT01cIl0gPSAxXSA9IFwiVVRGXzE2X1dJVEhfQk9NXCI7XG4gICAgSWQzVjJUZXh0RW5jb2RpbmdbSWQzVjJUZXh0RW5jb2RpbmdbXCJVVEZfMTZfQkVfTk9fQk9NXCJdID0gMl0gPSBcIlVURl8xNl9CRV9OT19CT01cIjtcbiAgICBJZDNWMlRleHRFbmNvZGluZ1tJZDNWMlRleHRFbmNvZGluZ1tcIlVURl84XCJdID0gM10gPSBcIlVURl84XCI7XG59KShJZDNWMlRleHRFbmNvZGluZyB8fCAoSWQzVjJUZXh0RW5jb2RpbmcgPSB7fSkpO1xuZXhwb3J0IGNvbnN0IElEM19WMV9UQUdfU0laRSA9IDEyODtcbmV4cG9ydCBjb25zdCBJRDNfVjJfSEVBREVSX1NJWkUgPSAxMDtcbmV4cG9ydCBjb25zdCBJRDNfVjFfR0VOUkVTID0gW1xuICAgICdCbHVlcycsICdDbGFzc2ljIHJvY2snLCAnQ291bnRyeScsICdEYW5jZScsICdEaXNjbycsICdGdW5rJywgJ0dydW5nZScsICdIaXAtaG9wJywgJ0phenonLFxuICAgICdNZXRhbCcsICdOZXcgYWdlJywgJ09sZGllcycsICdPdGhlcicsICdQb3AnLCAnUmh5dGhtIGFuZCBibHVlcycsICdSYXAnLCAnUmVnZ2FlJywgJ1JvY2snLFxuICAgICdUZWNobm8nLCAnSW5kdXN0cmlhbCcsICdBbHRlcm5hdGl2ZScsICdTa2EnLCAnRGVhdGggbWV0YWwnLCAnUHJhbmtzJywgJ1NvdW5kdHJhY2snLFxuICAgICdFdXJvLXRlY2hubycsICdBbWJpZW50JywgJ1RyaXAtaG9wJywgJ1ZvY2FsJywgJ0phenogJiBmdW5rJywgJ0Z1c2lvbicsICdUcmFuY2UnLCAnQ2xhc3NpY2FsJyxcbiAgICAnSW5zdHJ1bWVudGFsJywgJ0FjaWQnLCAnSG91c2UnLCAnR2FtZScsICdTb3VuZCBjbGlwJywgJ0dvc3BlbCcsICdOb2lzZScsICdBbHRlcm5hdGl2ZSByb2NrJyxcbiAgICAnQmFzcycsICdTb3VsJywgJ1B1bmsnLCAnU3BhY2UnLCAnTWVkaXRhdGl2ZScsICdJbnN0cnVtZW50YWwgcG9wJywgJ0luc3RydW1lbnRhbCByb2NrJyxcbiAgICAnRXRobmljJywgJ0dvdGhpYycsICdEYXJrd2F2ZScsICdUZWNobm8taW5kdXN0cmlhbCcsICdFbGVjdHJvbmljJywgJ1BvcC1mb2xrJywgJ0V1cm9kYW5jZScsXG4gICAgJ0RyZWFtJywgJ1NvdXRoZXJuIHJvY2snLCAnQ29tZWR5JywgJ0N1bHQnLCAnR2FuZ3N0YScsICdUb3AgNDAnLCAnQ2hyaXN0aWFuIHJhcCcsICdQb3AvZnVuaycsXG4gICAgJ0p1bmdsZSBtdXNpYycsICdOYXRpdmUgVVMnLCAnQ2FiYXJldCcsICdOZXcgd2F2ZScsICdQc3ljaGVkZWxpYycsICdSYXZlJywgJ1Nob3d0dW5lcycsXG4gICAgJ1RyYWlsZXInLCAnTG8tZmknLCAnVHJpYmFsJywgJ0FjaWQgcHVuaycsICdBY2lkIGphenonLCAnUG9sa2EnLCAnUmV0cm8nLCAnTXVzaWNhbCcsXG4gICAgJ1JvY2sgXFwnblxcJyByb2xsJywgJ0hhcmQgcm9jaycsICdGb2xrJywgJ0ZvbGsgcm9jaycsICdOYXRpb25hbCBmb2xrJywgJ1N3aW5nJywgJ0Zhc3QgZnVzaW9uJyxcbiAgICAnQmVib3AnLCAnTGF0aW4nLCAnUmV2aXZhbCcsICdDZWx0aWMnLCAnQmx1ZWdyYXNzJywgJ0F2YW50Z2FyZGUnLCAnR290aGljIHJvY2snLFxuICAgICdQcm9ncmVzc2l2ZSByb2NrJywgJ1BzeWNoZWRlbGljIHJvY2snLCAnU3ltcGhvbmljIHJvY2snLCAnU2xvdyByb2NrJywgJ0JpZyBiYW5kJywgJ0Nob3J1cycsXG4gICAgJ0Vhc3kgbGlzdGVuaW5nJywgJ0Fjb3VzdGljJywgJ0h1bW91cicsICdTcGVlY2gnLCAnQ2hhbnNvbicsICdPcGVyYScsICdDaGFtYmVyIG11c2ljJyxcbiAgICAnU29uYXRhJywgJ1N5bXBob255JywgJ0Jvb3R5IGJhc3MnLCAnUHJpbXVzJywgJ1Bvcm4gZ3Jvb3ZlJywgJ1NhdGlyZScsICdTbG93IGphbScsICdDbHViJyxcbiAgICAnVGFuZ28nLCAnU2FtYmEnLCAnRm9sa2xvcmUnLCAnQmFsbGFkJywgJ1Bvd2VyIGJhbGxhZCcsICdSaHl0aG1pYyBTb3VsJywgJ0ZyZWVzdHlsZScsICdEdWV0JyxcbiAgICAnUHVuayByb2NrJywgJ0RydW0gc29sbycsICdBIGNhcHBlbGxhJywgJ0V1cm8taG91c2UnLCAnRGFuY2UgaGFsbCcsICdHb2EgbXVzaWMnLCAnRHJ1bSAmIGJhc3MnLFxuICAgICdDbHViLWhvdXNlJywgJ0hhcmRjb3JlIHRlY2hubycsICdUZXJyb3InLCAnSW5kaWUnLCAnQnJpdHBvcCcsICdOZWdlcnB1bmsnLCAnUG9sc2sgcHVuaycsXG4gICAgJ0JlYXQnLCAnQ2hyaXN0aWFuIGdhbmdzdGEgcmFwJywgJ0hlYXZ5IG1ldGFsJywgJ0JsYWNrIG1ldGFsJywgJ0Nyb3Nzb3ZlcicsXG4gICAgJ0NvbnRlbXBvcmFyeSBDaHJpc3RpYW4nLCAnQ2hyaXN0aWFuIHJvY2snLCAnTWVyZW5ndWUnLCAnU2Fsc2EnLCAnVGhyYXNoIG1ldGFsJywgJ0FuaW1lJyxcbiAgICAnSnBvcCcsICdTeW50aHBvcCcsICdDaHJpc3RtYXMnLCAnQXJ0IHJvY2snLCAnQmFyb3F1ZScsICdCaGFuZ3JhJywgJ0JpZyBiZWF0JywgJ0JyZWFrYmVhdCcsXG4gICAgJ0NoaWxsb3V0JywgJ0Rvd250ZW1wbycsICdEdWInLCAnRUJNJywgJ0VjbGVjdGljJywgJ0VsZWN0cm8nLCAnRWxlY3Ryb2NsYXNoJywgJ0VtbycsXG4gICAgJ0V4cGVyaW1lbnRhbCcsICdHYXJhZ2UnLCAnR2xvYmFsJywgJ0lETScsICdJbGxiaWVudCcsICdJbmR1c3Ryby1Hb3RoJywgJ0phbSBCYW5kJyxcbiAgICAnS3JhdXRyb2NrJywgJ0xlZnRmaWVsZCcsICdMb3VuZ2UnLCAnTWF0aCByb2NrJywgJ05ldyByb21hbnRpYycsICdOdS1icmVha3onLCAnUG9zdC1wdW5rJyxcbiAgICAnUG9zdC1yb2NrJywgJ1BzeXRyYW5jZScsICdTaG9lZ2F6ZScsICdTcGFjZSByb2NrJywgJ1Ryb3Agcm9jaycsICdXb3JsZCBtdXNpYycsICdOZW9jbGFzc2ljYWwnLFxuICAgICdBdWRpb2Jvb2snLCAnQXVkaW8gdGhlYXRyZScsICdOZXVlIERldXRzY2hlIFdlbGxlJywgJ1BvZGNhc3QnLCAnSW5kaWUgcm9jaycsICdHLUZ1bmsnLFxuICAgICdEdWJzdGVwJywgJ0dhcmFnZSByb2NrJywgJ1BzeWJpZW50Jyxcbl07XG5leHBvcnQgY29uc3QgcmVhZE5leHRGcmFtZUhlYWRlciA9IGFzeW5jIChyZWFkZXIsIHN0YXJ0UG9zLCB1bnRpbCkgPT4ge1xuICAgIGxldCBjdXJyZW50UG9zID0gc3RhcnRQb3M7XG4gICAgd2hpbGUgKHVudGlsID09PSBudWxsIHx8IGN1cnJlbnRQb3MgPCB1bnRpbCkge1xuICAgICAgICBsZXQgc2xpY2UgPSByZWFkZXIucmVxdWVzdFNsaWNlKGN1cnJlbnRQb3MsIEZSQU1FX0hFQURFUl9TSVpFKTtcbiAgICAgICAgaWYgKHNsaWNlIGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgICAgIHNsaWNlID0gYXdhaXQgc2xpY2U7XG4gICAgICAgIGlmICghc2xpY2UpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY29uc3Qgd29yZCA9IHJlYWRVMzJCZShzbGljZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlYWRGcmFtZUhlYWRlcih3b3JkLCByZWFkZXIuZmlsZVNpemUgIT09IG51bGwgPyByZWFkZXIuZmlsZVNpemUgLSBjdXJyZW50UG9zIDogbnVsbCk7XG4gICAgICAgIGlmIChyZXN1bHQuaGVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4geyBoZWFkZXI6IHJlc3VsdC5oZWFkZXIsIHN0YXJ0UG9zOiBjdXJyZW50UG9zIH07XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBvcyArPSByZXN1bHQuYnl0ZXNBZHZhbmNlZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuZXhwb3J0IGNvbnN0IHBhcnNlSWQzVjFUYWcgPSAoc2xpY2UsIHRhZ3MpID0+IHtcbiAgICBjb25zdCBzdGFydFBvcyA9IHNsaWNlLmZpbGVQb3M7XG4gICAgdGFncy5yYXcgPz89IHt9O1xuICAgIHRhZ3MucmF3WydUQUcnXSA/Pz0gcmVhZEJ5dGVzKHNsaWNlLCBJRDNfVjFfVEFHX1NJWkUgLSAzKTsgLy8gRHVtcCB0aGUgd2hvbGUgdGFnIGludG8gdGhlIHJhdyBtZXRhZGF0YVxuICAgIHNsaWNlLmZpbGVQb3MgPSBzdGFydFBvcztcbiAgICBjb25zdCB0aXRsZSA9IHJlYWRJZDNWMVN0cmluZyhzbGljZSwgMzApO1xuICAgIGlmICh0aXRsZSlcbiAgICAgICAgdGFncy50aXRsZSA/Pz0gdGl0bGU7XG4gICAgY29uc3QgYXJ0aXN0ID0gcmVhZElkM1YxU3RyaW5nKHNsaWNlLCAzMCk7XG4gICAgaWYgKGFydGlzdClcbiAgICAgICAgdGFncy5hcnRpc3QgPz89IGFydGlzdDtcbiAgICBjb25zdCBhbGJ1bSA9IHJlYWRJZDNWMVN0cmluZyhzbGljZSwgMzApO1xuICAgIGlmIChhbGJ1bSlcbiAgICAgICAgdGFncy5hbGJ1bSA/Pz0gYWxidW07XG4gICAgY29uc3QgeWVhclRleHQgPSByZWFkSWQzVjFTdHJpbmcoc2xpY2UsIDQpO1xuICAgIGNvbnN0IHllYXIgPSBOdW1iZXIucGFyc2VJbnQoeWVhclRleHQsIDEwKTtcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih5ZWFyKSAmJiB5ZWFyID4gMCkge1xuICAgICAgICB0YWdzLmRhdGUgPz89IG5ldyBEYXRlKHllYXIsIDAsIDEpO1xuICAgIH1cbiAgICBjb25zdCBjb21tZW50Qnl0ZXMgPSByZWFkQnl0ZXMoc2xpY2UsIDMwKTtcbiAgICBsZXQgY29tbWVudDtcbiAgICAvLyBDaGVjayBmb3IgdGhlIElEM3YxLjEgdHJhY2sgbnVtYmVyIGZvcm1hdDpcbiAgICAvLyBUaGUgMjl0aCBieXRlIChpbmRleCAyOCkgaXMgYSBudWxsIHRlcm1pbmF0b3IsIGFuZCB0aGUgMzB0aCBieXRlIGlzIHRoZSB0cmFjayBudW1iZXIuXG4gICAgaWYgKGNvbW1lbnRCeXRlc1syOF0gPT09IDAgJiYgY29tbWVudEJ5dGVzWzI5XSAhPT0gMCkge1xuICAgICAgICBjb25zdCB0cmFja051bSA9IGNvbW1lbnRCeXRlc1syOV07XG4gICAgICAgIGlmICh0cmFja051bSA+IDApIHtcbiAgICAgICAgICAgIHRhZ3MudHJhY2tOdW1iZXIgPz89IHRyYWNrTnVtO1xuICAgICAgICB9XG4gICAgICAgIHNsaWNlLnNraXAoLTMwKTtcbiAgICAgICAgY29tbWVudCA9IHJlYWRJZDNWMVN0cmluZyhzbGljZSwgMjgpO1xuICAgICAgICBzbGljZS5za2lwKDIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2xpY2Uuc2tpcCgtMzApO1xuICAgICAgICBjb21tZW50ID0gcmVhZElkM1YxU3RyaW5nKHNsaWNlLCAzMCk7XG4gICAgfVxuICAgIGlmIChjb21tZW50KVxuICAgICAgICB0YWdzLmNvbW1lbnQgPz89IGNvbW1lbnQ7XG4gICAgY29uc3QgZ2VucmVJbmRleCA9IHJlYWRVOChzbGljZSk7XG4gICAgaWYgKGdlbnJlSW5kZXggPCBJRDNfVjFfR0VOUkVTLmxlbmd0aCkge1xuICAgICAgICB0YWdzLmdlbnJlID8/PSBJRDNfVjFfR0VOUkVTW2dlbnJlSW5kZXhdO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgcmVhZElkM1YxU3RyaW5nID0gKHNsaWNlLCBsZW5ndGgpID0+IHtcbiAgICBjb25zdCBieXRlcyA9IHJlYWRCeXRlcyhzbGljZSwgbGVuZ3RoKTtcbiAgICBjb25zdCBlbmRJbmRleCA9IGNvYWxlc2NlSW5kZXgoYnl0ZXMuaW5kZXhPZigwKSwgYnl0ZXMubGVuZ3RoKTtcbiAgICBjb25zdCByZWxldmFudEJ5dGVzID0gYnl0ZXMuc3ViYXJyYXkoMCwgZW5kSW5kZXgpO1xuICAgIC8vIERlY29kZSBhcyBJU08tODg1OS0xXG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVsZXZhbnRCeXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyZWxldmFudEJ5dGVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci50cmltRW5kKCk7IC8vIFN0cmluZyBhbHNvIG1heSBiZSBwYWRkZWQgd2l0aCBzcGFjZXNcbn07XG5leHBvcnQgY29uc3QgcmVhZElkM1YySGVhZGVyID0gKHNsaWNlKSA9PiB7XG4gICAgY29uc3Qgc3RhcnRQb3MgPSBzbGljZS5maWxlUG9zO1xuICAgIGNvbnN0IHRhZyA9IHJlYWRBc2NpaShzbGljZSwgMyk7XG4gICAgY29uc3QgbWFqb3JWZXJzaW9uID0gcmVhZFU4KHNsaWNlKTtcbiAgICBjb25zdCByZXZpc2lvbiA9IHJlYWRVOChzbGljZSk7XG4gICAgY29uc3QgZmxhZ3MgPSByZWFkVTgoc2xpY2UpO1xuICAgIGNvbnN0IHNpemVSYXcgPSByZWFkVTMyQmUoc2xpY2UpO1xuICAgIGlmICh0YWcgIT09ICdJRDMnIHx8IG1ham9yVmVyc2lvbiA9PT0gMHhmZiB8fCByZXZpc2lvbiA9PT0gMHhmZiB8fCAoc2l6ZVJhdyAmIDB4ODA4MDgwODApICE9PSAwKSB7XG4gICAgICAgIHNsaWNlLmZpbGVQb3MgPSBzdGFydFBvcztcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNpemUgPSBkZWNvZGVTeW5jaHNhZmUoc2l6ZVJhdyk7XG4gICAgcmV0dXJuIHsgbWFqb3JWZXJzaW9uLCByZXZpc2lvbiwgZmxhZ3MsIHNpemUgfTtcbn07XG5leHBvcnQgY29uc3QgcGFyc2VJZDNWMlRhZyA9IChzbGljZSwgaGVhZGVyLCB0YWdzKSA9PiB7XG4gICAgLy8gaHR0cHM6Ly9pZDMub3JnL2lkM3YyLjMuMFxuICAgIGlmICghWzIsIDMsIDRdLmluY2x1ZGVzKGhlYWRlci5tYWpvclZlcnNpb24pKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVW5zdXBwb3J0ZWQgSUQzdjIgbWFqb3IgdmVyc2lvbjogJHtoZWFkZXIubWFqb3JWZXJzaW9ufWApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gcmVhZEJ5dGVzKHNsaWNlLCBoZWFkZXIuc2l6ZSk7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IElkM1YyUmVhZGVyKGhlYWRlciwgYnl0ZXMpO1xuICAgIGlmIChoZWFkZXIuZmxhZ3MgJiBJZDNWMkhlYWRlckZsYWdzLkZvb3Rlcikge1xuICAgICAgICByZWFkZXIucmVtb3ZlRm9vdGVyKCk7XG4gICAgfVxuICAgIGlmICgoaGVhZGVyLmZsYWdzICYgSWQzVjJIZWFkZXJGbGFncy5VbnN5bmNocm9uaXNhdGlvbikgJiYgaGVhZGVyLm1ham9yVmVyc2lvbiA9PT0gMykge1xuICAgICAgICByZWFkZXIudW51bnN5bmNocm9uaXplQWxsKCk7XG4gICAgfVxuICAgIGlmIChoZWFkZXIuZmxhZ3MgJiBJZDNWMkhlYWRlckZsYWdzLkV4dGVuZGVkSGVhZGVyKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuZGVkSGVhZGVyU2l6ZSA9IHJlYWRlci5yZWFkVTMyKCk7XG4gICAgICAgIGlmIChoZWFkZXIubWFqb3JWZXJzaW9uID09PSAzKSB7XG4gICAgICAgICAgICByZWFkZXIucG9zICs9IGV4dGVuZGVkSGVhZGVyU2l6ZTsgLy8gVGhlIGV4dGVuZGVkIGhlYWRlciBzaXplIGV4Y2x1ZGVzIGl0c2VsZlxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVhZGVyLnBvcyArPSBleHRlbmRlZEhlYWRlclNpemUgLSA0OyAvLyBUaGUgZXh0ZW5kZWQgaGVhZGVyIHNpemUgaW5jbHVkZXMgaXRzZWxmXG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPD0gcmVhZGVyLmJ5dGVzLmxlbmd0aCAtIHJlYWRlci5mcmFtZUhlYWRlclNpemUoKSkge1xuICAgICAgICBjb25zdCBmcmFtZSA9IHJlYWRlci5yZWFkSWQzVjJGcmFtZSgpO1xuICAgICAgICBpZiAoIWZyYW1lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFtZVN0YXJ0UG9zID0gcmVhZGVyLnBvcztcbiAgICAgICAgY29uc3QgZnJhbWVFbmRQb3MgPSByZWFkZXIucG9zICsgZnJhbWUuc2l6ZTtcbiAgICAgICAgbGV0IGZyYW1lRW5jcnlwdGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBmcmFtZUNvbXByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGZyYW1lVW5zeW5jaHJvbml6ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGhlYWRlci5tYWpvclZlcnNpb24gPT09IDMpIHtcbiAgICAgICAgICAgIGZyYW1lRW5jcnlwdGVkID0gISEoZnJhbWUuZmxhZ3MgJiAoMSA8PCA2KSk7XG4gICAgICAgICAgICBmcmFtZUNvbXByZXNzZWQgPSAhIShmcmFtZS5mbGFncyAmICgxIDw8IDcpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoZWFkZXIubWFqb3JWZXJzaW9uID09PSA0KSB7XG4gICAgICAgICAgICBmcmFtZUVuY3J5cHRlZCA9ICEhKGZyYW1lLmZsYWdzICYgKDEgPDwgMikpO1xuICAgICAgICAgICAgZnJhbWVDb21wcmVzc2VkID0gISEoZnJhbWUuZmxhZ3MgJiAoMSA8PCAzKSk7XG4gICAgICAgICAgICBmcmFtZVVuc3luY2hyb25pemVkID0gISEoZnJhbWUuZmxhZ3MgJiAoMSA8PCAxKSlcbiAgICAgICAgICAgICAgICB8fCAhIShoZWFkZXIuZmxhZ3MgJiBJZDNWMkhlYWRlckZsYWdzLlVuc3luY2hyb25pc2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhbWVFbmNyeXB0ZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2tpcHBpbmcgZW5jcnlwdGVkIElEM3YyIGZyYW1lICR7ZnJhbWUuaWR9YCk7XG4gICAgICAgICAgICByZWFkZXIucG9zID0gZnJhbWVFbmRQb3M7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhbWVDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFNraXBwaW5nIGNvbXByZXNzZWQgSUQzdjIgZnJhbWUgJHtmcmFtZS5pZH1gKTsgLy8gTWF5YmUgc29tZWRheT8gSWRrXG4gICAgICAgICAgICByZWFkZXIucG9zID0gZnJhbWVFbmRQb3M7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhbWVVbnN5bmNocm9uaXplZCkge1xuICAgICAgICAgICAgcmVhZGVyLnVudW5zeW5jaHJvbml6ZVJlZ2lvbihyZWFkZXIucG9zLCBmcmFtZUVuZFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGFncy5yYXcgPz89IHt9O1xuICAgICAgICBpZiAoZnJhbWUuaWRbMF0gPT09ICdUJykge1xuICAgICAgICAgICAgLy8gSXQncyBhIHRleHQgZnJhbWUsIGxldCdzIGRlY29kZSBhcyB0ZXh0XG4gICAgICAgICAgICB0YWdzLnJhd1tmcmFtZS5pZF0gPz89IHJlYWRlci5yZWFkSWQzVjJFbmNvZGluZ0FuZFRleHQoZnJhbWVFbmRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIHRoZSBvdGhlcnMsIGxldCdzIGp1c3QgZ2V0IHRoZSBieXRlc1xuICAgICAgICAgICAgdGFncy5yYXdbZnJhbWUuaWRdID8/PSByZWFkZXIucmVhZEJ5dGVzKGZyYW1lLnNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJlYWRlci5wb3MgPSBmcmFtZVN0YXJ0UG9zO1xuICAgICAgICBzd2l0Y2ggKGZyYW1lLmlkKSB7XG4gICAgICAgICAgICBjYXNlICdUSVQyJzpcbiAgICAgICAgICAgIGNhc2UgJ1RUMic6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0YWdzLnRpdGxlID8/PSByZWFkZXIucmVhZElkM1YyRW5jb2RpbmdBbmRUZXh0KGZyYW1lRW5kUG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVElUMyc6XG4gICAgICAgICAgICBjYXNlICdUVDMnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGFncy5kZXNjcmlwdGlvbiA/Pz0gcmVhZGVyLnJlYWRJZDNWMkVuY29kaW5nQW5kVGV4dChmcmFtZUVuZFBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1RQRTEnOlxuICAgICAgICAgICAgY2FzZSAnVFAxJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ3MuYXJ0aXN0ID8/PSByZWFkZXIucmVhZElkM1YyRW5jb2RpbmdBbmRUZXh0KGZyYW1lRW5kUG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVEFMQic6XG4gICAgICAgICAgICBjYXNlICdUQUwnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGFncy5hbGJ1bSA/Pz0gcmVhZGVyLnJlYWRJZDNWMkVuY29kaW5nQW5kVGV4dChmcmFtZUVuZFBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1RQRTInOlxuICAgICAgICAgICAgY2FzZSAnVFAyJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ3MuYWxidW1BcnRpc3QgPz89IHJlYWRlci5yZWFkSWQzVjJFbmNvZGluZ0FuZFRleHQoZnJhbWVFbmRQb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdUUkNLJzpcbiAgICAgICAgICAgIGNhc2UgJ1RSSyc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFja1RleHQgPSByZWFkZXIucmVhZElkM1YyRW5jb2RpbmdBbmRUZXh0KGZyYW1lRW5kUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSB0cmFja1RleHQuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhY2tOdW0gPSBOdW1iZXIucGFyc2VJbnQocGFydHNbMF0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhY2tzVG90YWwgPSBwYXJ0c1sxXSAmJiBOdW1iZXIucGFyc2VJbnQocGFydHNbMV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodHJhY2tOdW0pICYmIHRyYWNrTnVtID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFncy50cmFja051bWJlciA/Pz0gdHJhY2tOdW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrc1RvdGFsICYmIE51bWJlci5pc0ludGVnZXIodHJhY2tzVG90YWwpICYmIHRyYWNrc1RvdGFsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFncy50cmFja3NUb3RhbCA/Pz0gdHJhY2tzVG90YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVFBPUyc6XG4gICAgICAgICAgICBjYXNlICdUUEEnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzY1RleHQgPSByZWFkZXIucmVhZElkM1YyRW5jb2RpbmdBbmRUZXh0KGZyYW1lRW5kUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBkaXNjVGV4dC5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXNjTnVtID0gTnVtYmVyLnBhcnNlSW50KHBhcnRzWzBdLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc2NzVG90YWwgPSBwYXJ0c1sxXSAmJiBOdW1iZXIucGFyc2VJbnQocGFydHNbMV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoZGlzY051bSkgJiYgZGlzY051bSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3MuZGlzY051bWJlciA/Pz0gZGlzY051bTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzY3NUb3RhbCAmJiBOdW1iZXIuaXNJbnRlZ2VyKGRpc2NzVG90YWwpICYmIGRpc2NzVG90YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdzLmRpc2NzVG90YWwgPz89IGRpc2NzVG90YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVENPTic6XG4gICAgICAgICAgICBjYXNlICdUQ08nOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VucmVUZXh0ID0gcmVhZGVyLnJlYWRJZDNWMkVuY29kaW5nQW5kVGV4dChmcmFtZUVuZFBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IC9eXFwoKFxcZCspXFwpLy5leGVjKGdlbnJlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VucmVOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKElEM19WMV9HRU5SRVNbZ2VucmVOdW1iZXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzLmdlbnJlID8/PSBJRDNfVjFfR0VOUkVTW2dlbnJlTnVtYmVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IC9eXFxkKyQvLmV4ZWMoZ2VucmVUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW5yZU51bWJlciA9IE51bWJlci5wYXJzZUludChtYXRjaFswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSUQzX1YxX0dFTlJFU1tnZW5yZU51bWJlcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3MuZ2VucmUgPz89IElEM19WMV9HRU5SRVNbZ2VucmVOdW1iZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhZ3MuZ2VucmUgPz89IGdlbnJlVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVERSQyc6XG4gICAgICAgICAgICBjYXNlICdUREFUJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVUZXh0ID0gcmVhZGVyLnJlYWRJZDNWMkVuY29kaW5nQW5kVGV4dChmcmFtZUVuZFBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFncy5kYXRlID8/PSBkYXRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1RZRVInOlxuICAgICAgICAgICAgY2FzZSAnVFlFJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHllYXJUZXh0ID0gcmVhZGVyLnJlYWRJZDNWMkVuY29kaW5nQW5kVGV4dChmcmFtZUVuZFBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHllYXIgPSBOdW1iZXIucGFyc2VJbnQoeWVhclRleHQsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoeWVhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3MuZGF0ZSA/Pz0gbmV3IERhdGUoeWVhciwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVVNMVCc6XG4gICAgICAgICAgICBjYXNlICdVTFQnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5jb2RpbmcgPSByZWFkZXIucmVhZFU4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5wb3MgKz0gMzsgLy8gU2tpcCBsYW5ndWFnZVxuICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZElkM1YyVGV4dChlbmNvZGluZywgZnJhbWVFbmRQb3MpOyAvLyBTaG9ydCBjb250ZW50IGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRhZ3MubHlyaWNzID8/PSByZWFkZXIucmVhZElkM1YyVGV4dChlbmNvZGluZywgZnJhbWVFbmRQb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdDT01NJzpcbiAgICAgICAgICAgIGNhc2UgJ0NPTSc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGluZyA9IHJlYWRlci5yZWFkVTgoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnBvcyArPSAzOyAvLyBTa2lwIGxhbmd1YWdlXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkSWQzVjJUZXh0KGVuY29kaW5nLCBmcmFtZUVuZFBvcyk7IC8vIFNob3J0IGNvbnRlbnQgZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgdGFncy5jb21tZW50ID8/PSByZWFkZXIucmVhZElkM1YyVGV4dChlbmNvZGluZywgZnJhbWVFbmRQb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdBUElDJzpcbiAgICAgICAgICAgIGNhc2UgJ1BJQyc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGluZyA9IHJlYWRlci5yZWFkSWQzVjJUZXh0RW5jb2RpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbWVUeXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyLm1ham9yVmVyc2lvbiA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VGb3JtYXQgPSByZWFkZXIucmVhZEFzY2lpKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGUgPSBpbWFnZUZvcm1hdCA9PT0gJ1BORydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdpbWFnZS9wbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpbWFnZUZvcm1hdCA9PT0gJ0pQRydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnaW1hZ2UvanBlZydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnaW1hZ2UvKic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSA9IHJlYWRlci5yZWFkSWQzVjJUZXh0KGVuY29kaW5nLCBmcmFtZUVuZFBvcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGljdHVyZVR5cGUgPSByZWFkZXIucmVhZFU4KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gcmVhZGVyLnJlYWRJZDNWMlRleHQoZW5jb2RpbmcsIGZyYW1lRW5kUG9zKS50cmltRW5kKCk7IC8vIFRyaW0gZW5kaW5nIHNwYWNlc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZURhdGFTaXplID0gZnJhbWVFbmRQb3MgLSByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VEYXRhU2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZURhdGEgPSByZWFkZXIucmVhZEJ5dGVzKGltYWdlRGF0YVNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0YWdzLmltYWdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzLmltYWdlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFncy5pbWFnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaW1hZ2VEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IHBpY3R1cmVUeXBlID09PSAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2NvdmVyRnJvbnQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcGljdHVyZVR5cGUgPT09IDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2NvdmVyQmFjaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3Vua25vd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5wb3MgKz0gZnJhbWUuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlYWRlci5wb3MgPSBmcmFtZUVuZFBvcztcbiAgICB9XG59O1xuLy8gaHR0cHM6Ly9pZDMub3JnL2lkM3YyLjMuMFxuZXhwb3J0IGNsYXNzIElkM1YyUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihoZWFkZXIsIGJ5dGVzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyO1xuICAgICAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIGZyYW1lSGVhZGVyU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyLm1ham9yVmVyc2lvbiA9PT0gMiA/IDYgOiAxMDtcbiAgICB9XG4gICAgdW51bnN5bmNocm9uaXplQWxsKCkge1xuICAgICAgICBjb25zdCBuZXdCeXRlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlMSA9IHRoaXMuYnl0ZXNbaV07XG4gICAgICAgICAgICBuZXdCeXRlcy5wdXNoKHZhbHVlMSk7XG4gICAgICAgICAgICBpZiAodmFsdWUxID09PSAweGZmICYmIGkgIT09IHRoaXMuYnl0ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IHRoaXMuYnl0ZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlMiA9PT0gMHgwMCkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnl0ZXMgPSBuZXcgVWludDhBcnJheShuZXdCeXRlcyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLmJ5dGVzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVudW5zeW5jaHJvbml6ZVJlZ2lvbihzdGFydCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IG5ld0J5dGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZTEgPSB0aGlzLmJ5dGVzW2ldO1xuICAgICAgICAgICAgbmV3Qnl0ZXMucHVzaCh2YWx1ZTEpO1xuICAgICAgICAgICAgaWYgKHZhbHVlMSA9PT0gMHhmZiAmJiBpICE9PSBlbmQgLSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gdGhpcy5ieXRlc1tpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlMiA9PT0gMHgwMCkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJlZm9yZSA9IHRoaXMuYnl0ZXMuc3ViYXJyYXkoMCwgc3RhcnQpO1xuICAgICAgICBjb25zdCBhZnRlciA9IHRoaXMuYnl0ZXMuc3ViYXJyYXkoZW5kKTtcbiAgICAgICAgdGhpcy5ieXRlcyA9IG5ldyBVaW50OEFycmF5KGJlZm9yZS5sZW5ndGggKyBuZXdCeXRlcy5sZW5ndGggKyBhZnRlci5sZW5ndGgpO1xuICAgICAgICB0aGlzLmJ5dGVzLnNldChiZWZvcmUsIDApO1xuICAgICAgICB0aGlzLmJ5dGVzLnNldChuZXdCeXRlcywgYmVmb3JlLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuYnl0ZXMuc2V0KGFmdGVyLCBiZWZvcmUubGVuZ3RoICsgbmV3Qnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuYnl0ZXMuYnVmZmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlRm9vdGVyKCkge1xuICAgICAgICB0aGlzLmJ5dGVzID0gdGhpcy5ieXRlcy5zdWJhcnJheSgwLCB0aGlzLmJ5dGVzLmxlbmd0aCAtIElEM19WMl9IRUFERVJfU0laRSk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLmJ5dGVzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHJlYWRCeXRlcyhsZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgc2xpY2UgPSB0aGlzLmJ5dGVzLnN1YmFycmF5KHRoaXMucG9zLCB0aGlzLnBvcyArIGxlbmd0aCk7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgIH1cbiAgICByZWFkVTgoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZWFkVTE2KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5wb3MsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZWFkVTI0KCkge1xuICAgICAgICBjb25zdCBoaWdoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLnBvcywgZmFsc2UpO1xuICAgICAgICBjb25zdCBsb3cgPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3MgKyAxKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gMztcbiAgICAgICAgcmV0dXJuIGhpZ2ggKiAweDEwMCArIGxvdztcbiAgICB9XG4gICAgcmVhZFUzMigpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMucG9zLCBmYWxzZSk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmVhZEFzY2lpKGxlbmd0aCkge1xuICAgICAgICBsZXQgc3RyID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvcyArIGkpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJlYWRJZDNWMkZyYW1lKCkge1xuICAgICAgICBpZiAodGhpcy5oZWFkZXIubWFqb3JWZXJzaW9uID09PSAyKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHRoaXMucmVhZEFzY2lpKDMpO1xuICAgICAgICAgICAgaWYgKGlkID09PSAnXFx4MDBcXHgwMFxceDAwJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMucmVhZFUyNCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgaWQsIHNpemUsIGZsYWdzOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHRoaXMucmVhZEFzY2lpKDQpO1xuICAgICAgICAgICAgaWYgKGlkID09PSAnXFx4MDBcXHgwMFxceDAwXFx4MDAnKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UndmUgbGFuZGVkIGluIHRoZSBwYWRkaW5nIHNlY3Rpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpemVSYXcgPSB0aGlzLnJlYWRVMzIoKTtcbiAgICAgICAgICAgIGxldCBzaXplID0gdGhpcy5oZWFkZXIubWFqb3JWZXJzaW9uID09PSA0XG4gICAgICAgICAgICAgICAgPyBkZWNvZGVTeW5jaHNhZmUoc2l6ZVJhdylcbiAgICAgICAgICAgICAgICA6IHNpemVSYXc7XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IHRoaXMucmVhZFUxNigpO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyRW5kUG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICAvLyBTb21lIGZpbGVzIG1heSBoYXZlIGluY29ycmVjdGx5IHN5bmNoc2FmZWQvdW5zeW5jaHNhZmVkIHNpemVzLiBUbyB2YWxpZGF0ZSB3aGljaCBpbnRlcnByZXRhdGlvbiBpcyB2YWxpZCxcbiAgICAgICAgICAgIC8vIHdlIHZhbGlkYXRlIGEgc2l6ZSBieSBza2lwcGluZyBhaGVhZCBhbmQgc2VlaW5nIGlmIHdlIGxhbmQgYXQgYSB2YWxpZCBmcmFtZSBoZWFkZXIgKG9yIGF0IHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAvLyB0YWcuXG4gICAgICAgICAgICBjb25zdCBpc1NpemVWYWxpZCA9IChzaXplKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBvcyA9IHRoaXMucG9zICsgc2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFBvcyA+IHRoaXMuYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHRQb3MgPD0gdGhpcy5ieXRlcy5sZW5ndGggLSB0aGlzLmZyYW1lSGVhZGVyU2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IHNpemU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJZCA9IHRoaXMucmVhZEFzY2lpKDQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dElkICE9PSAnXFx4MDBcXHgwMFxceDAwXFx4MDAnICYmICEvWzAtOUEtWl17NH0vLnRlc3QobmV4dElkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghaXNTaXplVmFsaWQoc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBGbGlwIHRoZSBzeW5jaHNhZmluZywgYW5kIHRyeSBpZiB0aGlzIG9uZSBtYWtlcyBtb3JlIHNlbnNlXG4gICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJTaXplID0gdGhpcy5oZWFkZXIubWFqb3JWZXJzaW9uID09PSA0XG4gICAgICAgICAgICAgICAgICAgID8gc2l6ZVJhd1xuICAgICAgICAgICAgICAgICAgICA6IGRlY29kZVN5bmNoc2FmZShzaXplUmF3KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNTaXplVmFsaWQob3RoZXJTaXplKSkge1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gb3RoZXJTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucG9zID0gaGVhZGVyRW5kUG9zO1xuICAgICAgICAgICAgcmV0dXJuIHsgaWQsIHNpemUsIGZsYWdzIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZElkM1YyVGV4dEVuY29kaW5nKCkge1xuICAgICAgICBjb25zdCBudW1iZXIgPSB0aGlzLnJlYWRVOCgpO1xuICAgICAgICBpZiAobnVtYmVyID4gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0ZXh0IGVuY29kaW5nOiAke251bWJlcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cbiAgICByZWFkSWQzVjJUZXh0KGVuY29kaW5nLCB1bnRpbCkge1xuICAgICAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMucG9zO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5yZWFkQnl0ZXModW50aWwpO1xuICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICAgICAgICBjYXNlIElkM1YyVGV4dEVuY29kaW5nLklTT184ODU5XzE6IHtcbiAgICAgICAgICAgICAgICBsZXQgc3RyID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zICsgaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIElkM1YyVGV4dEVuY29kaW5nLlVURl8xNl9XSVRIX0JPTToge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhWzBdID09PSAweGZmICYmIGRhdGFbMV0gPT09IDB4ZmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTE2bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kSW5kZXggPSBjb2FsZXNjZUluZGV4KGRhdGEuZmluZEluZGV4KCh4LCBpKSA9PiB4ID09PSAwICYmIGRhdGFbaSArIDFdID09PSAwICYmIGkgJSAyID09PSAwKSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zICsgTWF0aC5taW4oZW5kSW5kZXggKyAyLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShkYXRhLnN1YmFycmF5KDIsIGVuZEluZGV4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFbMF0gPT09IDB4ZmUgJiYgZGF0YVsxXSA9PT0gMHhmZikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtMTZiZScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmRJbmRleCA9IGNvYWxlc2NlSW5kZXgoZGF0YS5maW5kSW5kZXgoKHgsIGkpID0+IHggPT09IDAgJiYgZGF0YVtpICsgMV0gPT09IDAgJiYgaSAlIDIgPT09IDApLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zID0gc3RhcnRQb3MgKyBNYXRoLm1pbihlbmRJbmRleCArIDIsIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGRhdGEuc3ViYXJyYXkoMiwgZW5kSW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyZWF0IGl0IGxpa2UgVVRGLTgsIHNvbWUgZmlsZXMgZG8gdGhpc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmRJbmRleCA9IGNvYWxlc2NlSW5kZXgoZGF0YS5maW5kSW5kZXgoeCA9PiB4ID09PSAwKSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zICsgTWF0aC5taW4oZW5kSW5kZXggKyAxLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0RGVjb2Rlci5kZWNvZGUoZGF0YS5zdWJhcnJheSgwLCBlbmRJbmRleCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgSWQzVjJUZXh0RW5jb2RpbmcuVVRGXzE2X0JFX05PX0JPTToge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi0xNmJlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kSW5kZXggPSBjb2FsZXNjZUluZGV4KGRhdGEuZmluZEluZGV4KCh4LCBpKSA9PiB4ID09PSAwICYmIGRhdGFbaSArIDFdID09PSAwICYmIGkgJSAyID09PSAwKSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gc3RhcnRQb3MgKyBNYXRoLm1pbihlbmRJbmRleCArIDIsIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoZGF0YS5zdWJhcnJheSgwLCBlbmRJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBJZDNWMlRleHRFbmNvZGluZy5VVEZfODoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gY29hbGVzY2VJbmRleChkYXRhLmZpbmRJbmRleCh4ID0+IHggPT09IDApLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBzdGFydFBvcyArIE1hdGgubWluKGVuZEluZGV4ICsgMSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0RGVjb2Rlci5kZWNvZGUoZGF0YS5zdWJhcnJheSgwLCBlbmRJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWRJZDNWMkVuY29kaW5nQW5kVGV4dCh1bnRpbCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdW50aWwpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGluZyA9IHRoaXMucmVhZElkM1YyVGV4dEVuY29kaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRJZDNWMlRleHQoZW5jb2RpbmcsIHVudGlsKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/mp3/mp3-reader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/mp3/mp3-writer.js":
/*!********************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/mp3/mp3-writer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mp3Writer: () => (/* binding */ Mp3Writer)\n/* harmony export */ });\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/* harmony import */ var _shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/mp3-misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/shared/mp3-misc.js\");\n/* harmony import */ var _mp3_reader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mp3-reader.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/mp3/mp3-reader.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\nclass Mp3Writer {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n    }\n    writeU8(value) {\n        this.helper[0] = value;\n        this.writer.write(this.helper.subarray(0, 1));\n    }\n    writeU16(value) {\n        this.helperView.setUint16(0, value, false);\n        this.writer.write(this.helper.subarray(0, 2));\n    }\n    writeU32(value) {\n        this.helperView.setUint32(0, value, false);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeAscii(text) {\n        for (let i = 0; i < text.length; i++) {\n            this.helper[i] = text.charCodeAt(i);\n        }\n        this.writer.write(this.helper.subarray(0, text.length));\n    }\n    writeSynchsafeU32(value) {\n        this.writeU32((0,_shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_0__.encodeSynchsafe)(value));\n    }\n    writeIsoString(text) {\n        const bytes = new Uint8Array(text.length + 1);\n        for (let i = 0; i < text.length; i++) {\n            bytes[i] = text.charCodeAt(i);\n        }\n        bytes[text.length] = 0x00;\n        this.writer.write(bytes);\n    }\n    writeUtf8String(text) {\n        const utf8Data = _misc_js__WEBPACK_IMPORTED_MODULE_1__.textEncoder.encode(text);\n        this.writer.write(utf8Data);\n        this.writeU8(0x00);\n    }\n    writeId3V2TextFrame(frameId, text) {\n        const useIso88591 = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.isIso88591Compatible)(text);\n        const textDataLength = useIso88591 ? text.length : _misc_js__WEBPACK_IMPORTED_MODULE_1__.textEncoder.encode(text).byteLength;\n        const frameSize = 1 + textDataLength + 1;\n        this.writeAscii(frameId);\n        this.writeSynchsafeU32(frameSize);\n        this.writeU16(0x0000);\n        this.writeU8(useIso88591 ? _mp3_reader_js__WEBPACK_IMPORTED_MODULE_2__.Id3V2TextEncoding.ISO_8859_1 : _mp3_reader_js__WEBPACK_IMPORTED_MODULE_2__.Id3V2TextEncoding.UTF_8);\n        if (useIso88591) {\n            this.writeIsoString(text);\n        }\n        else {\n            this.writeUtf8String(text);\n        }\n    }\n    writeId3V2LyricsFrame(lyrics) {\n        const useIso88591 = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.isIso88591Compatible)(lyrics);\n        const shortDescription = '';\n        const frameSize = 1 + 3 + shortDescription.length + 1 + lyrics.length + 1;\n        this.writeAscii('USLT');\n        this.writeSynchsafeU32(frameSize);\n        this.writeU16(0x0000);\n        this.writeU8(useIso88591 ? _mp3_reader_js__WEBPACK_IMPORTED_MODULE_2__.Id3V2TextEncoding.ISO_8859_1 : _mp3_reader_js__WEBPACK_IMPORTED_MODULE_2__.Id3V2TextEncoding.UTF_8);\n        this.writeAscii('und');\n        if (useIso88591) {\n            this.writeIsoString(shortDescription);\n            this.writeIsoString(lyrics);\n        }\n        else {\n            this.writeUtf8String(shortDescription);\n            this.writeUtf8String(lyrics);\n        }\n    }\n    writeId3V2CommentFrame(comment) {\n        const useIso88591 = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.isIso88591Compatible)(comment);\n        const textDataLength = useIso88591 ? comment.length : _misc_js__WEBPACK_IMPORTED_MODULE_1__.textEncoder.encode(comment).byteLength;\n        const shortDescription = '';\n        const frameSize = 1 + 3 + shortDescription.length + 1 + textDataLength + 1;\n        this.writeAscii('COMM');\n        this.writeSynchsafeU32(frameSize);\n        this.writeU16(0x0000);\n        this.writeU8(useIso88591 ? _mp3_reader_js__WEBPACK_IMPORTED_MODULE_2__.Id3V2TextEncoding.ISO_8859_1 : _mp3_reader_js__WEBPACK_IMPORTED_MODULE_2__.Id3V2TextEncoding.UTF_8);\n        this.writeU8(0x75); // 'u'\n        this.writeU8(0x6E); // 'n'\n        this.writeU8(0x64); // 'd'\n        if (useIso88591) {\n            this.writeIsoString(shortDescription);\n            this.writeIsoString(comment);\n        }\n        else {\n            this.writeUtf8String(shortDescription);\n            this.writeUtf8String(comment);\n        }\n    }\n    writeId3V2ApicFrame(mimeType, pictureType, description, imageData) {\n        const useIso88591 = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.isIso88591Compatible)(mimeType) && (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.isIso88591Compatible)(description);\n        const descriptionDataLength = useIso88591 ? description.length : _misc_js__WEBPACK_IMPORTED_MODULE_1__.textEncoder.encode(description).byteLength;\n        const frameSize = 1 + mimeType.length + 1 + 1 + descriptionDataLength + 1 + imageData.byteLength;\n        this.writeAscii('APIC');\n        this.writeSynchsafeU32(frameSize);\n        this.writeU16(0x0000);\n        this.writeU8(useIso88591 ? _mp3_reader_js__WEBPACK_IMPORTED_MODULE_2__.Id3V2TextEncoding.ISO_8859_1 : _mp3_reader_js__WEBPACK_IMPORTED_MODULE_2__.Id3V2TextEncoding.UTF_8);\n        if (useIso88591) {\n            this.writeIsoString(mimeType);\n        }\n        else {\n            this.writeUtf8String(mimeType);\n        }\n        this.writeU8(pictureType);\n        if (useIso88591) {\n            this.writeIsoString(description);\n        }\n        else {\n            this.writeUtf8String(description);\n        }\n        this.writer.write(imageData);\n    }\n    writeXingFrame(data) {\n        const startPos = this.writer.getPos();\n        const firstByte = 0xff;\n        const secondByte = 0xe0 | (data.mpegVersionId << 3) | (data.layer << 1);\n        const bitrateGroup = data.mpegVersionId === 3 ? _shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_0__.MPEG_V1_BITRATES : _shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_0__.MPEG_V2_BITRATES;\n        const bitrates = bitrateGroup?.[data.layer];\n        if (!bitrates) {\n            throw new Error('Invalid MPEG version and layer combination.');\n        }\n        const sampleRate = _shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_0__.SAMPLING_RATES[data.mpegVersionId]?.[data.frequencyIndex];\n        if (!sampleRate || sampleRate === -1) {\n            throw new Error('Invalid MPEG version and frequency index combination.');\n        }\n        const padding = 0;\n        const neededBytes = 155;\n        // Let's find the lowest bitrate for which the frame size is sufficiently large to fit all the data\n        const bitrateIndex = bitrates.findIndex((kbr) => {\n            return (0,_shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_0__.computeMp3FrameSize)(data.layer, 1000 * kbr, sampleRate, padding) >= neededBytes;\n        });\n        if (bitrateIndex === -1) {\n            throw new Error('No suitable bitrate found.');\n        }\n        const thirdByte = (bitrateIndex << 4) | (data.frequencyIndex << 2) | padding << 1;\n        const fourthByte = (data.channel << 6)\n            | (data.modeExtension << 4)\n            | (data.copyright << 3)\n            | (data.original << 2)\n            | data.emphasis;\n        this.helper[0] = firstByte;\n        this.helper[1] = secondByte;\n        this.helper[2] = thirdByte;\n        this.helper[3] = fourthByte;\n        this.writer.write(this.helper.subarray(0, 4));\n        const xingOffset = (0,_shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_0__.getXingOffset)(data.mpegVersionId, data.channel);\n        this.writer.seek(startPos + xingOffset);\n        this.writeU32(_shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_0__.XING);\n        let flags = 0;\n        if (data.frameCount !== null) {\n            flags |= 1;\n        }\n        if (data.fileSize !== null) {\n            flags |= 2;\n        }\n        if (data.toc !== null) {\n            flags |= 4;\n        }\n        this.writeU32(flags);\n        this.writeU32(data.frameCount ?? 0);\n        this.writeU32(data.fileSize ?? 0);\n        this.writer.write(data.toc ?? new Uint8Array(100));\n        const frameSize = (0,_shared_mp3_misc_js__WEBPACK_IMPORTED_MODULE_0__.computeMp3FrameSize)(data.layer, 1000 * bitrates[bitrateIndex], sampleRate, padding);\n        this.writer.seek(startPos + frameSize);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL21wMy9tcDMtd3JpdGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrRDtBQUMyRjtBQUN0RztBQUM3QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvRUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4REFBb0I7QUFDaEQsMkRBQTJELGlEQUFXO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDZEQUFpQixjQUFjLDZEQUFpQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhEQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDZEQUFpQixjQUFjLDZEQUFpQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhEQUFvQjtBQUNoRCw4REFBOEQsaURBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw2REFBaUIsY0FBYyw2REFBaUI7QUFDbkYsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOERBQW9CLGNBQWMsOERBQW9CO0FBQ2xGLHlFQUF5RSxpREFBVztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw2REFBaUIsY0FBYyw2REFBaUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsaUVBQWdCLEdBQUcsaUVBQWdCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtEQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdFQUFtQjtBQUN0QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrRUFBYTtBQUN4QztBQUNBLHNCQUFzQixxREFBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdFQUFtQjtBQUM3QztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRjaC1jdXQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL21lZGlhYnVubnkvZGlzdC9tb2R1bGVzL3NyYy9tcDMvbXAzLXdyaXRlci5qcz80NzljIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDI1LXByZXNlbnQsIFZhbmlsYWd5IGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgaXNJc284ODU5MUNvbXBhdGlibGUsIHRleHRFbmNvZGVyIH0gZnJvbSAnLi4vbWlzYy5qcyc7XG5pbXBvcnQgeyBjb21wdXRlTXAzRnJhbWVTaXplLCBlbmNvZGVTeW5jaHNhZmUsIGdldFhpbmdPZmZzZXQsIE1QRUdfVjFfQklUUkFURVMsIE1QRUdfVjJfQklUUkFURVMsIFNBTVBMSU5HX1JBVEVTLCBYSU5HLCB9IGZyb20gJy4uLy4uL3NoYXJlZC9tcDMtbWlzYy5qcyc7XG5pbXBvcnQgeyBJZDNWMlRleHRFbmNvZGluZyB9IGZyb20gJy4vbXAzLXJlYWRlci5qcyc7XG5leHBvcnQgY2xhc3MgTXAzV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih3cml0ZXIpIHtcbiAgICAgICAgdGhpcy53cml0ZXIgPSB3cml0ZXI7XG4gICAgICAgIHRoaXMuaGVscGVyID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgIHRoaXMuaGVscGVyVmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLmhlbHBlci5idWZmZXIpO1xuICAgIH1cbiAgICB3cml0ZVU4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaGVscGVyWzBdID0gdmFsdWU7XG4gICAgICAgIHRoaXMud3JpdGVyLndyaXRlKHRoaXMuaGVscGVyLnN1YmFycmF5KDAsIDEpKTtcbiAgICB9XG4gICAgd3JpdGVVMTYodmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWxwZXJWaWV3LnNldFVpbnQxNigwLCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLndyaXRlci53cml0ZSh0aGlzLmhlbHBlci5zdWJhcnJheSgwLCAyKSk7XG4gICAgfVxuICAgIHdyaXRlVTMyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaGVscGVyVmlldy5zZXRVaW50MzIoMCwgdmFsdWUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy53cml0ZXIud3JpdGUodGhpcy5oZWxwZXIuc3ViYXJyYXkoMCwgNCkpO1xuICAgIH1cbiAgICB3cml0ZUFzY2lpKHRleHQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmhlbHBlcltpXSA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlci53cml0ZSh0aGlzLmhlbHBlci5zdWJhcnJheSgwLCB0ZXh0Lmxlbmd0aCkpO1xuICAgIH1cbiAgICB3cml0ZVN5bmNoc2FmZVUzMih2YWx1ZSkge1xuICAgICAgICB0aGlzLndyaXRlVTMyKGVuY29kZVN5bmNoc2FmZSh2YWx1ZSkpO1xuICAgIH1cbiAgICB3cml0ZUlzb1N0cmluZyh0ZXh0KSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGV4dC5sZW5ndGggKyAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBieXRlc1tpXSA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlc1t0ZXh0Lmxlbmd0aF0gPSAweDAwO1xuICAgICAgICB0aGlzLndyaXRlci53cml0ZShieXRlcyk7XG4gICAgfVxuICAgIHdyaXRlVXRmOFN0cmluZyh0ZXh0KSB7XG4gICAgICAgIGNvbnN0IHV0ZjhEYXRhID0gdGV4dEVuY29kZXIuZW5jb2RlKHRleHQpO1xuICAgICAgICB0aGlzLndyaXRlci53cml0ZSh1dGY4RGF0YSk7XG4gICAgICAgIHRoaXMud3JpdGVVOCgweDAwKTtcbiAgICB9XG4gICAgd3JpdGVJZDNWMlRleHRGcmFtZShmcmFtZUlkLCB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IHVzZUlzbzg4NTkxID0gaXNJc284ODU5MUNvbXBhdGlibGUodGV4dCk7XG4gICAgICAgIGNvbnN0IHRleHREYXRhTGVuZ3RoID0gdXNlSXNvODg1OTEgPyB0ZXh0Lmxlbmd0aCA6IHRleHRFbmNvZGVyLmVuY29kZSh0ZXh0KS5ieXRlTGVuZ3RoO1xuICAgICAgICBjb25zdCBmcmFtZVNpemUgPSAxICsgdGV4dERhdGFMZW5ndGggKyAxO1xuICAgICAgICB0aGlzLndyaXRlQXNjaWkoZnJhbWVJZCk7XG4gICAgICAgIHRoaXMud3JpdGVTeW5jaHNhZmVVMzIoZnJhbWVTaXplKTtcbiAgICAgICAgdGhpcy53cml0ZVUxNigweDAwMDApO1xuICAgICAgICB0aGlzLndyaXRlVTgodXNlSXNvODg1OTEgPyBJZDNWMlRleHRFbmNvZGluZy5JU09fODg1OV8xIDogSWQzVjJUZXh0RW5jb2RpbmcuVVRGXzgpO1xuICAgICAgICBpZiAodXNlSXNvODg1OTEpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVJc29TdHJpbmcodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlVXRmOFN0cmluZyh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUlkM1YyTHlyaWNzRnJhbWUobHlyaWNzKSB7XG4gICAgICAgIGNvbnN0IHVzZUlzbzg4NTkxID0gaXNJc284ODU5MUNvbXBhdGlibGUobHlyaWNzKTtcbiAgICAgICAgY29uc3Qgc2hvcnREZXNjcmlwdGlvbiA9ICcnO1xuICAgICAgICBjb25zdCBmcmFtZVNpemUgPSAxICsgMyArIHNob3J0RGVzY3JpcHRpb24ubGVuZ3RoICsgMSArIGx5cmljcy5sZW5ndGggKyAxO1xuICAgICAgICB0aGlzLndyaXRlQXNjaWkoJ1VTTFQnKTtcbiAgICAgICAgdGhpcy53cml0ZVN5bmNoc2FmZVUzMihmcmFtZVNpemUpO1xuICAgICAgICB0aGlzLndyaXRlVTE2KDB4MDAwMCk7XG4gICAgICAgIHRoaXMud3JpdGVVOCh1c2VJc284ODU5MSA/IElkM1YyVGV4dEVuY29kaW5nLklTT184ODU5XzEgOiBJZDNWMlRleHRFbmNvZGluZy5VVEZfOCk7XG4gICAgICAgIHRoaXMud3JpdGVBc2NpaSgndW5kJyk7XG4gICAgICAgIGlmICh1c2VJc284ODU5MSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZUlzb1N0cmluZyhzaG9ydERlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVJc29TdHJpbmcobHlyaWNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVVdGY4U3RyaW5nKHNob3J0RGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgdGhpcy53cml0ZVV0ZjhTdHJpbmcobHlyaWNzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUlkM1YyQ29tbWVudEZyYW1lKGNvbW1lbnQpIHtcbiAgICAgICAgY29uc3QgdXNlSXNvODg1OTEgPSBpc0lzbzg4NTkxQ29tcGF0aWJsZShjb21tZW50KTtcbiAgICAgICAgY29uc3QgdGV4dERhdGFMZW5ndGggPSB1c2VJc284ODU5MSA/IGNvbW1lbnQubGVuZ3RoIDogdGV4dEVuY29kZXIuZW5jb2RlKGNvbW1lbnQpLmJ5dGVMZW5ndGg7XG4gICAgICAgIGNvbnN0IHNob3J0RGVzY3JpcHRpb24gPSAnJztcbiAgICAgICAgY29uc3QgZnJhbWVTaXplID0gMSArIDMgKyBzaG9ydERlc2NyaXB0aW9uLmxlbmd0aCArIDEgKyB0ZXh0RGF0YUxlbmd0aCArIDE7XG4gICAgICAgIHRoaXMud3JpdGVBc2NpaSgnQ09NTScpO1xuICAgICAgICB0aGlzLndyaXRlU3luY2hzYWZlVTMyKGZyYW1lU2l6ZSk7XG4gICAgICAgIHRoaXMud3JpdGVVMTYoMHgwMDAwKTtcbiAgICAgICAgdGhpcy53cml0ZVU4KHVzZUlzbzg4NTkxID8gSWQzVjJUZXh0RW5jb2RpbmcuSVNPXzg4NTlfMSA6IElkM1YyVGV4dEVuY29kaW5nLlVURl84KTtcbiAgICAgICAgdGhpcy53cml0ZVU4KDB4NzUpOyAvLyAndSdcbiAgICAgICAgdGhpcy53cml0ZVU4KDB4NkUpOyAvLyAnbidcbiAgICAgICAgdGhpcy53cml0ZVU4KDB4NjQpOyAvLyAnZCdcbiAgICAgICAgaWYgKHVzZUlzbzg4NTkxKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlSXNvU3RyaW5nKHNob3J0RGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgdGhpcy53cml0ZUlzb1N0cmluZyhjb21tZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVVdGY4U3RyaW5nKHNob3J0RGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgdGhpcy53cml0ZVV0ZjhTdHJpbmcoY29tbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVJZDNWMkFwaWNGcmFtZShtaW1lVHlwZSwgcGljdHVyZVR5cGUsIGRlc2NyaXB0aW9uLCBpbWFnZURhdGEpIHtcbiAgICAgICAgY29uc3QgdXNlSXNvODg1OTEgPSBpc0lzbzg4NTkxQ29tcGF0aWJsZShtaW1lVHlwZSkgJiYgaXNJc284ODU5MUNvbXBhdGlibGUoZGVzY3JpcHRpb24pO1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbkRhdGFMZW5ndGggPSB1c2VJc284ODU5MSA/IGRlc2NyaXB0aW9uLmxlbmd0aCA6IHRleHRFbmNvZGVyLmVuY29kZShkZXNjcmlwdGlvbikuYnl0ZUxlbmd0aDtcbiAgICAgICAgY29uc3QgZnJhbWVTaXplID0gMSArIG1pbWVUeXBlLmxlbmd0aCArIDEgKyAxICsgZGVzY3JpcHRpb25EYXRhTGVuZ3RoICsgMSArIGltYWdlRGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICB0aGlzLndyaXRlQXNjaWkoJ0FQSUMnKTtcbiAgICAgICAgdGhpcy53cml0ZVN5bmNoc2FmZVUzMihmcmFtZVNpemUpO1xuICAgICAgICB0aGlzLndyaXRlVTE2KDB4MDAwMCk7XG4gICAgICAgIHRoaXMud3JpdGVVOCh1c2VJc284ODU5MSA/IElkM1YyVGV4dEVuY29kaW5nLklTT184ODU5XzEgOiBJZDNWMlRleHRFbmNvZGluZy5VVEZfOCk7XG4gICAgICAgIGlmICh1c2VJc284ODU5MSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZUlzb1N0cmluZyhtaW1lVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlVXRmOFN0cmluZyhtaW1lVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZVU4KHBpY3R1cmVUeXBlKTtcbiAgICAgICAgaWYgKHVzZUlzbzg4NTkxKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlSXNvU3RyaW5nKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVVdGY4U3RyaW5nKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlci53cml0ZShpbWFnZURhdGEpO1xuICAgIH1cbiAgICB3cml0ZVhpbmdGcmFtZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy53cml0ZXIuZ2V0UG9zKCk7XG4gICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IDB4ZmY7XG4gICAgICAgIGNvbnN0IHNlY29uZEJ5dGUgPSAweGUwIHwgKGRhdGEubXBlZ1ZlcnNpb25JZCA8PCAzKSB8IChkYXRhLmxheWVyIDw8IDEpO1xuICAgICAgICBjb25zdCBiaXRyYXRlR3JvdXAgPSBkYXRhLm1wZWdWZXJzaW9uSWQgPT09IDMgPyBNUEVHX1YxX0JJVFJBVEVTIDogTVBFR19WMl9CSVRSQVRFUztcbiAgICAgICAgY29uc3QgYml0cmF0ZXMgPSBiaXRyYXRlR3JvdXA/LltkYXRhLmxheWVyXTtcbiAgICAgICAgaWYgKCFiaXRyYXRlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIE1QRUcgdmVyc2lvbiBhbmQgbGF5ZXIgY29tYmluYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2FtcGxlUmF0ZSA9IFNBTVBMSU5HX1JBVEVTW2RhdGEubXBlZ1ZlcnNpb25JZF0/LltkYXRhLmZyZXF1ZW5jeUluZGV4XTtcbiAgICAgICAgaWYgKCFzYW1wbGVSYXRlIHx8IHNhbXBsZVJhdGUgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTVBFRyB2ZXJzaW9uIGFuZCBmcmVxdWVuY3kgaW5kZXggY29tYmluYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFkZGluZyA9IDA7XG4gICAgICAgIGNvbnN0IG5lZWRlZEJ5dGVzID0gMTU1O1xuICAgICAgICAvLyBMZXQncyBmaW5kIHRoZSBsb3dlc3QgYml0cmF0ZSBmb3Igd2hpY2ggdGhlIGZyYW1lIHNpemUgaXMgc3VmZmljaWVudGx5IGxhcmdlIHRvIGZpdCBhbGwgdGhlIGRhdGFcbiAgICAgICAgY29uc3QgYml0cmF0ZUluZGV4ID0gYml0cmF0ZXMuZmluZEluZGV4KChrYnIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlTXAzRnJhbWVTaXplKGRhdGEubGF5ZXIsIDEwMDAgKiBrYnIsIHNhbXBsZVJhdGUsIHBhZGRpbmcpID49IG5lZWRlZEJ5dGVzO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGJpdHJhdGVJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VpdGFibGUgYml0cmF0ZSBmb3VuZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aGlyZEJ5dGUgPSAoYml0cmF0ZUluZGV4IDw8IDQpIHwgKGRhdGEuZnJlcXVlbmN5SW5kZXggPDwgMikgfCBwYWRkaW5nIDw8IDE7XG4gICAgICAgIGNvbnN0IGZvdXJ0aEJ5dGUgPSAoZGF0YS5jaGFubmVsIDw8IDYpXG4gICAgICAgICAgICB8IChkYXRhLm1vZGVFeHRlbnNpb24gPDwgNClcbiAgICAgICAgICAgIHwgKGRhdGEuY29weXJpZ2h0IDw8IDMpXG4gICAgICAgICAgICB8IChkYXRhLm9yaWdpbmFsIDw8IDIpXG4gICAgICAgICAgICB8IGRhdGEuZW1waGFzaXM7XG4gICAgICAgIHRoaXMuaGVscGVyWzBdID0gZmlyc3RCeXRlO1xuICAgICAgICB0aGlzLmhlbHBlclsxXSA9IHNlY29uZEJ5dGU7XG4gICAgICAgIHRoaXMuaGVscGVyWzJdID0gdGhpcmRCeXRlO1xuICAgICAgICB0aGlzLmhlbHBlclszXSA9IGZvdXJ0aEJ5dGU7XG4gICAgICAgIHRoaXMud3JpdGVyLndyaXRlKHRoaXMuaGVscGVyLnN1YmFycmF5KDAsIDQpKTtcbiAgICAgICAgY29uc3QgeGluZ09mZnNldCA9IGdldFhpbmdPZmZzZXQoZGF0YS5tcGVnVmVyc2lvbklkLCBkYXRhLmNoYW5uZWwpO1xuICAgICAgICB0aGlzLndyaXRlci5zZWVrKHN0YXJ0UG9zICsgeGluZ09mZnNldCk7XG4gICAgICAgIHRoaXMud3JpdGVVMzIoWElORyk7XG4gICAgICAgIGxldCBmbGFncyA9IDA7XG4gICAgICAgIGlmIChkYXRhLmZyYW1lQ291bnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZmlsZVNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEudG9jICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmbGFncyB8PSA0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVVMzIoZmxhZ3MpO1xuICAgICAgICB0aGlzLndyaXRlVTMyKGRhdGEuZnJhbWVDb3VudCA/PyAwKTtcbiAgICAgICAgdGhpcy53cml0ZVUzMihkYXRhLmZpbGVTaXplID8/IDApO1xuICAgICAgICB0aGlzLndyaXRlci53cml0ZShkYXRhLnRvYyA/PyBuZXcgVWludDhBcnJheSgxMDApKTtcbiAgICAgICAgY29uc3QgZnJhbWVTaXplID0gY29tcHV0ZU1wM0ZyYW1lU2l6ZShkYXRhLmxheWVyLCAxMDAwICogYml0cmF0ZXNbYml0cmF0ZUluZGV4XSwgc2FtcGxlUmF0ZSwgcGFkZGluZyk7XG4gICAgICAgIHRoaXMud3JpdGVyLnNlZWsoc3RhcnRQb3MgKyBmcmFtZVNpemUpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/mp3/mp3-writer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/muxer.js":
/*!***********************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/muxer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Muxer: () => (/* binding */ Muxer)\n/* harmony export */ });\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\nclass Muxer {\n    constructor(output) {\n        this.mutex = new _misc_js__WEBPACK_IMPORTED_MODULE_0__.AsyncMutex();\n        /**\n         * This field is used to synchronize multiple MediaStreamTracks. They use the same time coordinate system across\n         * tracks, and to ensure correct audio-video sync, we must use the same offset for all of them. The reason an offset\n         * is needed at all is because the timestamps typically don't start at zero.\n         */\n        this.firstMediaStreamTimestamp = null;\n        this.trackTimestampInfo = new WeakMap();\n        this.output = output;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onTrackClose(track) { }\n    validateAndNormalizeTimestamp(track, timestampInSeconds, isKeyFrame) {\n        timestampInSeconds += track.source._timestampOffset;\n        let timestampInfo = this.trackTimestampInfo.get(track);\n        if (!timestampInfo) {\n            if (!isKeyFrame) {\n                throw new Error('First frame must be a key frame.');\n            }\n            timestampInfo = {\n                maxTimestamp: timestampInSeconds,\n                maxTimestampBeforeLastKeyFrame: timestampInSeconds,\n            };\n            this.trackTimestampInfo.set(track, timestampInfo);\n        }\n        if (timestampInSeconds < 0) {\n            throw new Error(`Timestamps must be non-negative (got ${timestampInSeconds}s).`);\n        }\n        if (isKeyFrame) {\n            timestampInfo.maxTimestampBeforeLastKeyFrame = timestampInfo.maxTimestamp;\n        }\n        if (timestampInSeconds < timestampInfo.maxTimestampBeforeLastKeyFrame) {\n            throw new Error(`Timestamps cannot be smaller than the highest timestamp of the previous run (a run begins with a`\n                + ` key frame and ends right before the next key frame). Got ${timestampInSeconds}s, but highest`\n                + ` timestamp is ${timestampInfo.maxTimestampBeforeLastKeyFrame}s.`);\n        }\n        timestampInfo.maxTimestamp = Math.max(timestampInfo.maxTimestamp, timestampInSeconds);\n        return timestampInSeconds;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL211eGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDdUM7QUFDaEM7QUFDUDtBQUNBLHlCQUF5QixnREFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxtQkFBbUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLG1CQUFtQjtBQUNsRyxtQ0FBbUMsNkNBQTZDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRjaC1jdXQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL21lZGlhYnVubnkvZGlzdC9tb2R1bGVzL3NyYy9tdXhlci5qcz80MzVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDI1LXByZXNlbnQsIFZhbmlsYWd5IGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgQXN5bmNNdXRleCB9IGZyb20gJy4vbWlzYy5qcyc7XG5leHBvcnQgY2xhc3MgTXV4ZXIge1xuICAgIGNvbnN0cnVjdG9yKG91dHB1dCkge1xuICAgICAgICB0aGlzLm11dGV4ID0gbmV3IEFzeW5jTXV0ZXgoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZmllbGQgaXMgdXNlZCB0byBzeW5jaHJvbml6ZSBtdWx0aXBsZSBNZWRpYVN0cmVhbVRyYWNrcy4gVGhleSB1c2UgdGhlIHNhbWUgdGltZSBjb29yZGluYXRlIHN5c3RlbSBhY3Jvc3NcbiAgICAgICAgICogdHJhY2tzLCBhbmQgdG8gZW5zdXJlIGNvcnJlY3QgYXVkaW8tdmlkZW8gc3luYywgd2UgbXVzdCB1c2UgdGhlIHNhbWUgb2Zmc2V0IGZvciBhbGwgb2YgdGhlbS4gVGhlIHJlYXNvbiBhbiBvZmZzZXRcbiAgICAgICAgICogaXMgbmVlZGVkIGF0IGFsbCBpcyBiZWNhdXNlIHRoZSB0aW1lc3RhbXBzIHR5cGljYWxseSBkb24ndCBzdGFydCBhdCB6ZXJvLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maXJzdE1lZGlhU3RyZWFtVGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmFja1RpbWVzdGFtcEluZm8gPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIG9uVHJhY2tDbG9zZSh0cmFjaykgeyB9XG4gICAgdmFsaWRhdGVBbmROb3JtYWxpemVUaW1lc3RhbXAodHJhY2ssIHRpbWVzdGFtcEluU2Vjb25kcywgaXNLZXlGcmFtZSkge1xuICAgICAgICB0aW1lc3RhbXBJblNlY29uZHMgKz0gdHJhY2suc291cmNlLl90aW1lc3RhbXBPZmZzZXQ7XG4gICAgICAgIGxldCB0aW1lc3RhbXBJbmZvID0gdGhpcy50cmFja1RpbWVzdGFtcEluZm8uZ2V0KHRyYWNrKTtcbiAgICAgICAgaWYgKCF0aW1lc3RhbXBJbmZvKSB7XG4gICAgICAgICAgICBpZiAoIWlzS2V5RnJhbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGZyYW1lIG11c3QgYmUgYSBrZXkgZnJhbWUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1lc3RhbXBJbmZvID0ge1xuICAgICAgICAgICAgICAgIG1heFRpbWVzdGFtcDogdGltZXN0YW1wSW5TZWNvbmRzLFxuICAgICAgICAgICAgICAgIG1heFRpbWVzdGFtcEJlZm9yZUxhc3RLZXlGcmFtZTogdGltZXN0YW1wSW5TZWNvbmRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tUaW1lc3RhbXBJbmZvLnNldCh0cmFjaywgdGltZXN0YW1wSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVzdGFtcEluU2Vjb25kcyA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGltZXN0YW1wcyBtdXN0IGJlIG5vbi1uZWdhdGl2ZSAoZ290ICR7dGltZXN0YW1wSW5TZWNvbmRzfXMpLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0tleUZyYW1lKSB7XG4gICAgICAgICAgICB0aW1lc3RhbXBJbmZvLm1heFRpbWVzdGFtcEJlZm9yZUxhc3RLZXlGcmFtZSA9IHRpbWVzdGFtcEluZm8ubWF4VGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lc3RhbXBJblNlY29uZHMgPCB0aW1lc3RhbXBJbmZvLm1heFRpbWVzdGFtcEJlZm9yZUxhc3RLZXlGcmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaW1lc3RhbXBzIGNhbm5vdCBiZSBzbWFsbGVyIHRoYW4gdGhlIGhpZ2hlc3QgdGltZXN0YW1wIG9mIHRoZSBwcmV2aW91cyBydW4gKGEgcnVuIGJlZ2lucyB3aXRoIGFgXG4gICAgICAgICAgICAgICAgKyBgIGtleSBmcmFtZSBhbmQgZW5kcyByaWdodCBiZWZvcmUgdGhlIG5leHQga2V5IGZyYW1lKS4gR290ICR7dGltZXN0YW1wSW5TZWNvbmRzfXMsIGJ1dCBoaWdoZXN0YFxuICAgICAgICAgICAgICAgICsgYCB0aW1lc3RhbXAgaXMgJHt0aW1lc3RhbXBJbmZvLm1heFRpbWVzdGFtcEJlZm9yZUxhc3RLZXlGcmFtZX1zLmApO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVzdGFtcEluZm8ubWF4VGltZXN0YW1wID0gTWF0aC5tYXgodGltZXN0YW1wSW5mby5tYXhUaW1lc3RhbXAsIHRpbWVzdGFtcEluU2Vjb25kcyk7XG4gICAgICAgIHJldHVybiB0aW1lc3RhbXBJblNlY29uZHM7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/muxer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/ogg/ogg-misc.js":
/*!******************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/ogg/ogg-misc.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OGGS: () => (/* binding */ OGGS),\n/* harmony export */   buildOggMimeType: () => (/* binding */ buildOggMimeType),\n/* harmony export */   computeOggPageCrc: () => (/* binding */ computeOggPageCrc),\n/* harmony export */   extractSampleMetadata: () => (/* binding */ extractSampleMetadata)\n/* harmony export */ });\n/* harmony import */ var _codec_data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../codec-data.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec-data.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\nconst OGGS = 0x5367674f; // 'OggS'\nconst OGG_CRC_POLYNOMIAL = 0x04c11db7;\nconst OGG_CRC_TABLE = new Uint32Array(256);\nfor (let n = 0; n < 256; n++) {\n    let crc = n << 24;\n    for (let k = 0; k < 8; k++) {\n        crc = (crc & 0x80000000)\n            ? ((crc << 1) ^ OGG_CRC_POLYNOMIAL)\n            : (crc << 1);\n    }\n    OGG_CRC_TABLE[n] = (crc >>> 0) & 0xffffffff;\n}\nconst computeOggPageCrc = (bytes) => {\n    const view = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.toDataView)(bytes);\n    const originalChecksum = view.getUint32(22, true);\n    view.setUint32(22, 0, true); // Zero out checksum field\n    let crc = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const byte = bytes[i];\n        crc = ((crc << 8) ^ OGG_CRC_TABLE[(crc >>> 24) ^ byte]) >>> 0;\n    }\n    view.setUint32(22, originalChecksum, true); // Restore checksum field\n    return crc;\n};\nconst extractSampleMetadata = (data, codecInfo, vorbisLastBlocksize) => {\n    let durationInSamples = 0;\n    let currentBlocksize = null;\n    if (data.length > 0) {\n        // To know sample duration, we'll need to peak inside the packet\n        if (codecInfo.codec === 'vorbis') {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(codecInfo.vorbisInfo);\n            const vorbisModeCount = codecInfo.vorbisInfo.modeBlockflags.length;\n            const bitCount = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.ilog)(vorbisModeCount - 1);\n            const modeMask = ((1 << bitCount) - 1) << 1;\n            const modeNumber = (data[0] & modeMask) >> 1;\n            if (modeNumber >= codecInfo.vorbisInfo.modeBlockflags.length) {\n                throw new Error('Invalid mode number.');\n            }\n            // In Vorbis, packet duration also depends on the blocksize of the previous packet\n            let prevBlocksize = vorbisLastBlocksize;\n            const blockflag = codecInfo.vorbisInfo.modeBlockflags[modeNumber];\n            currentBlocksize = codecInfo.vorbisInfo.blocksizes[blockflag];\n            if (blockflag === 1) {\n                const prevMask = (modeMask | 0x1) + 1;\n                const flag = data[0] & prevMask ? 1 : 0;\n                prevBlocksize = codecInfo.vorbisInfo.blocksizes[flag];\n            }\n            durationInSamples = prevBlocksize !== null\n                ? (prevBlocksize + currentBlocksize) >> 2\n                : 0; // The first sample outputs no audio data and therefore has a duration of 0\n        }\n        else if (codecInfo.codec === 'opus') {\n            const toc = (0,_codec_data_js__WEBPACK_IMPORTED_MODULE_1__.parseOpusTocByte)(data);\n            durationInSamples = toc.durationInSamples;\n        }\n    }\n    return {\n        durationInSamples,\n        vorbisBlockSize: currentBlocksize,\n    };\n};\nconst buildOggMimeType = (info) => {\n    let string = 'audio/ogg';\n    if (info.codecStrings) {\n        const uniqueCodecMimeTypes = [...new Set(info.codecStrings)];\n        string += `; codecs=\"${uniqueCodecMimeTypes.join(', ')}\"`;\n    }\n    return string;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL29nZy9vZ2ctbWlzYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNvRDtBQUNFO0FBQy9DLHlCQUF5QjtBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQixvREFBVTtBQUMzQjtBQUNBLGlDQUFpQztBQUNqQztBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFNO0FBQ2xCO0FBQ0EsNkJBQTZCLDhDQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVLGdDQUFnQztBQUMvRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRjaC1jdXQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL21lZGlhYnVubnkvZGlzdC9tb2R1bGVzL3NyYy9vZ2cvb2dnLW1pc2MuanM/NTllZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAyNS1wcmVzZW50LCBWYW5pbGFneSBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmltcG9ydCB7IHBhcnNlT3B1c1RvY0J5dGUgfSBmcm9tICcuLi9jb2RlYy1kYXRhLmpzJztcbmltcG9ydCB7IGFzc2VydCwgaWxvZywgdG9EYXRhVmlldyB9IGZyb20gJy4uL21pc2MuanMnO1xuZXhwb3J0IGNvbnN0IE9HR1MgPSAweDUzNjc2NzRmOyAvLyAnT2dnUydcbmNvbnN0IE9HR19DUkNfUE9MWU5PTUlBTCA9IDB4MDRjMTFkYjc7XG5jb25zdCBPR0dfQ1JDX1RBQkxFID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG5mb3IgKGxldCBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgbGV0IGNyYyA9IG4gPDwgMjQ7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgICAgY3JjID0gKGNyYyAmIDB4ODAwMDAwMDApXG4gICAgICAgICAgICA/ICgoY3JjIDw8IDEpIF4gT0dHX0NSQ19QT0xZTk9NSUFMKVxuICAgICAgICAgICAgOiAoY3JjIDw8IDEpO1xuICAgIH1cbiAgICBPR0dfQ1JDX1RBQkxFW25dID0gKGNyYyA+Pj4gMCkgJiAweGZmZmZmZmZmO1xufVxuZXhwb3J0IGNvbnN0IGNvbXB1dGVPZ2dQYWdlQ3JjID0gKGJ5dGVzKSA9PiB7XG4gICAgY29uc3QgdmlldyA9IHRvRGF0YVZpZXcoYnl0ZXMpO1xuICAgIGNvbnN0IG9yaWdpbmFsQ2hlY2tzdW0gPSB2aWV3LmdldFVpbnQzMigyMiwgdHJ1ZSk7XG4gICAgdmlldy5zZXRVaW50MzIoMjIsIDAsIHRydWUpOyAvLyBaZXJvIG91dCBjaGVja3N1bSBmaWVsZFxuICAgIGxldCBjcmMgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IGJ5dGVzW2ldO1xuICAgICAgICBjcmMgPSAoKGNyYyA8PCA4KSBeIE9HR19DUkNfVEFCTEVbKGNyYyA+Pj4gMjQpIF4gYnl0ZV0pID4+PiAwO1xuICAgIH1cbiAgICB2aWV3LnNldFVpbnQzMigyMiwgb3JpZ2luYWxDaGVja3N1bSwgdHJ1ZSk7IC8vIFJlc3RvcmUgY2hlY2tzdW0gZmllbGRcbiAgICByZXR1cm4gY3JjO1xufTtcbmV4cG9ydCBjb25zdCBleHRyYWN0U2FtcGxlTWV0YWRhdGEgPSAoZGF0YSwgY29kZWNJbmZvLCB2b3JiaXNMYXN0QmxvY2tzaXplKSA9PiB7XG4gICAgbGV0IGR1cmF0aW9uSW5TYW1wbGVzID0gMDtcbiAgICBsZXQgY3VycmVudEJsb2Nrc2l6ZSA9IG51bGw7XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBUbyBrbm93IHNhbXBsZSBkdXJhdGlvbiwgd2UnbGwgbmVlZCB0byBwZWFrIGluc2lkZSB0aGUgcGFja2V0XG4gICAgICAgIGlmIChjb2RlY0luZm8uY29kZWMgPT09ICd2b3JiaXMnKSB7XG4gICAgICAgICAgICBhc3NlcnQoY29kZWNJbmZvLnZvcmJpc0luZm8pO1xuICAgICAgICAgICAgY29uc3Qgdm9yYmlzTW9kZUNvdW50ID0gY29kZWNJbmZvLnZvcmJpc0luZm8ubW9kZUJsb2NrZmxhZ3MubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYml0Q291bnQgPSBpbG9nKHZvcmJpc01vZGVDb3VudCAtIDEpO1xuICAgICAgICAgICAgY29uc3QgbW9kZU1hc2sgPSAoKDEgPDwgYml0Q291bnQpIC0gMSkgPDwgMTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVOdW1iZXIgPSAoZGF0YVswXSAmIG1vZGVNYXNrKSA+PiAxO1xuICAgICAgICAgICAgaWYgKG1vZGVOdW1iZXIgPj0gY29kZWNJbmZvLnZvcmJpc0luZm8ubW9kZUJsb2NrZmxhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1vZGUgbnVtYmVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW4gVm9yYmlzLCBwYWNrZXQgZHVyYXRpb24gYWxzbyBkZXBlbmRzIG9uIHRoZSBibG9ja3NpemUgb2YgdGhlIHByZXZpb3VzIHBhY2tldFxuICAgICAgICAgICAgbGV0IHByZXZCbG9ja3NpemUgPSB2b3JiaXNMYXN0QmxvY2tzaXplO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tmbGFnID0gY29kZWNJbmZvLnZvcmJpc0luZm8ubW9kZUJsb2NrZmxhZ3NbbW9kZU51bWJlcl07XG4gICAgICAgICAgICBjdXJyZW50QmxvY2tzaXplID0gY29kZWNJbmZvLnZvcmJpc0luZm8uYmxvY2tzaXplc1tibG9ja2ZsYWddO1xuICAgICAgICAgICAgaWYgKGJsb2NrZmxhZyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZNYXNrID0gKG1vZGVNYXNrIHwgMHgxKSArIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgZmxhZyA9IGRhdGFbMF0gJiBwcmV2TWFzayA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIHByZXZCbG9ja3NpemUgPSBjb2RlY0luZm8udm9yYmlzSW5mby5ibG9ja3NpemVzW2ZsYWddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHVyYXRpb25JblNhbXBsZXMgPSBwcmV2QmxvY2tzaXplICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyAocHJldkJsb2Nrc2l6ZSArIGN1cnJlbnRCbG9ja3NpemUpID4+IDJcbiAgICAgICAgICAgICAgICA6IDA7IC8vIFRoZSBmaXJzdCBzYW1wbGUgb3V0cHV0cyBubyBhdWRpbyBkYXRhIGFuZCB0aGVyZWZvcmUgaGFzIGEgZHVyYXRpb24gb2YgMFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVjSW5mby5jb2RlYyA9PT0gJ29wdXMnKSB7XG4gICAgICAgICAgICBjb25zdCB0b2MgPSBwYXJzZU9wdXNUb2NCeXRlKGRhdGEpO1xuICAgICAgICAgICAgZHVyYXRpb25JblNhbXBsZXMgPSB0b2MuZHVyYXRpb25JblNhbXBsZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHVyYXRpb25JblNhbXBsZXMsXG4gICAgICAgIHZvcmJpc0Jsb2NrU2l6ZTogY3VycmVudEJsb2Nrc2l6ZSxcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBidWlsZE9nZ01pbWVUeXBlID0gKGluZm8pID0+IHtcbiAgICBsZXQgc3RyaW5nID0gJ2F1ZGlvL29nZyc7XG4gICAgaWYgKGluZm8uY29kZWNTdHJpbmdzKSB7XG4gICAgICAgIGNvbnN0IHVuaXF1ZUNvZGVjTWltZVR5cGVzID0gWy4uLm5ldyBTZXQoaW5mby5jb2RlY1N0cmluZ3MpXTtcbiAgICAgICAgc3RyaW5nICs9IGA7IGNvZGVjcz1cIiR7dW5pcXVlQ29kZWNNaW1lVHlwZXMuam9pbignLCAnKX1cImA7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmc7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/ogg/ogg-misc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/ogg/ogg-muxer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/ogg/ogg-muxer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OggMuxer: () => (/* binding */ OggMuxer)\n/* harmony export */ });\n/* harmony import */ var _codec_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../codec.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec.js\");\n/* harmony import */ var _codec_data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../codec-data.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec-data.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/* harmony import */ var _muxer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../muxer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/muxer.js\");\n/* harmony import */ var _ogg_misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ogg-misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/ogg/ogg-misc.js\");\n/* harmony import */ var _ogg_reader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ogg-reader.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/ogg/ogg-reader.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n\nconst PAGE_SIZE_TARGET = 8192;\nclass OggMuxer extends _muxer_js__WEBPACK_IMPORTED_MODULE_0__.Muxer {\n    constructor(output, format) {\n        super(output);\n        this.trackDatas = [];\n        this.bosPagesWritten = false;\n        this.allTracksKnown = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.promiseWithResolvers)();\n        this.pageBytes = new Uint8Array(_ogg_reader_js__WEBPACK_IMPORTED_MODULE_2__.MAX_PAGE_SIZE);\n        this.pageView = new DataView(this.pageBytes.buffer);\n        this.format = format;\n        this.writer = output._writer;\n        this.writer.ensureMonotonicity = true; // Ogg is always monotonically written!\n    }\n    async start() {\n        // Nothin'\n    }\n    async getMimeType() {\n        await this.allTracksKnown.promise;\n        return (0,_ogg_misc_js__WEBPACK_IMPORTED_MODULE_3__.buildOggMimeType)({\n            codecStrings: this.trackDatas.map(x => x.codecInfo.codec),\n        });\n    }\n    addEncodedVideoPacket() {\n        throw new Error('Video tracks are not supported.');\n    }\n    getTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(td => td.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        // Give the track a unique random serial number\n        let serialNumber;\n        do {\n            serialNumber = Math.floor(2 ** 32 * Math.random());\n        } while (this.trackDatas.some(td => td.serialNumber === serialNumber));\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(track.source._codec === 'vorbis' || track.source._codec === 'opus');\n        (0,_codec_js__WEBPACK_IMPORTED_MODULE_4__.validateAudioChunkMetadata)(meta);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(meta);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(meta.decoderConfig);\n        const newTrackData = {\n            track,\n            serialNumber,\n            internalSampleRate: track.source._codec === 'opus'\n                ? _codec_js__WEBPACK_IMPORTED_MODULE_4__.OPUS_SAMPLE_RATE\n                : meta.decoderConfig.sampleRate,\n            codecInfo: {\n                codec: track.source._codec,\n                vorbisInfo: null,\n                opusInfo: null,\n            },\n            vorbisLastBlocksize: null,\n            packetQueue: [],\n            currentTimestampInSamples: 0,\n            pagesWritten: 0,\n            currentGranulePosition: 0,\n            currentLacingValues: [],\n            currentPageData: [],\n            currentPageSize: 27,\n            currentPageStartsWithFreshPacket: true,\n        };\n        this.queueHeaderPackets(newTrackData, meta);\n        this.trackDatas.push(newTrackData);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    queueHeaderPackets(trackData, meta) {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(meta.decoderConfig);\n        if (trackData.track.source._codec === 'vorbis') {\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(meta.decoderConfig.description);\n            const bytes = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.toUint8Array)(meta.decoderConfig.description);\n            if (bytes[0] !== 2) {\n                throw new TypeError('First byte of Vorbis decoder description must be 2.');\n            }\n            let pos = 1;\n            const readPacketLength = () => {\n                let length = 0;\n                while (true) {\n                    const value = bytes[pos++];\n                    if (value === undefined) {\n                        throw new TypeError('Vorbis decoder description is too short.');\n                    }\n                    length += value;\n                    if (value < 255) {\n                        return length;\n                    }\n                }\n            };\n            const identificationHeaderLength = readPacketLength();\n            const commentHeaderLength = readPacketLength();\n            const setupHeaderLength = bytes.length - pos; // Setup header fills the remaining bytes\n            if (setupHeaderLength <= 0) {\n                throw new TypeError('Vorbis decoder description is too short.');\n            }\n            const identificationHeader = bytes.subarray(pos, pos += identificationHeaderLength);\n            pos += commentHeaderLength; // Skip the comment header, we'll build our own\n            const setupHeader = bytes.subarray(pos);\n            const commentHeaderHeader = new Uint8Array(7);\n            commentHeaderHeader[0] = 3; // Packet type\n            commentHeaderHeader[1] = 0x76; // 'v'\n            commentHeaderHeader[2] = 0x6f; // 'o'\n            commentHeaderHeader[3] = 0x72; // 'r'\n            commentHeaderHeader[4] = 0x62; // 'b'\n            commentHeaderHeader[5] = 0x69; // 'i'\n            commentHeaderHeader[6] = 0x73; // 's'\n            const commentHeader = this.createVorbisComments(commentHeaderHeader);\n            trackData.packetQueue.push({\n                data: identificationHeader,\n                endGranulePosition: 0,\n                timestamp: 0,\n                forcePageFlush: true,\n            }, {\n                data: commentHeader,\n                endGranulePosition: 0,\n                timestamp: 0,\n                forcePageFlush: false,\n            }, {\n                data: setupHeader,\n                endGranulePosition: 0,\n                timestamp: 0,\n                forcePageFlush: true, // The last header packet must flush the page\n            });\n            const view = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.toDataView)(identificationHeader);\n            const blockSizeByte = view.getUint8(28);\n            trackData.codecInfo.vorbisInfo = {\n                blocksizes: [\n                    1 << (blockSizeByte & 0xf),\n                    1 << (blockSizeByte >> 4),\n                ],\n                modeBlockflags: (0,_codec_data_js__WEBPACK_IMPORTED_MODULE_5__.parseModesFromVorbisSetupPacket)(setupHeader).modeBlockflags,\n            };\n        }\n        else if (trackData.track.source._codec === 'opus') {\n            if (!meta.decoderConfig.description) {\n                throw new TypeError('For Ogg, Opus decoder description is required.');\n            }\n            const identificationHeader = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.toUint8Array)(meta.decoderConfig.description);\n            const commentHeaderHeader = new Uint8Array(8);\n            const commentHeaderHeaderView = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.toDataView)(commentHeaderHeader);\n            commentHeaderHeaderView.setUint32(0, 0x4f707573, false); // 'Opus'\n            commentHeaderHeaderView.setUint32(4, 0x54616773, false); // 'Tags'\n            const commentHeader = this.createVorbisComments(commentHeaderHeader);\n            trackData.packetQueue.push({\n                data: identificationHeader,\n                endGranulePosition: 0,\n                timestamp: 0,\n                forcePageFlush: true,\n            }, {\n                data: commentHeader,\n                endGranulePosition: 0,\n                timestamp: 0,\n                forcePageFlush: true, // The last header packet must flush the page\n            });\n            trackData.codecInfo.opusInfo = {\n                preSkip: (0,_codec_data_js__WEBPACK_IMPORTED_MODULE_5__.parseOpusIdentificationHeader)(identificationHeader).preSkip,\n            };\n        }\n    }\n    createVorbisComments(headerBytes) {\n        // https://datatracker.ietf.org/doc/html/rfc7845#section-5.2\n        const tags = this.output._metadataTags;\n        const commentHeaderParts = [\n            headerBytes,\n        ];\n        let vendorString = '';\n        if (typeof tags.raw?.['vendor'] === 'string') {\n            vendorString = tags.raw?.['vendor'];\n        }\n        const encodedVendorString = _misc_js__WEBPACK_IMPORTED_MODULE_1__.textEncoder.encode(vendorString);\n        let currentBuffer = new Uint8Array(4 + encodedVendorString.length);\n        let currentView = new DataView(currentBuffer.buffer);\n        currentView.setUint32(0, encodedVendorString.length, true);\n        currentBuffer.set(encodedVendorString, 4);\n        commentHeaderParts.push(currentBuffer);\n        const writtenTags = new Set();\n        const addCommentTag = (key, value) => {\n            const joined = `${key}=${value}`;\n            const encoded = _misc_js__WEBPACK_IMPORTED_MODULE_1__.textEncoder.encode(joined);\n            currentBuffer = new Uint8Array(4 + encoded.length);\n            currentView = new DataView(currentBuffer.buffer);\n            currentView.setUint32(0, encoded.length, true);\n            currentBuffer.set(encoded, 4);\n            commentHeaderParts.push(currentBuffer);\n            writtenTags.add(key);\n        };\n        for (const { key, value } of (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.keyValueIterator)(tags)) {\n            switch (key) {\n                case 'title':\n                    {\n                        addCommentTag('TITLE', value);\n                    }\n                    ;\n                    break;\n                case 'description':\n                    {\n                        addCommentTag('DESCRIPTION', value);\n                    }\n                    ;\n                    break;\n                case 'artist':\n                    {\n                        addCommentTag('ARTIST', value);\n                    }\n                    ;\n                    break;\n                case 'album':\n                    {\n                        addCommentTag('ALBUM', value);\n                    }\n                    ;\n                    break;\n                case 'albumArtist':\n                    {\n                        addCommentTag('ALBUMARTIST', value);\n                    }\n                    ;\n                    break;\n                case 'genre':\n                    {\n                        addCommentTag('GENRE', value);\n                    }\n                    ;\n                    break;\n                case 'date':\n                    {\n                        addCommentTag('DATE', value.toISOString().slice(0, 10));\n                    }\n                    ;\n                    break;\n                case 'comment':\n                    {\n                        addCommentTag('COMMENT', value);\n                    }\n                    ;\n                    break;\n                case 'lyrics':\n                    {\n                        addCommentTag('LYRICS', value);\n                    }\n                    ;\n                    break;\n                case 'trackNumber':\n                    {\n                        addCommentTag('TRACKNUMBER', value.toString());\n                    }\n                    ;\n                    break;\n                case 'tracksTotal':\n                    {\n                        addCommentTag('TRACKTOTAL', value.toString());\n                    }\n                    ;\n                    break;\n                case 'discNumber':\n                    {\n                        addCommentTag('DISCNUMBER', value.toString());\n                    }\n                    ;\n                    break;\n                case 'discsTotal':\n                    {\n                        addCommentTag('DISCTOTAL', value.toString());\n                    }\n                    ;\n                    break;\n                case 'images':\n                    {\n                        for (const image of value) {\n                            // https://datatracker.ietf.org/doc/rfc9639/ Section 8.8\n                            const pictureType = image.kind === 'coverFront' ? 3 : image.kind === 'coverBack' ? 4 : 0;\n                            const encodedMediaType = new Uint8Array(image.mimeType.length);\n                            for (let i = 0; i < image.mimeType.length; i++) {\n                                encodedMediaType[i] = image.mimeType.charCodeAt(i);\n                            }\n                            const encodedDescription = _misc_js__WEBPACK_IMPORTED_MODULE_1__.textEncoder.encode(image.description ?? '');\n                            const buffer = new Uint8Array(4 // Picture type\n                                + 4 // MIME type length\n                                + encodedMediaType.length // MIME type\n                                + 4 // Description length\n                                + encodedDescription.length // Description\n                                + 16 // Width, height, color depth, number of colors\n                                + 4 // Picture data length\n                                + image.data.length);\n                            const view = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.toDataView)(buffer);\n                            view.setUint32(0, pictureType, false);\n                            view.setUint32(4, encodedMediaType.length, false);\n                            buffer.set(encodedMediaType, 8);\n                            view.setUint32(8 + encodedMediaType.length, encodedDescription.length, false);\n                            buffer.set(encodedDescription, 12 + encodedMediaType.length);\n                            // Skip a bunch of fields (width, height, color depth, number of colors)\n                            view.setUint32(28 + encodedMediaType.length + encodedDescription.length, image.data.length, false);\n                            buffer.set(image.data, 32 + encodedMediaType.length + encodedDescription.length);\n                            const encoded = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.bytesToBase64)(buffer);\n                            addCommentTag('METADATA_BLOCK_PICTURE', encoded);\n                        }\n                    }\n                    ;\n                    break;\n                case 'raw':\n                    {\n                        // Handled later\n                    }\n                    ;\n                    break;\n                default: (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assertNever)(key);\n            }\n        }\n        if (tags.raw) {\n            for (const key in tags.raw) {\n                const value = tags.raw[key];\n                if (key === 'vendor' || value == null || writtenTags.has(key)) {\n                    continue;\n                }\n                if (typeof value === 'string') {\n                    addCommentTag(key, value);\n                }\n            }\n        }\n        const listLengthBuffer = new Uint8Array(4);\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.toDataView)(listLengthBuffer).setUint32(0, writtenTags.size, true);\n        commentHeaderParts.splice(2, 0, listLengthBuffer); // Insert after the header and vendor section\n        // Merge all comment header parts into a single buffer\n        const commentHeaderLength = commentHeaderParts.reduce((a, b) => a + b.length, 0);\n        const commentHeader = new Uint8Array(commentHeaderLength);\n        let pos = 0;\n        for (const part of commentHeaderParts) {\n            commentHeader.set(part, pos);\n            pos += part.length;\n        }\n        return commentHeader;\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getTrackData(track, meta);\n            this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');\n            const currentTimestampInSamples = trackData.currentTimestampInSamples;\n            const { durationInSamples, vorbisBlockSize } = (0,_ogg_misc_js__WEBPACK_IMPORTED_MODULE_3__.extractSampleMetadata)(packet.data, trackData.codecInfo, trackData.vorbisLastBlocksize);\n            trackData.currentTimestampInSamples += durationInSamples;\n            trackData.vorbisLastBlocksize = vorbisBlockSize;\n            trackData.packetQueue.push({\n                data: packet.data,\n                endGranulePosition: trackData.currentTimestampInSamples,\n                timestamp: currentTimestampInSamples / trackData.internalSampleRate,\n                forcePageFlush: false,\n            });\n            await this.interleavePages();\n        }\n        finally {\n            release();\n        }\n    }\n    addSubtitleCue() {\n        throw new Error('Subtitle tracks are not supported.');\n    }\n    allTracksAreKnown() {\n        for (const track of this.output._tracks) {\n            if (!track.source._closed && !this.trackDatas.some(x => x.track === track)) {\n                return false; // We haven't seen a sample from this open track yet\n            }\n        }\n        return true;\n    }\n    async interleavePages(isFinalCall = false) {\n        if (!this.bosPagesWritten) {\n            if (!this.allTracksAreKnown()) {\n                return; // We can't interleave yet as we don't yet know how many tracks we'll truly have\n            }\n            // Write the header page for all bitstreams\n            for (const trackData of this.trackDatas) {\n                while (trackData.packetQueue.length > 0) {\n                    const packet = trackData.packetQueue.shift();\n                    this.writePacket(trackData, packet, false);\n                    if (packet.forcePageFlush) {\n                        // We say the header page ends once the first packet is encountered that forces a page flush\n                        break;\n                    }\n                }\n            }\n            this.bosPagesWritten = true;\n        }\n        outer: while (true) {\n            let trackWithMinTimestamp = null;\n            let minTimestamp = Infinity;\n            for (const trackData of this.trackDatas) {\n                if (!isFinalCall\n                    && trackData.packetQueue.length <= 1 // Limit is 1, not 0, for correct EOS flag logic\n                    && !trackData.track.source._closed) {\n                    break outer;\n                }\n                if (trackData.packetQueue.length > 0\n                    && trackData.packetQueue[0].timestamp < minTimestamp) {\n                    trackWithMinTimestamp = trackData;\n                    minTimestamp = trackData.packetQueue[0].timestamp;\n                }\n            }\n            if (!trackWithMinTimestamp) {\n                break;\n            }\n            const packet = trackWithMinTimestamp.packetQueue.shift();\n            const isFinalPacket = trackWithMinTimestamp.packetQueue.length === 0;\n            this.writePacket(trackWithMinTimestamp, packet, isFinalPacket);\n        }\n        if (!isFinalCall) {\n            await this.writer.flush();\n        }\n    }\n    writePacket(trackData, packet, isFinalPacket) {\n        let remainingLength = packet.data.length;\n        let dataStartOffset = 0;\n        let dataOffset = 0;\n        while (true) {\n            if (trackData.currentLacingValues.length === 0 && dataStartOffset > 0) {\n                // This is a packet spanning multiple pages\n                trackData.currentPageStartsWithFreshPacket = false;\n            }\n            const segmentSize = Math.min(255, remainingLength);\n            trackData.currentLacingValues.push(segmentSize);\n            trackData.currentPageSize++;\n            dataOffset += segmentSize;\n            const segmentIsLastOfPacket = remainingLength < 255;\n            if (trackData.currentLacingValues.length === 255) {\n                // The page is full, we need to add part of the packet data and then flush the page\n                const slice = packet.data.subarray(dataStartOffset, dataOffset);\n                dataStartOffset = dataOffset;\n                trackData.currentPageData.push(slice);\n                trackData.currentPageSize += slice.length;\n                this.writePage(trackData, isFinalPacket && segmentIsLastOfPacket);\n                if (segmentIsLastOfPacket) {\n                    return;\n                }\n            }\n            if (segmentIsLastOfPacket) {\n                break;\n            }\n            remainingLength -= 255;\n        }\n        const slice = packet.data.subarray(dataStartOffset);\n        trackData.currentPageData.push(slice);\n        trackData.currentPageSize += slice.length;\n        trackData.currentGranulePosition = packet.endGranulePosition;\n        if (trackData.currentPageSize >= PAGE_SIZE_TARGET || packet.forcePageFlush) {\n            this.writePage(trackData, isFinalPacket);\n        }\n    }\n    writePage(trackData, isEos) {\n        this.pageView.setUint32(0, _ogg_misc_js__WEBPACK_IMPORTED_MODULE_3__.OGGS, true); // Capture pattern\n        this.pageView.setUint8(4, 0); // Version\n        let headerType = 0;\n        if (!trackData.currentPageStartsWithFreshPacket) {\n            headerType |= 1;\n        }\n        if (trackData.pagesWritten === 0) {\n            headerType |= 2; // Beginning of stream\n        }\n        if (isEos) {\n            headerType |= 4; // End of stream\n        }\n        this.pageView.setUint8(5, headerType); // Header type\n        const granulePosition = trackData.currentLacingValues.every(x => x === 255)\n            ? -1 // No packets end on this page\n            : trackData.currentGranulePosition;\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.setInt64)(this.pageView, 6, granulePosition, true); // Granule position\n        this.pageView.setUint32(14, trackData.serialNumber, true); // Serial number\n        this.pageView.setUint32(18, trackData.pagesWritten, true); // Page sequence number\n        this.pageView.setUint32(22, 0, true); // Checksum placeholder\n        this.pageView.setUint8(26, trackData.currentLacingValues.length); // Number of page segments\n        this.pageBytes.set(trackData.currentLacingValues, 27);\n        let pos = 27 + trackData.currentLacingValues.length;\n        for (const data of trackData.currentPageData) {\n            this.pageBytes.set(data, pos);\n            pos += data.length;\n        }\n        const slice = this.pageBytes.subarray(0, pos);\n        const crc = (0,_ogg_misc_js__WEBPACK_IMPORTED_MODULE_3__.computeOggPageCrc)(slice);\n        this.pageView.setUint32(22, crc, true); // Checksum\n        trackData.pagesWritten++;\n        trackData.currentLacingValues.length = 0;\n        trackData.currentPageData.length = 0;\n        trackData.currentPageSize = 27;\n        trackData.currentPageStartsWithFreshPacket = true;\n        if (this.format._options.onPage) {\n            this.writer.startTrackingWrites();\n        }\n        this.writer.write(slice);\n        if (this.format._options.onPage) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onPage(data, start, trackData.track.source);\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    async onTrackClose() {\n        const release = await this.mutex.acquire();\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        // Since a track is now closed, we may be able to write out chunks that were previously waiting\n        await this.interleavePages();\n        release();\n    }\n    async finalize() {\n        const release = await this.mutex.acquire();\n        this.allTracksKnown.resolve();\n        await this.interleavePages(true);\n        for (const trackData of this.trackDatas) {\n            if (trackData.currentLacingValues.length > 0) {\n                this.writePage(trackData, true);\n            }\n        }\n        release();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL29nZy9vZ2ctbXV4ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzJFO0FBQ3VCO0FBQ3dEO0FBQ3RIO0FBQzhEO0FBQ2xEO0FBQ2hEO0FBQ08sdUJBQXVCLDRDQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhEQUFvQjtBQUNsRCx3Q0FBd0MseURBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOERBQWdCO0FBQy9CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVEsZ0RBQU07QUFDZCxRQUFRLHFFQUEwQjtBQUNsQyxRQUFRLGdEQUFNO0FBQ2QsUUFBUSxnREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVEQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQU07QUFDZDtBQUNBLFlBQVksZ0RBQU07QUFDbEIsMEJBQTBCLHNEQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsMkNBQTJDO0FBQzND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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOENBQUksU0FBUztBQUNoRCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQVEsMkNBQTJDO0FBQzNELG1FQUFtRTtBQUNuRSxtRUFBbUU7QUFDbkUsOENBQThDO0FBQzlDLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrREFBaUI7QUFDckMsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRjaC1jdXQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL21lZGlhYnVubnkvZGlzdC9tb2R1bGVzL3NyYy9vZ2cvb2dnLW11eGVyLmpzP2Q5ZjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjUtcHJlc2VudCwgVmFuaWxhZ3kgYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgeyBPUFVTX1NBTVBMRV9SQVRFLCB2YWxpZGF0ZUF1ZGlvQ2h1bmtNZXRhZGF0YSB9IGZyb20gJy4uL2NvZGVjLmpzJztcbmltcG9ydCB7IHBhcnNlTW9kZXNGcm9tVm9yYmlzU2V0dXBQYWNrZXQsIHBhcnNlT3B1c0lkZW50aWZpY2F0aW9uSGVhZGVyIH0gZnJvbSAnLi4vY29kZWMtZGF0YS5qcyc7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydE5ldmVyLCBieXRlc1RvQmFzZTY0LCBrZXlWYWx1ZUl0ZXJhdG9yLCBwcm9taXNlV2l0aFJlc29sdmVycywgc2V0SW50NjQsIHRleHRFbmNvZGVyLCB0b0RhdGFWaWV3LCB0b1VpbnQ4QXJyYXksIH0gZnJvbSAnLi4vbWlzYy5qcyc7XG5pbXBvcnQgeyBNdXhlciB9IGZyb20gJy4uL211eGVyLmpzJztcbmltcG9ydCB7IGJ1aWxkT2dnTWltZVR5cGUsIGNvbXB1dGVPZ2dQYWdlQ3JjLCBleHRyYWN0U2FtcGxlTWV0YWRhdGEsIE9HR1MsIH0gZnJvbSAnLi9vZ2ctbWlzYy5qcyc7XG5pbXBvcnQgeyBNQVhfUEFHRV9TSVpFIH0gZnJvbSAnLi9vZ2ctcmVhZGVyLmpzJztcbmNvbnN0IFBBR0VfU0laRV9UQVJHRVQgPSA4MTkyO1xuZXhwb3J0IGNsYXNzIE9nZ011eGVyIGV4dGVuZHMgTXV4ZXIge1xuICAgIGNvbnN0cnVjdG9yKG91dHB1dCwgZm9ybWF0KSB7XG4gICAgICAgIHN1cGVyKG91dHB1dCk7XG4gICAgICAgIHRoaXMudHJhY2tEYXRhcyA9IFtdO1xuICAgICAgICB0aGlzLmJvc1BhZ2VzV3JpdHRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbFRyYWNrc0tub3duID0gcHJvbWlzZVdpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgdGhpcy5wYWdlQnl0ZXMgPSBuZXcgVWludDhBcnJheShNQVhfUEFHRV9TSVpFKTtcbiAgICAgICAgdGhpcy5wYWdlVmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLnBhZ2VCeXRlcy5idWZmZXIpO1xuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgdGhpcy53cml0ZXIgPSBvdXRwdXQuX3dyaXRlcjtcbiAgICAgICAgdGhpcy53cml0ZXIuZW5zdXJlTW9ub3RvbmljaXR5ID0gdHJ1ZTsgLy8gT2dnIGlzIGFsd2F5cyBtb25vdG9uaWNhbGx5IHdyaXR0ZW4hXG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICAvLyBOb3RoaW4nXG4gICAgfVxuICAgIGFzeW5jIGdldE1pbWVUeXBlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmFsbFRyYWNrc0tub3duLnByb21pc2U7XG4gICAgICAgIHJldHVybiBidWlsZE9nZ01pbWVUeXBlKHtcbiAgICAgICAgICAgIGNvZGVjU3RyaW5nczogdGhpcy50cmFja0RhdGFzLm1hcCh4ID0+IHguY29kZWNJbmZvLmNvZGVjKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZEVuY29kZWRWaWRlb1BhY2tldCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWaWRlbyB0cmFja3MgYXJlIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIGdldFRyYWNrRGF0YSh0cmFjaywgbWV0YSkge1xuICAgICAgICBjb25zdCBleGlzdGluZ1RyYWNrRGF0YSA9IHRoaXMudHJhY2tEYXRhcy5maW5kKHRkID0+IHRkLnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgIGlmIChleGlzdGluZ1RyYWNrRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nVHJhY2tEYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdpdmUgdGhlIHRyYWNrIGEgdW5pcXVlIHJhbmRvbSBzZXJpYWwgbnVtYmVyXG4gICAgICAgIGxldCBzZXJpYWxOdW1iZXI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHNlcmlhbE51bWJlciA9IE1hdGguZmxvb3IoMiAqKiAzMiAqIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLnRyYWNrRGF0YXMuc29tZSh0ZCA9PiB0ZC5zZXJpYWxOdW1iZXIgPT09IHNlcmlhbE51bWJlcikpO1xuICAgICAgICBhc3NlcnQodHJhY2suc291cmNlLl9jb2RlYyA9PT0gJ3ZvcmJpcycgfHwgdHJhY2suc291cmNlLl9jb2RlYyA9PT0gJ29wdXMnKTtcbiAgICAgICAgdmFsaWRhdGVBdWRpb0NodW5rTWV0YWRhdGEobWV0YSk7XG4gICAgICAgIGFzc2VydChtZXRhKTtcbiAgICAgICAgYXNzZXJ0KG1ldGEuZGVjb2RlckNvbmZpZyk7XG4gICAgICAgIGNvbnN0IG5ld1RyYWNrRGF0YSA9IHtcbiAgICAgICAgICAgIHRyYWNrLFxuICAgICAgICAgICAgc2VyaWFsTnVtYmVyLFxuICAgICAgICAgICAgaW50ZXJuYWxTYW1wbGVSYXRlOiB0cmFjay5zb3VyY2UuX2NvZGVjID09PSAnb3B1cydcbiAgICAgICAgICAgICAgICA/IE9QVVNfU0FNUExFX1JBVEVcbiAgICAgICAgICAgICAgICA6IG1ldGEuZGVjb2RlckNvbmZpZy5zYW1wbGVSYXRlLFxuICAgICAgICAgICAgY29kZWNJbmZvOiB7XG4gICAgICAgICAgICAgICAgY29kZWM6IHRyYWNrLnNvdXJjZS5fY29kZWMsXG4gICAgICAgICAgICAgICAgdm9yYmlzSW5mbzogbnVsbCxcbiAgICAgICAgICAgICAgICBvcHVzSW5mbzogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2b3JiaXNMYXN0QmxvY2tzaXplOiBudWxsLFxuICAgICAgICAgICAgcGFja2V0UXVldWU6IFtdLFxuICAgICAgICAgICAgY3VycmVudFRpbWVzdGFtcEluU2FtcGxlczogMCxcbiAgICAgICAgICAgIHBhZ2VzV3JpdHRlbjogMCxcbiAgICAgICAgICAgIGN1cnJlbnRHcmFudWxlUG9zaXRpb246IDAsXG4gICAgICAgICAgICBjdXJyZW50TGFjaW5nVmFsdWVzOiBbXSxcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlRGF0YTogW10sXG4gICAgICAgICAgICBjdXJyZW50UGFnZVNpemU6IDI3LFxuICAgICAgICAgICAgY3VycmVudFBhZ2VTdGFydHNXaXRoRnJlc2hQYWNrZXQ6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucXVldWVIZWFkZXJQYWNrZXRzKG5ld1RyYWNrRGF0YSwgbWV0YSk7XG4gICAgICAgIHRoaXMudHJhY2tEYXRhcy5wdXNoKG5ld1RyYWNrRGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmFsbFRyYWNrc0FyZUtub3duKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsVHJhY2tzS25vd24ucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdUcmFja0RhdGE7XG4gICAgfVxuICAgIHF1ZXVlSGVhZGVyUGFja2V0cyh0cmFja0RhdGEsIG1ldGEpIHtcbiAgICAgICAgYXNzZXJ0KG1ldGEuZGVjb2RlckNvbmZpZyk7XG4gICAgICAgIGlmICh0cmFja0RhdGEudHJhY2suc291cmNlLl9jb2RlYyA9PT0gJ3ZvcmJpcycpIHtcbiAgICAgICAgICAgIGFzc2VydChtZXRhLmRlY29kZXJDb25maWcuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0b1VpbnQ4QXJyYXkobWV0YS5kZWNvZGVyQ29uZmlnLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChieXRlc1swXSAhPT0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGJ5dGUgb2YgVm9yYmlzIGRlY29kZXIgZGVzY3JpcHRpb24gbXVzdCBiZSAyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBvcyA9IDE7XG4gICAgICAgICAgICBjb25zdCByZWFkUGFja2V0TGVuZ3RoID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYnl0ZXNbcG9zKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVm9yYmlzIGRlY29kZXIgZGVzY3JpcHRpb24gaXMgdG9vIHNob3J0LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMjU1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpY2F0aW9uSGVhZGVyTGVuZ3RoID0gcmVhZFBhY2tldExlbmd0aCgpO1xuICAgICAgICAgICAgY29uc3QgY29tbWVudEhlYWRlckxlbmd0aCA9IHJlYWRQYWNrZXRMZW5ndGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNldHVwSGVhZGVyTGVuZ3RoID0gYnl0ZXMubGVuZ3RoIC0gcG9zOyAvLyBTZXR1cCBoZWFkZXIgZmlsbHMgdGhlIHJlbWFpbmluZyBieXRlc1xuICAgICAgICAgICAgaWYgKHNldHVwSGVhZGVyTGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWb3JiaXMgZGVjb2RlciBkZXNjcmlwdGlvbiBpcyB0b28gc2hvcnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWNhdGlvbkhlYWRlciA9IGJ5dGVzLnN1YmFycmF5KHBvcywgcG9zICs9IGlkZW50aWZpY2F0aW9uSGVhZGVyTGVuZ3RoKTtcbiAgICAgICAgICAgIHBvcyArPSBjb21tZW50SGVhZGVyTGVuZ3RoOyAvLyBTa2lwIHRoZSBjb21tZW50IGhlYWRlciwgd2UnbGwgYnVpbGQgb3VyIG93blxuICAgICAgICAgICAgY29uc3Qgc2V0dXBIZWFkZXIgPSBieXRlcy5zdWJhcnJheShwb3MpO1xuICAgICAgICAgICAgY29uc3QgY29tbWVudEhlYWRlckhlYWRlciA9IG5ldyBVaW50OEFycmF5KDcpO1xuICAgICAgICAgICAgY29tbWVudEhlYWRlckhlYWRlclswXSA9IDM7IC8vIFBhY2tldCB0eXBlXG4gICAgICAgICAgICBjb21tZW50SGVhZGVySGVhZGVyWzFdID0gMHg3NjsgLy8gJ3YnXG4gICAgICAgICAgICBjb21tZW50SGVhZGVySGVhZGVyWzJdID0gMHg2ZjsgLy8gJ28nXG4gICAgICAgICAgICBjb21tZW50SGVhZGVySGVhZGVyWzNdID0gMHg3MjsgLy8gJ3InXG4gICAgICAgICAgICBjb21tZW50SGVhZGVySGVhZGVyWzRdID0gMHg2MjsgLy8gJ2InXG4gICAgICAgICAgICBjb21tZW50SGVhZGVySGVhZGVyWzVdID0gMHg2OTsgLy8gJ2knXG4gICAgICAgICAgICBjb21tZW50SGVhZGVySGVhZGVyWzZdID0gMHg3MzsgLy8gJ3MnXG4gICAgICAgICAgICBjb25zdCBjb21tZW50SGVhZGVyID0gdGhpcy5jcmVhdGVWb3JiaXNDb21tZW50cyhjb21tZW50SGVhZGVySGVhZGVyKTtcbiAgICAgICAgICAgIHRyYWNrRGF0YS5wYWNrZXRRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBpZGVudGlmaWNhdGlvbkhlYWRlcixcbiAgICAgICAgICAgICAgICBlbmRHcmFudWxlUG9zaXRpb246IDAsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiAwLFxuICAgICAgICAgICAgICAgIGZvcmNlUGFnZUZsdXNoOiB0cnVlLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGRhdGE6IGNvbW1lbnRIZWFkZXIsXG4gICAgICAgICAgICAgICAgZW5kR3JhbnVsZVBvc2l0aW9uOiAwLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogMCxcbiAgICAgICAgICAgICAgICBmb3JjZVBhZ2VGbHVzaDogZmFsc2UsXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgZGF0YTogc2V0dXBIZWFkZXIsXG4gICAgICAgICAgICAgICAgZW5kR3JhbnVsZVBvc2l0aW9uOiAwLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogMCxcbiAgICAgICAgICAgICAgICBmb3JjZVBhZ2VGbHVzaDogdHJ1ZSwgLy8gVGhlIGxhc3QgaGVhZGVyIHBhY2tldCBtdXN0IGZsdXNoIHRoZSBwYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSB0b0RhdGFWaWV3KGlkZW50aWZpY2F0aW9uSGVhZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrU2l6ZUJ5dGUgPSB2aWV3LmdldFVpbnQ4KDI4KTtcbiAgICAgICAgICAgIHRyYWNrRGF0YS5jb2RlY0luZm8udm9yYmlzSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBibG9ja3NpemVzOiBbXG4gICAgICAgICAgICAgICAgICAgIDEgPDwgKGJsb2NrU2l6ZUJ5dGUgJiAweGYpLFxuICAgICAgICAgICAgICAgICAgICAxIDw8IChibG9ja1NpemVCeXRlID4+IDQpLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgbW9kZUJsb2NrZmxhZ3M6IHBhcnNlTW9kZXNGcm9tVm9yYmlzU2V0dXBQYWNrZXQoc2V0dXBIZWFkZXIpLm1vZGVCbG9ja2ZsYWdzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmFja0RhdGEudHJhY2suc291cmNlLl9jb2RlYyA9PT0gJ29wdXMnKSB7XG4gICAgICAgICAgICBpZiAoIW1ldGEuZGVjb2RlckNvbmZpZy5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZvciBPZ2csIE9wdXMgZGVjb2RlciBkZXNjcmlwdGlvbiBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpY2F0aW9uSGVhZGVyID0gdG9VaW50OEFycmF5KG1ldGEuZGVjb2RlckNvbmZpZy5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50SGVhZGVySGVhZGVyID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50SGVhZGVySGVhZGVyVmlldyA9IHRvRGF0YVZpZXcoY29tbWVudEhlYWRlckhlYWRlcik7XG4gICAgICAgICAgICBjb21tZW50SGVhZGVySGVhZGVyVmlldy5zZXRVaW50MzIoMCwgMHg0ZjcwNzU3MywgZmFsc2UpOyAvLyAnT3B1cydcbiAgICAgICAgICAgIGNvbW1lbnRIZWFkZXJIZWFkZXJWaWV3LnNldFVpbnQzMig0LCAweDU0NjE2NzczLCBmYWxzZSk7IC8vICdUYWdzJ1xuICAgICAgICAgICAgY29uc3QgY29tbWVudEhlYWRlciA9IHRoaXMuY3JlYXRlVm9yYmlzQ29tbWVudHMoY29tbWVudEhlYWRlckhlYWRlcik7XG4gICAgICAgICAgICB0cmFja0RhdGEucGFja2V0UXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgZGF0YTogaWRlbnRpZmljYXRpb25IZWFkZXIsXG4gICAgICAgICAgICAgICAgZW5kR3JhbnVsZVBvc2l0aW9uOiAwLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogMCxcbiAgICAgICAgICAgICAgICBmb3JjZVBhZ2VGbHVzaDogdHJ1ZSxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjb21tZW50SGVhZGVyLFxuICAgICAgICAgICAgICAgIGVuZEdyYW51bGVQb3NpdGlvbjogMCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IDAsXG4gICAgICAgICAgICAgICAgZm9yY2VQYWdlRmx1c2g6IHRydWUsIC8vIFRoZSBsYXN0IGhlYWRlciBwYWNrZXQgbXVzdCBmbHVzaCB0aGUgcGFnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cmFja0RhdGEuY29kZWNJbmZvLm9wdXNJbmZvID0ge1xuICAgICAgICAgICAgICAgIHByZVNraXA6IHBhcnNlT3B1c0lkZW50aWZpY2F0aW9uSGVhZGVyKGlkZW50aWZpY2F0aW9uSGVhZGVyKS5wcmVTa2lwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVWb3JiaXNDb21tZW50cyhoZWFkZXJCeXRlcykge1xuICAgICAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzc4NDUjc2VjdGlvbi01LjJcbiAgICAgICAgY29uc3QgdGFncyA9IHRoaXMub3V0cHV0Ll9tZXRhZGF0YVRhZ3M7XG4gICAgICAgIGNvbnN0IGNvbW1lbnRIZWFkZXJQYXJ0cyA9IFtcbiAgICAgICAgICAgIGhlYWRlckJ5dGVzLFxuICAgICAgICBdO1xuICAgICAgICBsZXQgdmVuZG9yU3RyaW5nID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgdGFncy5yYXc/LlsndmVuZG9yJ10gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2ZW5kb3JTdHJpbmcgPSB0YWdzLnJhdz8uWyd2ZW5kb3InXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGVkVmVuZG9yU3RyaW5nID0gdGV4dEVuY29kZXIuZW5jb2RlKHZlbmRvclN0cmluZyk7XG4gICAgICAgIGxldCBjdXJyZW50QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoNCArIGVuY29kZWRWZW5kb3JTdHJpbmcubGVuZ3RoKTtcbiAgICAgICAgbGV0IGN1cnJlbnRWaWV3ID0gbmV3IERhdGFWaWV3KGN1cnJlbnRCdWZmZXIuYnVmZmVyKTtcbiAgICAgICAgY3VycmVudFZpZXcuc2V0VWludDMyKDAsIGVuY29kZWRWZW5kb3JTdHJpbmcubGVuZ3RoLCB0cnVlKTtcbiAgICAgICAgY3VycmVudEJ1ZmZlci5zZXQoZW5jb2RlZFZlbmRvclN0cmluZywgNCk7XG4gICAgICAgIGNvbW1lbnRIZWFkZXJQYXJ0cy5wdXNoKGN1cnJlbnRCdWZmZXIpO1xuICAgICAgICBjb25zdCB3cml0dGVuVGFncyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgYWRkQ29tbWVudFRhZyA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBqb2luZWQgPSBgJHtrZXl9PSR7dmFsdWV9YDtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWQgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoam9pbmVkKTtcbiAgICAgICAgICAgIGN1cnJlbnRCdWZmZXIgPSBuZXcgVWludDhBcnJheSg0ICsgZW5jb2RlZC5sZW5ndGgpO1xuICAgICAgICAgICAgY3VycmVudFZpZXcgPSBuZXcgRGF0YVZpZXcoY3VycmVudEJ1ZmZlci5idWZmZXIpO1xuICAgICAgICAgICAgY3VycmVudFZpZXcuc2V0VWludDMyKDAsIGVuY29kZWQubGVuZ3RoLCB0cnVlKTtcbiAgICAgICAgICAgIGN1cnJlbnRCdWZmZXIuc2V0KGVuY29kZWQsIDQpO1xuICAgICAgICAgICAgY29tbWVudEhlYWRlclBhcnRzLnB1c2goY3VycmVudEJ1ZmZlcik7XG4gICAgICAgICAgICB3cml0dGVuVGFncy5hZGQoa2V5KTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCB7IGtleSwgdmFsdWUgfSBvZiBrZXlWYWx1ZUl0ZXJhdG9yKHRhZ3MpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ29tbWVudFRhZygnVElUTEUnLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkZXNjcmlwdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnRUYWcoJ0RFU0NSSVBUSU9OJywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYXJ0aXN0JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ29tbWVudFRhZygnQVJUSVNUJywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYWxidW0nOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDb21tZW50VGFnKCdBTEJVTScsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FsYnVtQXJ0aXN0JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ29tbWVudFRhZygnQUxCVU1BUlRJU1QnLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnZW5yZSc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnRUYWcoJ0dFTlJFJywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnRUYWcoJ0RBVEUnLCB2YWx1ZS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDEwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ29tbWVudFRhZygnQ09NTUVOVCcsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2x5cmljcyc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnRUYWcoJ0xZUklDUycsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYWNrTnVtYmVyJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ29tbWVudFRhZygnVFJBQ0tOVU1CRVInLCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYWNrc1RvdGFsJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ29tbWVudFRhZygnVFJBQ0tUT1RBTCcsIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY051bWJlcic6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnRUYWcoJ0RJU0NOVU1CRVInLCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2NzVG90YWwnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDb21tZW50VGFnKCdESVNDVE9UQUwnLCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ltYWdlcyc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW1hZ2Ugb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9yZmM5NjM5LyBTZWN0aW9uIDguOFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpY3R1cmVUeXBlID0gaW1hZ2Uua2luZCA9PT0gJ2NvdmVyRnJvbnQnID8gMyA6IGltYWdlLmtpbmQgPT09ICdjb3ZlckJhY2snID8gNCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlZE1lZGlhVHlwZSA9IG5ldyBVaW50OEFycmF5KGltYWdlLm1pbWVUeXBlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZS5taW1lVHlwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkTWVkaWFUeXBlW2ldID0gaW1hZ2UubWltZVR5cGUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlZERlc2NyaXB0aW9uID0gdGV4dEVuY29kZXIuZW5jb2RlKGltYWdlLmRlc2NyaXB0aW9uID8/ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheSg0IC8vIFBpY3R1cmUgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIDQgLy8gTUlNRSB0eXBlIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGVuY29kZWRNZWRpYVR5cGUubGVuZ3RoIC8vIE1JTUUgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIDQgLy8gRGVzY3JpcHRpb24gbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgZW5jb2RlZERlc2NyaXB0aW9uLmxlbmd0aCAvLyBEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIDE2IC8vIFdpZHRoLCBoZWlnaHQsIGNvbG9yIGRlcHRoLCBudW1iZXIgb2YgY29sb3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgNCAvLyBQaWN0dXJlIGRhdGEgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgaW1hZ2UuZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSB0b0RhdGFWaWV3KGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgcGljdHVyZVR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQzMig0LCBlbmNvZGVkTWVkaWFUeXBlLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXQoZW5jb2RlZE1lZGlhVHlwZSwgOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoOCArIGVuY29kZWRNZWRpYVR5cGUubGVuZ3RoLCBlbmNvZGVkRGVzY3JpcHRpb24ubGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnNldChlbmNvZGVkRGVzY3JpcHRpb24sIDEyICsgZW5jb2RlZE1lZGlhVHlwZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgYSBidW5jaCBvZiBmaWVsZHMgKHdpZHRoLCBoZWlnaHQsIGNvbG9yIGRlcHRoLCBudW1iZXIgb2YgY29sb3JzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDMyKDI4ICsgZW5jb2RlZE1lZGlhVHlwZS5sZW5ndGggKyBlbmNvZGVkRGVzY3JpcHRpb24ubGVuZ3RoLCBpbWFnZS5kYXRhLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXQoaW1hZ2UuZGF0YSwgMzIgKyBlbmNvZGVkTWVkaWFUeXBlLmxlbmd0aCArIGVuY29kZWREZXNjcmlwdGlvbi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZWQgPSBieXRlc1RvQmFzZTY0KGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ29tbWVudFRhZygnTUVUQURBVEFfQkxPQ0tfUElDVFVSRScsIGVuY29kZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmF3JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlZCBsYXRlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogYXNzZXJ0TmV2ZXIoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGFncy5yYXcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRhZ3MucmF3KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0YWdzLnJhd1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICd2ZW5kb3InIHx8IHZhbHVlID09IG51bGwgfHwgd3JpdHRlblRhZ3MuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnRUYWcoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpc3RMZW5ndGhCdWZmZXIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgdG9EYXRhVmlldyhsaXN0TGVuZ3RoQnVmZmVyKS5zZXRVaW50MzIoMCwgd3JpdHRlblRhZ3Muc2l6ZSwgdHJ1ZSk7XG4gICAgICAgIGNvbW1lbnRIZWFkZXJQYXJ0cy5zcGxpY2UoMiwgMCwgbGlzdExlbmd0aEJ1ZmZlcik7IC8vIEluc2VydCBhZnRlciB0aGUgaGVhZGVyIGFuZCB2ZW5kb3Igc2VjdGlvblxuICAgICAgICAvLyBNZXJnZSBhbGwgY29tbWVudCBoZWFkZXIgcGFydHMgaW50byBhIHNpbmdsZSBidWZmZXJcbiAgICAgICAgY29uc3QgY29tbWVudEhlYWRlckxlbmd0aCA9IGNvbW1lbnRIZWFkZXJQYXJ0cy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLmxlbmd0aCwgMCk7XG4gICAgICAgIGNvbnN0IGNvbW1lbnRIZWFkZXIgPSBuZXcgVWludDhBcnJheShjb21tZW50SGVhZGVyTGVuZ3RoKTtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBjb21tZW50SGVhZGVyUGFydHMpIHtcbiAgICAgICAgICAgIGNvbW1lbnRIZWFkZXIuc2V0KHBhcnQsIHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gcGFydC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1lbnRIZWFkZXI7XG4gICAgfVxuICAgIGFzeW5jIGFkZEVuY29kZWRBdWRpb1BhY2tldCh0cmFjaywgcGFja2V0LCBtZXRhKSB7XG4gICAgICAgIGNvbnN0IHJlbGVhc2UgPSBhd2FpdCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrRGF0YSA9IHRoaXMuZ2V0VHJhY2tEYXRhKHRyYWNrLCBtZXRhKTtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVBbmROb3JtYWxpemVUaW1lc3RhbXAodHJhY2tEYXRhLnRyYWNrLCBwYWNrZXQudGltZXN0YW1wLCBwYWNrZXQudHlwZSA9PT0gJ2tleScpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRpbWVzdGFtcEluU2FtcGxlcyA9IHRyYWNrRGF0YS5jdXJyZW50VGltZXN0YW1wSW5TYW1wbGVzO1xuICAgICAgICAgICAgY29uc3QgeyBkdXJhdGlvbkluU2FtcGxlcywgdm9yYmlzQmxvY2tTaXplIH0gPSBleHRyYWN0U2FtcGxlTWV0YWRhdGEocGFja2V0LmRhdGEsIHRyYWNrRGF0YS5jb2RlY0luZm8sIHRyYWNrRGF0YS52b3JiaXNMYXN0QmxvY2tzaXplKTtcbiAgICAgICAgICAgIHRyYWNrRGF0YS5jdXJyZW50VGltZXN0YW1wSW5TYW1wbGVzICs9IGR1cmF0aW9uSW5TYW1wbGVzO1xuICAgICAgICAgICAgdHJhY2tEYXRhLnZvcmJpc0xhc3RCbG9ja3NpemUgPSB2b3JiaXNCbG9ja1NpemU7XG4gICAgICAgICAgICB0cmFja0RhdGEucGFja2V0UXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgZGF0YTogcGFja2V0LmRhdGEsXG4gICAgICAgICAgICAgICAgZW5kR3JhbnVsZVBvc2l0aW9uOiB0cmFja0RhdGEuY3VycmVudFRpbWVzdGFtcEluU2FtcGxlcyxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGN1cnJlbnRUaW1lc3RhbXBJblNhbXBsZXMgLyB0cmFja0RhdGEuaW50ZXJuYWxTYW1wbGVSYXRlLFxuICAgICAgICAgICAgICAgIGZvcmNlUGFnZUZsdXNoOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbnRlcmxlYXZlUGFnZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRTdWJ0aXRsZUN1ZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdWJ0aXRsZSB0cmFja3MgYXJlIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIGFsbFRyYWNrc0FyZUtub3duKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHRyYWNrIG9mIHRoaXMub3V0cHV0Ll90cmFja3MpIHtcbiAgICAgICAgICAgIGlmICghdHJhY2suc291cmNlLl9jbG9zZWQgJiYgIXRoaXMudHJhY2tEYXRhcy5zb21lKHggPT4geC50cmFjayA9PT0gdHJhY2spKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBXZSBoYXZlbid0IHNlZW4gYSBzYW1wbGUgZnJvbSB0aGlzIG9wZW4gdHJhY2sgeWV0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFzeW5jIGludGVybGVhdmVQYWdlcyhpc0ZpbmFsQ2FsbCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5ib3NQYWdlc1dyaXR0ZW4pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxUcmFja3NBcmVLbm93bigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBXZSBjYW4ndCBpbnRlcmxlYXZlIHlldCBhcyB3ZSBkb24ndCB5ZXQga25vdyBob3cgbWFueSB0cmFja3Mgd2UnbGwgdHJ1bHkgaGF2ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV3JpdGUgdGhlIGhlYWRlciBwYWdlIGZvciBhbGwgYml0c3RyZWFtc1xuICAgICAgICAgICAgZm9yIChjb25zdCB0cmFja0RhdGEgb2YgdGhpcy50cmFja0RhdGFzKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRyYWNrRGF0YS5wYWNrZXRRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IHRyYWNrRGF0YS5wYWNrZXRRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlUGFja2V0KHRyYWNrRGF0YSwgcGFja2V0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWNrZXQuZm9yY2VQYWdlRmx1c2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNheSB0aGUgaGVhZGVyIHBhZ2UgZW5kcyBvbmNlIHRoZSBmaXJzdCBwYWNrZXQgaXMgZW5jb3VudGVyZWQgdGhhdCBmb3JjZXMgYSBwYWdlIGZsdXNoXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYm9zUGFnZXNXcml0dGVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBvdXRlcjogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGxldCB0cmFja1dpdGhNaW5UaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICAgICAgbGV0IG1pblRpbWVzdGFtcCA9IEluZmluaXR5O1xuICAgICAgICAgICAgZm9yIChjb25zdCB0cmFja0RhdGEgb2YgdGhpcy50cmFja0RhdGFzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZpbmFsQ2FsbFxuICAgICAgICAgICAgICAgICAgICAmJiB0cmFja0RhdGEucGFja2V0UXVldWUubGVuZ3RoIDw9IDEgLy8gTGltaXQgaXMgMSwgbm90IDAsIGZvciBjb3JyZWN0IEVPUyBmbGFnIGxvZ2ljXG4gICAgICAgICAgICAgICAgICAgICYmICF0cmFja0RhdGEudHJhY2suc291cmNlLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cmFja0RhdGEucGFja2V0UXVldWUubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICAmJiB0cmFja0RhdGEucGFja2V0UXVldWVbMF0udGltZXN0YW1wIDwgbWluVGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrV2l0aE1pblRpbWVzdGFtcCA9IHRyYWNrRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgbWluVGltZXN0YW1wID0gdHJhY2tEYXRhLnBhY2tldFF1ZXVlWzBdLnRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRyYWNrV2l0aE1pblRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gdHJhY2tXaXRoTWluVGltZXN0YW1wLnBhY2tldFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCBpc0ZpbmFsUGFja2V0ID0gdHJhY2tXaXRoTWluVGltZXN0YW1wLnBhY2tldFF1ZXVlLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgIHRoaXMud3JpdGVQYWNrZXQodHJhY2tXaXRoTWluVGltZXN0YW1wLCBwYWNrZXQsIGlzRmluYWxQYWNrZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNGaW5hbENhbGwpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVQYWNrZXQodHJhY2tEYXRhLCBwYWNrZXQsIGlzRmluYWxQYWNrZXQpIHtcbiAgICAgICAgbGV0IHJlbWFpbmluZ0xlbmd0aCA9IHBhY2tldC5kYXRhLmxlbmd0aDtcbiAgICAgICAgbGV0IGRhdGFTdGFydE9mZnNldCA9IDA7XG4gICAgICAgIGxldCBkYXRhT2Zmc2V0ID0gMDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0cmFja0RhdGEuY3VycmVudExhY2luZ1ZhbHVlcy5sZW5ndGggPT09IDAgJiYgZGF0YVN0YXJ0T2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwYWNrZXQgc3Bhbm5pbmcgbXVsdGlwbGUgcGFnZXNcbiAgICAgICAgICAgICAgICB0cmFja0RhdGEuY3VycmVudFBhZ2VTdGFydHNXaXRoRnJlc2hQYWNrZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRTaXplID0gTWF0aC5taW4oMjU1LCByZW1haW5pbmdMZW5ndGgpO1xuICAgICAgICAgICAgdHJhY2tEYXRhLmN1cnJlbnRMYWNpbmdWYWx1ZXMucHVzaChzZWdtZW50U2l6ZSk7XG4gICAgICAgICAgICB0cmFja0RhdGEuY3VycmVudFBhZ2VTaXplKys7XG4gICAgICAgICAgICBkYXRhT2Zmc2V0ICs9IHNlZ21lbnRTaXplO1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudElzTGFzdE9mUGFja2V0ID0gcmVtYWluaW5nTGVuZ3RoIDwgMjU1O1xuICAgICAgICAgICAgaWYgKHRyYWNrRGF0YS5jdXJyZW50TGFjaW5nVmFsdWVzLmxlbmd0aCA9PT0gMjU1KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHBhZ2UgaXMgZnVsbCwgd2UgbmVlZCB0byBhZGQgcGFydCBvZiB0aGUgcGFja2V0IGRhdGEgYW5kIHRoZW4gZmx1c2ggdGhlIHBhZ2VcbiAgICAgICAgICAgICAgICBjb25zdCBzbGljZSA9IHBhY2tldC5kYXRhLnN1YmFycmF5KGRhdGFTdGFydE9mZnNldCwgZGF0YU9mZnNldCk7XG4gICAgICAgICAgICAgICAgZGF0YVN0YXJ0T2Zmc2V0ID0gZGF0YU9mZnNldDtcbiAgICAgICAgICAgICAgICB0cmFja0RhdGEuY3VycmVudFBhZ2VEYXRhLnB1c2goc2xpY2UpO1xuICAgICAgICAgICAgICAgIHRyYWNrRGF0YS5jdXJyZW50UGFnZVNpemUgKz0gc2xpY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVQYWdlKHRyYWNrRGF0YSwgaXNGaW5hbFBhY2tldCAmJiBzZWdtZW50SXNMYXN0T2ZQYWNrZXQpO1xuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50SXNMYXN0T2ZQYWNrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWdtZW50SXNMYXN0T2ZQYWNrZXQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbWFpbmluZ0xlbmd0aCAtPSAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2xpY2UgPSBwYWNrZXQuZGF0YS5zdWJhcnJheShkYXRhU3RhcnRPZmZzZXQpO1xuICAgICAgICB0cmFja0RhdGEuY3VycmVudFBhZ2VEYXRhLnB1c2goc2xpY2UpO1xuICAgICAgICB0cmFja0RhdGEuY3VycmVudFBhZ2VTaXplICs9IHNsaWNlLmxlbmd0aDtcbiAgICAgICAgdHJhY2tEYXRhLmN1cnJlbnRHcmFudWxlUG9zaXRpb24gPSBwYWNrZXQuZW5kR3JhbnVsZVBvc2l0aW9uO1xuICAgICAgICBpZiAodHJhY2tEYXRhLmN1cnJlbnRQYWdlU2l6ZSA+PSBQQUdFX1NJWkVfVEFSR0VUIHx8IHBhY2tldC5mb3JjZVBhZ2VGbHVzaCkge1xuICAgICAgICAgICAgdGhpcy53cml0ZVBhZ2UodHJhY2tEYXRhLCBpc0ZpbmFsUGFja2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZVBhZ2UodHJhY2tEYXRhLCBpc0Vvcykge1xuICAgICAgICB0aGlzLnBhZ2VWaWV3LnNldFVpbnQzMigwLCBPR0dTLCB0cnVlKTsgLy8gQ2FwdHVyZSBwYXR0ZXJuXG4gICAgICAgIHRoaXMucGFnZVZpZXcuc2V0VWludDgoNCwgMCk7IC8vIFZlcnNpb25cbiAgICAgICAgbGV0IGhlYWRlclR5cGUgPSAwO1xuICAgICAgICBpZiAoIXRyYWNrRGF0YS5jdXJyZW50UGFnZVN0YXJ0c1dpdGhGcmVzaFBhY2tldCkge1xuICAgICAgICAgICAgaGVhZGVyVHlwZSB8PSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFja0RhdGEucGFnZXNXcml0dGVuID09PSAwKSB7XG4gICAgICAgICAgICBoZWFkZXJUeXBlIHw9IDI7IC8vIEJlZ2lubmluZyBvZiBzdHJlYW1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFb3MpIHtcbiAgICAgICAgICAgIGhlYWRlclR5cGUgfD0gNDsgLy8gRW5kIG9mIHN0cmVhbVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFnZVZpZXcuc2V0VWludDgoNSwgaGVhZGVyVHlwZSk7IC8vIEhlYWRlciB0eXBlXG4gICAgICAgIGNvbnN0IGdyYW51bGVQb3NpdGlvbiA9IHRyYWNrRGF0YS5jdXJyZW50TGFjaW5nVmFsdWVzLmV2ZXJ5KHggPT4geCA9PT0gMjU1KVxuICAgICAgICAgICAgPyAtMSAvLyBObyBwYWNrZXRzIGVuZCBvbiB0aGlzIHBhZ2VcbiAgICAgICAgICAgIDogdHJhY2tEYXRhLmN1cnJlbnRHcmFudWxlUG9zaXRpb247XG4gICAgICAgIHNldEludDY0KHRoaXMucGFnZVZpZXcsIDYsIGdyYW51bGVQb3NpdGlvbiwgdHJ1ZSk7IC8vIEdyYW51bGUgcG9zaXRpb25cbiAgICAgICAgdGhpcy5wYWdlVmlldy5zZXRVaW50MzIoMTQsIHRyYWNrRGF0YS5zZXJpYWxOdW1iZXIsIHRydWUpOyAvLyBTZXJpYWwgbnVtYmVyXG4gICAgICAgIHRoaXMucGFnZVZpZXcuc2V0VWludDMyKDE4LCB0cmFja0RhdGEucGFnZXNXcml0dGVuLCB0cnVlKTsgLy8gUGFnZSBzZXF1ZW5jZSBudW1iZXJcbiAgICAgICAgdGhpcy5wYWdlVmlldy5zZXRVaW50MzIoMjIsIDAsIHRydWUpOyAvLyBDaGVja3N1bSBwbGFjZWhvbGRlclxuICAgICAgICB0aGlzLnBhZ2VWaWV3LnNldFVpbnQ4KDI2LCB0cmFja0RhdGEuY3VycmVudExhY2luZ1ZhbHVlcy5sZW5ndGgpOyAvLyBOdW1iZXIgb2YgcGFnZSBzZWdtZW50c1xuICAgICAgICB0aGlzLnBhZ2VCeXRlcy5zZXQodHJhY2tEYXRhLmN1cnJlbnRMYWNpbmdWYWx1ZXMsIDI3KTtcbiAgICAgICAgbGV0IHBvcyA9IDI3ICsgdHJhY2tEYXRhLmN1cnJlbnRMYWNpbmdWYWx1ZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGNvbnN0IGRhdGEgb2YgdHJhY2tEYXRhLmN1cnJlbnRQYWdlRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5wYWdlQnl0ZXMuc2V0KGRhdGEsIHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2xpY2UgPSB0aGlzLnBhZ2VCeXRlcy5zdWJhcnJheSgwLCBwb3MpO1xuICAgICAgICBjb25zdCBjcmMgPSBjb21wdXRlT2dnUGFnZUNyYyhzbGljZSk7XG4gICAgICAgIHRoaXMucGFnZVZpZXcuc2V0VWludDMyKDIyLCBjcmMsIHRydWUpOyAvLyBDaGVja3N1bVxuICAgICAgICB0cmFja0RhdGEucGFnZXNXcml0dGVuKys7XG4gICAgICAgIHRyYWNrRGF0YS5jdXJyZW50TGFjaW5nVmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRyYWNrRGF0YS5jdXJyZW50UGFnZURhdGEubGVuZ3RoID0gMDtcbiAgICAgICAgdHJhY2tEYXRhLmN1cnJlbnRQYWdlU2l6ZSA9IDI3O1xuICAgICAgICB0cmFja0RhdGEuY3VycmVudFBhZ2VTdGFydHNXaXRoRnJlc2hQYWNrZXQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5mb3JtYXQuX29wdGlvbnMub25QYWdlKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlci5zdGFydFRyYWNraW5nV3JpdGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZXIud3JpdGUoc2xpY2UpO1xuICAgICAgICBpZiAodGhpcy5mb3JtYXQuX29wdGlvbnMub25QYWdlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIHN0YXJ0IH0gPSB0aGlzLndyaXRlci5zdG9wVHJhY2tpbmdXcml0ZXMoKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0Ll9vcHRpb25zLm9uUGFnZShkYXRhLCBzdGFydCwgdHJhY2tEYXRhLnRyYWNrLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzXG4gICAgYXN5bmMgb25UcmFja0Nsb3NlKCkge1xuICAgICAgICBjb25zdCByZWxlYXNlID0gYXdhaXQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgIGlmICh0aGlzLmFsbFRyYWNrc0FyZUtub3duKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsVHJhY2tzS25vd24ucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIGEgdHJhY2sgaXMgbm93IGNsb3NlZCwgd2UgbWF5IGJlIGFibGUgdG8gd3JpdGUgb3V0IGNodW5rcyB0aGF0IHdlcmUgcHJldmlvdXNseSB3YWl0aW5nXG4gICAgICAgIGF3YWl0IHRoaXMuaW50ZXJsZWF2ZVBhZ2VzKCk7XG4gICAgICAgIHJlbGVhc2UoKTtcbiAgICB9XG4gICAgYXN5bmMgZmluYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJlbGVhc2UgPSBhd2FpdCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgdGhpcy5hbGxUcmFja3NLbm93bi5yZXNvbHZlKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuaW50ZXJsZWF2ZVBhZ2VzKHRydWUpO1xuICAgICAgICBmb3IgKGNvbnN0IHRyYWNrRGF0YSBvZiB0aGlzLnRyYWNrRGF0YXMpIHtcbiAgICAgICAgICAgIGlmICh0cmFja0RhdGEuY3VycmVudExhY2luZ1ZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVBhZ2UodHJhY2tEYXRhLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWxlYXNlKCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/ogg/ogg-muxer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/ogg/ogg-reader.js":
/*!********************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/ogg/ogg-reader.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_PAGE_HEADER_SIZE: () => (/* binding */ MAX_PAGE_HEADER_SIZE),\n/* harmony export */   MAX_PAGE_SIZE: () => (/* binding */ MAX_PAGE_SIZE),\n/* harmony export */   MIN_PAGE_HEADER_SIZE: () => (/* binding */ MIN_PAGE_HEADER_SIZE),\n/* harmony export */   findNextPageHeader: () => (/* binding */ findNextPageHeader),\n/* harmony export */   readPageHeader: () => (/* binding */ readPageHeader)\n/* harmony export */ });\n/* harmony import */ var _reader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../reader.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/reader.js\");\n/* harmony import */ var _ogg_misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ogg-misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/ogg/ogg-misc.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\nconst MIN_PAGE_HEADER_SIZE = 27;\nconst MAX_PAGE_HEADER_SIZE = 27 + 255;\nconst MAX_PAGE_SIZE = MAX_PAGE_HEADER_SIZE + 255 * 255;\nconst readPageHeader = (slice) => {\n    const startPos = slice.filePos;\n    const capturePattern = (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readU32Le)(slice);\n    if (capturePattern !== _ogg_misc_js__WEBPACK_IMPORTED_MODULE_1__.OGGS) {\n        return null;\n    }\n    slice.skip(1); // Version\n    const headerType = (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readU8)(slice);\n    const granulePosition = (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readI64Le)(slice);\n    const serialNumber = (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readU32Le)(slice);\n    const sequenceNumber = (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readU32Le)(slice);\n    const checksum = (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readU32Le)(slice);\n    const numberPageSegments = (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readU8)(slice);\n    const lacingValues = new Uint8Array(numberPageSegments);\n    for (let i = 0; i < numberPageSegments; i++) {\n        lacingValues[i] = (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readU8)(slice);\n    }\n    const headerSize = 27 + numberPageSegments;\n    const dataSize = lacingValues.reduce((a, b) => a + b, 0);\n    const totalSize = headerSize + dataSize;\n    return {\n        headerStartPos: startPos,\n        totalSize,\n        dataStartPos: startPos + headerSize,\n        dataSize,\n        headerType,\n        granulePosition,\n        serialNumber,\n        sequenceNumber,\n        checksum,\n        lacingValues,\n    };\n};\nconst findNextPageHeader = (slice, until) => {\n    while (slice.filePos < until - (4 - 1)) { // Size of word minus 1\n        const word = (0,_reader_js__WEBPACK_IMPORTED_MODULE_0__.readU32Le)(slice);\n        const firstByte = word & 0xff;\n        const secondByte = (word >>> 8) & 0xff;\n        const thirdByte = (word >>> 16) & 0xff;\n        const fourthByte = (word >>> 24) & 0xff;\n        const O = 0x4f; // 'O'\n        if (firstByte !== O && secondByte !== O && thirdByte !== O && fourthByte !== O) {\n            continue;\n        }\n        slice.skip(-4);\n        if (word === _ogg_misc_js__WEBPACK_IMPORTED_MODULE_1__.OGGS) {\n            // We have found the capture pattern\n            return true;\n        }\n        slice.skip(1);\n    }\n    return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL29nZy9vZ2ctcmVhZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0RDtBQUN2QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0EsMkJBQTJCLHFEQUFTO0FBQ3BDLDJCQUEyQiw4Q0FBSTtBQUMvQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLHVCQUF1QixrREFBTTtBQUM3Qiw0QkFBNEIscURBQVM7QUFDckMseUJBQXlCLHFEQUFTO0FBQ2xDLDJCQUEyQixxREFBUztBQUNwQyxxQkFBcUIscURBQVM7QUFDOUIsK0JBQStCLGtEQUFNO0FBQ3JDO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QywwQkFBMEIsa0RBQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsOENBQThDO0FBQzlDLHFCQUFxQixxREFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4Q0FBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGNoLWN1dC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL29nZy9vZ2ctcmVhZGVyLmpzPzUwZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjUtcHJlc2VudCwgVmFuaWxhZ3kgYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgeyByZWFkSTY0TGUsIHJlYWRVMzJMZSwgcmVhZFU4IH0gZnJvbSAnLi4vcmVhZGVyLmpzJztcbmltcG9ydCB7IE9HR1MgfSBmcm9tICcuL29nZy1taXNjLmpzJztcbmV4cG9ydCBjb25zdCBNSU5fUEFHRV9IRUFERVJfU0laRSA9IDI3O1xuZXhwb3J0IGNvbnN0IE1BWF9QQUdFX0hFQURFUl9TSVpFID0gMjcgKyAyNTU7XG5leHBvcnQgY29uc3QgTUFYX1BBR0VfU0laRSA9IE1BWF9QQUdFX0hFQURFUl9TSVpFICsgMjU1ICogMjU1O1xuZXhwb3J0IGNvbnN0IHJlYWRQYWdlSGVhZGVyID0gKHNsaWNlKSA9PiB7XG4gICAgY29uc3Qgc3RhcnRQb3MgPSBzbGljZS5maWxlUG9zO1xuICAgIGNvbnN0IGNhcHR1cmVQYXR0ZXJuID0gcmVhZFUzMkxlKHNsaWNlKTtcbiAgICBpZiAoY2FwdHVyZVBhdHRlcm4gIT09IE9HR1MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNsaWNlLnNraXAoMSk7IC8vIFZlcnNpb25cbiAgICBjb25zdCBoZWFkZXJUeXBlID0gcmVhZFU4KHNsaWNlKTtcbiAgICBjb25zdCBncmFudWxlUG9zaXRpb24gPSByZWFkSTY0TGUoc2xpY2UpO1xuICAgIGNvbnN0IHNlcmlhbE51bWJlciA9IHJlYWRVMzJMZShzbGljZSk7XG4gICAgY29uc3Qgc2VxdWVuY2VOdW1iZXIgPSByZWFkVTMyTGUoc2xpY2UpO1xuICAgIGNvbnN0IGNoZWNrc3VtID0gcmVhZFUzMkxlKHNsaWNlKTtcbiAgICBjb25zdCBudW1iZXJQYWdlU2VnbWVudHMgPSByZWFkVTgoc2xpY2UpO1xuICAgIGNvbnN0IGxhY2luZ1ZhbHVlcyA9IG5ldyBVaW50OEFycmF5KG51bWJlclBhZ2VTZWdtZW50cyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJQYWdlU2VnbWVudHM7IGkrKykge1xuICAgICAgICBsYWNpbmdWYWx1ZXNbaV0gPSByZWFkVTgoc2xpY2UpO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJTaXplID0gMjcgKyBudW1iZXJQYWdlU2VnbWVudHM7XG4gICAgY29uc3QgZGF0YVNpemUgPSBsYWNpbmdWYWx1ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gICAgY29uc3QgdG90YWxTaXplID0gaGVhZGVyU2l6ZSArIGRhdGFTaXplO1xuICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlclN0YXJ0UG9zOiBzdGFydFBvcyxcbiAgICAgICAgdG90YWxTaXplLFxuICAgICAgICBkYXRhU3RhcnRQb3M6IHN0YXJ0UG9zICsgaGVhZGVyU2l6ZSxcbiAgICAgICAgZGF0YVNpemUsXG4gICAgICAgIGhlYWRlclR5cGUsXG4gICAgICAgIGdyYW51bGVQb3NpdGlvbixcbiAgICAgICAgc2VyaWFsTnVtYmVyLFxuICAgICAgICBzZXF1ZW5jZU51bWJlcixcbiAgICAgICAgY2hlY2tzdW0sXG4gICAgICAgIGxhY2luZ1ZhbHVlcyxcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBmaW5kTmV4dFBhZ2VIZWFkZXIgPSAoc2xpY2UsIHVudGlsKSA9PiB7XG4gICAgd2hpbGUgKHNsaWNlLmZpbGVQb3MgPCB1bnRpbCAtICg0IC0gMSkpIHsgLy8gU2l6ZSBvZiB3b3JkIG1pbnVzIDFcbiAgICAgICAgY29uc3Qgd29yZCA9IHJlYWRVMzJMZShzbGljZSk7XG4gICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IHdvcmQgJiAweGZmO1xuICAgICAgICBjb25zdCBzZWNvbmRCeXRlID0gKHdvcmQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgY29uc3QgdGhpcmRCeXRlID0gKHdvcmQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGNvbnN0IGZvdXJ0aEJ5dGUgPSAod29yZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgY29uc3QgTyA9IDB4NGY7IC8vICdPJ1xuICAgICAgICBpZiAoZmlyc3RCeXRlICE9PSBPICYmIHNlY29uZEJ5dGUgIT09IE8gJiYgdGhpcmRCeXRlICE9PSBPICYmIGZvdXJ0aEJ5dGUgIT09IE8pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHNsaWNlLnNraXAoLTQpO1xuICAgICAgICBpZiAod29yZCA9PT0gT0dHUykge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBmb3VuZCB0aGUgY2FwdHVyZSBwYXR0ZXJuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzbGljZS5za2lwKDEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/ogg/ogg-reader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/output-format.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/output-format.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdtsOutputFormat: () => (/* binding */ AdtsOutputFormat),\n/* harmony export */   IsobmffOutputFormat: () => (/* binding */ IsobmffOutputFormat),\n/* harmony export */   MkvOutputFormat: () => (/* binding */ MkvOutputFormat),\n/* harmony export */   MovOutputFormat: () => (/* binding */ MovOutputFormat),\n/* harmony export */   Mp3OutputFormat: () => (/* binding */ Mp3OutputFormat),\n/* harmony export */   Mp4OutputFormat: () => (/* binding */ Mp4OutputFormat),\n/* harmony export */   OggOutputFormat: () => (/* binding */ OggOutputFormat),\n/* harmony export */   OutputFormat: () => (/* binding */ OutputFormat),\n/* harmony export */   WavOutputFormat: () => (/* binding */ WavOutputFormat),\n/* harmony export */   WebMOutputFormat: () => (/* binding */ WebMOutputFormat)\n/* harmony export */ });\n/* harmony import */ var _adts_adts_muxer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./adts/adts-muxer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/adts/adts-muxer.js\");\n/* harmony import */ var _codec_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./codec.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec.js\");\n/* harmony import */ var _isobmff_isobmff_muxer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isobmff/isobmff-muxer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/isobmff/isobmff-muxer.js\");\n/* harmony import */ var _matroska_matroska_muxer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./matroska/matroska-muxer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/matroska/matroska-muxer.js\");\n/* harmony import */ var _mp3_mp3_muxer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mp3/mp3-muxer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/mp3/mp3-muxer.js\");\n/* harmony import */ var _ogg_ogg_muxer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ogg/ogg-muxer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/ogg/ogg-muxer.js\");\n/* harmony import */ var _wave_wave_muxer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wave/wave-muxer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/wave/wave-muxer.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n\n\n/**\n * Base class representing an output media file format.\n * @group Output formats\n * @public\n */\nclass OutputFormat {\n    /** Returns a list of video codecs that this output format can contain. */\n    getSupportedVideoCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => _codec_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO_CODECS.includes(codec));\n    }\n    /** Returns a list of audio codecs that this output format can contain. */\n    getSupportedAudioCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => _codec_js__WEBPACK_IMPORTED_MODULE_0__.AUDIO_CODECS.includes(codec));\n    }\n    /** Returns a list of subtitle codecs that this output format can contain. */\n    getSupportedSubtitleCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => _codec_js__WEBPACK_IMPORTED_MODULE_0__.SUBTITLE_CODECS.includes(codec));\n    }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _codecUnsupportedHint(codec) {\n        return '';\n    }\n}\n/**\n * Format representing files compatible with the ISO base media file format (ISOBMFF), like MP4 or MOV files.\n * @group Output formats\n * @public\n */\nclass IsobmffOutputFormat extends OutputFormat {\n    /** Internal constructor. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.fastStart !== undefined && ![false, 'in-memory', 'fragmented'].includes(options.fastStart)) {\n            throw new TypeError('options.fastStart, when provided, must be false, \"in-memory\", or \"fragmented\".');\n        }\n        if (options.minimumFragmentDuration !== undefined\n            && (!Number.isFinite(options.minimumFragmentDuration) || options.minimumFragmentDuration < 0)) {\n            throw new TypeError('options.minimumFragmentDuration, when provided, must be a non-negative number.');\n        }\n        if (options.onFtyp !== undefined && typeof options.onFtyp !== 'function') {\n            throw new TypeError('options.onFtyp, when provided, must be a function.');\n        }\n        if (options.onMoov !== undefined && typeof options.onMoov !== 'function') {\n            throw new TypeError('options.onMoov, when provided, must be a function.');\n        }\n        if (options.onMdat !== undefined && typeof options.onMdat !== 'function') {\n            throw new TypeError('options.onMdat, when provided, must be a function.');\n        }\n        if (options.onMoof !== undefined && typeof options.onMoof !== 'function') {\n            throw new TypeError('options.onMoof, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: Infinity },\n            audio: { min: 0, max: Infinity },\n            subtitle: { min: 0, max: Infinity },\n            total: { min: 1, max: 2 ** 32 - 1 }, // Have fun reaching this one\n        };\n    }\n    get supportsVideoRotationMetadata() {\n        return true;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new _isobmff_isobmff_muxer_js__WEBPACK_IMPORTED_MODULE_1__.IsobmffMuxer(output, this);\n    }\n}\n/**\n * MPEG-4 Part 14 (MP4) file format. Supports most codecs.\n * @group Output formats\n * @public\n */\nclass Mp4OutputFormat extends IsobmffOutputFormat {\n    /** Creates a new {@link Mp4OutputFormat} configured with the specified `options`. */\n    constructor(options) {\n        super(options);\n    }\n    /** @internal */\n    get _name() {\n        return 'MP4';\n    }\n    get fileExtension() {\n        return '.mp4';\n    }\n    get mimeType() {\n        return 'video/mp4';\n    }\n    getSupportedCodecs() {\n        return [\n            ..._codec_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO_CODECS,\n            ..._codec_js__WEBPACK_IMPORTED_MODULE_0__.NON_PCM_AUDIO_CODECS,\n            // These are supported via ISO/IEC 23003-5\n            'pcm-s16',\n            'pcm-s16be',\n            'pcm-s24',\n            'pcm-s24be',\n            'pcm-s32',\n            'pcm-s32be',\n            'pcm-f32',\n            'pcm-f32be',\n            'pcm-f64',\n            'pcm-f64be',\n            ..._codec_js__WEBPACK_IMPORTED_MODULE_0__.SUBTITLE_CODECS,\n        ];\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new MovOutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MOV will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * QuickTime File Format (QTFF), often called MOV. Supports all video and audio codecs, but not subtitle codecs.\n * @group Output formats\n * @public\n */\nclass MovOutputFormat extends IsobmffOutputFormat {\n    /** Creates a new {@link MovOutputFormat} configured with the specified `options`. */\n    constructor(options) {\n        super(options);\n    }\n    /** @internal */\n    get _name() {\n        return 'MOV';\n    }\n    get fileExtension() {\n        return '.mov';\n    }\n    get mimeType() {\n        return 'video/quicktime';\n    }\n    getSupportedCodecs() {\n        return [\n            ..._codec_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO_CODECS,\n            ..._codec_js__WEBPACK_IMPORTED_MODULE_0__.AUDIO_CODECS,\n        ];\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new Mp4OutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MP4 will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * Matroska file format.\n * @group Output formats\n * @public\n */\nclass MkvOutputFormat extends OutputFormat {\n    /** Creates a new {@link MkvOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.appendOnly !== undefined && typeof options.appendOnly !== 'boolean') {\n            throw new TypeError('options.appendOnly, when provided, must be a boolean.');\n        }\n        if (options.minimumClusterDuration !== undefined\n            && (!Number.isFinite(options.minimumClusterDuration) || options.minimumClusterDuration < 0)) {\n            throw new TypeError('options.minimumClusterDuration, when provided, must be a non-negative number.');\n        }\n        if (options.onEbmlHeader !== undefined && typeof options.onEbmlHeader !== 'function') {\n            throw new TypeError('options.onEbmlHeader, when provided, must be a function.');\n        }\n        if (options.onSegmentHeader !== undefined && typeof options.onSegmentHeader !== 'function') {\n            throw new TypeError('options.onHeader, when provided, must be a function.');\n        }\n        if (options.onCluster !== undefined && typeof options.onCluster !== 'function') {\n            throw new TypeError('options.onCluster, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new _matroska_matroska_muxer_js__WEBPACK_IMPORTED_MODULE_2__.MatroskaMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'Matroska';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: Infinity },\n            audio: { min: 0, max: Infinity },\n            subtitle: { min: 0, max: Infinity },\n            total: { min: 1, max: 127 },\n        };\n    }\n    get fileExtension() {\n        return '.mkv';\n    }\n    get mimeType() {\n        return 'video/x-matroska';\n    }\n    getSupportedCodecs() {\n        return [\n            ..._codec_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO_CODECS,\n            ..._codec_js__WEBPACK_IMPORTED_MODULE_0__.NON_PCM_AUDIO_CODECS,\n            ..._codec_js__WEBPACK_IMPORTED_MODULE_0__.PCM_AUDIO_CODECS.filter(codec => !['pcm-s8', 'pcm-f32be', 'pcm-f64be', 'ulaw', 'alaw'].includes(codec)),\n            ..._codec_js__WEBPACK_IMPORTED_MODULE_0__.SUBTITLE_CODECS,\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        // While it technically does support it with ProjectionPoseRoll, many players appear to ignore this value\n        return false;\n    }\n}\n/**\n * WebM file format, based on Matroska.\n * @group Output formats\n * @public\n */\nclass WebMOutputFormat extends MkvOutputFormat {\n    /** Creates a new {@link WebMOutputFormat} configured with the specified `options`. */\n    constructor(options) {\n        super(options);\n    }\n    getSupportedCodecs() {\n        return [\n            ..._codec_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO_CODECS.filter(codec => ['vp8', 'vp9', 'av1'].includes(codec)),\n            ..._codec_js__WEBPACK_IMPORTED_MODULE_0__.AUDIO_CODECS.filter(codec => ['opus', 'vorbis'].includes(codec)),\n            ..._codec_js__WEBPACK_IMPORTED_MODULE_0__.SUBTITLE_CODECS,\n        ];\n    }\n    /** @internal */\n    get _name() {\n        return 'WebM';\n    }\n    get fileExtension() {\n        return '.webm';\n    }\n    get mimeType() {\n        return 'video/webm';\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new MkvOutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MKV will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * MP3 file format.\n * @group Output formats\n * @public\n */\nclass Mp3OutputFormat extends OutputFormat {\n    /** Creates a new {@link Mp3OutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.xingHeader !== undefined && typeof options.xingHeader !== 'boolean') {\n            throw new TypeError('options.xingHeader, when provided, must be a boolean.');\n        }\n        if (options.onXingFrame !== undefined && typeof options.onXingFrame !== 'function') {\n            throw new TypeError('options.onXingFrame, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new _mp3_mp3_muxer_js__WEBPACK_IMPORTED_MODULE_3__.Mp3Muxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'MP3';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.mp3';\n    }\n    get mimeType() {\n        return 'audio/mpeg';\n    }\n    getSupportedCodecs() {\n        return ['mp3'];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * WAVE file format, based on RIFF.\n * @group Output formats\n * @public\n */\nclass WavOutputFormat extends OutputFormat {\n    /** Creates a new {@link WavOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.large !== undefined && typeof options.large !== 'boolean') {\n            throw new TypeError('options.large, when provided, must be a boolean.');\n        }\n        if (options.onHeader !== undefined && typeof options.onHeader !== 'function') {\n            throw new TypeError('options.onHeader, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new _wave_wave_muxer_js__WEBPACK_IMPORTED_MODULE_4__.WaveMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'WAVE';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.wav';\n    }\n    get mimeType() {\n        return 'audio/wav';\n    }\n    getSupportedCodecs() {\n        return [\n            ..._codec_js__WEBPACK_IMPORTED_MODULE_0__.PCM_AUDIO_CODECS.filter(codec => ['pcm-s16', 'pcm-s24', 'pcm-s32', 'pcm-f32', 'pcm-u8', 'ulaw', 'alaw'].includes(codec)),\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * Ogg file format.\n * @group Output formats\n * @public\n */\nclass OggOutputFormat extends OutputFormat {\n    /** Creates a new {@link OggOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.onPage !== undefined && typeof options.onPage !== 'function') {\n            throw new TypeError('options.onPage, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new _ogg_ogg_muxer_js__WEBPACK_IMPORTED_MODULE_5__.OggMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'Ogg';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 0, max: Infinity },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 2 ** 32 },\n        };\n    }\n    get fileExtension() {\n        return '.ogg';\n    }\n    get mimeType() {\n        return 'application/ogg';\n    }\n    getSupportedCodecs() {\n        return [\n            ..._codec_js__WEBPACK_IMPORTED_MODULE_0__.AUDIO_CODECS.filter(codec => ['vorbis', 'opus'].includes(codec)),\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * ADTS file format.\n * @group Output formats\n * @public\n */\nclass AdtsOutputFormat extends OutputFormat {\n    /** Creates a new {@link AdtsOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.onFrame !== undefined && typeof options.onFrame !== 'function') {\n            throw new TypeError('options.onFrame, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new _adts_adts_muxer_js__WEBPACK_IMPORTED_MODULE_6__.AdtsMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'ADTS';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.aac';\n    }\n    get mimeType() {\n        return 'audio/aac';\n    }\n    getSupportedCodecs() {\n        return ['aac'];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL291dHB1dC1mb3JtYXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpRDtBQUNpRTtBQUN4RDtBQUNHO0FBQ2Y7QUFDQTtBQUNHO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtREFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtREFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUMscUJBQXFCLHVCQUF1QjtBQUM1Qyx3QkFBd0IsdUJBQXVCO0FBQy9DLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUVBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBWTtBQUMzQixlQUFlLDJEQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdURBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDLHFCQUFxQix1QkFBdUI7QUFDNUMsd0JBQXdCLGdCQUFnQjtBQUN4QyxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx1QkFBdUIsd0JBQXdCO0FBQy9DLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQyxxQkFBcUIsZ0JBQWdCO0FBQ3JDLHdCQUF3QixnQkFBZ0I7QUFDeEMscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRjaC1jdXQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL21lZGlhYnVubnkvZGlzdC9tb2R1bGVzL3NyYy9vdXRwdXQtZm9ybWF0LmpzPzJmNjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjUtcHJlc2VudCwgVmFuaWxhZ3kgYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgeyBBZHRzTXV4ZXIgfSBmcm9tICcuL2FkdHMvYWR0cy1tdXhlci5qcyc7XG5pbXBvcnQgeyBBVURJT19DT0RFQ1MsIE5PTl9QQ01fQVVESU9fQ09ERUNTLCBQQ01fQVVESU9fQ09ERUNTLCBTVUJUSVRMRV9DT0RFQ1MsIFZJREVPX0NPREVDUywgfSBmcm9tICcuL2NvZGVjLmpzJztcbmltcG9ydCB7IElzb2JtZmZNdXhlciB9IGZyb20gJy4vaXNvYm1mZi9pc29ibWZmLW11eGVyLmpzJztcbmltcG9ydCB7IE1hdHJvc2thTXV4ZXIgfSBmcm9tICcuL21hdHJvc2thL21hdHJvc2thLW11eGVyLmpzJztcbmltcG9ydCB7IE1wM011eGVyIH0gZnJvbSAnLi9tcDMvbXAzLW11eGVyLmpzJztcbmltcG9ydCB7IE9nZ011eGVyIH0gZnJvbSAnLi9vZ2cvb2dnLW11eGVyLmpzJztcbmltcG9ydCB7IFdhdmVNdXhlciB9IGZyb20gJy4vd2F2ZS93YXZlLW11eGVyLmpzJztcbi8qKlxuICogQmFzZSBjbGFzcyByZXByZXNlbnRpbmcgYW4gb3V0cHV0IG1lZGlhIGZpbGUgZm9ybWF0LlxuICogQGdyb3VwIE91dHB1dCBmb3JtYXRzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBPdXRwdXRGb3JtYXQge1xuICAgIC8qKiBSZXR1cm5zIGEgbGlzdCBvZiB2aWRlbyBjb2RlY3MgdGhhdCB0aGlzIG91dHB1dCBmb3JtYXQgY2FuIGNvbnRhaW4uICovXG4gICAgZ2V0U3VwcG9ydGVkVmlkZW9Db2RlY3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN1cHBvcnRlZENvZGVjcygpXG4gICAgICAgICAgICAuZmlsdGVyKGNvZGVjID0+IFZJREVPX0NPREVDUy5pbmNsdWRlcyhjb2RlYykpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIGxpc3Qgb2YgYXVkaW8gY29kZWNzIHRoYXQgdGhpcyBvdXRwdXQgZm9ybWF0IGNhbiBjb250YWluLiAqL1xuICAgIGdldFN1cHBvcnRlZEF1ZGlvQ29kZWNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdXBwb3J0ZWRDb2RlY3MoKVxuICAgICAgICAgICAgLmZpbHRlcihjb2RlYyA9PiBBVURJT19DT0RFQ1MuaW5jbHVkZXMoY29kZWMpKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBsaXN0IG9mIHN1YnRpdGxlIGNvZGVjcyB0aGF0IHRoaXMgb3V0cHV0IGZvcm1hdCBjYW4gY29udGFpbi4gKi9cbiAgICBnZXRTdXBwb3J0ZWRTdWJ0aXRsZUNvZGVjcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3VwcG9ydGVkQ29kZWNzKClcbiAgICAgICAgICAgIC5maWx0ZXIoY29kZWMgPT4gU1VCVElUTEVfQ09ERUNTLmluY2x1ZGVzKGNvZGVjKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX2NvZGVjVW5zdXBwb3J0ZWRIaW50KGNvZGVjKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG4vKipcbiAqIEZvcm1hdCByZXByZXNlbnRpbmcgZmlsZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBJU08gYmFzZSBtZWRpYSBmaWxlIGZvcm1hdCAoSVNPQk1GRiksIGxpa2UgTVA0IG9yIE1PViBmaWxlcy5cbiAqIEBncm91cCBPdXRwdXQgZm9ybWF0c1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgSXNvYm1mZk91dHB1dEZvcm1hdCBleHRlbmRzIE91dHB1dEZvcm1hdCB7XG4gICAgLyoqIEludGVybmFsIGNvbnN0cnVjdG9yLiAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZhc3RTdGFydCAhPT0gdW5kZWZpbmVkICYmICFbZmFsc2UsICdpbi1tZW1vcnknLCAnZnJhZ21lbnRlZCddLmluY2x1ZGVzKG9wdGlvbnMuZmFzdFN0YXJ0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5mYXN0U3RhcnQsIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgZmFsc2UsIFwiaW4tbWVtb3J5XCIsIG9yIFwiZnJhZ21lbnRlZFwiLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm1pbmltdW1GcmFnbWVudER1cmF0aW9uICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICYmICghTnVtYmVyLmlzRmluaXRlKG9wdGlvbnMubWluaW11bUZyYWdtZW50RHVyYXRpb24pIHx8IG9wdGlvbnMubWluaW11bUZyYWdtZW50RHVyYXRpb24gPCAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5taW5pbXVtRnJhZ21lbnREdXJhdGlvbiwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMub25GdHlwICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMub25GdHlwICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLm9uRnR5cCwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm9uTW9vdiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLm9uTW9vdiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5vbk1vb3YsIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vbk1kYXQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5vbk1kYXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMub25NZGF0LCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMub25Nb29mICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMub25Nb29mICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLm9uTW9vZiwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBnZXRTdXBwb3J0ZWRUcmFja0NvdW50cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZpZGVvOiB7IG1pbjogMCwgbWF4OiBJbmZpbml0eSB9LFxuICAgICAgICAgICAgYXVkaW86IHsgbWluOiAwLCBtYXg6IEluZmluaXR5IH0sXG4gICAgICAgICAgICBzdWJ0aXRsZTogeyBtaW46IDAsIG1heDogSW5maW5pdHkgfSxcbiAgICAgICAgICAgIHRvdGFsOiB7IG1pbjogMSwgbWF4OiAyICoqIDMyIC0gMSB9LCAvLyBIYXZlIGZ1biByZWFjaGluZyB0aGlzIG9uZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgc3VwcG9ydHNWaWRlb1JvdGF0aW9uTWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2NyZWF0ZU11eGVyKG91dHB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IElzb2JtZmZNdXhlcihvdXRwdXQsIHRoaXMpO1xuICAgIH1cbn1cbi8qKlxuICogTVBFRy00IFBhcnQgMTQgKE1QNCkgZmlsZSBmb3JtYXQuIFN1cHBvcnRzIG1vc3QgY29kZWNzLlxuICogQGdyb3VwIE91dHB1dCBmb3JtYXRzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBNcDRPdXRwdXRGb3JtYXQgZXh0ZW5kcyBJc29ibWZmT3V0cHV0Rm9ybWF0IHtcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgTXA0T3V0cHV0Rm9ybWF0fSBjb25maWd1cmVkIHdpdGggdGhlIHNwZWNpZmllZCBgb3B0aW9uc2AuICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGdldCBfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdNUDQnO1xuICAgIH1cbiAgICBnZXQgZmlsZUV4dGVuc2lvbigpIHtcbiAgICAgICAgcmV0dXJuICcubXA0JztcbiAgICB9XG4gICAgZ2V0IG1pbWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gJ3ZpZGVvL21wNCc7XG4gICAgfVxuICAgIGdldFN1cHBvcnRlZENvZGVjcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLlZJREVPX0NPREVDUyxcbiAgICAgICAgICAgIC4uLk5PTl9QQ01fQVVESU9fQ09ERUNTLFxuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHN1cHBvcnRlZCB2aWEgSVNPL0lFQyAyMzAwMy01XG4gICAgICAgICAgICAncGNtLXMxNicsXG4gICAgICAgICAgICAncGNtLXMxNmJlJyxcbiAgICAgICAgICAgICdwY20tczI0JyxcbiAgICAgICAgICAgICdwY20tczI0YmUnLFxuICAgICAgICAgICAgJ3BjbS1zMzInLFxuICAgICAgICAgICAgJ3BjbS1zMzJiZScsXG4gICAgICAgICAgICAncGNtLWYzMicsXG4gICAgICAgICAgICAncGNtLWYzMmJlJyxcbiAgICAgICAgICAgICdwY20tZjY0JyxcbiAgICAgICAgICAgICdwY20tZjY0YmUnLFxuICAgICAgICAgICAgLi4uU1VCVElUTEVfQ09ERUNTLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2NvZGVjVW5zdXBwb3J0ZWRIaW50KGNvZGVjKSB7XG4gICAgICAgIGlmIChuZXcgTW92T3V0cHV0Rm9ybWF0KCkuZ2V0U3VwcG9ydGVkQ29kZWNzKCkuaW5jbHVkZXMoY29kZWMpKSB7XG4gICAgICAgICAgICByZXR1cm4gJyBTd2l0Y2hpbmcgdG8gTU9WIHdpbGwgZ3JhbnQgc3VwcG9ydCBmb3IgdGhpcyBjb2RlYy4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG4vKipcbiAqIFF1aWNrVGltZSBGaWxlIEZvcm1hdCAoUVRGRiksIG9mdGVuIGNhbGxlZCBNT1YuIFN1cHBvcnRzIGFsbCB2aWRlbyBhbmQgYXVkaW8gY29kZWNzLCBidXQgbm90IHN1YnRpdGxlIGNvZGVjcy5cbiAqIEBncm91cCBPdXRwdXQgZm9ybWF0c1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgTW92T3V0cHV0Rm9ybWF0IGV4dGVuZHMgSXNvYm1mZk91dHB1dEZvcm1hdCB7XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcge0BsaW5rIE1vdk91dHB1dEZvcm1hdH0gY29uZmlndXJlZCB3aXRoIHRoZSBzcGVjaWZpZWQgYG9wdGlvbnNgLiAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBnZXQgX25hbWUoKSB7XG4gICAgICAgIHJldHVybiAnTU9WJztcbiAgICB9XG4gICAgZ2V0IGZpbGVFeHRlbnNpb24oKSB7XG4gICAgICAgIHJldHVybiAnLm1vdic7XG4gICAgfVxuICAgIGdldCBtaW1lVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICd2aWRlby9xdWlja3RpbWUnO1xuICAgIH1cbiAgICBnZXRTdXBwb3J0ZWRDb2RlY3MoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi5WSURFT19DT0RFQ1MsXG4gICAgICAgICAgICAuLi5BVURJT19DT0RFQ1MsXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY29kZWNVbnN1cHBvcnRlZEhpbnQoY29kZWMpIHtcbiAgICAgICAgaWYgKG5ldyBNcDRPdXRwdXRGb3JtYXQoKS5nZXRTdXBwb3J0ZWRDb2RlY3MoKS5pbmNsdWRlcyhjb2RlYykpIHtcbiAgICAgICAgICAgIHJldHVybiAnIFN3aXRjaGluZyB0byBNUDQgd2lsbCBncmFudCBzdXBwb3J0IGZvciB0aGlzIGNvZGVjLic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbi8qKlxuICogTWF0cm9za2EgZmlsZSBmb3JtYXQuXG4gKiBAZ3JvdXAgT3V0cHV0IGZvcm1hdHNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIE1rdk91dHB1dEZvcm1hdCBleHRlbmRzIE91dHB1dEZvcm1hdCB7XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcge0BsaW5rIE1rdk91dHB1dEZvcm1hdH0gY29uZmlndXJlZCB3aXRoIHRoZSBzcGVjaWZpZWQgYG9wdGlvbnNgLiAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFwcGVuZE9ubHkgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5hcHBlbmRPbmx5ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuYXBwZW5kT25seSwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubWluaW11bUNsdXN0ZXJEdXJhdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAmJiAoIU51bWJlci5pc0Zpbml0ZShvcHRpb25zLm1pbmltdW1DbHVzdGVyRHVyYXRpb24pIHx8IG9wdGlvbnMubWluaW11bUNsdXN0ZXJEdXJhdGlvbiA8IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLm1pbmltdW1DbHVzdGVyRHVyYXRpb24sIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm9uRWJtbEhlYWRlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLm9uRWJtbEhlYWRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5vbkVibWxIZWFkZXIsIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vblNlZ21lbnRIZWFkZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5vblNlZ21lbnRIZWFkZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMub25IZWFkZXIsIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vbkNsdXN0ZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5vbkNsdXN0ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMub25DbHVzdGVyLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY3JlYXRlTXV4ZXIob3V0cHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTWF0cm9za2FNdXhlcihvdXRwdXQsIHRoaXMpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZ2V0IF9uYW1lKCkge1xuICAgICAgICByZXR1cm4gJ01hdHJvc2thJztcbiAgICB9XG4gICAgZ2V0U3VwcG9ydGVkVHJhY2tDb3VudHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2aWRlbzogeyBtaW46IDAsIG1heDogSW5maW5pdHkgfSxcbiAgICAgICAgICAgIGF1ZGlvOiB7IG1pbjogMCwgbWF4OiBJbmZpbml0eSB9LFxuICAgICAgICAgICAgc3VidGl0bGU6IHsgbWluOiAwLCBtYXg6IEluZmluaXR5IH0sXG4gICAgICAgICAgICB0b3RhbDogeyBtaW46IDEsIG1heDogMTI3IH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBmaWxlRXh0ZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4gJy5ta3YnO1xuICAgIH1cbiAgICBnZXQgbWltZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiAndmlkZW8veC1tYXRyb3NrYSc7XG4gICAgfVxuICAgIGdldFN1cHBvcnRlZENvZGVjcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLlZJREVPX0NPREVDUyxcbiAgICAgICAgICAgIC4uLk5PTl9QQ01fQVVESU9fQ09ERUNTLFxuICAgICAgICAgICAgLi4uUENNX0FVRElPX0NPREVDUy5maWx0ZXIoY29kZWMgPT4gIVsncGNtLXM4JywgJ3BjbS1mMzJiZScsICdwY20tZjY0YmUnLCAndWxhdycsICdhbGF3J10uaW5jbHVkZXMoY29kZWMpKSxcbiAgICAgICAgICAgIC4uLlNVQlRJVExFX0NPREVDUyxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZ2V0IHN1cHBvcnRzVmlkZW9Sb3RhdGlvbk1ldGFkYXRhKCkge1xuICAgICAgICAvLyBXaGlsZSBpdCB0ZWNobmljYWxseSBkb2VzIHN1cHBvcnQgaXQgd2l0aCBQcm9qZWN0aW9uUG9zZVJvbGwsIG1hbnkgcGxheWVycyBhcHBlYXIgdG8gaWdub3JlIHRoaXMgdmFsdWVcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogV2ViTSBmaWxlIGZvcm1hdCwgYmFzZWQgb24gTWF0cm9za2EuXG4gKiBAZ3JvdXAgT3V0cHV0IGZvcm1hdHNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFdlYk1PdXRwdXRGb3JtYXQgZXh0ZW5kcyBNa3ZPdXRwdXRGb3JtYXQge1xuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHtAbGluayBXZWJNT3V0cHV0Rm9ybWF0fSBjb25maWd1cmVkIHdpdGggdGhlIHNwZWNpZmllZCBgb3B0aW9uc2AuICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0U3VwcG9ydGVkQ29kZWNzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4uVklERU9fQ09ERUNTLmZpbHRlcihjb2RlYyA9PiBbJ3ZwOCcsICd2cDknLCAnYXYxJ10uaW5jbHVkZXMoY29kZWMpKSxcbiAgICAgICAgICAgIC4uLkFVRElPX0NPREVDUy5maWx0ZXIoY29kZWMgPT4gWydvcHVzJywgJ3ZvcmJpcyddLmluY2x1ZGVzKGNvZGVjKSksXG4gICAgICAgICAgICAuLi5TVUJUSVRMRV9DT0RFQ1MsXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBnZXQgX25hbWUoKSB7XG4gICAgICAgIHJldHVybiAnV2ViTSc7XG4gICAgfVxuICAgIGdldCBmaWxlRXh0ZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4gJy53ZWJtJztcbiAgICB9XG4gICAgZ2V0IG1pbWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gJ3ZpZGVvL3dlYm0nO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2NvZGVjVW5zdXBwb3J0ZWRIaW50KGNvZGVjKSB7XG4gICAgICAgIGlmIChuZXcgTWt2T3V0cHV0Rm9ybWF0KCkuZ2V0U3VwcG9ydGVkQ29kZWNzKCkuaW5jbHVkZXMoY29kZWMpKSB7XG4gICAgICAgICAgICByZXR1cm4gJyBTd2l0Y2hpbmcgdG8gTUtWIHdpbGwgZ3JhbnQgc3VwcG9ydCBmb3IgdGhpcyBjb2RlYy4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG4vKipcbiAqIE1QMyBmaWxlIGZvcm1hdC5cbiAqIEBncm91cCBPdXRwdXQgZm9ybWF0c1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgTXAzT3V0cHV0Rm9ybWF0IGV4dGVuZHMgT3V0cHV0Rm9ybWF0IHtcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgTXAzT3V0cHV0Rm9ybWF0fSBjb25maWd1cmVkIHdpdGggdGhlIHNwZWNpZmllZCBgb3B0aW9uc2AuICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMueGluZ0hlYWRlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLnhpbmdIZWFkZXIgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy54aW5nSGVhZGVyLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vblhpbmdGcmFtZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLm9uWGluZ0ZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLm9uWGluZ0ZyYW1lLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY3JlYXRlTXV4ZXIob3V0cHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTXAzTXV4ZXIob3V0cHV0LCB0aGlzKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGdldCBfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdNUDMnO1xuICAgIH1cbiAgICBnZXRTdXBwb3J0ZWRUcmFja0NvdW50cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZpZGVvOiB7IG1pbjogMCwgbWF4OiAwIH0sXG4gICAgICAgICAgICBhdWRpbzogeyBtaW46IDEsIG1heDogMSB9LFxuICAgICAgICAgICAgc3VidGl0bGU6IHsgbWluOiAwLCBtYXg6IDAgfSxcbiAgICAgICAgICAgIHRvdGFsOiB7IG1pbjogMSwgbWF4OiAxIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBmaWxlRXh0ZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4gJy5tcDMnO1xuICAgIH1cbiAgICBnZXQgbWltZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnYXVkaW8vbXBlZyc7XG4gICAgfVxuICAgIGdldFN1cHBvcnRlZENvZGVjcygpIHtcbiAgICAgICAgcmV0dXJuIFsnbXAzJ107XG4gICAgfVxuICAgIGdldCBzdXBwb3J0c1ZpZGVvUm90YXRpb25NZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogV0FWRSBmaWxlIGZvcm1hdCwgYmFzZWQgb24gUklGRi5cbiAqIEBncm91cCBPdXRwdXQgZm9ybWF0c1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgV2F2T3V0cHV0Rm9ybWF0IGV4dGVuZHMgT3V0cHV0Rm9ybWF0IHtcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgV2F2T3V0cHV0Rm9ybWF0fSBjb25maWd1cmVkIHdpdGggdGhlIHNwZWNpZmllZCBgb3B0aW9uc2AuICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubGFyZ2UgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5sYXJnZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLmxhcmdlLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vbkhlYWRlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLm9uSGVhZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLm9uSGVhZGVyLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY3JlYXRlTXV4ZXIob3V0cHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgV2F2ZU11eGVyKG91dHB1dCwgdGhpcyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBnZXQgX25hbWUoKSB7XG4gICAgICAgIHJldHVybiAnV0FWRSc7XG4gICAgfVxuICAgIGdldFN1cHBvcnRlZFRyYWNrQ291bnRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmlkZW86IHsgbWluOiAwLCBtYXg6IDAgfSxcbiAgICAgICAgICAgIGF1ZGlvOiB7IG1pbjogMSwgbWF4OiAxIH0sXG4gICAgICAgICAgICBzdWJ0aXRsZTogeyBtaW46IDAsIG1heDogMCB9LFxuICAgICAgICAgICAgdG90YWw6IHsgbWluOiAxLCBtYXg6IDEgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IGZpbGVFeHRlbnNpb24oKSB7XG4gICAgICAgIHJldHVybiAnLndhdic7XG4gICAgfVxuICAgIGdldCBtaW1lVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdhdWRpby93YXYnO1xuICAgIH1cbiAgICBnZXRTdXBwb3J0ZWRDb2RlY3MoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi5QQ01fQVVESU9fQ09ERUNTLmZpbHRlcihjb2RlYyA9PiBbJ3BjbS1zMTYnLCAncGNtLXMyNCcsICdwY20tczMyJywgJ3BjbS1mMzInLCAncGNtLXU4JywgJ3VsYXcnLCAnYWxhdyddLmluY2x1ZGVzKGNvZGVjKSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGdldCBzdXBwb3J0c1ZpZGVvUm90YXRpb25NZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogT2dnIGZpbGUgZm9ybWF0LlxuICogQGdyb3VwIE91dHB1dCBmb3JtYXRzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBPZ2dPdXRwdXRGb3JtYXQgZXh0ZW5kcyBPdXRwdXRGb3JtYXQge1xuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHtAbGluayBPZ2dPdXRwdXRGb3JtYXR9IGNvbmZpZ3VyZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGBvcHRpb25zYC4gKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vblBhZ2UgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5vblBhZ2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMub25QYWdlLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY3JlYXRlTXV4ZXIob3V0cHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgT2dnTXV4ZXIob3V0cHV0LCB0aGlzKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGdldCBfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdPZ2cnO1xuICAgIH1cbiAgICBnZXRTdXBwb3J0ZWRUcmFja0NvdW50cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZpZGVvOiB7IG1pbjogMCwgbWF4OiAwIH0sXG4gICAgICAgICAgICBhdWRpbzogeyBtaW46IDAsIG1heDogSW5maW5pdHkgfSxcbiAgICAgICAgICAgIHN1YnRpdGxlOiB7IG1pbjogMCwgbWF4OiAwIH0sXG4gICAgICAgICAgICB0b3RhbDogeyBtaW46IDEsIG1heDogMiAqKiAzMiB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgZmlsZUV4dGVuc2lvbigpIHtcbiAgICAgICAgcmV0dXJuICcub2dnJztcbiAgICB9XG4gICAgZ2V0IG1pbWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL29nZyc7XG4gICAgfVxuICAgIGdldFN1cHBvcnRlZENvZGVjcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLkFVRElPX0NPREVDUy5maWx0ZXIoY29kZWMgPT4gWyd2b3JiaXMnLCAnb3B1cyddLmluY2x1ZGVzKGNvZGVjKSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGdldCBzdXBwb3J0c1ZpZGVvUm90YXRpb25NZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogQURUUyBmaWxlIGZvcm1hdC5cbiAqIEBncm91cCBPdXRwdXQgZm9ybWF0c1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQWR0c091dHB1dEZvcm1hdCBleHRlbmRzIE91dHB1dEZvcm1hdCB7XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcge0BsaW5rIEFkdHNPdXRwdXRGb3JtYXR9IGNvbmZpZ3VyZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGBvcHRpb25zYC4gKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vbkZyYW1lICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMub25GcmFtZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5vbkZyYW1lLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY3JlYXRlTXV4ZXIob3V0cHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQWR0c011eGVyKG91dHB1dCwgdGhpcyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBnZXQgX25hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQURUUyc7XG4gICAgfVxuICAgIGdldFN1cHBvcnRlZFRyYWNrQ291bnRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmlkZW86IHsgbWluOiAwLCBtYXg6IDAgfSxcbiAgICAgICAgICAgIGF1ZGlvOiB7IG1pbjogMSwgbWF4OiAxIH0sXG4gICAgICAgICAgICBzdWJ0aXRsZTogeyBtaW46IDAsIG1heDogMCB9LFxuICAgICAgICAgICAgdG90YWw6IHsgbWluOiAxLCBtYXg6IDEgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IGZpbGVFeHRlbnNpb24oKSB7XG4gICAgICAgIHJldHVybiAnLmFhYyc7XG4gICAgfVxuICAgIGdldCBtaW1lVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdhdWRpby9hYWMnO1xuICAgIH1cbiAgICBnZXRTdXBwb3J0ZWRDb2RlY3MoKSB7XG4gICAgICAgIHJldHVybiBbJ2FhYyddO1xuICAgIH1cbiAgICBnZXQgc3VwcG9ydHNWaWRlb1JvdGF0aW9uTWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/output-format.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/output.js":
/*!************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/output.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALL_TRACK_TYPES: () => (/* binding */ ALL_TRACK_TYPES),\n/* harmony export */   Output: () => (/* binding */ Output)\n/* harmony export */ });\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/* harmony import */ var _tags_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tags.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/tags.js\");\n/* harmony import */ var _output_format_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./output-format.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/output-format.js\");\n/* harmony import */ var _media_source_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./media-source.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/media-source.js\");\n/* harmony import */ var _target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./target.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/target.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n/**\n * List of all track types.\n * @group Miscellaneous\n * @public\n */\nconst ALL_TRACK_TYPES = ['video', 'audio', 'subtitle'];\nconst validateBaseTrackMetadata = (metadata) => {\n    if (!metadata || typeof metadata !== 'object') {\n        throw new TypeError('metadata must be an object.');\n    }\n    if (metadata.languageCode !== undefined && !(0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.isIso639Dash2LanguageCode)(metadata.languageCode)) {\n        throw new TypeError('metadata.languageCode, when provided, must be a three-letter, ISO 639-2/T language code.');\n    }\n    if (metadata.name !== undefined && typeof metadata.name !== 'string') {\n        throw new TypeError('metadata.name, when provided, must be a string.');\n    }\n};\n/**\n * Main class orchestrating the creation of a new media file.\n * @group Output files\n * @public\n */\nclass Output {\n    /**\n     * Creates a new instance of {@link Output} which can then be used to create a new media file according to the\n     * specified {@link OutputOptions}.\n     */\n    constructor(options) {\n        /** The current state of the output. */\n        this.state = 'pending';\n        /** @internal */\n        this._tracks = [];\n        /** @internal */\n        this._startPromise = null;\n        /** @internal */\n        this._cancelPromise = null;\n        /** @internal */\n        this._finalizePromise = null;\n        /** @internal */\n        this._mutex = new _misc_js__WEBPACK_IMPORTED_MODULE_0__.AsyncMutex();\n        /** @internal */\n        this._metadataTags = {};\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!(options.format instanceof _output_format_js__WEBPACK_IMPORTED_MODULE_1__.OutputFormat)) {\n            throw new TypeError('options.format must be an OutputFormat.');\n        }\n        if (!(options.target instanceof _target_js__WEBPACK_IMPORTED_MODULE_2__.Target)) {\n            throw new TypeError('options.target must be a Target.');\n        }\n        if (options.target._output) {\n            throw new Error('Target is already used for another output.');\n        }\n        options.target._output = this;\n        this.format = options.format;\n        this.target = options.target;\n        this._writer = options.target._createWriter();\n        this._muxer = options.format._createMuxer(this);\n    }\n    /** Adds a video track to the output with the given source. Must be called before output is started. */\n    addVideoTrack(source, metadata = {}) {\n        if (!(source instanceof _media_source_js__WEBPACK_IMPORTED_MODULE_3__.VideoSource)) {\n            throw new TypeError('source must be a VideoSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        if (metadata.rotation !== undefined && ![0, 90, 180, 270].includes(metadata.rotation)) {\n            throw new TypeError(`Invalid video rotation: ${metadata.rotation}. Has to be 0, 90, 180 or 270.`);\n        }\n        if (!this.format.supportsVideoRotationMetadata && metadata.rotation) {\n            throw new Error(`${this.format._name} does not support video rotation metadata.`);\n        }\n        if (metadata.frameRate !== undefined\n            && (!Number.isFinite(metadata.frameRate) || metadata.frameRate <= 0)) {\n            throw new TypeError(`Invalid video frame rate: ${metadata.frameRate}. Must be a positive number.`);\n        }\n        this._addTrack('video', source, metadata);\n    }\n    /** Adds an audio track to the output with the given source. Must be called before output is started. */\n    addAudioTrack(source, metadata = {}) {\n        if (!(source instanceof _media_source_js__WEBPACK_IMPORTED_MODULE_3__.AudioSource)) {\n            throw new TypeError('source must be an AudioSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        this._addTrack('audio', source, metadata);\n    }\n    /** Adds a subtitle track to the output with the given source. Must be called before output is started. */\n    addSubtitleTrack(source, metadata = {}) {\n        if (!(source instanceof _media_source_js__WEBPACK_IMPORTED_MODULE_3__.SubtitleSource)) {\n            throw new TypeError('source must be a SubtitleSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        this._addTrack('subtitle', source, metadata);\n    }\n    /**\n     * Sets descriptive metadata tags about the media file, such as title, author, date, or cover art. When called\n     * multiple times, only the metadata from the last call will be used.\n     *\n     * Must be called before output is started.\n     */\n    setMetadataTags(tags) {\n        (0,_tags_js__WEBPACK_IMPORTED_MODULE_4__.validateMetadataTags)(tags);\n        if (this.state !== 'pending') {\n            throw new Error('Cannot set metadata tags after output has been started or canceled.');\n        }\n        this._metadataTags = tags;\n    }\n    /** @internal */\n    _addTrack(type, source, metadata) {\n        if (this.state !== 'pending') {\n            throw new Error('Cannot add track after output has been started or canceled.');\n        }\n        if (source._connectedTrack) {\n            throw new Error('Source is already used for a track.');\n        }\n        // Verify maximum track count constraints\n        const supportedTrackCounts = this.format.getSupportedTrackCounts();\n        const presentTracksOfThisType = this._tracks.reduce((count, track) => count + (track.type === type ? 1 : 0), 0);\n        const maxCount = supportedTrackCounts[type].max;\n        if (presentTracksOfThisType === maxCount) {\n            throw new Error(maxCount === 0\n                ? `${this.format._name} does not support ${type} tracks.`\n                : (`${this.format._name} does not support more than ${maxCount} ${type} track`\n                    + `${maxCount === 1 ? '' : 's'}.`));\n        }\n        const maxTotalCount = supportedTrackCounts.total.max;\n        if (this._tracks.length === maxTotalCount) {\n            throw new Error(`${this.format._name} does not support more than ${maxTotalCount} tracks`\n                + `${maxTotalCount === 1 ? '' : 's'} in total.`);\n        }\n        const track = {\n            id: this._tracks.length + 1,\n            output: this,\n            type,\n            source: source,\n            metadata,\n        };\n        if (track.type === 'video') {\n            const supportedVideoCodecs = this.format.getSupportedVideoCodecs();\n            if (supportedVideoCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support video tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedVideoCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` video codecs are: ${supportedVideoCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        else if (track.type === 'audio') {\n            const supportedAudioCodecs = this.format.getSupportedAudioCodecs();\n            if (supportedAudioCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support audio tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedAudioCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` audio codecs are: ${supportedAudioCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        else if (track.type === 'subtitle') {\n            const supportedSubtitleCodecs = this.format.getSupportedSubtitleCodecs();\n            if (supportedSubtitleCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support subtitle tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedSubtitleCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` subtitle codecs are: ${supportedSubtitleCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        this._tracks.push(track);\n        source._connectedTrack = track;\n    }\n    /**\n     * Starts the creation of the output file. This method should be called after all tracks have been added. Only after\n     * the output has started can media samples be added to the tracks.\n     *\n     * @returns A promise that resolves when the output has successfully started and is ready to receive media samples.\n     */\n    async start() {\n        // Verify minimum track count constraints\n        const supportedTrackCounts = this.format.getSupportedTrackCounts();\n        for (const trackType of ALL_TRACK_TYPES) {\n            const presentTracksOfThisType = this._tracks.reduce((count, track) => count + (track.type === trackType ? 1 : 0), 0);\n            const minCount = supportedTrackCounts[trackType].min;\n            if (presentTracksOfThisType < minCount) {\n                throw new Error(minCount === supportedTrackCounts[trackType].max\n                    ? (`${this.format._name} requires exactly ${minCount} ${trackType}`\n                        + ` track${minCount === 1 ? '' : 's'}.`)\n                    : (`${this.format._name} requires at least ${minCount} ${trackType}`\n                        + ` track${minCount === 1 ? '' : 's'}.`));\n            }\n        }\n        const totalMinCount = supportedTrackCounts.total.min;\n        if (this._tracks.length < totalMinCount) {\n            throw new Error(totalMinCount === supportedTrackCounts.total.max\n                ? (`${this.format._name} requires exactly ${totalMinCount} track`\n                    + `${totalMinCount === 1 ? '' : 's'}.`)\n                : (`${this.format._name} requires at least ${totalMinCount} track`\n                    + `${totalMinCount === 1 ? '' : 's'}.`));\n        }\n        if (this.state === 'canceled') {\n            throw new Error('Output has been canceled.');\n        }\n        if (this._startPromise) {\n            console.warn('Output has already been started.');\n            return this._startPromise;\n        }\n        return this._startPromise = (async () => {\n            this.state = 'started';\n            this._writer.start();\n            const release = await this._mutex.acquire();\n            await this._muxer.start();\n            const promises = this._tracks.map(track => track.source._start());\n            await Promise.all(promises);\n            release();\n        })();\n    }\n    /**\n     * Resolves with the full MIME type of the output file, including track codecs.\n     *\n     * The returned promise will resolve only once the precise codec strings of all tracks are known.\n     */\n    getMimeType() {\n        return this._muxer.getMimeType();\n    }\n    /**\n     * Cancels the creation of the output file, releasing internal resources like encoders and preventing further\n     * samples from being added.\n     *\n     * @returns A promise that resolves once all internal resources have been released.\n     */\n    async cancel() {\n        if (this._cancelPromise) {\n            console.warn('Output has already been canceled.');\n            return this._cancelPromise;\n        }\n        else if (this.state === 'finalizing' || this.state === 'finalized') {\n            console.warn('Output has already been finalized.');\n            return;\n        }\n        return this._cancelPromise = (async () => {\n            this.state = 'canceled';\n            const release = await this._mutex.acquire();\n            const promises = this._tracks.map(x => x.source._flushOrWaitForOngoingClose(true)); // Force close\n            await Promise.all(promises);\n            await this._writer.close();\n            release();\n        })();\n    }\n    /**\n     * Finalizes the output file. This method must be called after all media samples across all tracks have been added.\n     * Once the Promise returned by this method completes, the output file is ready.\n     */\n    async finalize() {\n        if (this.state === 'pending') {\n            throw new Error('Cannot finalize before starting.');\n        }\n        if (this.state === 'canceled') {\n            throw new Error('Cannot finalize after canceling.');\n        }\n        if (this._finalizePromise) {\n            console.warn('Output has already been finalized.');\n            return this._finalizePromise;\n        }\n        return this._finalizePromise = (async () => {\n            this.state = 'finalizing';\n            const release = await this._mutex.acquire();\n            const promises = this._tracks.map(x => x.source._flushOrWaitForOngoingClose(false));\n            await Promise.all(promises);\n            await this._muxer.finalize();\n            await this._writer.flush();\n            await this._writer.finalize();\n            this.state = 'finalized';\n            release();\n        })();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL291dHB1dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0U7QUFDakI7QUFDQztBQUMyQjtBQUN4QztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxtRUFBeUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRCxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkRBQVk7QUFDcEQ7QUFDQTtBQUNBLHdDQUF3Qyw4Q0FBTTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsZ0NBQWdDLHlEQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGtCQUFrQjtBQUM3RTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsbUJBQW1CO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGdDQUFnQyx5REFBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsZ0NBQWdDLDREQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQixtQkFBbUIsTUFBTTtBQUNqRSxzQkFBc0IsbUJBQW1CLDZCQUE2QixVQUFVLEVBQUUsTUFBTTtBQUN4Rix5QkFBeUIsMEJBQTBCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUIsNkJBQTZCLGVBQWU7QUFDOUYscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1CQUFtQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CLCtCQUErQixrQkFBa0I7QUFDL0csNENBQTRDLHNDQUFzQyxNQUFNLGVBQWU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1CQUFtQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CLCtCQUErQixrQkFBa0I7QUFDL0csNENBQTRDLHNDQUFzQyxNQUFNLGVBQWU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1CQUFtQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CLCtCQUErQixrQkFBa0I7QUFDL0csK0NBQStDLHlDQUF5QyxNQUFNLGVBQWU7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUIsbUJBQW1CLFVBQVUsRUFBRSxVQUFVO0FBQ3RGLG1DQUFtQywwQkFBMEI7QUFDN0QsMEJBQTBCLG1CQUFtQixvQkFBb0IsVUFBVSxFQUFFLFVBQVU7QUFDdkYsbUNBQW1DLDBCQUEwQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQixtQkFBbUIsZUFBZTtBQUMzRSx5QkFBeUIsK0JBQStCO0FBQ3hELHNCQUFzQixtQkFBbUIsb0JBQW9CLGVBQWU7QUFDNUUseUJBQXlCLCtCQUErQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGNoLWN1dC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL291dHB1dC5qcz82NTEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDI1LXByZXNlbnQsIFZhbmlsYWd5IGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgQXN5bmNNdXRleCwgaXNJc282MzlEYXNoMkxhbmd1YWdlQ29kZSB9IGZyb20gJy4vbWlzYy5qcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZU1ldGFkYXRhVGFncyB9IGZyb20gJy4vdGFncy5qcyc7XG5pbXBvcnQgeyBPdXRwdXRGb3JtYXQgfSBmcm9tICcuL291dHB1dC1mb3JtYXQuanMnO1xuaW1wb3J0IHsgQXVkaW9Tb3VyY2UsIFN1YnRpdGxlU291cmNlLCBWaWRlb1NvdXJjZSB9IGZyb20gJy4vbWVkaWEtc291cmNlLmpzJztcbmltcG9ydCB7IFRhcmdldCB9IGZyb20gJy4vdGFyZ2V0LmpzJztcbi8qKlxuICogTGlzdCBvZiBhbGwgdHJhY2sgdHlwZXMuXG4gKiBAZ3JvdXAgTWlzY2VsbGFuZW91c1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgQUxMX1RSQUNLX1RZUEVTID0gWyd2aWRlbycsICdhdWRpbycsICdzdWJ0aXRsZSddO1xuY29uc3QgdmFsaWRhdGVCYXNlVHJhY2tNZXRhZGF0YSA9IChtZXRhZGF0YSkgPT4ge1xuICAgIGlmICghbWV0YWRhdGEgfHwgdHlwZW9mIG1ldGFkYXRhICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtZXRhZGF0YSBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICB9XG4gICAgaWYgKG1ldGFkYXRhLmxhbmd1YWdlQ29kZSAhPT0gdW5kZWZpbmVkICYmICFpc0lzbzYzOURhc2gyTGFuZ3VhZ2VDb2RlKG1ldGFkYXRhLmxhbmd1YWdlQ29kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWV0YWRhdGEubGFuZ3VhZ2VDb2RlLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgdGhyZWUtbGV0dGVyLCBJU08gNjM5LTIvVCBsYW5ndWFnZSBjb2RlLicpO1xuICAgIH1cbiAgICBpZiAobWV0YWRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBtZXRhZGF0YS5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtZXRhZGF0YS5uYW1lLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgIH1cbn07XG4vKipcbiAqIE1haW4gY2xhc3Mgb3JjaGVzdHJhdGluZyB0aGUgY3JlYXRpb24gb2YgYSBuZXcgbWVkaWEgZmlsZS5cbiAqIEBncm91cCBPdXRwdXQgZmlsZXNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIE91dHB1dCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgT3V0cHV0fSB3aGljaCBjYW4gdGhlbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIG5ldyBtZWRpYSBmaWxlIGFjY29yZGluZyB0byB0aGVcbiAgICAgKiBzcGVjaWZpZWQge0BsaW5rIE91dHB1dE9wdGlvbnN9LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgLyoqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBvdXRwdXQuICovXG4gICAgICAgIHRoaXMuc3RhdGUgPSAncGVuZGluZyc7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fdHJhY2tzID0gW107XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fc3RhcnRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9jYW5jZWxQcm9taXNlID0gbnVsbDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9maW5hbGl6ZVByb21pc2UgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX211dGV4ID0gbmV3IEFzeW5jTXV0ZXgoKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9tZXRhZGF0YVRhZ3MgPSB7fTtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShvcHRpb25zLmZvcm1hdCBpbnN0YW5jZW9mIE91dHB1dEZvcm1hdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuZm9ybWF0IG11c3QgYmUgYW4gT3V0cHV0Rm9ybWF0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG9wdGlvbnMudGFyZ2V0IGluc3RhbmNlb2YgVGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy50YXJnZXQgbXVzdCBiZSBhIFRhcmdldC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50YXJnZXQuX291dHB1dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgaXMgYWxyZWFkeSB1c2VkIGZvciBhbm90aGVyIG91dHB1dC4nKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnRhcmdldC5fb3V0cHV0ID0gdGhpcztcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBvcHRpb25zLmZvcm1hdDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBvcHRpb25zLnRhcmdldDtcbiAgICAgICAgdGhpcy5fd3JpdGVyID0gb3B0aW9ucy50YXJnZXQuX2NyZWF0ZVdyaXRlcigpO1xuICAgICAgICB0aGlzLl9tdXhlciA9IG9wdGlvbnMuZm9ybWF0Ll9jcmVhdGVNdXhlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqIEFkZHMgYSB2aWRlbyB0cmFjayB0byB0aGUgb3V0cHV0IHdpdGggdGhlIGdpdmVuIHNvdXJjZS4gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIG91dHB1dCBpcyBzdGFydGVkLiAqL1xuICAgIGFkZFZpZGVvVHJhY2soc291cmNlLCBtZXRhZGF0YSA9IHt9KSB7XG4gICAgICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFZpZGVvU291cmNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc291cmNlIG11c3QgYmUgYSBWaWRlb1NvdXJjZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZUJhc2VUcmFja01ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICAgICAgaWYgKG1ldGFkYXRhLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgJiYgIVswLCA5MCwgMTgwLCAyNzBdLmluY2x1ZGVzKG1ldGFkYXRhLnJvdGF0aW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2aWRlbyByb3RhdGlvbjogJHttZXRhZGF0YS5yb3RhdGlvbn0uIEhhcyB0byBiZSAwLCA5MCwgMTgwIG9yIDI3MC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZm9ybWF0LnN1cHBvcnRzVmlkZW9Sb3RhdGlvbk1ldGFkYXRhICYmIG1ldGFkYXRhLnJvdGF0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5mb3JtYXQuX25hbWV9IGRvZXMgbm90IHN1cHBvcnQgdmlkZW8gcm90YXRpb24gbWV0YWRhdGEuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhLmZyYW1lUmF0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAmJiAoIU51bWJlci5pc0Zpbml0ZShtZXRhZGF0YS5mcmFtZVJhdGUpIHx8IG1ldGFkYXRhLmZyYW1lUmF0ZSA8PSAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2aWRlbyBmcmFtZSByYXRlOiAke21ldGFkYXRhLmZyYW1lUmF0ZX0uIE11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWRkVHJhY2soJ3ZpZGVvJywgc291cmNlLCBtZXRhZGF0YSk7XG4gICAgfVxuICAgIC8qKiBBZGRzIGFuIGF1ZGlvIHRyYWNrIHRvIHRoZSBvdXRwdXQgd2l0aCB0aGUgZ2l2ZW4gc291cmNlLiBNdXN0IGJlIGNhbGxlZCBiZWZvcmUgb3V0cHV0IGlzIHN0YXJ0ZWQuICovXG4gICAgYWRkQXVkaW9UcmFjayhzb3VyY2UsIG1ldGFkYXRhID0ge30pIHtcbiAgICAgICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgQXVkaW9Tb3VyY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2UgbXVzdCBiZSBhbiBBdWRpb1NvdXJjZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZUJhc2VUcmFja01ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5fYWRkVHJhY2soJ2F1ZGlvJywgc291cmNlLCBtZXRhZGF0YSk7XG4gICAgfVxuICAgIC8qKiBBZGRzIGEgc3VidGl0bGUgdHJhY2sgdG8gdGhlIG91dHB1dCB3aXRoIHRoZSBnaXZlbiBzb3VyY2UuIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBvdXRwdXQgaXMgc3RhcnRlZC4gKi9cbiAgICBhZGRTdWJ0aXRsZVRyYWNrKHNvdXJjZSwgbWV0YWRhdGEgPSB7fSkge1xuICAgICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBTdWJ0aXRsZVNvdXJjZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NvdXJjZSBtdXN0IGJlIGEgU3VidGl0bGVTb3VyY2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVCYXNlVHJhY2tNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgIHRoaXMuX2FkZFRyYWNrKCdzdWJ0aXRsZScsIHNvdXJjZSwgbWV0YWRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGRlc2NyaXB0aXZlIG1ldGFkYXRhIHRhZ3MgYWJvdXQgdGhlIG1lZGlhIGZpbGUsIHN1Y2ggYXMgdGl0bGUsIGF1dGhvciwgZGF0ZSwgb3IgY292ZXIgYXJ0LiBXaGVuIGNhbGxlZFxuICAgICAqIG11bHRpcGxlIHRpbWVzLCBvbmx5IHRoZSBtZXRhZGF0YSBmcm9tIHRoZSBsYXN0IGNhbGwgd2lsbCBiZSB1c2VkLlxuICAgICAqXG4gICAgICogTXVzdCBiZSBjYWxsZWQgYmVmb3JlIG91dHB1dCBpcyBzdGFydGVkLlxuICAgICAqL1xuICAgIHNldE1ldGFkYXRhVGFncyh0YWdzKSB7XG4gICAgICAgIHZhbGlkYXRlTWV0YWRhdGFUYWdzKHRhZ3MpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgbWV0YWRhdGEgdGFncyBhZnRlciBvdXRwdXQgaGFzIGJlZW4gc3RhcnRlZCBvciBjYW5jZWxlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tZXRhZGF0YVRhZ3MgPSB0YWdzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2FkZFRyYWNrKHR5cGUsIHNvdXJjZSwgbWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIHRyYWNrIGFmdGVyIG91dHB1dCBoYXMgYmVlbiBzdGFydGVkIG9yIGNhbmNlbGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UuX2Nvbm5lY3RlZFRyYWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvdXJjZSBpcyBhbHJlYWR5IHVzZWQgZm9yIGEgdHJhY2suJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmVyaWZ5IG1heGltdW0gdHJhY2sgY291bnQgY29uc3RyYWludHNcbiAgICAgICAgY29uc3Qgc3VwcG9ydGVkVHJhY2tDb3VudHMgPSB0aGlzLmZvcm1hdC5nZXRTdXBwb3J0ZWRUcmFja0NvdW50cygpO1xuICAgICAgICBjb25zdCBwcmVzZW50VHJhY2tzT2ZUaGlzVHlwZSA9IHRoaXMuX3RyYWNrcy5yZWR1Y2UoKGNvdW50LCB0cmFjaykgPT4gY291bnQgKyAodHJhY2sudHlwZSA9PT0gdHlwZSA/IDEgOiAwKSwgMCk7XG4gICAgICAgIGNvbnN0IG1heENvdW50ID0gc3VwcG9ydGVkVHJhY2tDb3VudHNbdHlwZV0ubWF4O1xuICAgICAgICBpZiAocHJlc2VudFRyYWNrc09mVGhpc1R5cGUgPT09IG1heENvdW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWF4Q291bnQgPT09IDBcbiAgICAgICAgICAgICAgICA/IGAke3RoaXMuZm9ybWF0Ll9uYW1lfSBkb2VzIG5vdCBzdXBwb3J0ICR7dHlwZX0gdHJhY2tzLmBcbiAgICAgICAgICAgICAgICA6IChgJHt0aGlzLmZvcm1hdC5fbmFtZX0gZG9lcyBub3Qgc3VwcG9ydCBtb3JlIHRoYW4gJHttYXhDb3VudH0gJHt0eXBlfSB0cmFja2BcbiAgICAgICAgICAgICAgICAgICAgKyBgJHttYXhDb3VudCA9PT0gMSA/ICcnIDogJ3MnfS5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF4VG90YWxDb3VudCA9IHN1cHBvcnRlZFRyYWNrQ291bnRzLnRvdGFsLm1heDtcbiAgICAgICAgaWYgKHRoaXMuX3RyYWNrcy5sZW5ndGggPT09IG1heFRvdGFsQ291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLmZvcm1hdC5fbmFtZX0gZG9lcyBub3Qgc3VwcG9ydCBtb3JlIHRoYW4gJHttYXhUb3RhbENvdW50fSB0cmFja3NgXG4gICAgICAgICAgICAgICAgKyBgJHttYXhUb3RhbENvdW50ID09PSAxID8gJycgOiAncyd9IGluIHRvdGFsLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYWNrID0ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuX3RyYWNrcy5sZW5ndGggKyAxLFxuICAgICAgICAgICAgb3V0cHV0OiB0aGlzLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0cmFjay50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICBjb25zdCBzdXBwb3J0ZWRWaWRlb0NvZGVjcyA9IHRoaXMuZm9ybWF0LmdldFN1cHBvcnRlZFZpZGVvQ29kZWNzKCk7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydGVkVmlkZW9Db2RlY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMuZm9ybWF0Ll9uYW1lfSBkb2VzIG5vdCBzdXBwb3J0IHZpZGVvIHRyYWNrcy5gXG4gICAgICAgICAgICAgICAgICAgICsgdGhpcy5mb3JtYXQuX2NvZGVjVW5zdXBwb3J0ZWRIaW50KHRyYWNrLnNvdXJjZS5fY29kZWMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFzdXBwb3J0ZWRWaWRlb0NvZGVjcy5pbmNsdWRlcyh0cmFjay5zb3VyY2UuX2NvZGVjKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZWMgJyR7dHJhY2suc291cmNlLl9jb2RlY30nIGNhbm5vdCBiZSBjb250YWluZWQgd2l0aGluICR7dGhpcy5mb3JtYXQuX25hbWV9LiBTdXBwb3J0ZWRgXG4gICAgICAgICAgICAgICAgICAgICsgYCB2aWRlbyBjb2RlY3MgYXJlOiAke3N1cHBvcnRlZFZpZGVvQ29kZWNzLm1hcChjb2RlYyA9PiBgJyR7Y29kZWN9J2ApLmpvaW4oJywgJyl9LmBcbiAgICAgICAgICAgICAgICAgICAgKyB0aGlzLmZvcm1hdC5fY29kZWNVbnN1cHBvcnRlZEhpbnQodHJhY2suc291cmNlLl9jb2RlYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1cHBvcnRlZEF1ZGlvQ29kZWNzID0gdGhpcy5mb3JtYXQuZ2V0U3VwcG9ydGVkQXVkaW9Db2RlY3MoKTtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0ZWRBdWRpb0NvZGVjcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5mb3JtYXQuX25hbWV9IGRvZXMgbm90IHN1cHBvcnQgYXVkaW8gdHJhY2tzLmBcbiAgICAgICAgICAgICAgICAgICAgKyB0aGlzLmZvcm1hdC5fY29kZWNVbnN1cHBvcnRlZEhpbnQodHJhY2suc291cmNlLl9jb2RlYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXN1cHBvcnRlZEF1ZGlvQ29kZWNzLmluY2x1ZGVzKHRyYWNrLnNvdXJjZS5fY29kZWMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlYyAnJHt0cmFjay5zb3VyY2UuX2NvZGVjfScgY2Fubm90IGJlIGNvbnRhaW5lZCB3aXRoaW4gJHt0aGlzLmZvcm1hdC5fbmFtZX0uIFN1cHBvcnRlZGBcbiAgICAgICAgICAgICAgICAgICAgKyBgIGF1ZGlvIGNvZGVjcyBhcmU6ICR7c3VwcG9ydGVkQXVkaW9Db2RlY3MubWFwKGNvZGVjID0+IGAnJHtjb2RlY30nYCkuam9pbignLCAnKX0uYFxuICAgICAgICAgICAgICAgICAgICArIHRoaXMuZm9ybWF0Ll9jb2RlY1Vuc3VwcG9ydGVkSGludCh0cmFjay5zb3VyY2UuX2NvZGVjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJhY2sudHlwZSA9PT0gJ3N1YnRpdGxlJykge1xuICAgICAgICAgICAgY29uc3Qgc3VwcG9ydGVkU3VidGl0bGVDb2RlY3MgPSB0aGlzLmZvcm1hdC5nZXRTdXBwb3J0ZWRTdWJ0aXRsZUNvZGVjcygpO1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRlZFN1YnRpdGxlQ29kZWNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLmZvcm1hdC5fbmFtZX0gZG9lcyBub3Qgc3VwcG9ydCBzdWJ0aXRsZSB0cmFja3MuYFxuICAgICAgICAgICAgICAgICAgICArIHRoaXMuZm9ybWF0Ll9jb2RlY1Vuc3VwcG9ydGVkSGludCh0cmFjay5zb3VyY2UuX2NvZGVjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghc3VwcG9ydGVkU3VidGl0bGVDb2RlY3MuaW5jbHVkZXModHJhY2suc291cmNlLl9jb2RlYykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVjICcke3RyYWNrLnNvdXJjZS5fY29kZWN9JyBjYW5ub3QgYmUgY29udGFpbmVkIHdpdGhpbiAke3RoaXMuZm9ybWF0Ll9uYW1lfS4gU3VwcG9ydGVkYFxuICAgICAgICAgICAgICAgICAgICArIGAgc3VidGl0bGUgY29kZWNzIGFyZTogJHtzdXBwb3J0ZWRTdWJ0aXRsZUNvZGVjcy5tYXAoY29kZWMgPT4gYCcke2NvZGVjfSdgKS5qb2luKCcsICcpfS5gXG4gICAgICAgICAgICAgICAgICAgICsgdGhpcy5mb3JtYXQuX2NvZGVjVW5zdXBwb3J0ZWRIaW50KHRyYWNrLnNvdXJjZS5fY29kZWMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFja3MucHVzaCh0cmFjayk7XG4gICAgICAgIHNvdXJjZS5fY29ubmVjdGVkVHJhY2sgPSB0cmFjaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBjcmVhdGlvbiBvZiB0aGUgb3V0cHV0IGZpbGUuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIHRyYWNrcyBoYXZlIGJlZW4gYWRkZWQuIE9ubHkgYWZ0ZXJcbiAgICAgKiB0aGUgb3V0cHV0IGhhcyBzdGFydGVkIGNhbiBtZWRpYSBzYW1wbGVzIGJlIGFkZGVkIHRvIHRoZSB0cmFja3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBvdXRwdXQgaGFzIHN1Y2Nlc3NmdWxseSBzdGFydGVkIGFuZCBpcyByZWFkeSB0byByZWNlaXZlIG1lZGlhIHNhbXBsZXMuXG4gICAgICovXG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIC8vIFZlcmlmeSBtaW5pbXVtIHRyYWNrIGNvdW50IGNvbnN0cmFpbnRzXG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZFRyYWNrQ291bnRzID0gdGhpcy5mb3JtYXQuZ2V0U3VwcG9ydGVkVHJhY2tDb3VudHMoKTtcbiAgICAgICAgZm9yIChjb25zdCB0cmFja1R5cGUgb2YgQUxMX1RSQUNLX1RZUEVTKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVzZW50VHJhY2tzT2ZUaGlzVHlwZSA9IHRoaXMuX3RyYWNrcy5yZWR1Y2UoKGNvdW50LCB0cmFjaykgPT4gY291bnQgKyAodHJhY2sudHlwZSA9PT0gdHJhY2tUeXBlID8gMSA6IDApLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IG1pbkNvdW50ID0gc3VwcG9ydGVkVHJhY2tDb3VudHNbdHJhY2tUeXBlXS5taW47XG4gICAgICAgICAgICBpZiAocHJlc2VudFRyYWNrc09mVGhpc1R5cGUgPCBtaW5Db3VudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtaW5Db3VudCA9PT0gc3VwcG9ydGVkVHJhY2tDb3VudHNbdHJhY2tUeXBlXS5tYXhcbiAgICAgICAgICAgICAgICAgICAgPyAoYCR7dGhpcy5mb3JtYXQuX25hbWV9IHJlcXVpcmVzIGV4YWN0bHkgJHttaW5Db3VudH0gJHt0cmFja1R5cGV9YFxuICAgICAgICAgICAgICAgICAgICAgICAgKyBgIHRyYWNrJHttaW5Db3VudCA9PT0gMSA/ICcnIDogJ3MnfS5gKVxuICAgICAgICAgICAgICAgICAgICA6IChgJHt0aGlzLmZvcm1hdC5fbmFtZX0gcmVxdWlyZXMgYXQgbGVhc3QgJHttaW5Db3VudH0gJHt0cmFja1R5cGV9YFxuICAgICAgICAgICAgICAgICAgICAgICAgKyBgIHRyYWNrJHttaW5Db3VudCA9PT0gMSA/ICcnIDogJ3MnfS5gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG90YWxNaW5Db3VudCA9IHN1cHBvcnRlZFRyYWNrQ291bnRzLnRvdGFsLm1pbjtcbiAgICAgICAgaWYgKHRoaXMuX3RyYWNrcy5sZW5ndGggPCB0b3RhbE1pbkNvdW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodG90YWxNaW5Db3VudCA9PT0gc3VwcG9ydGVkVHJhY2tDb3VudHMudG90YWwubWF4XG4gICAgICAgICAgICAgICAgPyAoYCR7dGhpcy5mb3JtYXQuX25hbWV9IHJlcXVpcmVzIGV4YWN0bHkgJHt0b3RhbE1pbkNvdW50fSB0cmFja2BcbiAgICAgICAgICAgICAgICAgICAgKyBgJHt0b3RhbE1pbkNvdW50ID09PSAxID8gJycgOiAncyd9LmApXG4gICAgICAgICAgICAgICAgOiAoYCR7dGhpcy5mb3JtYXQuX25hbWV9IHJlcXVpcmVzIGF0IGxlYXN0ICR7dG90YWxNaW5Db3VudH0gdHJhY2tgXG4gICAgICAgICAgICAgICAgICAgICsgYCR7dG90YWxNaW5Db3VudCA9PT0gMSA/ICcnIDogJ3MnfS5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdjYW5jZWxlZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3V0cHV0IGhhcyBiZWVuIGNhbmNlbGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdGFydFByb21pc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignT3V0cHV0IGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZC4nKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFydFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0UHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3N0YXJ0ZWQnO1xuICAgICAgICAgICAgdGhpcy5fd3JpdGVyLnN0YXJ0KCk7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlID0gYXdhaXQgdGhpcy5fbXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbXV4ZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fdHJhY2tzLm1hcCh0cmFjayA9PiB0cmFjay5zb3VyY2UuX3N0YXJ0KCkpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB3aXRoIHRoZSBmdWxsIE1JTUUgdHlwZSBvZiB0aGUgb3V0cHV0IGZpbGUsIGluY2x1ZGluZyB0cmFjayBjb2RlY3MuXG4gICAgICpcbiAgICAgKiBUaGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIHJlc29sdmUgb25seSBvbmNlIHRoZSBwcmVjaXNlIGNvZGVjIHN0cmluZ3Mgb2YgYWxsIHRyYWNrcyBhcmUga25vd24uXG4gICAgICovXG4gICAgZ2V0TWltZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tdXhlci5nZXRNaW1lVHlwZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIHRoZSBjcmVhdGlvbiBvZiB0aGUgb3V0cHV0IGZpbGUsIHJlbGVhc2luZyBpbnRlcm5hbCByZXNvdXJjZXMgbGlrZSBlbmNvZGVycyBhbmQgcHJldmVudGluZyBmdXJ0aGVyXG4gICAgICogc2FtcGxlcyBmcm9tIGJlaW5nIGFkZGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSBhbGwgaW50ZXJuYWwgcmVzb3VyY2VzIGhhdmUgYmVlbiByZWxlYXNlZC5cbiAgICAgKi9cbiAgICBhc3luYyBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYW5jZWxQcm9taXNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ091dHB1dCBoYXMgYWxyZWFkeSBiZWVuIGNhbmNlbGVkLicpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ2ZpbmFsaXppbmcnIHx8IHRoaXMuc3RhdGUgPT09ICdmaW5hbGl6ZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ091dHB1dCBoYXMgYWxyZWFkeSBiZWVuIGZpbmFsaXplZC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FuY2VsUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ2NhbmNlbGVkJztcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2UgPSBhd2FpdCB0aGlzLl9tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3RyYWNrcy5tYXAoeCA9PiB4LnNvdXJjZS5fZmx1c2hPcldhaXRGb3JPbmdvaW5nQ2xvc2UodHJ1ZSkpOyAvLyBGb3JjZSBjbG9zZVxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fd3JpdGVyLmNsb3NlKCk7XG4gICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmFsaXplcyB0aGUgb3V0cHV0IGZpbGUuIFRoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGFmdGVyIGFsbCBtZWRpYSBzYW1wbGVzIGFjcm9zcyBhbGwgdHJhY2tzIGhhdmUgYmVlbiBhZGRlZC5cbiAgICAgKiBPbmNlIHRoZSBQcm9taXNlIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kIGNvbXBsZXRlcywgdGhlIG91dHB1dCBmaWxlIGlzIHJlYWR5LlxuICAgICAqL1xuICAgIGFzeW5jIGZpbmFsaXplKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5hbGl6ZSBiZWZvcmUgc3RhcnRpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdjYW5jZWxlZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmFsaXplIGFmdGVyIGNhbmNlbGluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZmluYWxpemVQcm9taXNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ091dHB1dCBoYXMgYWxyZWFkeSBiZWVuIGZpbmFsaXplZC4nKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZVByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ2ZpbmFsaXppbmcnO1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZSA9IGF3YWl0IHRoaXMuX211dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fdHJhY2tzLm1hcCh4ID0+IHguc291cmNlLl9mbHVzaE9yV2FpdEZvck9uZ29pbmdDbG9zZShmYWxzZSkpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbXV4ZXIuZmluYWxpemUoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3dyaXRlci5mbHVzaCgpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fd3JpdGVyLmZpbmFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ2ZpbmFsaXplZCc7XG4gICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/output.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/packet.js":
/*!************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/packet.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EncodedPacket: () => (/* binding */ EncodedPacket),\n/* harmony export */   PLACEHOLDER_DATA: () => (/* binding */ PLACEHOLDER_DATA)\n/* harmony export */ });\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\nconst PLACEHOLDER_DATA = new Uint8Array(0);\n/**\n * Represents an encoded chunk of media. Mainly used as an expressive wrapper around WebCodecs API's\n * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) and\n * [`EncodedAudioChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedAudioChunk), but can also be used\n * standalone.\n * @group Packets\n * @public\n */\nclass EncodedPacket {\n    /** Creates a new {@link EncodedPacket} from raw bytes and timing information. */\n    constructor(\n    /** The encoded data of this packet. */\n    data, \n    /** The type of this packet. */\n    type, \n    /**\n     * The presentation timestamp of this packet in seconds. May be negative. Samples with negative end timestamps\n     * should not be presented.\n     */\n    timestamp, \n    /** The duration of this packet in seconds. */\n    duration, \n    /**\n     * The sequence number indicates the decode order of the packets. Packet A  must be decoded before packet B if A\n     * has a lower sequence number than B. If two packets have the same sequence number, they are the same packet.\n     * Otherwise, sequence numbers are arbitrary and are not guaranteed to have any meaning besides their relative\n     * ordering. Negative sequence numbers mean the sequence number is undefined.\n     */\n    sequenceNumber = -1, byteLength) {\n        this.data = data;\n        this.type = type;\n        this.timestamp = timestamp;\n        this.duration = duration;\n        this.sequenceNumber = sequenceNumber;\n        if (data === PLACEHOLDER_DATA && byteLength === undefined) {\n            throw new Error('Internal error: byteLength must be explicitly provided when constructing metadata-only packets.');\n        }\n        if (byteLength === undefined) {\n            byteLength = data.byteLength;\n        }\n        if (!(data instanceof Uint8Array)) {\n            throw new TypeError('data must be a Uint8Array.');\n        }\n        if (type !== 'key' && type !== 'delta') {\n            throw new TypeError('type must be either \"key\" or \"delta\".');\n        }\n        if (!Number.isFinite(timestamp)) {\n            throw new TypeError('timestamp must be a number.');\n        }\n        if (!Number.isFinite(duration) || duration < 0) {\n            throw new TypeError('duration must be a non-negative number.');\n        }\n        if (!Number.isFinite(sequenceNumber)) {\n            throw new TypeError('sequenceNumber must be a number.');\n        }\n        if (!Number.isInteger(byteLength) || byteLength < 0) {\n            throw new TypeError('byteLength must be a non-negative integer.');\n        }\n        this.byteLength = byteLength;\n    }\n    /** If this packet is a metadata-only packet. Metadata-only packets don't contain their packet data. */\n    get isMetadataOnly() {\n        return this.data === PLACEHOLDER_DATA;\n    }\n    /** The timestamp of this packet in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(_misc_js__WEBPACK_IMPORTED_MODULE_0__.SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of this packet in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(_misc_js__WEBPACK_IMPORTED_MODULE_0__.SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    /** Converts this packet to an EncodedVideoChunk for use with the WebCodecs API. */\n    toEncodedVideoChunk() {\n        if (this.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be converted to a video chunk.');\n        }\n        if (typeof EncodedVideoChunk === 'undefined') {\n            throw new Error('Your browser does not support EncodedVideoChunk.');\n        }\n        return new EncodedVideoChunk({\n            data: this.data,\n            type: this.type,\n            timestamp: this.microsecondTimestamp,\n            duration: this.microsecondDuration,\n        });\n    }\n    /** Converts this packet to an EncodedAudioChunk for use with the WebCodecs API. */\n    toEncodedAudioChunk() {\n        if (this.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be converted to an audio chunk.');\n        }\n        if (typeof EncodedAudioChunk === 'undefined') {\n            throw new Error('Your browser does not support EncodedAudioChunk.');\n        }\n        return new EncodedAudioChunk({\n            data: this.data,\n            type: this.type,\n            timestamp: this.microsecondTimestamp,\n            duration: this.microsecondDuration,\n        });\n    }\n    /**\n     * Creates an EncodedPacket from an EncodedVideoChunk or EncodedAudioChunk. This method is useful for converting\n     * chunks from the WebCodecs API to EncodedPackets.\n     */\n    static fromEncodedChunk(chunk) {\n        if (!(chunk instanceof EncodedVideoChunk || chunk instanceof EncodedAudioChunk)) {\n            throw new TypeError('chunk must be an EncodedVideoChunk or EncodedAudioChunk.');\n        }\n        const data = new Uint8Array(chunk.byteLength);\n        chunk.copyTo(data);\n        return new EncodedPacket(data, chunk.type, chunk.timestamp / 1e6, (chunk.duration ?? 0) / 1e6);\n    }\n    /** Clones this packet while optionally updating timing information. */\n    clone(options) {\n        if (options !== undefined && (typeof options !== 'object' || options === null)) {\n            throw new TypeError('options, when provided, must be an object.');\n        }\n        if (options?.timestamp !== undefined && !Number.isFinite(options.timestamp)) {\n            throw new TypeError('options.timestamp, when provided, must be a number.');\n        }\n        if (options?.duration !== undefined && !Number.isFinite(options.duration)) {\n            throw new TypeError('options.duration, when provided, must be a number.');\n        }\n        return new EncodedPacket(this.data, this.type, options?.timestamp ?? this.timestamp, options?.duration ?? this.duration, this.sequenceNumber, this.byteLength);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL3BhY2tldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RDtBQUNsRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrRUFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtFQUE0QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWF0Y2gtY3V0LWdlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9tZWRpYWJ1bm55L2Rpc3QvbW9kdWxlcy9zcmMvcGFja2V0LmpzP2U4MTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjUtcHJlc2VudCwgVmFuaWxhZ3kgYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgeyBTRUNPTkRfVE9fTUlDUk9TRUNPTkRfRkFDVE9SIH0gZnJvbSAnLi9taXNjLmpzJztcbmV4cG9ydCBjb25zdCBQTEFDRUhPTERFUl9EQVRBID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZW5jb2RlZCBjaHVuayBvZiBtZWRpYS4gTWFpbmx5IHVzZWQgYXMgYW4gZXhwcmVzc2l2ZSB3cmFwcGVyIGFyb3VuZCBXZWJDb2RlY3MgQVBJJ3NcbiAqIFtgRW5jb2RlZFZpZGVvQ2h1bmtgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRW5jb2RlZFZpZGVvQ2h1bmspIGFuZFxuICogW2BFbmNvZGVkQXVkaW9DaHVua2BdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbmNvZGVkQXVkaW9DaHVuayksIGJ1dCBjYW4gYWxzbyBiZSB1c2VkXG4gKiBzdGFuZGFsb25lLlxuICogQGdyb3VwIFBhY2tldHNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEVuY29kZWRQYWNrZXQge1xuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHtAbGluayBFbmNvZGVkUGFja2V0fSBmcm9tIHJhdyBieXRlcyBhbmQgdGltaW5nIGluZm9ybWF0aW9uLiAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgZW5jb2RlZCBkYXRhIG9mIHRoaXMgcGFja2V0LiAqL1xuICAgIGRhdGEsIFxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHBhY2tldC4gKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICAgKiBUaGUgcHJlc2VudGF0aW9uIHRpbWVzdGFtcCBvZiB0aGlzIHBhY2tldCBpbiBzZWNvbmRzLiBNYXkgYmUgbmVnYXRpdmUuIFNhbXBsZXMgd2l0aCBuZWdhdGl2ZSBlbmQgdGltZXN0YW1wc1xuICAgICAqIHNob3VsZCBub3QgYmUgcHJlc2VudGVkLlxuICAgICAqL1xuICAgIHRpbWVzdGFtcCwgXG4gICAgLyoqIFRoZSBkdXJhdGlvbiBvZiB0aGlzIHBhY2tldCBpbiBzZWNvbmRzLiAqL1xuICAgIGR1cmF0aW9uLCBcbiAgICAvKipcbiAgICAgKiBUaGUgc2VxdWVuY2UgbnVtYmVyIGluZGljYXRlcyB0aGUgZGVjb2RlIG9yZGVyIG9mIHRoZSBwYWNrZXRzLiBQYWNrZXQgQSAgbXVzdCBiZSBkZWNvZGVkIGJlZm9yZSBwYWNrZXQgQiBpZiBBXG4gICAgICogaGFzIGEgbG93ZXIgc2VxdWVuY2UgbnVtYmVyIHRoYW4gQi4gSWYgdHdvIHBhY2tldHMgaGF2ZSB0aGUgc2FtZSBzZXF1ZW5jZSBudW1iZXIsIHRoZXkgYXJlIHRoZSBzYW1lIHBhY2tldC5cbiAgICAgKiBPdGhlcndpc2UsIHNlcXVlbmNlIG51bWJlcnMgYXJlIGFyYml0cmFyeSBhbmQgYXJlIG5vdCBndWFyYW50ZWVkIHRvIGhhdmUgYW55IG1lYW5pbmcgYmVzaWRlcyB0aGVpciByZWxhdGl2ZVxuICAgICAqIG9yZGVyaW5nLiBOZWdhdGl2ZSBzZXF1ZW5jZSBudW1iZXJzIG1lYW4gdGhlIHNlcXVlbmNlIG51bWJlciBpcyB1bmRlZmluZWQuXG4gICAgICovXG4gICAgc2VxdWVuY2VOdW1iZXIgPSAtMSwgYnl0ZUxlbmd0aCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIGlmIChkYXRhID09PSBQTEFDRUhPTERFUl9EQVRBICYmIGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBlcnJvcjogYnl0ZUxlbmd0aCBtdXN0IGJlIGV4cGxpY2l0bHkgcHJvdmlkZWQgd2hlbiBjb25zdHJ1Y3RpbmcgbWV0YWRhdGEtb25seSBwYWNrZXRzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieXRlTGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkYXRhIG11c3QgYmUgYSBVaW50OEFycmF5LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlICE9PSAna2V5JyAmJiB0eXBlICE9PSAnZGVsdGEnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0eXBlIG11c3QgYmUgZWl0aGVyIFwia2V5XCIgb3IgXCJkZWx0YVwiLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHRpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RpbWVzdGFtcCBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uKSB8fCBkdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2R1cmF0aW9uIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHNlcXVlbmNlTnVtYmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2VxdWVuY2VOdW1iZXIgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYnl0ZUxlbmd0aCkgfHwgYnl0ZUxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVMZW5ndGggbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIC8qKiBJZiB0aGlzIHBhY2tldCBpcyBhIG1ldGFkYXRhLW9ubHkgcGFja2V0LiBNZXRhZGF0YS1vbmx5IHBhY2tldHMgZG9uJ3QgY29udGFpbiB0aGVpciBwYWNrZXQgZGF0YS4gKi9cbiAgICBnZXQgaXNNZXRhZGF0YU9ubHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEgPT09IFBMQUNFSE9MREVSX0RBVEE7XG4gICAgfVxuICAgIC8qKiBUaGUgdGltZXN0YW1wIG9mIHRoaXMgcGFja2V0IGluIG1pY3Jvc2Vjb25kcy4gKi9cbiAgICBnZXQgbWljcm9zZWNvbmRUaW1lc3RhbXAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnRydW5jKFNFQ09ORF9UT19NSUNST1NFQ09ORF9GQUNUT1IgKiB0aGlzLnRpbWVzdGFtcCk7XG4gICAgfVxuICAgIC8qKiBUaGUgZHVyYXRpb24gb2YgdGhpcyBwYWNrZXQgaW4gbWljcm9zZWNvbmRzLiAqL1xuICAgIGdldCBtaWNyb3NlY29uZER1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC50cnVuYyhTRUNPTkRfVE9fTUlDUk9TRUNPTkRfRkFDVE9SICogdGhpcy5kdXJhdGlvbik7XG4gICAgfVxuICAgIC8qKiBDb252ZXJ0cyB0aGlzIHBhY2tldCB0byBhbiBFbmNvZGVkVmlkZW9DaHVuayBmb3IgdXNlIHdpdGggdGhlIFdlYkNvZGVjcyBBUEkuICovXG4gICAgdG9FbmNvZGVkVmlkZW9DaHVuaygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNNZXRhZGF0YU9ubHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01ldGFkYXRhLW9ubHkgcGFja2V0cyBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgdmlkZW8gY2h1bmsuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBFbmNvZGVkVmlkZW9DaHVuayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgRW5jb2RlZFZpZGVvQ2h1bmsuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFbmNvZGVkVmlkZW9DaHVuayh7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMubWljcm9zZWNvbmRUaW1lc3RhbXAsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5taWNyb3NlY29uZER1cmF0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIENvbnZlcnRzIHRoaXMgcGFja2V0IHRvIGFuIEVuY29kZWRBdWRpb0NodW5rIGZvciB1c2Ugd2l0aCB0aGUgV2ViQ29kZWNzIEFQSS4gKi9cbiAgICB0b0VuY29kZWRBdWRpb0NodW5rKCkge1xuICAgICAgICBpZiAodGhpcy5pc01ldGFkYXRhT25seSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWV0YWRhdGEtb25seSBwYWNrZXRzIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYW4gYXVkaW8gY2h1bmsuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBFbmNvZGVkQXVkaW9DaHVuayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgRW5jb2RlZEF1ZGlvQ2h1bmsuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFbmNvZGVkQXVkaW9DaHVuayh7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMubWljcm9zZWNvbmRUaW1lc3RhbXAsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5taWNyb3NlY29uZER1cmF0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBFbmNvZGVkUGFja2V0IGZyb20gYW4gRW5jb2RlZFZpZGVvQ2h1bmsgb3IgRW5jb2RlZEF1ZGlvQ2h1bmsuIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBmb3IgY29udmVydGluZ1xuICAgICAqIGNodW5rcyBmcm9tIHRoZSBXZWJDb2RlY3MgQVBJIHRvIEVuY29kZWRQYWNrZXRzLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tRW5jb2RlZENodW5rKGNodW5rKSB7XG4gICAgICAgIGlmICghKGNodW5rIGluc3RhbmNlb2YgRW5jb2RlZFZpZGVvQ2h1bmsgfHwgY2h1bmsgaW5zdGFuY2VvZiBFbmNvZGVkQXVkaW9DaHVuaykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NodW5rIG11c3QgYmUgYW4gRW5jb2RlZFZpZGVvQ2h1bmsgb3IgRW5jb2RlZEF1ZGlvQ2h1bmsuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICBjaHVuay5jb3B5VG8oZGF0YSk7XG4gICAgICAgIHJldHVybiBuZXcgRW5jb2RlZFBhY2tldChkYXRhLCBjaHVuay50eXBlLCBjaHVuay50aW1lc3RhbXAgLyAxZTYsIChjaHVuay5kdXJhdGlvbiA/PyAwKSAvIDFlNik7XG4gICAgfVxuICAgIC8qKiBDbG9uZXMgdGhpcyBwYWNrZXQgd2hpbGUgb3B0aW9uYWxseSB1cGRhdGluZyB0aW1pbmcgaW5mb3JtYXRpb24uICovXG4gICAgY2xvbmUob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMsIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zPy50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJiAhTnVtYmVyLmlzRmluaXRlKG9wdGlvbnMudGltZXN0YW1wKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy50aW1lc3RhbXAsIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnM/LmR1cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgIU51bWJlci5pc0Zpbml0ZShvcHRpb25zLmR1cmF0aW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5kdXJhdGlvbiwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVuY29kZWRQYWNrZXQodGhpcy5kYXRhLCB0aGlzLnR5cGUsIG9wdGlvbnM/LnRpbWVzdGFtcCA/PyB0aGlzLnRpbWVzdGFtcCwgb3B0aW9ucz8uZHVyYXRpb24gPz8gdGhpcy5kdXJhdGlvbiwgdGhpcy5zZXF1ZW5jZU51bWJlciwgdGhpcy5ieXRlTGVuZ3RoKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/packet.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/pcm.js":
/*!*********************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/pcm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromAlaw: () => (/* binding */ fromAlaw),\n/* harmony export */   fromUlaw: () => (/* binding */ fromUlaw),\n/* harmony export */   toAlaw: () => (/* binding */ toAlaw),\n/* harmony export */   toUlaw: () => (/* binding */ toUlaw)\n/* harmony export */ });\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n// https://github.com/dystopiancode/pcm-g711/blob/master/pcm-g711/g711.c\nconst toUlaw = (s16) => {\n    const MULAW_MAX = 0x1FFF;\n    const MULAW_BIAS = 33;\n    let number = s16;\n    let mask = 0x1000;\n    let sign = 0;\n    let position = 12;\n    let lsb = 0;\n    if (number < 0) {\n        number = -number;\n        sign = 0x80;\n    }\n    number += MULAW_BIAS;\n    if (number > MULAW_MAX) {\n        number = MULAW_MAX;\n    }\n    while ((number & mask) !== mask && position >= 5) {\n        mask >>= 1;\n        position--;\n    }\n    lsb = (number >> (position - 4)) & 0x0f;\n    return ~(sign | ((position - 5) << 4) | lsb) & 0xFF;\n};\nconst fromUlaw = (u8) => {\n    const MULAW_BIAS = 33;\n    let sign = 0;\n    let position = 0;\n    let number = ~u8;\n    if (number & 0x80) {\n        number &= ~(1 << 7);\n        sign = -1;\n    }\n    position = ((number & 0xF0) >> 4) + 5;\n    const decoded = ((1 << position) | ((number & 0x0F) << (position - 4))\n        | (1 << (position - 5))) - MULAW_BIAS;\n    return (sign === 0) ? decoded : -decoded;\n};\nconst toAlaw = (s16) => {\n    const ALAW_MAX = 0xFFF;\n    let mask = 0x800;\n    let sign = 0;\n    let position = 11;\n    let lsb = 0;\n    let number = s16;\n    if (number < 0) {\n        number = -number;\n        sign = 0x80;\n    }\n    if (number > ALAW_MAX) {\n        number = ALAW_MAX;\n    }\n    while ((number & mask) !== mask && position >= 5) {\n        mask >>= 1;\n        position--;\n    }\n    lsb = (number >> ((position === 4) ? 1 : (position - 4))) & 0x0f;\n    return (sign | ((position - 4) << 4) | lsb) ^ 0x55;\n};\nconst fromAlaw = (u8) => {\n    let sign = 0x00;\n    let position = 0;\n    let number = u8 ^ 0x55;\n    if (number & 0x80) {\n        number &= ~(1 << 7);\n        sign = -1;\n    }\n    position = ((number & 0xF0) >> 4) + 4;\n    let decoded = 0;\n    if (position !== 4) {\n        decoded = ((1 << position) | ((number & 0x0F) << (position - 4))\n            | (1 << (position - 5)));\n    }\n    else {\n        decoded = (number << 1) | 1;\n    }\n    return (sign === 0) ? decoded : -decoded;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL3BjbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRjaC1jdXQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL21lZGlhYnVubnkvZGlzdC9tb2R1bGVzL3NyYy9wY20uanM/YmRmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAyNS1wcmVzZW50LCBWYW5pbGFneSBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9keXN0b3BpYW5jb2RlL3BjbS1nNzExL2Jsb2IvbWFzdGVyL3BjbS1nNzExL2c3MTEuY1xuZXhwb3J0IGNvbnN0IHRvVWxhdyA9IChzMTYpID0+IHtcbiAgICBjb25zdCBNVUxBV19NQVggPSAweDFGRkY7XG4gICAgY29uc3QgTVVMQVdfQklBUyA9IDMzO1xuICAgIGxldCBudW1iZXIgPSBzMTY7XG4gICAgbGV0IG1hc2sgPSAweDEwMDA7XG4gICAgbGV0IHNpZ24gPSAwO1xuICAgIGxldCBwb3NpdGlvbiA9IDEyO1xuICAgIGxldCBsc2IgPSAwO1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIG51bWJlciA9IC1udW1iZXI7XG4gICAgICAgIHNpZ24gPSAweDgwO1xuICAgIH1cbiAgICBudW1iZXIgKz0gTVVMQVdfQklBUztcbiAgICBpZiAobnVtYmVyID4gTVVMQVdfTUFYKSB7XG4gICAgICAgIG51bWJlciA9IE1VTEFXX01BWDtcbiAgICB9XG4gICAgd2hpbGUgKChudW1iZXIgJiBtYXNrKSAhPT0gbWFzayAmJiBwb3NpdGlvbiA+PSA1KSB7XG4gICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgIHBvc2l0aW9uLS07XG4gICAgfVxuICAgIGxzYiA9IChudW1iZXIgPj4gKHBvc2l0aW9uIC0gNCkpICYgMHgwZjtcbiAgICByZXR1cm4gfihzaWduIHwgKChwb3NpdGlvbiAtIDUpIDw8IDQpIHwgbHNiKSAmIDB4RkY7XG59O1xuZXhwb3J0IGNvbnN0IGZyb21VbGF3ID0gKHU4KSA9PiB7XG4gICAgY29uc3QgTVVMQVdfQklBUyA9IDMzO1xuICAgIGxldCBzaWduID0gMDtcbiAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgIGxldCBudW1iZXIgPSB+dTg7XG4gICAgaWYgKG51bWJlciAmIDB4ODApIHtcbiAgICAgICAgbnVtYmVyICY9IH4oMSA8PCA3KTtcbiAgICAgICAgc2lnbiA9IC0xO1xuICAgIH1cbiAgICBwb3NpdGlvbiA9ICgobnVtYmVyICYgMHhGMCkgPj4gNCkgKyA1O1xuICAgIGNvbnN0IGRlY29kZWQgPSAoKDEgPDwgcG9zaXRpb24pIHwgKChudW1iZXIgJiAweDBGKSA8PCAocG9zaXRpb24gLSA0KSlcbiAgICAgICAgfCAoMSA8PCAocG9zaXRpb24gLSA1KSkpIC0gTVVMQVdfQklBUztcbiAgICByZXR1cm4gKHNpZ24gPT09IDApID8gZGVjb2RlZCA6IC1kZWNvZGVkO1xufTtcbmV4cG9ydCBjb25zdCB0b0FsYXcgPSAoczE2KSA9PiB7XG4gICAgY29uc3QgQUxBV19NQVggPSAweEZGRjtcbiAgICBsZXQgbWFzayA9IDB4ODAwO1xuICAgIGxldCBzaWduID0gMDtcbiAgICBsZXQgcG9zaXRpb24gPSAxMTtcbiAgICBsZXQgbHNiID0gMDtcbiAgICBsZXQgbnVtYmVyID0gczE2O1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIG51bWJlciA9IC1udW1iZXI7XG4gICAgICAgIHNpZ24gPSAweDgwO1xuICAgIH1cbiAgICBpZiAobnVtYmVyID4gQUxBV19NQVgpIHtcbiAgICAgICAgbnVtYmVyID0gQUxBV19NQVg7XG4gICAgfVxuICAgIHdoaWxlICgobnVtYmVyICYgbWFzaykgIT09IG1hc2sgJiYgcG9zaXRpb24gPj0gNSkge1xuICAgICAgICBtYXNrID4+PSAxO1xuICAgICAgICBwb3NpdGlvbi0tO1xuICAgIH1cbiAgICBsc2IgPSAobnVtYmVyID4+ICgocG9zaXRpb24gPT09IDQpID8gMSA6IChwb3NpdGlvbiAtIDQpKSkgJiAweDBmO1xuICAgIHJldHVybiAoc2lnbiB8ICgocG9zaXRpb24gLSA0KSA8PCA0KSB8IGxzYikgXiAweDU1O1xufTtcbmV4cG9ydCBjb25zdCBmcm9tQWxhdyA9ICh1OCkgPT4ge1xuICAgIGxldCBzaWduID0gMHgwMDtcbiAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgIGxldCBudW1iZXIgPSB1OCBeIDB4NTU7XG4gICAgaWYgKG51bWJlciAmIDB4ODApIHtcbiAgICAgICAgbnVtYmVyICY9IH4oMSA8PCA3KTtcbiAgICAgICAgc2lnbiA9IC0xO1xuICAgIH1cbiAgICBwb3NpdGlvbiA9ICgobnVtYmVyICYgMHhGMCkgPj4gNCkgKyA0O1xuICAgIGxldCBkZWNvZGVkID0gMDtcbiAgICBpZiAocG9zaXRpb24gIT09IDQpIHtcbiAgICAgICAgZGVjb2RlZCA9ICgoMSA8PCBwb3NpdGlvbikgfCAoKG51bWJlciAmIDB4MEYpIDw8IChwb3NpdGlvbiAtIDQpKVxuICAgICAgICAgICAgfCAoMSA8PCAocG9zaXRpb24gLSA1KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVjb2RlZCA9IChudW1iZXIgPDwgMSkgfCAxO1xuICAgIH1cbiAgICByZXR1cm4gKHNpZ24gPT09IDApID8gZGVjb2RlZCA6IC1kZWNvZGVkO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/pcm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/reader.js":
/*!************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/reader.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FileSlice: () => (/* binding */ FileSlice),\n/* harmony export */   Reader: () => (/* binding */ Reader),\n/* harmony export */   readAscii: () => (/* binding */ readAscii),\n/* harmony export */   readBytes: () => (/* binding */ readBytes),\n/* harmony export */   readF32Be: () => (/* binding */ readF32Be),\n/* harmony export */   readF64Be: () => (/* binding */ readF64Be),\n/* harmony export */   readI16Be: () => (/* binding */ readI16Be),\n/* harmony export */   readI32Be: () => (/* binding */ readI32Be),\n/* harmony export */   readI32Le: () => (/* binding */ readI32Le),\n/* harmony export */   readI64Be: () => (/* binding */ readI64Be),\n/* harmony export */   readI64Le: () => (/* binding */ readI64Le),\n/* harmony export */   readU16: () => (/* binding */ readU16),\n/* harmony export */   readU16Be: () => (/* binding */ readU16Be),\n/* harmony export */   readU24Be: () => (/* binding */ readU24Be),\n/* harmony export */   readU32: () => (/* binding */ readU32),\n/* harmony export */   readU32Be: () => (/* binding */ readU32Be),\n/* harmony export */   readU32Le: () => (/* binding */ readU32Le),\n/* harmony export */   readU64: () => (/* binding */ readU64),\n/* harmony export */   readU64Be: () => (/* binding */ readU64Be),\n/* harmony export */   readU8: () => (/* binding */ readU8)\n/* harmony export */ });\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\nclass Reader {\n    constructor(source) {\n        this.source = source;\n    }\n    requestSlice(start, length) {\n        if (this.fileSize !== null && start + length > this.fileSize) {\n            return null;\n        }\n        const end = start + length;\n        const result = this.source._read(start, end);\n        if (result instanceof Promise) {\n            return result.then((x) => {\n                if (!x) {\n                    return null;\n                }\n                return new FileSlice(x.bytes, x.view, x.offset, start, end);\n            });\n        }\n        else {\n            if (!result) {\n                return null;\n            }\n            return new FileSlice(result.bytes, result.view, result.offset, start, end);\n        }\n    }\n    requestSliceRange(start, minLength, maxLength) {\n        if (this.fileSize !== null) {\n            return this.requestSlice(start, (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.clamp)(this.fileSize - start, minLength, maxLength));\n        }\n        else {\n            const promisedAttempt = this.requestSlice(start, maxLength);\n            const handleAttempt = (attempt) => {\n                if (attempt) {\n                    return attempt;\n                }\n                const handleFileSize = (fileSize) => {\n                    (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fileSize !== null); // The slice couldn't fit, meaning we must know the file size now\n                    return this.requestSlice(start, (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.clamp)(fileSize - start, minLength, maxLength));\n                };\n                const promisedFileSize = this.source._retrieveSize();\n                if (promisedFileSize instanceof Promise) {\n                    return promisedFileSize.then(handleFileSize);\n                }\n                else {\n                    return handleFileSize(promisedFileSize);\n                }\n            };\n            if (promisedAttempt instanceof Promise) {\n                return promisedAttempt.then(handleAttempt);\n            }\n            else {\n                return handleAttempt(promisedAttempt);\n            }\n        }\n    }\n}\nclass FileSlice {\n    constructor(bytes, view, offset, start, end) {\n        this.bytes = bytes;\n        this.view = view;\n        this.offset = offset;\n        this.start = start;\n        this.end = end;\n        this.bufferPos = start - offset;\n    }\n    static tempFromBytes(bytes) {\n        return new FileSlice(bytes, (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.toDataView)(bytes), 0, 0, bytes.length);\n    }\n    get length() {\n        return this.end - this.start;\n    }\n    get filePos() {\n        return this.offset + this.bufferPos;\n    }\n    set filePos(value) {\n        this.bufferPos = value - this.offset;\n    }\n    skip(byteCount) {\n        this.bufferPos += byteCount;\n    }\n    slice(filePos, length = this.end - filePos) {\n        if (filePos < this.start || filePos + length > this.end) {\n            throw new RangeError('Slicing outside of original slice.');\n        }\n        return new FileSlice(this.bytes, this.view, this.offset, filePos, filePos + length);\n    }\n}\nconst readBytes = (slice, length) => {\n    const bytes = slice.bytes.subarray(slice.bufferPos, slice.bufferPos + length);\n    slice.bufferPos += length;\n    return bytes;\n};\nconst readU8 = (slice) => slice.view.getUint8(slice.bufferPos++);\nconst readU16 = (slice, littleEndian) => {\n    const value = slice.view.getUint16(slice.bufferPos, littleEndian);\n    slice.bufferPos += 2;\n    return value;\n};\nconst readU16Be = (slice) => {\n    const value = slice.view.getUint16(slice.bufferPos, false);\n    slice.bufferPos += 2;\n    return value;\n};\nconst readU24Be = (slice) => {\n    const high = readU16Be(slice);\n    const low = readU8(slice);\n    return high * 0x100 + low;\n};\nconst readI16Be = (slice) => {\n    const value = slice.view.getInt16(slice.bufferPos, false);\n    slice.bufferPos += 2;\n    return value;\n};\nconst readU32 = (slice, littleEndian) => {\n    const value = slice.view.getUint32(slice.bufferPos, littleEndian);\n    slice.bufferPos += 4;\n    return value;\n};\nconst readU32Be = (slice) => {\n    const value = slice.view.getUint32(slice.bufferPos, false);\n    slice.bufferPos += 4;\n    return value;\n};\nconst readU32Le = (slice) => {\n    const value = slice.view.getUint32(slice.bufferPos, true);\n    slice.bufferPos += 4;\n    return value;\n};\nconst readI32Be = (slice) => {\n    const value = slice.view.getInt32(slice.bufferPos, false);\n    slice.bufferPos += 4;\n    return value;\n};\nconst readI32Le = (slice) => {\n    const value = slice.view.getInt32(slice.bufferPos, true);\n    slice.bufferPos += 4;\n    return value;\n};\nconst readU64 = (slice, littleEndian) => {\n    let low;\n    let high;\n    if (littleEndian) {\n        low = readU32(slice, true);\n        high = readU32(slice, true);\n    }\n    else {\n        high = readU32(slice, false);\n        low = readU32(slice, false);\n    }\n    return high * 0x100000000 + low;\n};\nconst readU64Be = (slice) => {\n    const high = readU32Be(slice);\n    const low = readU32Be(slice);\n    return high * 0x100000000 + low;\n};\nconst readI64Be = (slice) => {\n    const high = readI32Be(slice);\n    const low = readU32Be(slice);\n    return high * 0x100000000 + low;\n};\nconst readI64Le = (slice) => {\n    const low = readU32Le(slice);\n    const high = readI32Le(slice);\n    return high * 0x100000000 + low;\n};\nconst readF32Be = (slice) => {\n    const value = slice.view.getFloat32(slice.bufferPos, false);\n    slice.bufferPos += 4;\n    return value;\n};\nconst readF64Be = (slice) => {\n    const value = slice.view.getFloat64(slice.bufferPos, false);\n    slice.bufferPos += 8;\n    return value;\n};\nconst readAscii = (slice, length) => {\n    if (slice.bufferPos + length > slice.bytes.length) {\n        throw new RangeError('Reading past end of slice.');\n    }\n    let str = '';\n    for (let i = 0; i < length; i++) {\n        str += String.fromCharCode(slice.bytes[slice.bufferPos++]);\n    }\n    return str;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL3JlYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzRDtBQUMvQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywrQ0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdEQUFNLHFCQUFxQjtBQUMvQyxvREFBb0QsK0NBQUs7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0RBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRjaC1jdXQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL21lZGlhYnVubnkvZGlzdC9tb2R1bGVzL3NyYy9yZWFkZXIuanM/MGJiZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAyNS1wcmVzZW50LCBWYW5pbGFneSBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmltcG9ydCB7IGFzc2VydCwgY2xhbXAsIHRvRGF0YVZpZXcgfSBmcm9tICcuL21pc2MuanMnO1xuZXhwb3J0IGNsYXNzIFJlYWRlciB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICByZXF1ZXN0U2xpY2Uoc3RhcnQsIGxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5maWxlU2l6ZSAhPT0gbnVsbCAmJiBzdGFydCArIGxlbmd0aCA+IHRoaXMuZmlsZVNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNvdXJjZS5fcmVhZChzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigoeCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgheCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWxlU2xpY2UoeC5ieXRlcywgeC52aWV3LCB4Lm9mZnNldCwgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbGVTbGljZShyZXN1bHQuYnl0ZXMsIHJlc3VsdC52aWV3LCByZXN1bHQub2Zmc2V0LCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0U2xpY2VSYW5nZShzdGFydCwgbWluTGVuZ3RoLCBtYXhMZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsZVNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RTbGljZShzdGFydCwgY2xhbXAodGhpcy5maWxlU2l6ZSAtIHN0YXJ0LCBtaW5MZW5ndGgsIG1heExlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZWRBdHRlbXB0ID0gdGhpcy5yZXF1ZXN0U2xpY2Uoc3RhcnQsIG1heExlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVBdHRlbXB0ID0gKGF0dGVtcHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0ZW1wdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlRmlsZVNpemUgPSAoZmlsZVNpemUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZpbGVTaXplICE9PSBudWxsKTsgLy8gVGhlIHNsaWNlIGNvdWxkbid0IGZpdCwgbWVhbmluZyB3ZSBtdXN0IGtub3cgdGhlIGZpbGUgc2l6ZSBub3dcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFNsaWNlKHN0YXJ0LCBjbGFtcChmaWxlU2l6ZSAtIHN0YXJ0LCBtaW5MZW5ndGgsIG1heExlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZWRGaWxlU2l6ZSA9IHRoaXMuc291cmNlLl9yZXRyaWV2ZVNpemUoKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZWRGaWxlU2l6ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VkRmlsZVNpemUudGhlbihoYW5kbGVGaWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRmlsZVNpemUocHJvbWlzZWRGaWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwcm9taXNlZEF0dGVtcHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VkQXR0ZW1wdC50aGVuKGhhbmRsZUF0dGVtcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUF0dGVtcHQocHJvbWlzZWRBdHRlbXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGaWxlU2xpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzLCB2aWV3LCBvZmZzZXQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy5idWZmZXJQb3MgPSBzdGFydCAtIG9mZnNldDtcbiAgICB9XG4gICAgc3RhdGljIHRlbXBGcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlU2xpY2UoYnl0ZXMsIHRvRGF0YVZpZXcoYnl0ZXMpLCAwLCAwLCBieXRlcy5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmQgLSB0aGlzLnN0YXJ0O1xuICAgIH1cbiAgICBnZXQgZmlsZVBvcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ICsgdGhpcy5idWZmZXJQb3M7XG4gICAgfVxuICAgIHNldCBmaWxlUG9zKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyUG9zID0gdmFsdWUgLSB0aGlzLm9mZnNldDtcbiAgICB9XG4gICAgc2tpcChieXRlQ291bnQpIHtcbiAgICAgICAgdGhpcy5idWZmZXJQb3MgKz0gYnl0ZUNvdW50O1xuICAgIH1cbiAgICBzbGljZShmaWxlUG9zLCBsZW5ndGggPSB0aGlzLmVuZCAtIGZpbGVQb3MpIHtcbiAgICAgICAgaWYgKGZpbGVQb3MgPCB0aGlzLnN0YXJ0IHx8IGZpbGVQb3MgKyBsZW5ndGggPiB0aGlzLmVuZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1NsaWNpbmcgb3V0c2lkZSBvZiBvcmlnaW5hbCBzbGljZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZpbGVTbGljZSh0aGlzLmJ5dGVzLCB0aGlzLnZpZXcsIHRoaXMub2Zmc2V0LCBmaWxlUG9zLCBmaWxlUG9zICsgbGVuZ3RoKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgcmVhZEJ5dGVzID0gKHNsaWNlLCBsZW5ndGgpID0+IHtcbiAgICBjb25zdCBieXRlcyA9IHNsaWNlLmJ5dGVzLnN1YmFycmF5KHNsaWNlLmJ1ZmZlclBvcywgc2xpY2UuYnVmZmVyUG9zICsgbGVuZ3RoKTtcbiAgICBzbGljZS5idWZmZXJQb3MgKz0gbGVuZ3RoO1xuICAgIHJldHVybiBieXRlcztcbn07XG5leHBvcnQgY29uc3QgcmVhZFU4ID0gKHNsaWNlKSA9PiBzbGljZS52aWV3LmdldFVpbnQ4KHNsaWNlLmJ1ZmZlclBvcysrKTtcbmV4cG9ydCBjb25zdCByZWFkVTE2ID0gKHNsaWNlLCBsaXR0bGVFbmRpYW4pID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHNsaWNlLnZpZXcuZ2V0VWludDE2KHNsaWNlLmJ1ZmZlclBvcywgbGl0dGxlRW5kaWFuKTtcbiAgICBzbGljZS5idWZmZXJQb3MgKz0gMjtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IHJlYWRVMTZCZSA9IChzbGljZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gc2xpY2Uudmlldy5nZXRVaW50MTYoc2xpY2UuYnVmZmVyUG9zLCBmYWxzZSk7XG4gICAgc2xpY2UuYnVmZmVyUG9zICs9IDI7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCByZWFkVTI0QmUgPSAoc2xpY2UpID0+IHtcbiAgICBjb25zdCBoaWdoID0gcmVhZFUxNkJlKHNsaWNlKTtcbiAgICBjb25zdCBsb3cgPSByZWFkVTgoc2xpY2UpO1xuICAgIHJldHVybiBoaWdoICogMHgxMDAgKyBsb3c7XG59O1xuZXhwb3J0IGNvbnN0IHJlYWRJMTZCZSA9IChzbGljZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gc2xpY2Uudmlldy5nZXRJbnQxNihzbGljZS5idWZmZXJQb3MsIGZhbHNlKTtcbiAgICBzbGljZS5idWZmZXJQb3MgKz0gMjtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IHJlYWRVMzIgPSAoc2xpY2UsIGxpdHRsZUVuZGlhbikgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gc2xpY2Uudmlldy5nZXRVaW50MzIoc2xpY2UuYnVmZmVyUG9zLCBsaXR0bGVFbmRpYW4pO1xuICAgIHNsaWNlLmJ1ZmZlclBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5leHBvcnQgY29uc3QgcmVhZFUzMkJlID0gKHNsaWNlKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBzbGljZS52aWV3LmdldFVpbnQzMihzbGljZS5idWZmZXJQb3MsIGZhbHNlKTtcbiAgICBzbGljZS5idWZmZXJQb3MgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IHJlYWRVMzJMZSA9IChzbGljZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gc2xpY2Uudmlldy5nZXRVaW50MzIoc2xpY2UuYnVmZmVyUG9zLCB0cnVlKTtcbiAgICBzbGljZS5idWZmZXJQb3MgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IHJlYWRJMzJCZSA9IChzbGljZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gc2xpY2Uudmlldy5nZXRJbnQzMihzbGljZS5idWZmZXJQb3MsIGZhbHNlKTtcbiAgICBzbGljZS5idWZmZXJQb3MgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IHJlYWRJMzJMZSA9IChzbGljZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gc2xpY2Uudmlldy5nZXRJbnQzMihzbGljZS5idWZmZXJQb3MsIHRydWUpO1xuICAgIHNsaWNlLmJ1ZmZlclBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5leHBvcnQgY29uc3QgcmVhZFU2NCA9IChzbGljZSwgbGl0dGxlRW5kaWFuKSA9PiB7XG4gICAgbGV0IGxvdztcbiAgICBsZXQgaGlnaDtcbiAgICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIGxvdyA9IHJlYWRVMzIoc2xpY2UsIHRydWUpO1xuICAgICAgICBoaWdoID0gcmVhZFUzMihzbGljZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoaWdoID0gcmVhZFUzMihzbGljZSwgZmFsc2UpO1xuICAgICAgICBsb3cgPSByZWFkVTMyKHNsaWNlLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiBoaWdoICogMHgxMDAwMDAwMDAgKyBsb3c7XG59O1xuZXhwb3J0IGNvbnN0IHJlYWRVNjRCZSA9IChzbGljZSkgPT4ge1xuICAgIGNvbnN0IGhpZ2ggPSByZWFkVTMyQmUoc2xpY2UpO1xuICAgIGNvbnN0IGxvdyA9IHJlYWRVMzJCZShzbGljZSk7XG4gICAgcmV0dXJuIGhpZ2ggKiAweDEwMDAwMDAwMCArIGxvdztcbn07XG5leHBvcnQgY29uc3QgcmVhZEk2NEJlID0gKHNsaWNlKSA9PiB7XG4gICAgY29uc3QgaGlnaCA9IHJlYWRJMzJCZShzbGljZSk7XG4gICAgY29uc3QgbG93ID0gcmVhZFUzMkJlKHNsaWNlKTtcbiAgICByZXR1cm4gaGlnaCAqIDB4MTAwMDAwMDAwICsgbG93O1xufTtcbmV4cG9ydCBjb25zdCByZWFkSTY0TGUgPSAoc2xpY2UpID0+IHtcbiAgICBjb25zdCBsb3cgPSByZWFkVTMyTGUoc2xpY2UpO1xuICAgIGNvbnN0IGhpZ2ggPSByZWFkSTMyTGUoc2xpY2UpO1xuICAgIHJldHVybiBoaWdoICogMHgxMDAwMDAwMDAgKyBsb3c7XG59O1xuZXhwb3J0IGNvbnN0IHJlYWRGMzJCZSA9IChzbGljZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gc2xpY2Uudmlldy5nZXRGbG9hdDMyKHNsaWNlLmJ1ZmZlclBvcywgZmFsc2UpO1xuICAgIHNsaWNlLmJ1ZmZlclBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5leHBvcnQgY29uc3QgcmVhZEY2NEJlID0gKHNsaWNlKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBzbGljZS52aWV3LmdldEZsb2F0NjQoc2xpY2UuYnVmZmVyUG9zLCBmYWxzZSk7XG4gICAgc2xpY2UuYnVmZmVyUG9zICs9IDg7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCByZWFkQXNjaWkgPSAoc2xpY2UsIGxlbmd0aCkgPT4ge1xuICAgIGlmIChzbGljZS5idWZmZXJQb3MgKyBsZW5ndGggPiBzbGljZS5ieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1JlYWRpbmcgcGFzdCBlbmQgb2Ygc2xpY2UuJyk7XG4gICAgfVxuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHNsaWNlLmJ5dGVzW3NsaWNlLmJ1ZmZlclBvcysrXSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/reader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/sample.js":
/*!************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/sample.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioSample: () => (/* binding */ AudioSample),\n/* harmony export */   VideoSample: () => (/* binding */ VideoSample)\n/* harmony export */ });\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n/**\n * Represents a raw, unencoded video sample (frame). Mainly used as an expressive wrapper around WebCodecs API's\n * [`VideoFrame`](https://developer.mozilla.org/en-US/docs/Web/API/VideoFrame), but can also be used standalone.\n * @group Samples\n * @public\n */\nclass VideoSample {\n    /** The width of the frame in pixels after rotation. */\n    get displayWidth() {\n        return this.rotation % 180 === 0 ? this.codedWidth : this.codedHeight;\n    }\n    /** The height of the frame in pixels after rotation. */\n    get displayHeight() {\n        return this.rotation % 180 === 0 ? this.codedHeight : this.codedWidth;\n    }\n    /** The presentation timestamp of the frame in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(_misc_js__WEBPACK_IMPORTED_MODULE_0__.SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of the frame in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(_misc_js__WEBPACK_IMPORTED_MODULE_0__.SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    constructor(data, init) {\n        /** @internal */\n        this._closed = false;\n        if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('init must be an object.');\n            }\n            if (!('format' in init) || typeof init.format !== 'string') {\n                throw new TypeError('init.format must be a string.');\n            }\n            if (!Number.isInteger(init.codedWidth) || init.codedWidth <= 0) {\n                throw new TypeError('init.codedWidth must be a positive integer.');\n            }\n            if (!Number.isInteger(init.codedHeight) || init.codedHeight <= 0) {\n                throw new TypeError('init.codedHeight must be a positive integer.');\n            }\n            if (init.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (!Number.isFinite(init.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            if (init.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            this._data = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.toUint8Array)(data).slice(); // Copy it\n            this.format = init.format;\n            this.codedWidth = init.codedWidth;\n            this.codedHeight = init.codedHeight;\n            this.rotation = init.rotation ?? 0;\n            this.timestamp = init.timestamp;\n            this.duration = init.duration ?? 0;\n            this.colorSpace = new VideoColorSpace(init.colorSpace);\n        }\n        else if (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) {\n            if (init?.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (init?.timestamp !== undefined && !Number.isFinite(init?.timestamp)) {\n                throw new TypeError('init.timestamp, when provided, must be a number.');\n            }\n            if (init?.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            this._data = data;\n            this.format = data.format;\n            // Copying the display dimensions here, assuming no innate VideoFrame rotation\n            this.codedWidth = data.displayWidth;\n            this.codedHeight = data.displayHeight;\n            // The VideoFrame's rotation is ignored here. It's still a new field, and I'm not sure of any application\n            // where the browser makes use of it. If a case gets found, I'll add it.\n            this.rotation = init?.rotation ?? 0;\n            this.timestamp = init?.timestamp ?? data.timestamp / 1e6;\n            this.duration = init?.duration ?? (data.duration ?? 0) / 1e6;\n            this.colorSpace = data.colorSpace;\n        }\n        else if ((typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement)\n            || (typeof SVGImageElement !== 'undefined' && data instanceof SVGImageElement)\n            || (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap)\n            || (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement)\n            || (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement)\n            || (typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas)) {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('init must be an object.');\n            }\n            if (init.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (!Number.isFinite(init.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            if (init.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            if (typeof VideoFrame !== 'undefined') {\n                return new VideoSample(new VideoFrame(data, {\n                    timestamp: Math.trunc(init.timestamp * _misc_js__WEBPACK_IMPORTED_MODULE_0__.SECOND_TO_MICROSECOND_FACTOR),\n                    duration: Math.trunc((init.duration ?? 0) * _misc_js__WEBPACK_IMPORTED_MODULE_0__.SECOND_TO_MICROSECOND_FACTOR),\n                }), init);\n            }\n            let width = 0;\n            let height = 0;\n            // Determine the dimensions of the thing\n            if ('naturalWidth' in data) {\n                width = data.naturalWidth;\n                height = data.naturalHeight;\n            }\n            else if ('videoWidth' in data) {\n                width = data.videoWidth;\n                height = data.videoHeight;\n            }\n            else if ('width' in data) {\n                width = Number(data.width);\n                height = Number(data.height);\n            }\n            if (!width || !height) {\n                throw new TypeError('Could not determine dimensions.');\n            }\n            const canvas = new OffscreenCanvas(width, height);\n            const context = canvas.getContext('2d', { alpha: false, willReadFrequently: true });\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(context);\n            // Draw it to a canvas\n            context.drawImage(data, 0, 0);\n            this._data = canvas;\n            this.format = 'RGBX';\n            this.codedWidth = width;\n            this.codedHeight = height;\n            this.rotation = init.rotation ?? 0;\n            this.timestamp = init.timestamp;\n            this.duration = init.duration ?? 0;\n            this.colorSpace = new VideoColorSpace({\n                matrix: 'rgb',\n                primaries: 'bt709',\n                transfer: 'iec61966-2-1',\n                fullRange: true,\n            });\n        }\n        else {\n            throw new TypeError('Invalid data type: Must be a BufferSource or CanvasImageSource.');\n        }\n    }\n    /** Clones this video sample. */\n    clone() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            return new VideoSample(this._data.clone(), {\n                timestamp: this.timestamp,\n                duration: this.duration,\n                rotation: this.rotation,\n            });\n        }\n        else if (this._data instanceof Uint8Array) {\n            return new VideoSample(this._data.slice(), {\n                format: this.format,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.timestamp,\n                duration: this.duration,\n                colorSpace: this.colorSpace,\n                rotation: this.rotation,\n            });\n        }\n        else {\n            return new VideoSample(this._data, {\n                format: this.format,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.timestamp,\n                duration: this.duration,\n                colorSpace: this.colorSpace,\n                rotation: this.rotation,\n            });\n        }\n    }\n    /**\n     * Closes this video sample, releasing held resources. Video samples should be closed as soon as they are not\n     * needed anymore.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        if (isVideoFrame(this._data)) {\n            this._data.close();\n        }\n        else {\n            this._data = null; // GC that shit\n        }\n        this._closed = true;\n    }\n    /** Returns the number of bytes required to hold this video sample's pixel data. */\n    allocationSize() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            return this._data.allocationSize();\n        }\n        else if (this._data instanceof Uint8Array) {\n            return this._data.byteLength;\n        }\n        else {\n            return this.codedWidth * this.codedHeight * 4; // RGBX\n        }\n    }\n    /** Copies this video sample's pixel data to an ArrayBuffer or ArrayBufferView. */\n    async copyTo(destination) {\n        if (!(0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.isAllowSharedBufferSource)(destination)) {\n            throw new TypeError('destination must be an ArrayBuffer or an ArrayBuffer view.');\n        }\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            await this._data.copyTo(destination);\n        }\n        else if (this._data instanceof Uint8Array) {\n            const dest = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.toUint8Array)(destination);\n            dest.set(this._data);\n        }\n        else {\n            const canvas = this._data;\n            const context = canvas.getContext('2d', { alpha: false });\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(context);\n            const imageData = context.getImageData(0, 0, this.codedWidth, this.codedHeight);\n            const dest = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.toUint8Array)(destination);\n            dest.set(imageData.data);\n        }\n    }\n    /**\n     * Converts this video sample to a VideoFrame for use with the WebCodecs API. The VideoFrame returned by this\n     * method *must* be closed separately from this video sample.\n     */\n    toVideoFrame() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            return new VideoFrame(this._data, {\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration || undefined, // Drag 0 duration to undefined, glitches some codecs\n            });\n        }\n        else if (this._data instanceof Uint8Array) {\n            return new VideoFrame(this._data, {\n                format: this.format,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration,\n                colorSpace: this.colorSpace,\n            });\n        }\n        else {\n            return new VideoFrame(this._data, {\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration,\n            });\n        }\n    }\n    draw(context, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {\n        let sx = 0;\n        let sy = 0;\n        let sWidth = this.displayWidth;\n        let sHeight = this.displayHeight;\n        let dx = 0;\n        let dy = 0;\n        let dWidth = this.displayWidth;\n        let dHeight = this.displayHeight;\n        if (arg5 !== undefined) {\n            sx = arg1;\n            sy = arg2;\n            sWidth = arg3;\n            sHeight = arg4;\n            dx = arg5;\n            dy = arg6;\n            if (arg7 !== undefined) {\n                dWidth = arg7;\n                dHeight = arg8;\n            }\n            else {\n                dWidth = sWidth;\n                dHeight = sHeight;\n            }\n        }\n        else {\n            dx = arg1;\n            dy = arg2;\n            if (arg3 !== undefined) {\n                dWidth = arg3;\n                dHeight = arg4;\n            }\n        }\n        if (!((typeof CanvasRenderingContext2D !== 'undefined' && context instanceof CanvasRenderingContext2D)\n            || (typeof OffscreenCanvasRenderingContext2D !== 'undefined'\n                && context instanceof OffscreenCanvasRenderingContext2D))) {\n            throw new TypeError('context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.');\n        }\n        if (!Number.isFinite(sx)) {\n            throw new TypeError('sx must be a number.');\n        }\n        if (!Number.isFinite(sy)) {\n            throw new TypeError('sy must be a number.');\n        }\n        if (!Number.isFinite(sWidth) || sWidth < 0) {\n            throw new TypeError('sWidth must be a non-negative number.');\n        }\n        if (!Number.isFinite(sHeight) || sHeight < 0) {\n            throw new TypeError('sHeight must be a non-negative number.');\n        }\n        if (!Number.isFinite(dx)) {\n            throw new TypeError('dx must be a number.');\n        }\n        if (!Number.isFinite(dy)) {\n            throw new TypeError('dy must be a number.');\n        }\n        if (!Number.isFinite(dWidth) || dWidth < 0) {\n            throw new TypeError('dWidth must be a non-negative number.');\n        }\n        if (!Number.isFinite(dHeight) || dHeight < 0) {\n            throw new TypeError('dHeight must be a non-negative number.');\n        }\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        // The provided sx,sy,sWidth,sHeight refer to the final rotated image, but that's not actually how the image is\n        // stored. Therefore, we must map these back onto the original, pre-rotation image.\n        if (this.rotation === 90) {\n            [sx, sy, sWidth, sHeight] = [\n                sy,\n                this.codedHeight - sx - sWidth,\n                sHeight,\n                sWidth,\n            ];\n        }\n        else if (this.rotation === 180) {\n            [sx, sy] = [\n                this.codedWidth - sx - sWidth,\n                this.codedHeight - sy - sHeight,\n            ];\n        }\n        else if (this.rotation === 270) {\n            [sx, sy, sWidth, sHeight] = [\n                this.codedWidth - sy - sHeight,\n                sx,\n                sHeight,\n                sWidth,\n            ];\n        }\n        const source = this.toCanvasImageSource();\n        context.save();\n        const centerX = dx + dWidth / 2;\n        const centerY = dy + dHeight / 2;\n        context.translate(centerX, centerY);\n        context.rotate(this.rotation * Math.PI / 180);\n        const aspectRatioChange = this.rotation % 180 === 0 ? 1 : dWidth / dHeight;\n        // Scale to compensate for aspect ratio changes when rotated\n        context.scale(1 / aspectRatioChange, aspectRatioChange);\n        context.drawImage(source, sx, sy, sWidth, sHeight, -dWidth / 2, -dHeight / 2, dWidth, dHeight);\n        // Restore the previous transformation state\n        context.restore();\n    }\n    /**\n     * Draws the sample in the middle of the canvas corresponding to the context with the specified fit behavior.\n     */\n    drawWithFit(context, options) {\n        const canvasWidth = context.canvas.width;\n        const canvasHeight = context.canvas.height;\n        const rotation = options.rotation ?? this.rotation;\n        // These variables specify where the final sample will be drawn on the canvas\n        let dx;\n        let dy;\n        let newWidth;\n        let newHeight;\n        if (options.fit === 'fill') {\n            dx = 0;\n            dy = 0;\n            newWidth = canvasWidth;\n            newHeight = canvasHeight;\n        }\n        else {\n            const [sampleWidth, sampleHeight] = rotation % 180 === 0\n                ? [this.codedWidth, this.codedHeight]\n                : [this.codedHeight, this.codedWidth];\n            const scale = options.fit === 'contain'\n                ? Math.min(canvasWidth / sampleWidth, canvasHeight / sampleHeight)\n                : Math.max(canvasWidth / sampleWidth, canvasHeight / sampleHeight);\n            newWidth = sampleWidth * scale;\n            newHeight = sampleHeight * scale;\n            dx = (canvasWidth - newWidth) / 2;\n            dy = (canvasHeight - newHeight) / 2;\n        }\n        const aspectRatioChange = rotation % 180 === 0 ? 1 : newWidth / newHeight;\n        context.translate(canvasWidth / 2, canvasHeight / 2);\n        context.rotate(rotation * Math.PI / 180);\n        // This aspect ratio compensation is done so that we can draw the sample with the intended dimensions and\n        // don't need to think about how those dimensions change after the rotation\n        context.scale(1 / aspectRatioChange, aspectRatioChange);\n        context.translate(-canvasWidth / 2, -canvasHeight / 2);\n        // Important that we don't use .draw() here since that would take rotation into account, but we wanna handle it\n        // ourselves here\n        context.drawImage(this.toCanvasImageSource(), dx, dy, newWidth, newHeight);\n    }\n    /**\n     * Converts this video sample to a\n     * [`CanvasImageSource`](https://udn.realityripple.com/docs/Web/API/CanvasImageSource) for drawing to a canvas.\n     *\n     * You must use the value returned by this method immediately, as any VideoFrame created internally will\n     * automatically be closed in the next microtask.\n     */\n    toCanvasImageSource() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this._data !== null);\n        if (this._data instanceof Uint8Array) {\n            // Requires VideoFrame to be defined\n            const videoFrame = this.toVideoFrame();\n            queueMicrotask(() => videoFrame.close()); // Let's automatically close the frame in the next microtask\n            return videoFrame;\n        }\n        else {\n            return this._data;\n        }\n    }\n    /** Sets the rotation metadata of this video sample. */\n    setRotation(newRotation) {\n        if (![0, 90, 180, 270].includes(newRotation)) {\n            throw new TypeError('newRotation must be 0, 90, 180, or 270.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.rotation = newRotation;\n    }\n    /** Sets the presentation timestamp of this video sample, in seconds. */\n    setTimestamp(newTimestamp) {\n        if (!Number.isFinite(newTimestamp)) {\n            throw new TypeError('newTimestamp must be a number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.timestamp = newTimestamp;\n    }\n    /** Sets the duration of this video sample, in seconds. */\n    setDuration(newDuration) {\n        if (!Number.isFinite(newDuration) || newDuration < 0) {\n            throw new TypeError('newDuration must be a non-negative number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.duration = newDuration;\n    }\n}\nconst isVideoFrame = (x) => {\n    return typeof VideoFrame !== 'undefined' && x instanceof VideoFrame;\n};\nconst AUDIO_SAMPLE_FORMATS = new Set(['f32', 'f32-planar', 's16', 's16-planar', 's32', 's32-planar', 'u8', 'u8-planar']);\n/**\n * Represents a raw, unencoded audio sample. Mainly used as an expressive wrapper around WebCodecs API's\n * [`AudioData`](https://developer.mozilla.org/en-US/docs/Web/API/AudioData), but can also be used standalone.\n * @group Samples\n * @public\n */\nclass AudioSample {\n    /** The presentation timestamp of the sample in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(_misc_js__WEBPACK_IMPORTED_MODULE_0__.SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of the sample in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(_misc_js__WEBPACK_IMPORTED_MODULE_0__.SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    /**\n     * Creates a new {@link AudioSample}, either from an existing\n     * [`AudioData`](https://developer.mozilla.org/en-US/docs/Web/API/AudioData) or from raw bytes specified in\n     * {@link AudioSampleInit}.\n     */\n    constructor(init) {\n        /** @internal */\n        this._closed = false;\n        if (isAudioData(init)) {\n            if (init.format === null) {\n                throw new TypeError('AudioData with null format is not supported.');\n            }\n            this._data = init;\n            this.format = init.format;\n            this.sampleRate = init.sampleRate;\n            this.numberOfFrames = init.numberOfFrames;\n            this.numberOfChannels = init.numberOfChannels;\n            this.timestamp = init.timestamp / 1e6;\n            this.duration = init.numberOfFrames / init.sampleRate;\n        }\n        else {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('Invalid AudioDataInit: must be an object.');\n            }\n            if (!AUDIO_SAMPLE_FORMATS.has(init.format)) {\n                throw new TypeError('Invalid AudioDataInit: invalid format.');\n            }\n            if (!Number.isFinite(init.sampleRate) || init.sampleRate <= 0) {\n                throw new TypeError('Invalid AudioDataInit: sampleRate must be > 0.');\n            }\n            if (!Number.isInteger(init.numberOfChannels) || init.numberOfChannels === 0) {\n                throw new TypeError('Invalid AudioDataInit: numberOfChannels must be an integer > 0.');\n            }\n            if (!Number.isFinite(init?.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            const numberOfFrames = init.data.byteLength / (getBytesPerSample(init.format) * init.numberOfChannels);\n            if (!Number.isInteger(numberOfFrames)) {\n                throw new TypeError('Invalid AudioDataInit: data size is not a multiple of frame size.');\n            }\n            this.format = init.format;\n            this.sampleRate = init.sampleRate;\n            this.numberOfFrames = numberOfFrames;\n            this.numberOfChannels = init.numberOfChannels;\n            this.timestamp = init.timestamp;\n            this.duration = numberOfFrames / init.sampleRate;\n            let dataBuffer;\n            if (init.data instanceof ArrayBuffer) {\n                dataBuffer = new Uint8Array(init.data);\n            }\n            else if (ArrayBuffer.isView(init.data)) {\n                dataBuffer = new Uint8Array(init.data.buffer, init.data.byteOffset, init.data.byteLength);\n            }\n            else {\n                throw new TypeError('Invalid AudioDataInit: data is not a BufferSource.');\n            }\n            const expectedSize = this.numberOfFrames * this.numberOfChannels * getBytesPerSample(this.format);\n            if (dataBuffer.byteLength < expectedSize) {\n                throw new TypeError('Invalid AudioDataInit: insufficient data size.');\n            }\n            this._data = dataBuffer;\n        }\n    }\n    /** Returns the number of bytes required to hold the audio sample's data as specified by the given options. */\n    allocationSize(options) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!Number.isInteger(options.planeIndex) || options.planeIndex < 0) {\n            throw new TypeError('planeIndex must be a non-negative integer.');\n        }\n        if (options.format !== undefined && !AUDIO_SAMPLE_FORMATS.has(options.format)) {\n            throw new TypeError('Invalid format.');\n        }\n        if (options.frameOffset !== undefined && (!Number.isInteger(options.frameOffset) || options.frameOffset < 0)) {\n            throw new TypeError('frameOffset must be a non-negative integer.');\n        }\n        if (options.frameCount !== undefined && (!Number.isInteger(options.frameCount) || options.frameCount < 0)) {\n            throw new TypeError('frameCount must be a non-negative integer.');\n        }\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const destFormat = options.format ?? this.format;\n        const frameOffset = options.frameOffset ?? 0;\n        if (frameOffset >= this.numberOfFrames) {\n            throw new RangeError('frameOffset out of range');\n        }\n        const copyFrameCount = options.frameCount !== undefined ? options.frameCount : (this.numberOfFrames - frameOffset);\n        if (copyFrameCount > (this.numberOfFrames - frameOffset)) {\n            throw new RangeError('frameCount out of range');\n        }\n        const bytesPerSample = getBytesPerSample(destFormat);\n        const isPlanar = formatIsPlanar(destFormat);\n        if (isPlanar && options.planeIndex >= this.numberOfChannels) {\n            throw new RangeError('planeIndex out of range');\n        }\n        if (!isPlanar && options.planeIndex !== 0) {\n            throw new RangeError('planeIndex out of range');\n        }\n        const elementCount = isPlanar ? copyFrameCount : copyFrameCount * this.numberOfChannels;\n        return elementCount * bytesPerSample;\n    }\n    /** Copies the audio sample's data to an ArrayBuffer or ArrayBufferView as specified by the given options. */\n    copyTo(destination, options) {\n        if (!(0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.isAllowSharedBufferSource)(destination)) {\n            throw new TypeError('destination must be an ArrayBuffer or an ArrayBuffer view.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!Number.isInteger(options.planeIndex) || options.planeIndex < 0) {\n            throw new TypeError('planeIndex must be a non-negative integer.');\n        }\n        if (options.format !== undefined && !AUDIO_SAMPLE_FORMATS.has(options.format)) {\n            throw new TypeError('Invalid format.');\n        }\n        if (options.frameOffset !== undefined && (!Number.isInteger(options.frameOffset) || options.frameOffset < 0)) {\n            throw new TypeError('frameOffset must be a non-negative integer.');\n        }\n        if (options.frameCount !== undefined && (!Number.isInteger(options.frameCount) || options.frameCount < 0)) {\n            throw new TypeError('frameCount must be a non-negative integer.');\n        }\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const { planeIndex, format, frameCount: optFrameCount, frameOffset: optFrameOffset } = options;\n        const destFormat = format ?? this.format;\n        if (!destFormat)\n            throw new Error('Destination format not determined');\n        const numFrames = this.numberOfFrames;\n        const numChannels = this.numberOfChannels;\n        const frameOffset = optFrameOffset ?? 0;\n        if (frameOffset >= numFrames) {\n            throw new RangeError('frameOffset out of range');\n        }\n        const copyFrameCount = optFrameCount !== undefined ? optFrameCount : (numFrames - frameOffset);\n        if (copyFrameCount > (numFrames - frameOffset)) {\n            throw new RangeError('frameCount out of range');\n        }\n        const destBytesPerSample = getBytesPerSample(destFormat);\n        const destIsPlanar = formatIsPlanar(destFormat);\n        if (destIsPlanar && planeIndex >= numChannels) {\n            throw new RangeError('planeIndex out of range');\n        }\n        if (!destIsPlanar && planeIndex !== 0) {\n            throw new RangeError('planeIndex out of range');\n        }\n        const destElementCount = destIsPlanar ? copyFrameCount : copyFrameCount * numChannels;\n        const requiredSize = destElementCount * destBytesPerSample;\n        if (destination.byteLength < requiredSize) {\n            throw new RangeError('Destination buffer is too small');\n        }\n        const destView = (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.toDataView)(destination);\n        const writeFn = getWriteFunction(destFormat);\n        if (isAudioData(this._data)) {\n            if (destIsPlanar) {\n                if (destFormat === 'f32-planar') {\n                    // Simple, since the browser must support f32-planar, we can just delegate here\n                    this._data.copyTo(destination, {\n                        planeIndex,\n                        frameOffset,\n                        frameCount: copyFrameCount,\n                        format: 'f32-planar',\n                    });\n                }\n                else {\n                    // Allocate temporary buffer for f32-planar data\n                    const tempBuffer = new ArrayBuffer(copyFrameCount * 4);\n                    const tempArray = new Float32Array(tempBuffer);\n                    this._data.copyTo(tempArray, {\n                        planeIndex,\n                        frameOffset,\n                        frameCount: copyFrameCount,\n                        format: 'f32-planar',\n                    });\n                    // Convert each f32 sample to destination format\n                    const tempView = new DataView(tempBuffer);\n                    for (let i = 0; i < copyFrameCount; i++) {\n                        const destOffset = i * destBytesPerSample;\n                        const sample = tempView.getFloat32(i * 4, true);\n                        writeFn(destView, destOffset, sample);\n                    }\n                }\n            }\n            else {\n                // Destination is interleaved.\n                // Allocate a temporary Float32Array to hold one channel's worth of data.\n                const numCh = numChannels;\n                const temp = new Float32Array(copyFrameCount);\n                for (let ch = 0; ch < numCh; ch++) {\n                    this._data.copyTo(temp, {\n                        planeIndex: ch,\n                        frameOffset,\n                        frameCount: copyFrameCount,\n                        format: 'f32-planar',\n                    });\n                    for (let i = 0; i < copyFrameCount; i++) {\n                        const destIndex = i * numCh + ch;\n                        const destOffset = destIndex * destBytesPerSample;\n                        writeFn(destView, destOffset, temp[i]);\n                    }\n                }\n            }\n        }\n        else {\n            // Branch for Uint8Array data (non-AudioData)\n            const uint8Data = this._data;\n            const srcView = new DataView(uint8Data.buffer, uint8Data.byteOffset, uint8Data.byteLength);\n            const srcFormat = this.format;\n            const readFn = getReadFunction(srcFormat);\n            const srcBytesPerSample = getBytesPerSample(srcFormat);\n            const srcIsPlanar = formatIsPlanar(srcFormat);\n            for (let i = 0; i < copyFrameCount; i++) {\n                if (destIsPlanar) {\n                    const destOffset = i * destBytesPerSample;\n                    let srcOffset;\n                    if (srcIsPlanar) {\n                        srcOffset = (planeIndex * numFrames + (i + frameOffset)) * srcBytesPerSample;\n                    }\n                    else {\n                        srcOffset = (((i + frameOffset) * numChannels) + planeIndex) * srcBytesPerSample;\n                    }\n                    const normalized = readFn(srcView, srcOffset);\n                    writeFn(destView, destOffset, normalized);\n                }\n                else {\n                    for (let ch = 0; ch < numChannels; ch++) {\n                        const destIndex = i * numChannels + ch;\n                        const destOffset = destIndex * destBytesPerSample;\n                        let srcOffset;\n                        if (srcIsPlanar) {\n                            srcOffset = (ch * numFrames + (i + frameOffset)) * srcBytesPerSample;\n                        }\n                        else {\n                            srcOffset = (((i + frameOffset) * numChannels) + ch) * srcBytesPerSample;\n                        }\n                        const normalized = readFn(srcView, srcOffset);\n                        writeFn(destView, destOffset, normalized);\n                    }\n                }\n            }\n        }\n    }\n    /** Clones this audio sample. */\n    clone() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        if (isAudioData(this._data)) {\n            const sample = new AudioSample(this._data.clone());\n            sample.setTimestamp(this.timestamp); // Make sure the timestamp is precise (beyond microsecond accuracy)\n            return sample;\n        }\n        else {\n            return new AudioSample({\n                format: this.format,\n                sampleRate: this.sampleRate,\n                numberOfFrames: this.numberOfFrames,\n                numberOfChannels: this.numberOfChannels,\n                timestamp: this.timestamp,\n                data: this._data,\n            });\n        }\n    }\n    /**\n     * Closes this audio sample, releasing held resources. Audio samples should be closed as soon as they are not\n     * needed anymore.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        if (isAudioData(this._data)) {\n            this._data.close();\n        }\n        else {\n            this._data = new Uint8Array(0);\n        }\n        this._closed = true;\n    }\n    /**\n     * Converts this audio sample to an AudioData for use with the WebCodecs API. The AudioData returned by this\n     * method *must* be closed separately from this audio sample.\n     */\n    toAudioData() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        if (isAudioData(this._data)) {\n            if (this._data.timestamp === this.microsecondTimestamp) {\n                // Timestamp matches, let's just return the data (but cloned)\n                return this._data.clone();\n            }\n            else {\n                // It's impossible to simply change an AudioData's timestamp, so we'll need to create a new one\n                if (formatIsPlanar(this.format)) {\n                    const size = this.allocationSize({ planeIndex: 0, format: this.format });\n                    const data = new ArrayBuffer(size * this.numberOfChannels);\n                    // We gotta read out each plane individually\n                    for (let i = 0; i < this.numberOfChannels; i++) {\n                        this.copyTo(new Uint8Array(data, i * size, size), { planeIndex: i, format: this.format });\n                    }\n                    return new AudioData({\n                        format: this.format,\n                        sampleRate: this.sampleRate,\n                        numberOfFrames: this.numberOfFrames,\n                        numberOfChannels: this.numberOfChannels,\n                        timestamp: this.microsecondTimestamp,\n                        data,\n                    });\n                }\n                else {\n                    const data = new ArrayBuffer(this.allocationSize({ planeIndex: 0, format: this.format }));\n                    this.copyTo(data, { planeIndex: 0, format: this.format });\n                    return new AudioData({\n                        format: this.format,\n                        sampleRate: this.sampleRate,\n                        numberOfFrames: this.numberOfFrames,\n                        numberOfChannels: this.numberOfChannels,\n                        timestamp: this.microsecondTimestamp,\n                        data,\n                    });\n                }\n            }\n        }\n        else {\n            return new AudioData({\n                format: this.format,\n                sampleRate: this.sampleRate,\n                numberOfFrames: this.numberOfFrames,\n                numberOfChannels: this.numberOfChannels,\n                timestamp: this.microsecondTimestamp,\n                data: this._data,\n            });\n        }\n    }\n    /** Convert this audio sample to an AudioBuffer for use with the Web Audio API. */\n    toAudioBuffer() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const audioBuffer = new AudioBuffer({\n            numberOfChannels: this.numberOfChannels,\n            length: this.numberOfFrames,\n            sampleRate: this.sampleRate,\n        });\n        const dataBytes = new Float32Array(this.allocationSize({ planeIndex: 0, format: 'f32-planar' }) / 4);\n        for (let i = 0; i < this.numberOfChannels; i++) {\n            this.copyTo(dataBytes, { planeIndex: i, format: 'f32-planar' });\n            audioBuffer.copyToChannel(dataBytes, i);\n        }\n        return audioBuffer;\n    }\n    /** Sets the presentation timestamp of this audio sample, in seconds. */\n    setTimestamp(newTimestamp) {\n        if (!Number.isFinite(newTimestamp)) {\n            throw new TypeError('newTimestamp must be a number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.timestamp = newTimestamp;\n    }\n    /** @internal */\n    static *_fromAudioBuffer(audioBuffer, timestamp) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const MAX_FLOAT_COUNT = 48000 * 5; // 5 seconds of mono 48 kHz audio per sample\n        const numberOfChannels = audioBuffer.numberOfChannels;\n        const sampleRate = audioBuffer.sampleRate;\n        const totalFrames = audioBuffer.length;\n        const maxFramesPerChunk = Math.floor(MAX_FLOAT_COUNT / numberOfChannels);\n        let currentRelativeFrame = 0;\n        let remainingFrames = totalFrames;\n        // Create AudioSamples in a chunked fashion so we don't create huge Float32Arrays\n        while (remainingFrames > 0) {\n            const framesToCopy = Math.min(maxFramesPerChunk, remainingFrames);\n            const chunkData = new Float32Array(numberOfChannels * framesToCopy);\n            for (let channel = 0; channel < numberOfChannels; channel++) {\n                audioBuffer.copyFromChannel(chunkData.subarray(channel * framesToCopy, (channel + 1) * framesToCopy), channel, currentRelativeFrame);\n            }\n            yield new AudioSample({\n                format: 'f32-planar',\n                sampleRate,\n                numberOfFrames: framesToCopy,\n                numberOfChannels,\n                timestamp: timestamp + currentRelativeFrame / sampleRate,\n                data: chunkData,\n            });\n            currentRelativeFrame += framesToCopy;\n            remainingFrames -= framesToCopy;\n        }\n    }\n    /**\n     * Creates AudioSamples from an AudioBuffer, starting at the given timestamp in seconds. Typically creates exactly\n     * one sample, but may create multiple if the AudioBuffer is exceedingly large.\n     */\n    static fromAudioBuffer(audioBuffer, timestamp) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const MAX_FLOAT_COUNT = 48000 * 5; // 5 seconds of mono 48 kHz audio per sample\n        const numberOfChannels = audioBuffer.numberOfChannels;\n        const sampleRate = audioBuffer.sampleRate;\n        const totalFrames = audioBuffer.length;\n        const maxFramesPerChunk = Math.floor(MAX_FLOAT_COUNT / numberOfChannels);\n        let currentRelativeFrame = 0;\n        let remainingFrames = totalFrames;\n        const result = [];\n        // Create AudioSamples in a chunked fashion so we don't create huge Float32Arrays\n        while (remainingFrames > 0) {\n            const framesToCopy = Math.min(maxFramesPerChunk, remainingFrames);\n            const chunkData = new Float32Array(numberOfChannels * framesToCopy);\n            for (let channel = 0; channel < numberOfChannels; channel++) {\n                audioBuffer.copyFromChannel(chunkData.subarray(channel * framesToCopy, (channel + 1) * framesToCopy), channel, currentRelativeFrame);\n            }\n            const audioSample = new AudioSample({\n                format: 'f32-planar',\n                sampleRate,\n                numberOfFrames: framesToCopy,\n                numberOfChannels,\n                timestamp: timestamp + currentRelativeFrame / sampleRate,\n                data: chunkData,\n            });\n            result.push(audioSample);\n            currentRelativeFrame += framesToCopy;\n            remainingFrames -= framesToCopy;\n        }\n        return result;\n    }\n}\nconst getBytesPerSample = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return 1;\n        case 's16':\n        case 's16-planar':\n            return 2;\n        case 's32':\n        case 's32-planar':\n            return 4;\n        case 'f32':\n        case 'f32-planar':\n            return 4;\n        default:\n            throw new Error('Unknown AudioSampleFormat');\n    }\n};\nconst formatIsPlanar = (format) => {\n    switch (format) {\n        case 'u8-planar':\n        case 's16-planar':\n        case 's32-planar':\n        case 'f32-planar':\n            return true;\n        default:\n            return false;\n    }\n};\nconst getReadFunction = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return (view, offset) => (view.getUint8(offset) - 128) / 128;\n        case 's16':\n        case 's16-planar':\n            return (view, offset) => view.getInt16(offset, true) / 32768;\n        case 's32':\n        case 's32-planar':\n            return (view, offset) => view.getInt32(offset, true) / 2147483648;\n        case 'f32':\n        case 'f32-planar':\n            return (view, offset) => view.getFloat32(offset, true);\n    }\n};\nconst getWriteFunction = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return (view, offset, value) => view.setUint8(offset, (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.clamp)((value + 1) * 127.5, 0, 255));\n        case 's16':\n        case 's16-planar':\n            return (view, offset, value) => view.setInt16(offset, (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.clamp)(Math.round(value * 32767), -32768, 32767), true);\n        case 's32':\n        case 's32-planar':\n            return (view, offset, value) => view.setInt32(offset, (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.clamp)(Math.round(value * 2147483647), -2147483648, 2147483647), true);\n        case 'f32':\n        case 'f32-planar':\n            return (view, offset, value) => view.setFloat32(offset, value, true);\n    }\n};\nconst isAudioData = (x) => {\n    return typeof AudioData !== 'undefined' && x instanceof AudioData;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL3NhbXBsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4SDtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtFQUE0QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0VBQTRCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQVksZ0JBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsa0VBQTRCO0FBQ3ZGLGdFQUFnRSxrRUFBNEI7QUFDNUYsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsd0NBQXdDO0FBQzlGLFlBQVksZ0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUVBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsY0FBYztBQUNwRSxZQUFZLGdEQUFNO0FBQ2xCO0FBQ0EseUJBQXlCLHNEQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMEJBQTBCLGtFQUE0QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0VBQTRCO0FBQ3REO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0EsUUFBUSxzQkFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUVBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkVBQTZFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSwrQ0FBSztBQUN2RTtBQUNBO0FBQ0Esa0VBQWtFLCtDQUFLO0FBQ3ZFO0FBQ0E7QUFDQSxrRUFBa0UsK0NBQUs7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGNoLWN1dC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL3NhbXBsZS5qcz80NDJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDI1LXByZXNlbnQsIFZhbmlsYWd5IGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgYXNzZXJ0LCBjbGFtcCwgaXNBbGxvd1NoYXJlZEJ1ZmZlclNvdXJjZSwgU0VDT05EX1RPX01JQ1JPU0VDT05EX0ZBQ1RPUiwgdG9EYXRhVmlldywgdG9VaW50OEFycmF5LCB9IGZyb20gJy4vbWlzYy5qcyc7XG4vKipcbiAqIFJlcHJlc2VudHMgYSByYXcsIHVuZW5jb2RlZCB2aWRlbyBzYW1wbGUgKGZyYW1lKS4gTWFpbmx5IHVzZWQgYXMgYW4gZXhwcmVzc2l2ZSB3cmFwcGVyIGFyb3VuZCBXZWJDb2RlY3MgQVBJJ3NcbiAqIFtgVmlkZW9GcmFtZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9WaWRlb0ZyYW1lKSwgYnV0IGNhbiBhbHNvIGJlIHVzZWQgc3RhbmRhbG9uZS5cbiAqIEBncm91cCBTYW1wbGVzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBWaWRlb1NhbXBsZSB7XG4gICAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgZnJhbWUgaW4gcGl4ZWxzIGFmdGVyIHJvdGF0aW9uLiAqL1xuICAgIGdldCBkaXNwbGF5V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdGF0aW9uICUgMTgwID09PSAwID8gdGhpcy5jb2RlZFdpZHRoIDogdGhpcy5jb2RlZEhlaWdodDtcbiAgICB9XG4gICAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIGZyYW1lIGluIHBpeGVscyBhZnRlciByb3RhdGlvbi4gKi9cbiAgICBnZXQgZGlzcGxheUhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm90YXRpb24gJSAxODAgPT09IDAgPyB0aGlzLmNvZGVkSGVpZ2h0IDogdGhpcy5jb2RlZFdpZHRoO1xuICAgIH1cbiAgICAvKiogVGhlIHByZXNlbnRhdGlvbiB0aW1lc3RhbXAgb2YgdGhlIGZyYW1lIGluIG1pY3Jvc2Vjb25kcy4gKi9cbiAgICBnZXQgbWljcm9zZWNvbmRUaW1lc3RhbXAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnRydW5jKFNFQ09ORF9UT19NSUNST1NFQ09ORF9GQUNUT1IgKiB0aGlzLnRpbWVzdGFtcCk7XG4gICAgfVxuICAgIC8qKiBUaGUgZHVyYXRpb24gb2YgdGhlIGZyYW1lIGluIG1pY3Jvc2Vjb25kcy4gKi9cbiAgICBnZXQgbWljcm9zZWNvbmREdXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgudHJ1bmMoU0VDT05EX1RPX01JQ1JPU0VDT05EX0ZBQ1RPUiAqIHRoaXMuZHVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBpbml0KSB7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoIWluaXQgfHwgdHlwZW9mIGluaXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5pdCBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKCdmb3JtYXQnIGluIGluaXQpIHx8IHR5cGVvZiBpbml0LmZvcm1hdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbml0LmZvcm1hdCBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGluaXQuY29kZWRXaWR0aCkgfHwgaW5pdC5jb2RlZFdpZHRoIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbml0LmNvZGVkV2lkdGggbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaW5pdC5jb2RlZEhlaWdodCkgfHwgaW5pdC5jb2RlZEhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5pdC5jb2RlZEhlaWdodCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbml0LnJvdGF0aW9uICE9PSB1bmRlZmluZWQgJiYgIVswLCA5MCwgMTgwLCAyNzBdLmluY2x1ZGVzKGluaXQucm90YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5pdC5yb3RhdGlvbiwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSAwLCA5MCwgMTgwLCBvciAyNzAuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpbml0LnRpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbml0LnRpbWVzdGFtcCBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluaXQuZHVyYXRpb24gIT09IHVuZGVmaW5lZCAmJiAoIU51bWJlci5pc0Zpbml0ZShpbml0LmR1cmF0aW9uKSB8fCBpbml0LmR1cmF0aW9uIDwgMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbml0LmR1cmF0aW9uLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSB0b1VpbnQ4QXJyYXkoZGF0YSkuc2xpY2UoKTsgLy8gQ29weSBpdFxuICAgICAgICAgICAgdGhpcy5mb3JtYXQgPSBpbml0LmZvcm1hdDtcbiAgICAgICAgICAgIHRoaXMuY29kZWRXaWR0aCA9IGluaXQuY29kZWRXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuY29kZWRIZWlnaHQgPSBpbml0LmNvZGVkSGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IGluaXQucm90YXRpb24gPz8gMDtcbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gaW5pdC50aW1lc3RhbXA7XG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gaW5pdC5kdXJhdGlvbiA/PyAwO1xuICAgICAgICAgICAgdGhpcy5jb2xvclNwYWNlID0gbmV3IFZpZGVvQ29sb3JTcGFjZShpbml0LmNvbG9yU3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBWaWRlb0ZyYW1lICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgVmlkZW9GcmFtZSkge1xuICAgICAgICAgICAgaWYgKGluaXQ/LnJvdGF0aW9uICE9PSB1bmRlZmluZWQgJiYgIVswLCA5MCwgMTgwLCAyNzBdLmluY2x1ZGVzKGluaXQucm90YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5pdC5yb3RhdGlvbiwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSAwLCA5MCwgMTgwLCBvciAyNzAuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5pdD8udGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiYgIU51bWJlci5pc0Zpbml0ZShpbml0Py50aW1lc3RhbXApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5pdC50aW1lc3RhbXAsIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5pdD8uZHVyYXRpb24gIT09IHVuZGVmaW5lZCAmJiAoIU51bWJlci5pc0Zpbml0ZShpbml0LmR1cmF0aW9uKSB8fCBpbml0LmR1cmF0aW9uIDwgMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbml0LmR1cmF0aW9uLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5mb3JtYXQgPSBkYXRhLmZvcm1hdDtcbiAgICAgICAgICAgIC8vIENvcHlpbmcgdGhlIGRpc3BsYXkgZGltZW5zaW9ucyBoZXJlLCBhc3N1bWluZyBubyBpbm5hdGUgVmlkZW9GcmFtZSByb3RhdGlvblxuICAgICAgICAgICAgdGhpcy5jb2RlZFdpZHRoID0gZGF0YS5kaXNwbGF5V2lkdGg7XG4gICAgICAgICAgICB0aGlzLmNvZGVkSGVpZ2h0ID0gZGF0YS5kaXNwbGF5SGVpZ2h0O1xuICAgICAgICAgICAgLy8gVGhlIFZpZGVvRnJhbWUncyByb3RhdGlvbiBpcyBpZ25vcmVkIGhlcmUuIEl0J3Mgc3RpbGwgYSBuZXcgZmllbGQsIGFuZCBJJ20gbm90IHN1cmUgb2YgYW55IGFwcGxpY2F0aW9uXG4gICAgICAgICAgICAvLyB3aGVyZSB0aGUgYnJvd3NlciBtYWtlcyB1c2Ugb2YgaXQuIElmIGEgY2FzZSBnZXRzIGZvdW5kLCBJJ2xsIGFkZCBpdC5cbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSBpbml0Py5yb3RhdGlvbiA/PyAwO1xuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBpbml0Py50aW1lc3RhbXAgPz8gZGF0YS50aW1lc3RhbXAgLyAxZTY7XG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gaW5pdD8uZHVyYXRpb24gPz8gKGRhdGEuZHVyYXRpb24gPz8gMCkgLyAxZTY7XG4gICAgICAgICAgICB0aGlzLmNvbG9yU3BhY2UgPSBkYXRhLmNvbG9yU3BhY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudClcbiAgICAgICAgICAgIHx8ICh0eXBlb2YgU1ZHSW1hZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgU1ZHSW1hZ2VFbGVtZW50KVxuICAgICAgICAgICAgfHwgKHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgZGF0YSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKVxuICAgICAgICAgICAgfHwgKHR5cGVvZiBIVE1MVmlkZW9FbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudClcbiAgICAgICAgICAgIHx8ICh0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudClcbiAgICAgICAgICAgIHx8ICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSkge1xuICAgICAgICAgICAgaWYgKCFpbml0IHx8IHR5cGVvZiBpbml0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luaXQgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5pdC5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICYmICFbMCwgOTAsIDE4MCwgMjcwXS5pbmNsdWRlcyhpbml0LnJvdGF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luaXQucm90YXRpb24sIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgMCwgOTAsIDE4MCwgb3IgMjcwLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaW5pdC50aW1lc3RhbXApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5pdC50aW1lc3RhbXAgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbml0LmR1cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgKCFOdW1iZXIuaXNGaW5pdGUoaW5pdC5kdXJhdGlvbikgfHwgaW5pdC5kdXJhdGlvbiA8IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5pdC5kdXJhdGlvbiwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFZpZGVvRnJhbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWRlb1NhbXBsZShuZXcgVmlkZW9GcmFtZShkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogTWF0aC50cnVuYyhpbml0LnRpbWVzdGFtcCAqIFNFQ09ORF9UT19NSUNST1NFQ09ORF9GQUNUT1IpLFxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogTWF0aC50cnVuYygoaW5pdC5kdXJhdGlvbiA/PyAwKSAqIFNFQ09ORF9UT19NSUNST1NFQ09ORF9GQUNUT1IpLFxuICAgICAgICAgICAgICAgIH0pLCBpbml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGhpbmdcbiAgICAgICAgICAgIGlmICgnbmF0dXJhbFdpZHRoJyBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBkYXRhLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBkYXRhLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgndmlkZW9XaWR0aCcgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gZGF0YS52aWRlb1dpZHRoO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGRhdGEudmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgnd2lkdGgnIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IE51bWJlcihkYXRhLndpZHRoKTtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBOdW1iZXIoZGF0YS5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IGRldGVybWluZSBkaW1lbnNpb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7IGFscGhhOiBmYWxzZSwgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlIH0pO1xuICAgICAgICAgICAgYXNzZXJ0KGNvbnRleHQpO1xuICAgICAgICAgICAgLy8gRHJhdyBpdCB0byBhIGNhbnZhc1xuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoZGF0YSwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gY2FudmFzO1xuICAgICAgICAgICAgdGhpcy5mb3JtYXQgPSAnUkdCWCc7XG4gICAgICAgICAgICB0aGlzLmNvZGVkV2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuY29kZWRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gaW5pdC5yb3RhdGlvbiA/PyAwO1xuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBpbml0LnRpbWVzdGFtcDtcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSBpbml0LmR1cmF0aW9uID8/IDA7XG4gICAgICAgICAgICB0aGlzLmNvbG9yU3BhY2UgPSBuZXcgVmlkZW9Db2xvclNwYWNlKHtcbiAgICAgICAgICAgICAgICBtYXRyaXg6ICdyZ2InLFxuICAgICAgICAgICAgICAgIHByaW1hcmllczogJ2J0NzA5JyxcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcjogJ2llYzYxOTY2LTItMScsXG4gICAgICAgICAgICAgICAgZnVsbFJhbmdlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGRhdGEgdHlwZTogTXVzdCBiZSBhIEJ1ZmZlclNvdXJjZSBvciBDYW52YXNJbWFnZVNvdXJjZS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQ2xvbmVzIHRoaXMgdmlkZW8gc2FtcGxlLiAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpZGVvU2FtcGxlIGlzIGNsb3NlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQodGhpcy5fZGF0YSAhPT0gbnVsbCk7XG4gICAgICAgIGlmIChpc1ZpZGVvRnJhbWUodGhpcy5fZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmlkZW9TYW1wbGUodGhpcy5fZGF0YS5jbG9uZSgpLCB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aGlzLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZpZGVvU2FtcGxlKHRoaXMuX2RhdGEuc2xpY2UoKSwge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5mb3JtYXQsXG4gICAgICAgICAgICAgICAgY29kZWRXaWR0aDogdGhpcy5jb2RlZFdpZHRoLFxuICAgICAgICAgICAgICAgIGNvZGVkSGVpZ2h0OiB0aGlzLmNvZGVkSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdGhpcy50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgY29sb3JTcGFjZTogdGhpcy5jb2xvclNwYWNlLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZpZGVvU2FtcGxlKHRoaXMuX2RhdGEsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuZm9ybWF0LFxuICAgICAgICAgICAgICAgIGNvZGVkV2lkdGg6IHRoaXMuY29kZWRXaWR0aCxcbiAgICAgICAgICAgICAgICBjb2RlZEhlaWdodDogdGhpcy5jb2RlZEhlaWdodCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIGNvbG9yU3BhY2U6IHRoaXMuY29sb3JTcGFjZSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGlzIHZpZGVvIHNhbXBsZSwgcmVsZWFzaW5nIGhlbGQgcmVzb3VyY2VzLiBWaWRlbyBzYW1wbGVzIHNob3VsZCBiZSBjbG9zZWQgYXMgc29vbiBhcyB0aGV5IGFyZSBub3RcbiAgICAgKiBuZWVkZWQgYW55bW9yZS5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZpZGVvRnJhbWUodGhpcy5fZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBudWxsOyAvLyBHQyB0aGF0IHNoaXRcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkIHRvIGhvbGQgdGhpcyB2aWRlbyBzYW1wbGUncyBwaXhlbCBkYXRhLiAqL1xuICAgIGFsbG9jYXRpb25TaXplKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpZGVvU2FtcGxlIGlzIGNsb3NlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQodGhpcy5fZGF0YSAhPT0gbnVsbCk7XG4gICAgICAgIGlmIChpc1ZpZGVvRnJhbWUodGhpcy5fZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmFsbG9jYXRpb25TaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2RlZFdpZHRoICogdGhpcy5jb2RlZEhlaWdodCAqIDQ7IC8vIFJHQlhcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQ29waWVzIHRoaXMgdmlkZW8gc2FtcGxlJ3MgcGl4ZWwgZGF0YSB0byBhbiBBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcuICovXG4gICAgYXN5bmMgY29weVRvKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIGlmICghaXNBbGxvd1NoYXJlZEJ1ZmZlclNvdXJjZShkZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Rlc3RpbmF0aW9uIG11c3QgYmUgYW4gQXJyYXlCdWZmZXIgb3IgYW4gQXJyYXlCdWZmZXIgdmlldy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpZGVvU2FtcGxlIGlzIGNsb3NlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQodGhpcy5fZGF0YSAhPT0gbnVsbCk7XG4gICAgICAgIGlmIChpc1ZpZGVvRnJhbWUodGhpcy5fZGF0YSkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RhdGEuY29weVRvKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgZGVzdCA9IHRvVWludDhBcnJheShkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICBkZXN0LnNldCh0aGlzLl9kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RhdGE7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJywgeyBhbHBoYTogZmFsc2UgfSk7XG4gICAgICAgICAgICBhc3NlcnQoY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLmNvZGVkV2lkdGgsIHRoaXMuY29kZWRIZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgZGVzdCA9IHRvVWludDhBcnJheShkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICBkZXN0LnNldChpbWFnZURhdGEuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyB2aWRlbyBzYW1wbGUgdG8gYSBWaWRlb0ZyYW1lIGZvciB1c2Ugd2l0aCB0aGUgV2ViQ29kZWNzIEFQSS4gVGhlIFZpZGVvRnJhbWUgcmV0dXJuZWQgYnkgdGhpc1xuICAgICAqIG1ldGhvZCAqbXVzdCogYmUgY2xvc2VkIHNlcGFyYXRlbHkgZnJvbSB0aGlzIHZpZGVvIHNhbXBsZS5cbiAgICAgKi9cbiAgICB0b1ZpZGVvRnJhbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmlkZW9TYW1wbGUgaXMgY2xvc2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCh0aGlzLl9kYXRhICE9PSBudWxsKTtcbiAgICAgICAgaWYgKGlzVmlkZW9GcmFtZSh0aGlzLl9kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWRlb0ZyYW1lKHRoaXMuX2RhdGEsIHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMubWljcm9zZWNvbmRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMubWljcm9zZWNvbmREdXJhdGlvbiB8fCB1bmRlZmluZWQsIC8vIERyYWcgMCBkdXJhdGlvbiB0byB1bmRlZmluZWQsIGdsaXRjaGVzIHNvbWUgY29kZWNzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWRlb0ZyYW1lKHRoaXMuX2RhdGEsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuZm9ybWF0LFxuICAgICAgICAgICAgICAgIGNvZGVkV2lkdGg6IHRoaXMuY29kZWRXaWR0aCxcbiAgICAgICAgICAgICAgICBjb2RlZEhlaWdodDogdGhpcy5jb2RlZEhlaWdodCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMubWljcm9zZWNvbmRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMubWljcm9zZWNvbmREdXJhdGlvbixcbiAgICAgICAgICAgICAgICBjb2xvclNwYWNlOiB0aGlzLmNvbG9yU3BhY2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmlkZW9GcmFtZSh0aGlzLl9kYXRhLCB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aGlzLm1pY3Jvc2Vjb25kVGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLm1pY3Jvc2Vjb25kRHVyYXRpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmF3KGNvbnRleHQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzYsIGFyZzcsIGFyZzgpIHtcbiAgICAgICAgbGV0IHN4ID0gMDtcbiAgICAgICAgbGV0IHN5ID0gMDtcbiAgICAgICAgbGV0IHNXaWR0aCA9IHRoaXMuZGlzcGxheVdpZHRoO1xuICAgICAgICBsZXQgc0hlaWdodCA9IHRoaXMuZGlzcGxheUhlaWdodDtcbiAgICAgICAgbGV0IGR4ID0gMDtcbiAgICAgICAgbGV0IGR5ID0gMDtcbiAgICAgICAgbGV0IGRXaWR0aCA9IHRoaXMuZGlzcGxheVdpZHRoO1xuICAgICAgICBsZXQgZEhlaWdodCA9IHRoaXMuZGlzcGxheUhlaWdodDtcbiAgICAgICAgaWYgKGFyZzUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3ggPSBhcmcxO1xuICAgICAgICAgICAgc3kgPSBhcmcyO1xuICAgICAgICAgICAgc1dpZHRoID0gYXJnMztcbiAgICAgICAgICAgIHNIZWlnaHQgPSBhcmc0O1xuICAgICAgICAgICAgZHggPSBhcmc1O1xuICAgICAgICAgICAgZHkgPSBhcmc2O1xuICAgICAgICAgICAgaWYgKGFyZzcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRXaWR0aCA9IGFyZzc7XG4gICAgICAgICAgICAgICAgZEhlaWdodCA9IGFyZzg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkV2lkdGggPSBzV2lkdGg7XG4gICAgICAgICAgICAgICAgZEhlaWdodCA9IHNIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkeCA9IGFyZzE7XG4gICAgICAgICAgICBkeSA9IGFyZzI7XG4gICAgICAgICAgICBpZiAoYXJnMyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZFdpZHRoID0gYXJnMztcbiAgICAgICAgICAgICAgICBkSGVpZ2h0ID0gYXJnNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoISgodHlwZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCAhPT0gJ3VuZGVmaW5lZCcgJiYgY29udGV4dCBpbnN0YW5jZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRClcbiAgICAgICAgICAgIHx8ICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICYmIGNvbnRleHQgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29udGV4dCBtdXN0IGJlIGEgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIG9yIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShzeCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N4IG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoc3kpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzeSBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHNXaWR0aCkgfHwgc1dpZHRoIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc1dpZHRoIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHNIZWlnaHQpIHx8IHNIZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzSGVpZ2h0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGR4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZHggbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShkeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2R5IG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZFdpZHRoKSB8fCBkV2lkdGggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkV2lkdGggbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZEhlaWdodCkgfHwgZEhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RIZWlnaHQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWaWRlb1NhbXBsZSBpcyBjbG9zZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHByb3ZpZGVkIHN4LHN5LHNXaWR0aCxzSGVpZ2h0IHJlZmVyIHRvIHRoZSBmaW5hbCByb3RhdGVkIGltYWdlLCBidXQgdGhhdCdzIG5vdCBhY3R1YWxseSBob3cgdGhlIGltYWdlIGlzXG4gICAgICAgIC8vIHN0b3JlZC4gVGhlcmVmb3JlLCB3ZSBtdXN0IG1hcCB0aGVzZSBiYWNrIG9udG8gdGhlIG9yaWdpbmFsLCBwcmUtcm90YXRpb24gaW1hZ2UuXG4gICAgICAgIGlmICh0aGlzLnJvdGF0aW9uID09PSA5MCkge1xuICAgICAgICAgICAgW3N4LCBzeSwgc1dpZHRoLCBzSGVpZ2h0XSA9IFtcbiAgICAgICAgICAgICAgICBzeSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvZGVkSGVpZ2h0IC0gc3ggLSBzV2lkdGgsXG4gICAgICAgICAgICAgICAgc0hlaWdodCxcbiAgICAgICAgICAgICAgICBzV2lkdGgsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucm90YXRpb24gPT09IDE4MCkge1xuICAgICAgICAgICAgW3N4LCBzeV0gPSBbXG4gICAgICAgICAgICAgICAgdGhpcy5jb2RlZFdpZHRoIC0gc3ggLSBzV2lkdGgsXG4gICAgICAgICAgICAgICAgdGhpcy5jb2RlZEhlaWdodCAtIHN5IC0gc0hlaWdodCxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5yb3RhdGlvbiA9PT0gMjcwKSB7XG4gICAgICAgICAgICBbc3gsIHN5LCBzV2lkdGgsIHNIZWlnaHRdID0gW1xuICAgICAgICAgICAgICAgIHRoaXMuY29kZWRXaWR0aCAtIHN5IC0gc0hlaWdodCxcbiAgICAgICAgICAgICAgICBzeCxcbiAgICAgICAgICAgICAgICBzSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHNXaWR0aCxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy50b0NhbnZhc0ltYWdlU291cmNlKCk7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb25zdCBjZW50ZXJYID0gZHggKyBkV2lkdGggLyAyO1xuICAgICAgICBjb25zdCBjZW50ZXJZID0gZHkgKyBkSGVpZ2h0IC8gMjtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgIGNvbnRleHQucm90YXRlKHRoaXMucm90YXRpb24gKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW9DaGFuZ2UgPSB0aGlzLnJvdGF0aW9uICUgMTgwID09PSAwID8gMSA6IGRXaWR0aCAvIGRIZWlnaHQ7XG4gICAgICAgIC8vIFNjYWxlIHRvIGNvbXBlbnNhdGUgZm9yIGFzcGVjdCByYXRpbyBjaGFuZ2VzIHdoZW4gcm90YXRlZFxuICAgICAgICBjb250ZXh0LnNjYWxlKDEgLyBhc3BlY3RSYXRpb0NoYW5nZSwgYXNwZWN0UmF0aW9DaGFuZ2UpO1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShzb3VyY2UsIHN4LCBzeSwgc1dpZHRoLCBzSGVpZ2h0LCAtZFdpZHRoIC8gMiwgLWRIZWlnaHQgLyAyLCBkV2lkdGgsIGRIZWlnaHQpO1xuICAgICAgICAvLyBSZXN0b3JlIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1hdGlvbiBzdGF0ZVxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIHNhbXBsZSBpbiB0aGUgbWlkZGxlIG9mIHRoZSBjYW52YXMgY29ycmVzcG9uZGluZyB0byB0aGUgY29udGV4dCB3aXRoIHRoZSBzcGVjaWZpZWQgZml0IGJlaGF2aW9yLlxuICAgICAqL1xuICAgIGRyYXdXaXRoRml0KGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2FudmFzV2lkdGggPSBjb250ZXh0LmNhbnZhcy53aWR0aDtcbiAgICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gY29udGV4dC5jYW52YXMuaGVpZ2h0O1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb24gPz8gdGhpcy5yb3RhdGlvbjtcbiAgICAgICAgLy8gVGhlc2UgdmFyaWFibGVzIHNwZWNpZnkgd2hlcmUgdGhlIGZpbmFsIHNhbXBsZSB3aWxsIGJlIGRyYXduIG9uIHRoZSBjYW52YXNcbiAgICAgICAgbGV0IGR4O1xuICAgICAgICBsZXQgZHk7XG4gICAgICAgIGxldCBuZXdXaWR0aDtcbiAgICAgICAgbGV0IG5ld0hlaWdodDtcbiAgICAgICAgaWYgKG9wdGlvbnMuZml0ID09PSAnZmlsbCcpIHtcbiAgICAgICAgICAgIGR4ID0gMDtcbiAgICAgICAgICAgIGR5ID0gMDtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICAgICAgICBuZXdIZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBbc2FtcGxlV2lkdGgsIHNhbXBsZUhlaWdodF0gPSByb3RhdGlvbiAlIDE4MCA9PT0gMFxuICAgICAgICAgICAgICAgID8gW3RoaXMuY29kZWRXaWR0aCwgdGhpcy5jb2RlZEhlaWdodF1cbiAgICAgICAgICAgICAgICA6IFt0aGlzLmNvZGVkSGVpZ2h0LCB0aGlzLmNvZGVkV2lkdGhdO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBvcHRpb25zLmZpdCA9PT0gJ2NvbnRhaW4nXG4gICAgICAgICAgICAgICAgPyBNYXRoLm1pbihjYW52YXNXaWR0aCAvIHNhbXBsZVdpZHRoLCBjYW52YXNIZWlnaHQgLyBzYW1wbGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgOiBNYXRoLm1heChjYW52YXNXaWR0aCAvIHNhbXBsZVdpZHRoLCBjYW52YXNIZWlnaHQgLyBzYW1wbGVIZWlnaHQpO1xuICAgICAgICAgICAgbmV3V2lkdGggPSBzYW1wbGVXaWR0aCAqIHNjYWxlO1xuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gc2FtcGxlSGVpZ2h0ICogc2NhbGU7XG4gICAgICAgICAgICBkeCA9IChjYW52YXNXaWR0aCAtIG5ld1dpZHRoKSAvIDI7XG4gICAgICAgICAgICBkeSA9IChjYW52YXNIZWlnaHQgLSBuZXdIZWlnaHQpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhc3BlY3RSYXRpb0NoYW5nZSA9IHJvdGF0aW9uICUgMTgwID09PSAwID8gMSA6IG5ld1dpZHRoIC8gbmV3SGVpZ2h0O1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShjYW52YXNXaWR0aCAvIDIsIGNhbnZhc0hlaWdodCAvIDIpO1xuICAgICAgICBjb250ZXh0LnJvdGF0ZShyb3RhdGlvbiAqIE1hdGguUEkgLyAxODApO1xuICAgICAgICAvLyBUaGlzIGFzcGVjdCByYXRpbyBjb21wZW5zYXRpb24gaXMgZG9uZSBzbyB0aGF0IHdlIGNhbiBkcmF3IHRoZSBzYW1wbGUgd2l0aCB0aGUgaW50ZW5kZWQgZGltZW5zaW9ucyBhbmRcbiAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byB0aGluayBhYm91dCBob3cgdGhvc2UgZGltZW5zaW9ucyBjaGFuZ2UgYWZ0ZXIgdGhlIHJvdGF0aW9uXG4gICAgICAgIGNvbnRleHQuc2NhbGUoMSAvIGFzcGVjdFJhdGlvQ2hhbmdlLCBhc3BlY3RSYXRpb0NoYW5nZSk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1jYW52YXNXaWR0aCAvIDIsIC1jYW52YXNIZWlnaHQgLyAyKTtcbiAgICAgICAgLy8gSW1wb3J0YW50IHRoYXQgd2UgZG9uJ3QgdXNlIC5kcmF3KCkgaGVyZSBzaW5jZSB0aGF0IHdvdWxkIHRha2Ugcm90YXRpb24gaW50byBhY2NvdW50LCBidXQgd2Ugd2FubmEgaGFuZGxlIGl0XG4gICAgICAgIC8vIG91cnNlbHZlcyBoZXJlXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRoaXMudG9DYW52YXNJbWFnZVNvdXJjZSgpLCBkeCwgZHksIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIHZpZGVvIHNhbXBsZSB0byBhXG4gICAgICogW2BDYW52YXNJbWFnZVNvdXJjZWBdKGh0dHBzOi8vdWRuLnJlYWxpdHlyaXBwbGUuY29tL2RvY3MvV2ViL0FQSS9DYW52YXNJbWFnZVNvdXJjZSkgZm9yIGRyYXdpbmcgdG8gYSBjYW52YXMuXG4gICAgICpcbiAgICAgKiBZb3UgbXVzdCB1c2UgdGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kIGltbWVkaWF0ZWx5LCBhcyBhbnkgVmlkZW9GcmFtZSBjcmVhdGVkIGludGVybmFsbHkgd2lsbFxuICAgICAqIGF1dG9tYXRpY2FsbHkgYmUgY2xvc2VkIGluIHRoZSBuZXh0IG1pY3JvdGFzay5cbiAgICAgKi9cbiAgICB0b0NhbnZhc0ltYWdlU291cmNlKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpZGVvU2FtcGxlIGlzIGNsb3NlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQodGhpcy5fZGF0YSAhPT0gbnVsbCk7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgLy8gUmVxdWlyZXMgVmlkZW9GcmFtZSB0byBiZSBkZWZpbmVkXG4gICAgICAgICAgICBjb25zdCB2aWRlb0ZyYW1lID0gdGhpcy50b1ZpZGVvRnJhbWUoKTtcbiAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHZpZGVvRnJhbWUuY2xvc2UoKSk7IC8vIExldCdzIGF1dG9tYXRpY2FsbHkgY2xvc2UgdGhlIGZyYW1lIGluIHRoZSBuZXh0IG1pY3JvdGFza1xuICAgICAgICAgICAgcmV0dXJuIHZpZGVvRnJhbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogU2V0cyB0aGUgcm90YXRpb24gbWV0YWRhdGEgb2YgdGhpcyB2aWRlbyBzYW1wbGUuICovXG4gICAgc2V0Um90YXRpb24obmV3Um90YXRpb24pIHtcbiAgICAgICAgaWYgKCFbMCwgOTAsIDE4MCwgMjcwXS5pbmNsdWRlcyhuZXdSb3RhdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25ld1JvdGF0aW9uIG11c3QgYmUgMCwgOTAsIDE4MCwgb3IgMjcwLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb25cbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IG5ld1JvdGF0aW9uO1xuICAgIH1cbiAgICAvKiogU2V0cyB0aGUgcHJlc2VudGF0aW9uIHRpbWVzdGFtcCBvZiB0aGlzIHZpZGVvIHNhbXBsZSwgaW4gc2Vjb25kcy4gKi9cbiAgICBzZXRUaW1lc3RhbXAobmV3VGltZXN0YW1wKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG5ld1RpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25ld1RpbWVzdGFtcCBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb25cbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBuZXdUaW1lc3RhbXA7XG4gICAgfVxuICAgIC8qKiBTZXRzIHRoZSBkdXJhdGlvbiBvZiB0aGlzIHZpZGVvIHNhbXBsZSwgaW4gc2Vjb25kcy4gKi9cbiAgICBzZXREdXJhdGlvbihuZXdEdXJhdGlvbikge1xuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShuZXdEdXJhdGlvbikgfHwgbmV3RHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduZXdEdXJhdGlvbiBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBuZXdEdXJhdGlvbjtcbiAgICB9XG59XG5jb25zdCBpc1ZpZGVvRnJhbWUgPSAoeCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgVmlkZW9GcmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIFZpZGVvRnJhbWU7XG59O1xuY29uc3QgQVVESU9fU0FNUExFX0ZPUk1BVFMgPSBuZXcgU2V0KFsnZjMyJywgJ2YzMi1wbGFuYXInLCAnczE2JywgJ3MxNi1wbGFuYXInLCAnczMyJywgJ3MzMi1wbGFuYXInLCAndTgnLCAndTgtcGxhbmFyJ10pO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgcmF3LCB1bmVuY29kZWQgYXVkaW8gc2FtcGxlLiBNYWlubHkgdXNlZCBhcyBhbiBleHByZXNzaXZlIHdyYXBwZXIgYXJvdW5kIFdlYkNvZGVjcyBBUEknc1xuICogW2BBdWRpb0RhdGFgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9EYXRhKSwgYnV0IGNhbiBhbHNvIGJlIHVzZWQgc3RhbmRhbG9uZS5cbiAqIEBncm91cCBTYW1wbGVzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBBdWRpb1NhbXBsZSB7XG4gICAgLyoqIFRoZSBwcmVzZW50YXRpb24gdGltZXN0YW1wIG9mIHRoZSBzYW1wbGUgaW4gbWljcm9zZWNvbmRzLiAqL1xuICAgIGdldCBtaWNyb3NlY29uZFRpbWVzdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgudHJ1bmMoU0VDT05EX1RPX01JQ1JPU0VDT05EX0ZBQ1RPUiAqIHRoaXMudGltZXN0YW1wKTtcbiAgICB9XG4gICAgLyoqIFRoZSBkdXJhdGlvbiBvZiB0aGUgc2FtcGxlIGluIG1pY3Jvc2Vjb25kcy4gKi9cbiAgICBnZXQgbWljcm9zZWNvbmREdXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgudHJ1bmMoU0VDT05EX1RPX01JQ1JPU0VDT05EX0ZBQ1RPUiAqIHRoaXMuZHVyYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBBdWRpb1NhbXBsZX0sIGVpdGhlciBmcm9tIGFuIGV4aXN0aW5nXG4gICAgICogW2BBdWRpb0RhdGFgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9EYXRhKSBvciBmcm9tIHJhdyBieXRlcyBzcGVjaWZpZWQgaW5cbiAgICAgKiB7QGxpbmsgQXVkaW9TYW1wbGVJbml0fS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihpbml0KSB7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChpc0F1ZGlvRGF0YShpbml0KSkge1xuICAgICAgICAgICAgaWYgKGluaXQuZm9ybWF0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXVkaW9EYXRhIHdpdGggbnVsbCBmb3JtYXQgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBpbml0O1xuICAgICAgICAgICAgdGhpcy5mb3JtYXQgPSBpbml0LmZvcm1hdDtcbiAgICAgICAgICAgIHRoaXMuc2FtcGxlUmF0ZSA9IGluaXQuc2FtcGxlUmF0ZTtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZGcmFtZXMgPSBpbml0Lm51bWJlck9mRnJhbWVzO1xuICAgICAgICAgICAgdGhpcy5udW1iZXJPZkNoYW5uZWxzID0gaW5pdC5udW1iZXJPZkNoYW5uZWxzO1xuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBpbml0LnRpbWVzdGFtcCAvIDFlNjtcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSBpbml0Lm51bWJlck9mRnJhbWVzIC8gaW5pdC5zYW1wbGVSYXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpbml0IHx8IHR5cGVvZiBpbml0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgQXVkaW9EYXRhSW5pdDogbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUFVRElPX1NBTVBMRV9GT1JNQVRTLmhhcyhpbml0LmZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIEF1ZGlvRGF0YUluaXQ6IGludmFsaWQgZm9ybWF0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaW5pdC5zYW1wbGVSYXRlKSB8fCBpbml0LnNhbXBsZVJhdGUgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgQXVkaW9EYXRhSW5pdDogc2FtcGxlUmF0ZSBtdXN0IGJlID4gMC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihpbml0Lm51bWJlck9mQ2hhbm5lbHMpIHx8IGluaXQubnVtYmVyT2ZDaGFubmVscyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgQXVkaW9EYXRhSW5pdDogbnVtYmVyT2ZDaGFubmVscyBtdXN0IGJlIGFuIGludGVnZXIgPiAwLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaW5pdD8udGltZXN0YW1wKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luaXQudGltZXN0YW1wIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBudW1iZXJPZkZyYW1lcyA9IGluaXQuZGF0YS5ieXRlTGVuZ3RoIC8gKGdldEJ5dGVzUGVyU2FtcGxlKGluaXQuZm9ybWF0KSAqIGluaXQubnVtYmVyT2ZDaGFubmVscyk7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtYmVyT2ZGcmFtZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBBdWRpb0RhdGFJbml0OiBkYXRhIHNpemUgaXMgbm90IGEgbXVsdGlwbGUgb2YgZnJhbWUgc2l6ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm9ybWF0ID0gaW5pdC5mb3JtYXQ7XG4gICAgICAgICAgICB0aGlzLnNhbXBsZVJhdGUgPSBpbml0LnNhbXBsZVJhdGU7XG4gICAgICAgICAgICB0aGlzLm51bWJlck9mRnJhbWVzID0gbnVtYmVyT2ZGcmFtZXM7XG4gICAgICAgICAgICB0aGlzLm51bWJlck9mQ2hhbm5lbHMgPSBpbml0Lm51bWJlck9mQ2hhbm5lbHM7XG4gICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IGluaXQudGltZXN0YW1wO1xuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IG51bWJlck9mRnJhbWVzIC8gaW5pdC5zYW1wbGVSYXRlO1xuICAgICAgICAgICAgbGV0IGRhdGFCdWZmZXI7XG4gICAgICAgICAgICBpZiAoaW5pdC5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICBkYXRhQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoaW5pdC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhpbml0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGluaXQuZGF0YS5idWZmZXIsIGluaXQuZGF0YS5ieXRlT2Zmc2V0LCBpbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIEF1ZGlvRGF0YUluaXQ6IGRhdGEgaXMgbm90IGEgQnVmZmVyU291cmNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRTaXplID0gdGhpcy5udW1iZXJPZkZyYW1lcyAqIHRoaXMubnVtYmVyT2ZDaGFubmVscyAqIGdldEJ5dGVzUGVyU2FtcGxlKHRoaXMuZm9ybWF0KTtcbiAgICAgICAgICAgIGlmIChkYXRhQnVmZmVyLmJ5dGVMZW5ndGggPCBleHBlY3RlZFNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIEF1ZGlvRGF0YUluaXQ6IGluc3VmZmljaWVudCBkYXRhIHNpemUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZGF0YUJ1ZmZlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkIHRvIGhvbGQgdGhlIGF1ZGlvIHNhbXBsZSdzIGRhdGEgYXMgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBvcHRpb25zLiAqL1xuICAgIGFsbG9jYXRpb25TaXplKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5wbGFuZUluZGV4KSB8fCBvcHRpb25zLnBsYW5lSW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwbGFuZUluZGV4IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCAmJiAhQVVESU9fU0FNUExFX0ZPUk1BVFMuaGFzKG9wdGlvbnMuZm9ybWF0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBmb3JtYXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZnJhbWVPZmZzZXQgIT09IHVuZGVmaW5lZCAmJiAoIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5mcmFtZU9mZnNldCkgfHwgb3B0aW9ucy5mcmFtZU9mZnNldCA8IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmcmFtZU9mZnNldCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZnJhbWVDb3VudCAhPT0gdW5kZWZpbmVkICYmICghTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmZyYW1lQ291bnQpIHx8IG9wdGlvbnMuZnJhbWVDb3VudCA8IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmcmFtZUNvdW50IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1ZGlvU2FtcGxlIGlzIGNsb3NlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXN0Rm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgPz8gdGhpcy5mb3JtYXQ7XG4gICAgICAgIGNvbnN0IGZyYW1lT2Zmc2V0ID0gb3B0aW9ucy5mcmFtZU9mZnNldCA/PyAwO1xuICAgICAgICBpZiAoZnJhbWVPZmZzZXQgPj0gdGhpcy5udW1iZXJPZkZyYW1lcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2ZyYW1lT2Zmc2V0IG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvcHlGcmFtZUNvdW50ID0gb3B0aW9ucy5mcmFtZUNvdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZyYW1lQ291bnQgOiAodGhpcy5udW1iZXJPZkZyYW1lcyAtIGZyYW1lT2Zmc2V0KTtcbiAgICAgICAgaWYgKGNvcHlGcmFtZUNvdW50ID4gKHRoaXMubnVtYmVyT2ZGcmFtZXMgLSBmcmFtZU9mZnNldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdmcmFtZUNvdW50IG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzUGVyU2FtcGxlID0gZ2V0Qnl0ZXNQZXJTYW1wbGUoZGVzdEZvcm1hdCk7XG4gICAgICAgIGNvbnN0IGlzUGxhbmFyID0gZm9ybWF0SXNQbGFuYXIoZGVzdEZvcm1hdCk7XG4gICAgICAgIGlmIChpc1BsYW5hciAmJiBvcHRpb25zLnBsYW5lSW5kZXggPj0gdGhpcy5udW1iZXJPZkNoYW5uZWxzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncGxhbmVJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUGxhbmFyICYmIG9wdGlvbnMucGxhbmVJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3BsYW5lSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudENvdW50ID0gaXNQbGFuYXIgPyBjb3B5RnJhbWVDb3VudCA6IGNvcHlGcmFtZUNvdW50ICogdGhpcy5udW1iZXJPZkNoYW5uZWxzO1xuICAgICAgICByZXR1cm4gZWxlbWVudENvdW50ICogYnl0ZXNQZXJTYW1wbGU7XG4gICAgfVxuICAgIC8qKiBDb3BpZXMgdGhlIGF1ZGlvIHNhbXBsZSdzIGRhdGEgdG8gYW4gQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3IGFzIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gb3B0aW9ucy4gKi9cbiAgICBjb3B5VG8oZGVzdGluYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFpc0FsbG93U2hhcmVkQnVmZmVyU291cmNlKGRlc3RpbmF0aW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGVzdGluYXRpb24gbXVzdCBiZSBhbiBBcnJheUJ1ZmZlciBvciBhbiBBcnJheUJ1ZmZlciB2aWV3LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMucGxhbmVJbmRleCkgfHwgb3B0aW9ucy5wbGFuZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGxhbmVJbmRleCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgIUFVRElPX1NBTVBMRV9GT1JNQVRTLmhhcyhvcHRpb25zLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZm9ybWF0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZyYW1lT2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMuZnJhbWVPZmZzZXQpIHx8IG9wdGlvbnMuZnJhbWVPZmZzZXQgPCAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZnJhbWVPZmZzZXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZyYW1lQ291bnQgIT09IHVuZGVmaW5lZCAmJiAoIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5mcmFtZUNvdW50KSB8fCBvcHRpb25zLmZyYW1lQ291bnQgPCAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZnJhbWVDb3VudCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdWRpb1NhbXBsZSBpcyBjbG9zZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwbGFuZUluZGV4LCBmb3JtYXQsIGZyYW1lQ291bnQ6IG9wdEZyYW1lQ291bnQsIGZyYW1lT2Zmc2V0OiBvcHRGcmFtZU9mZnNldCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgZGVzdEZvcm1hdCA9IGZvcm1hdCA/PyB0aGlzLmZvcm1hdDtcbiAgICAgICAgaWYgKCFkZXN0Rm9ybWF0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZXN0aW5hdGlvbiBmb3JtYXQgbm90IGRldGVybWluZWQnKTtcbiAgICAgICAgY29uc3QgbnVtRnJhbWVzID0gdGhpcy5udW1iZXJPZkZyYW1lcztcbiAgICAgICAgY29uc3QgbnVtQ2hhbm5lbHMgPSB0aGlzLm51bWJlck9mQ2hhbm5lbHM7XG4gICAgICAgIGNvbnN0IGZyYW1lT2Zmc2V0ID0gb3B0RnJhbWVPZmZzZXQgPz8gMDtcbiAgICAgICAgaWYgKGZyYW1lT2Zmc2V0ID49IG51bUZyYW1lcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2ZyYW1lT2Zmc2V0IG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvcHlGcmFtZUNvdW50ID0gb3B0RnJhbWVDb3VudCAhPT0gdW5kZWZpbmVkID8gb3B0RnJhbWVDb3VudCA6IChudW1GcmFtZXMgLSBmcmFtZU9mZnNldCk7XG4gICAgICAgIGlmIChjb3B5RnJhbWVDb3VudCA+IChudW1GcmFtZXMgLSBmcmFtZU9mZnNldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdmcmFtZUNvdW50IG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlc3RCeXRlc1BlclNhbXBsZSA9IGdldEJ5dGVzUGVyU2FtcGxlKGRlc3RGb3JtYXQpO1xuICAgICAgICBjb25zdCBkZXN0SXNQbGFuYXIgPSBmb3JtYXRJc1BsYW5hcihkZXN0Rm9ybWF0KTtcbiAgICAgICAgaWYgKGRlc3RJc1BsYW5hciAmJiBwbGFuZUluZGV4ID49IG51bUNoYW5uZWxzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncGxhbmVJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlc3RJc1BsYW5hciAmJiBwbGFuZUluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncGxhbmVJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXN0RWxlbWVudENvdW50ID0gZGVzdElzUGxhbmFyID8gY29weUZyYW1lQ291bnQgOiBjb3B5RnJhbWVDb3VudCAqIG51bUNoYW5uZWxzO1xuICAgICAgICBjb25zdCByZXF1aXJlZFNpemUgPSBkZXN0RWxlbWVudENvdW50ICogZGVzdEJ5dGVzUGVyU2FtcGxlO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24uYnl0ZUxlbmd0aCA8IHJlcXVpcmVkU2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0Rlc3RpbmF0aW9uIGJ1ZmZlciBpcyB0b28gc21hbGwnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXN0VmlldyA9IHRvRGF0YVZpZXcoZGVzdGluYXRpb24pO1xuICAgICAgICBjb25zdCB3cml0ZUZuID0gZ2V0V3JpdGVGdW5jdGlvbihkZXN0Rm9ybWF0KTtcbiAgICAgICAgaWYgKGlzQXVkaW9EYXRhKHRoaXMuX2RhdGEpKSB7XG4gICAgICAgICAgICBpZiAoZGVzdElzUGxhbmFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlc3RGb3JtYXQgPT09ICdmMzItcGxhbmFyJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbGUsIHNpbmNlIHRoZSBicm93c2VyIG11c3Qgc3VwcG9ydCBmMzItcGxhbmFyLCB3ZSBjYW4ganVzdCBkZWxlZ2F0ZSBoZXJlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEuY29weVRvKGRlc3RpbmF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFuZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZUNvdW50OiBjb3B5RnJhbWVDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ2YzMi1wbGFuYXInLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbG9jYXRlIHRlbXBvcmFyeSBidWZmZXIgZm9yIGYzMi1wbGFuYXIgZGF0YVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGNvcHlGcmFtZUNvdW50ICogNCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkodGVtcEJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEuY29weVRvKHRlbXBBcnJheSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhbmVJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVDb3VudDogY29weUZyYW1lQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdmMzItcGxhbmFyJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgZWFjaCBmMzIgc2FtcGxlIHRvIGRlc3RpbmF0aW9uIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wVmlldyA9IG5ldyBEYXRhVmlldyh0ZW1wQnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3B5RnJhbWVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXN0T2Zmc2V0ID0gaSAqIGRlc3RCeXRlc1BlclNhbXBsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNhbXBsZSA9IHRlbXBWaWV3LmdldEZsb2F0MzIoaSAqIDQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVGbihkZXN0VmlldywgZGVzdE9mZnNldCwgc2FtcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERlc3RpbmF0aW9uIGlzIGludGVybGVhdmVkLlxuICAgICAgICAgICAgICAgIC8vIEFsbG9jYXRlIGEgdGVtcG9yYXJ5IEZsb2F0MzJBcnJheSB0byBob2xkIG9uZSBjaGFubmVsJ3Mgd29ydGggb2YgZGF0YS5cbiAgICAgICAgICAgICAgICBjb25zdCBudW1DaCA9IG51bUNoYW5uZWxzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBuZXcgRmxvYXQzMkFycmF5KGNvcHlGcmFtZUNvdW50KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjaCA9IDA7IGNoIDwgbnVtQ2g7IGNoKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YS5jb3B5VG8odGVtcCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhbmVJbmRleDogY2gsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lQ291bnQ6IGNvcHlGcmFtZUNvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnZjMyLXBsYW5hcicsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvcHlGcmFtZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RJbmRleCA9IGkgKiBudW1DaCArIGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdE9mZnNldCA9IGRlc3RJbmRleCAqIGRlc3RCeXRlc1BlclNhbXBsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlRm4oZGVzdFZpZXcsIGRlc3RPZmZzZXQsIHRlbXBbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQnJhbmNoIGZvciBVaW50OEFycmF5IGRhdGEgKG5vbi1BdWRpb0RhdGEpXG4gICAgICAgICAgICBjb25zdCB1aW50OERhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICAgICAgY29uc3Qgc3JjVmlldyA9IG5ldyBEYXRhVmlldyh1aW50OERhdGEuYnVmZmVyLCB1aW50OERhdGEuYnl0ZU9mZnNldCwgdWludDhEYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3Qgc3JjRm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG4gICAgICAgICAgICBjb25zdCByZWFkRm4gPSBnZXRSZWFkRnVuY3Rpb24oc3JjRm9ybWF0KTtcbiAgICAgICAgICAgIGNvbnN0IHNyY0J5dGVzUGVyU2FtcGxlID0gZ2V0Qnl0ZXNQZXJTYW1wbGUoc3JjRm9ybWF0KTtcbiAgICAgICAgICAgIGNvbnN0IHNyY0lzUGxhbmFyID0gZm9ybWF0SXNQbGFuYXIoc3JjRm9ybWF0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29weUZyYW1lQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChkZXN0SXNQbGFuYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdE9mZnNldCA9IGkgKiBkZXN0Qnl0ZXNQZXJTYW1wbGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcmNPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNJc1BsYW5hcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjT2Zmc2V0ID0gKHBsYW5lSW5kZXggKiBudW1GcmFtZXMgKyAoaSArIGZyYW1lT2Zmc2V0KSkgKiBzcmNCeXRlc1BlclNhbXBsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY09mZnNldCA9ICgoKGkgKyBmcmFtZU9mZnNldCkgKiBudW1DaGFubmVscykgKyBwbGFuZUluZGV4KSAqIHNyY0J5dGVzUGVyU2FtcGxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSByZWFkRm4oc3JjVmlldywgc3JjT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVGbihkZXN0VmlldywgZGVzdE9mZnNldCwgbm9ybWFsaXplZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjaCA9IDA7IGNoIDwgbnVtQ2hhbm5lbHM7IGNoKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RJbmRleCA9IGkgKiBudW1DaGFubmVscyArIGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdE9mZnNldCA9IGRlc3RJbmRleCAqIGRlc3RCeXRlc1BlclNhbXBsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcmNPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3JjSXNQbGFuYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNPZmZzZXQgPSAoY2ggKiBudW1GcmFtZXMgKyAoaSArIGZyYW1lT2Zmc2V0KSkgKiBzcmNCeXRlc1BlclNhbXBsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY09mZnNldCA9ICgoKGkgKyBmcmFtZU9mZnNldCkgKiBudW1DaGFubmVscykgKyBjaCkgKiBzcmNCeXRlc1BlclNhbXBsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSByZWFkRm4oc3JjVmlldywgc3JjT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlRm4oZGVzdFZpZXcsIGRlc3RPZmZzZXQsIG5vcm1hbGl6ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBDbG9uZXMgdGhpcyBhdWRpbyBzYW1wbGUuICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXVkaW9TYW1wbGUgaXMgY2xvc2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0F1ZGlvRGF0YSh0aGlzLl9kYXRhKSkge1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlID0gbmV3IEF1ZGlvU2FtcGxlKHRoaXMuX2RhdGEuY2xvbmUoKSk7XG4gICAgICAgICAgICBzYW1wbGUuc2V0VGltZXN0YW1wKHRoaXMudGltZXN0YW1wKTsgLy8gTWFrZSBzdXJlIHRoZSB0aW1lc3RhbXAgaXMgcHJlY2lzZSAoYmV5b25kIG1pY3Jvc2Vjb25kIGFjY3VyYWN5KVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXVkaW9TYW1wbGUoe1xuICAgICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5mb3JtYXQsXG4gICAgICAgICAgICAgICAgc2FtcGxlUmF0ZTogdGhpcy5zYW1wbGVSYXRlLFxuICAgICAgICAgICAgICAgIG51bWJlck9mRnJhbWVzOiB0aGlzLm51bWJlck9mRnJhbWVzLFxuICAgICAgICAgICAgICAgIG51bWJlck9mQ2hhbm5lbHM6IHRoaXMubnVtYmVyT2ZDaGFubmVscyxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuX2RhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhpcyBhdWRpbyBzYW1wbGUsIHJlbGVhc2luZyBoZWxkIHJlc291cmNlcy4gQXVkaW8gc2FtcGxlcyBzaG91bGQgYmUgY2xvc2VkIGFzIHNvb24gYXMgdGhleSBhcmUgbm90XG4gICAgICogbmVlZGVkIGFueW1vcmUuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBdWRpb0RhdGEodGhpcy5fZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIGF1ZGlvIHNhbXBsZSB0byBhbiBBdWRpb0RhdGEgZm9yIHVzZSB3aXRoIHRoZSBXZWJDb2RlY3MgQVBJLiBUaGUgQXVkaW9EYXRhIHJldHVybmVkIGJ5IHRoaXNcbiAgICAgKiBtZXRob2QgKm11c3QqIGJlIGNsb3NlZCBzZXBhcmF0ZWx5IGZyb20gdGhpcyBhdWRpbyBzYW1wbGUuXG4gICAgICovXG4gICAgdG9BdWRpb0RhdGEoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXVkaW9TYW1wbGUgaXMgY2xvc2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0F1ZGlvRGF0YSh0aGlzLl9kYXRhKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RhdGEudGltZXN0YW1wID09PSB0aGlzLm1pY3Jvc2Vjb25kVGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgLy8gVGltZXN0YW1wIG1hdGNoZXMsIGxldCdzIGp1c3QgcmV0dXJuIHRoZSBkYXRhIChidXQgY2xvbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGltcG9zc2libGUgdG8gc2ltcGx5IGNoYW5nZSBhbiBBdWRpb0RhdGEncyB0aW1lc3RhbXAsIHNvIHdlJ2xsIG5lZWQgdG8gY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXRJc1BsYW5hcih0aGlzLmZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuYWxsb2NhdGlvblNpemUoeyBwbGFuZUluZGV4OiAwLCBmb3JtYXQ6IHRoaXMuZm9ybWF0IH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbmV3IEFycmF5QnVmZmVyKHNpemUgKiB0aGlzLm51bWJlck9mQ2hhbm5lbHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnb3R0YSByZWFkIG91dCBlYWNoIHBsYW5lIGluZGl2aWR1YWxseVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtYmVyT2ZDaGFubmVsczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcHlUbyhuZXcgVWludDhBcnJheShkYXRhLCBpICogc2l6ZSwgc2l6ZSksIHsgcGxhbmVJbmRleDogaSwgZm9ybWF0OiB0aGlzLmZvcm1hdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEF1ZGlvRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuZm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlUmF0ZTogdGhpcy5zYW1wbGVSYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZGcmFtZXM6IHRoaXMubnVtYmVyT2ZGcmFtZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJPZkNoYW5uZWxzOiB0aGlzLm51bWJlck9mQ2hhbm5lbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMubWljcm9zZWNvbmRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5hbGxvY2F0aW9uU2l6ZSh7IHBsYW5lSW5kZXg6IDAsIGZvcm1hdDogdGhpcy5mb3JtYXQgfSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcHlUbyhkYXRhLCB7IHBsYW5lSW5kZXg6IDAsIGZvcm1hdDogdGhpcy5mb3JtYXQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXVkaW9EYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5mb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVSYXRlOiB0aGlzLnNhbXBsZVJhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJPZkZyYW1lczogdGhpcy5udW1iZXJPZkZyYW1lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlck9mQ2hhbm5lbHM6IHRoaXMubnVtYmVyT2ZDaGFubmVscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdGhpcy5taWNyb3NlY29uZFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXVkaW9EYXRhKHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuZm9ybWF0LFxuICAgICAgICAgICAgICAgIHNhbXBsZVJhdGU6IHRoaXMuc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgICAgICBudW1iZXJPZkZyYW1lczogdGhpcy5udW1iZXJPZkZyYW1lcyxcbiAgICAgICAgICAgICAgICBudW1iZXJPZkNoYW5uZWxzOiB0aGlzLm51bWJlck9mQ2hhbm5lbHMsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aGlzLm1pY3Jvc2Vjb25kVGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuX2RhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQ29udmVydCB0aGlzIGF1ZGlvIHNhbXBsZSB0byBhbiBBdWRpb0J1ZmZlciBmb3IgdXNlIHdpdGggdGhlIFdlYiBBdWRpbyBBUEkuICovXG4gICAgdG9BdWRpb0J1ZmZlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdWRpb1NhbXBsZSBpcyBjbG9zZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXVkaW9CdWZmZXIgPSBuZXcgQXVkaW9CdWZmZXIoe1xuICAgICAgICAgICAgbnVtYmVyT2ZDaGFubmVsczogdGhpcy5udW1iZXJPZkNoYW5uZWxzLFxuICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLm51bWJlck9mRnJhbWVzLFxuICAgICAgICAgICAgc2FtcGxlUmF0ZTogdGhpcy5zYW1wbGVSYXRlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGF0YUJ5dGVzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmFsbG9jYXRpb25TaXplKHsgcGxhbmVJbmRleDogMCwgZm9ybWF0OiAnZjMyLXBsYW5hcicgfSkgLyA0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bWJlck9mQ2hhbm5lbHM7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jb3B5VG8oZGF0YUJ5dGVzLCB7IHBsYW5lSW5kZXg6IGksIGZvcm1hdDogJ2YzMi1wbGFuYXInIH0pO1xuICAgICAgICAgICAgYXVkaW9CdWZmZXIuY29weVRvQ2hhbm5lbChkYXRhQnl0ZXMsIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdWRpb0J1ZmZlcjtcbiAgICB9XG4gICAgLyoqIFNldHMgdGhlIHByZXNlbnRhdGlvbiB0aW1lc3RhbXAgb2YgdGhpcyBhdWRpbyBzYW1wbGUsIGluIHNlY29uZHMuICovXG4gICAgc2V0VGltZXN0YW1wKG5ld1RpbWVzdGFtcCkge1xuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShuZXdUaW1lc3RhbXApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduZXdUaW1lc3RhbXAgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gbmV3VGltZXN0YW1wO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljICpfZnJvbUF1ZGlvQnVmZmVyKGF1ZGlvQnVmZmVyLCB0aW1lc3RhbXApIHtcbiAgICAgICAgaWYgKCEoYXVkaW9CdWZmZXIgaW5zdGFuY2VvZiBBdWRpb0J1ZmZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F1ZGlvQnVmZmVyIG11c3QgYmUgYW4gQXVkaW9CdWZmZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgTUFYX0ZMT0FUX0NPVU5UID0gNDgwMDAgKiA1OyAvLyA1IHNlY29uZHMgb2YgbW9ubyA0OCBrSHogYXVkaW8gcGVyIHNhbXBsZVxuICAgICAgICBjb25zdCBudW1iZXJPZkNoYW5uZWxzID0gYXVkaW9CdWZmZXIubnVtYmVyT2ZDaGFubmVscztcbiAgICAgICAgY29uc3Qgc2FtcGxlUmF0ZSA9IGF1ZGlvQnVmZmVyLnNhbXBsZVJhdGU7XG4gICAgICAgIGNvbnN0IHRvdGFsRnJhbWVzID0gYXVkaW9CdWZmZXIubGVuZ3RoO1xuICAgICAgICBjb25zdCBtYXhGcmFtZXNQZXJDaHVuayA9IE1hdGguZmxvb3IoTUFYX0ZMT0FUX0NPVU5UIC8gbnVtYmVyT2ZDaGFubmVscyk7XG4gICAgICAgIGxldCBjdXJyZW50UmVsYXRpdmVGcmFtZSA9IDA7XG4gICAgICAgIGxldCByZW1haW5pbmdGcmFtZXMgPSB0b3RhbEZyYW1lcztcbiAgICAgICAgLy8gQ3JlYXRlIEF1ZGlvU2FtcGxlcyBpbiBhIGNodW5rZWQgZmFzaGlvbiBzbyB3ZSBkb24ndCBjcmVhdGUgaHVnZSBGbG9hdDMyQXJyYXlzXG4gICAgICAgIHdoaWxlIChyZW1haW5pbmdGcmFtZXMgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZXNUb0NvcHkgPSBNYXRoLm1pbihtYXhGcmFtZXNQZXJDaHVuaywgcmVtYWluaW5nRnJhbWVzKTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkobnVtYmVyT2ZDaGFubmVscyAqIGZyYW1lc1RvQ29weSk7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGFubmVsID0gMDsgY2hhbm5lbCA8IG51bWJlck9mQ2hhbm5lbHM7IGNoYW5uZWwrKykge1xuICAgICAgICAgICAgICAgIGF1ZGlvQnVmZmVyLmNvcHlGcm9tQ2hhbm5lbChjaHVua0RhdGEuc3ViYXJyYXkoY2hhbm5lbCAqIGZyYW1lc1RvQ29weSwgKGNoYW5uZWwgKyAxKSAqIGZyYW1lc1RvQ29weSksIGNoYW5uZWwsIGN1cnJlbnRSZWxhdGl2ZUZyYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIG5ldyBBdWRpb1NhbXBsZSh7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnZjMyLXBsYW5hcicsXG4gICAgICAgICAgICAgICAgc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgICAgICBudW1iZXJPZkZyYW1lczogZnJhbWVzVG9Db3B5LFxuICAgICAgICAgICAgICAgIG51bWJlck9mQ2hhbm5lbHMsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAgKyBjdXJyZW50UmVsYXRpdmVGcmFtZSAvIHNhbXBsZVJhdGUsXG4gICAgICAgICAgICAgICAgZGF0YTogY2h1bmtEYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50UmVsYXRpdmVGcmFtZSArPSBmcmFtZXNUb0NvcHk7XG4gICAgICAgICAgICByZW1haW5pbmdGcmFtZXMgLT0gZnJhbWVzVG9Db3B5O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgQXVkaW9TYW1wbGVzIGZyb20gYW4gQXVkaW9CdWZmZXIsIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiB0aW1lc3RhbXAgaW4gc2Vjb25kcy4gVHlwaWNhbGx5IGNyZWF0ZXMgZXhhY3RseVxuICAgICAqIG9uZSBzYW1wbGUsIGJ1dCBtYXkgY3JlYXRlIG11bHRpcGxlIGlmIHRoZSBBdWRpb0J1ZmZlciBpcyBleGNlZWRpbmdseSBsYXJnZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUF1ZGlvQnVmZmVyKGF1ZGlvQnVmZmVyLCB0aW1lc3RhbXApIHtcbiAgICAgICAgaWYgKCEoYXVkaW9CdWZmZXIgaW5zdGFuY2VvZiBBdWRpb0J1ZmZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F1ZGlvQnVmZmVyIG11c3QgYmUgYW4gQXVkaW9CdWZmZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgTUFYX0ZMT0FUX0NPVU5UID0gNDgwMDAgKiA1OyAvLyA1IHNlY29uZHMgb2YgbW9ubyA0OCBrSHogYXVkaW8gcGVyIHNhbXBsZVxuICAgICAgICBjb25zdCBudW1iZXJPZkNoYW5uZWxzID0gYXVkaW9CdWZmZXIubnVtYmVyT2ZDaGFubmVscztcbiAgICAgICAgY29uc3Qgc2FtcGxlUmF0ZSA9IGF1ZGlvQnVmZmVyLnNhbXBsZVJhdGU7XG4gICAgICAgIGNvbnN0IHRvdGFsRnJhbWVzID0gYXVkaW9CdWZmZXIubGVuZ3RoO1xuICAgICAgICBjb25zdCBtYXhGcmFtZXNQZXJDaHVuayA9IE1hdGguZmxvb3IoTUFYX0ZMT0FUX0NPVU5UIC8gbnVtYmVyT2ZDaGFubmVscyk7XG4gICAgICAgIGxldCBjdXJyZW50UmVsYXRpdmVGcmFtZSA9IDA7XG4gICAgICAgIGxldCByZW1haW5pbmdGcmFtZXMgPSB0b3RhbEZyYW1lcztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIC8vIENyZWF0ZSBBdWRpb1NhbXBsZXMgaW4gYSBjaHVua2VkIGZhc2hpb24gc28gd2UgZG9uJ3QgY3JlYXRlIGh1Z2UgRmxvYXQzMkFycmF5c1xuICAgICAgICB3aGlsZSAocmVtYWluaW5nRnJhbWVzID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZnJhbWVzVG9Db3B5ID0gTWF0aC5taW4obWF4RnJhbWVzUGVyQ2h1bmssIHJlbWFpbmluZ0ZyYW1lcyk7XG4gICAgICAgICAgICBjb25zdCBjaHVua0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KG51bWJlck9mQ2hhbm5lbHMgKiBmcmFtZXNUb0NvcHkpO1xuICAgICAgICAgICAgZm9yIChsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBudW1iZXJPZkNoYW5uZWxzOyBjaGFubmVsKyspIHtcbiAgICAgICAgICAgICAgICBhdWRpb0J1ZmZlci5jb3B5RnJvbUNoYW5uZWwoY2h1bmtEYXRhLnN1YmFycmF5KGNoYW5uZWwgKiBmcmFtZXNUb0NvcHksIChjaGFubmVsICsgMSkgKiBmcmFtZXNUb0NvcHkpLCBjaGFubmVsLCBjdXJyZW50UmVsYXRpdmVGcmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdWRpb1NhbXBsZSA9IG5ldyBBdWRpb1NhbXBsZSh7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnZjMyLXBsYW5hcicsXG4gICAgICAgICAgICAgICAgc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgICAgICBudW1iZXJPZkZyYW1lczogZnJhbWVzVG9Db3B5LFxuICAgICAgICAgICAgICAgIG51bWJlck9mQ2hhbm5lbHMsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAgKyBjdXJyZW50UmVsYXRpdmVGcmFtZSAvIHNhbXBsZVJhdGUsXG4gICAgICAgICAgICAgICAgZGF0YTogY2h1bmtEYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhdWRpb1NhbXBsZSk7XG4gICAgICAgICAgICBjdXJyZW50UmVsYXRpdmVGcmFtZSArPSBmcmFtZXNUb0NvcHk7XG4gICAgICAgICAgICByZW1haW5pbmdGcmFtZXMgLT0gZnJhbWVzVG9Db3B5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuY29uc3QgZ2V0Qnl0ZXNQZXJTYW1wbGUgPSAoZm9ybWF0KSA9PiB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgY2FzZSAndTgnOlxuICAgICAgICBjYXNlICd1OC1wbGFuYXInOlxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGNhc2UgJ3MxNic6XG4gICAgICAgIGNhc2UgJ3MxNi1wbGFuYXInOlxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIGNhc2UgJ3MzMic6XG4gICAgICAgIGNhc2UgJ3MzMi1wbGFuYXInOlxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIGNhc2UgJ2YzMic6XG4gICAgICAgIGNhc2UgJ2YzMi1wbGFuYXInOlxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gQXVkaW9TYW1wbGVGb3JtYXQnKTtcbiAgICB9XG59O1xuY29uc3QgZm9ybWF0SXNQbGFuYXIgPSAoZm9ybWF0KSA9PiB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgY2FzZSAndTgtcGxhbmFyJzpcbiAgICAgICAgY2FzZSAnczE2LXBsYW5hcic6XG4gICAgICAgIGNhc2UgJ3MzMi1wbGFuYXInOlxuICAgICAgICBjYXNlICdmMzItcGxhbmFyJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5jb25zdCBnZXRSZWFkRnVuY3Rpb24gPSAoZm9ybWF0KSA9PiB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgY2FzZSAndTgnOlxuICAgICAgICBjYXNlICd1OC1wbGFuYXInOlxuICAgICAgICAgICAgcmV0dXJuICh2aWV3LCBvZmZzZXQpID0+ICh2aWV3LmdldFVpbnQ4KG9mZnNldCkgLSAxMjgpIC8gMTI4O1xuICAgICAgICBjYXNlICdzMTYnOlxuICAgICAgICBjYXNlICdzMTYtcGxhbmFyJzpcbiAgICAgICAgICAgIHJldHVybiAodmlldywgb2Zmc2V0KSA9PiB2aWV3LmdldEludDE2KG9mZnNldCwgdHJ1ZSkgLyAzMjc2ODtcbiAgICAgICAgY2FzZSAnczMyJzpcbiAgICAgICAgY2FzZSAnczMyLXBsYW5hcic6XG4gICAgICAgICAgICByZXR1cm4gKHZpZXcsIG9mZnNldCkgPT4gdmlldy5nZXRJbnQzMihvZmZzZXQsIHRydWUpIC8gMjE0NzQ4MzY0ODtcbiAgICAgICAgY2FzZSAnZjMyJzpcbiAgICAgICAgY2FzZSAnZjMyLXBsYW5hcic6XG4gICAgICAgICAgICByZXR1cm4gKHZpZXcsIG9mZnNldCkgPT4gdmlldy5nZXRGbG9hdDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgfVxufTtcbmNvbnN0IGdldFdyaXRlRnVuY3Rpb24gPSAoZm9ybWF0KSA9PiB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgY2FzZSAndTgnOlxuICAgICAgICBjYXNlICd1OC1wbGFuYXInOlxuICAgICAgICAgICAgcmV0dXJuICh2aWV3LCBvZmZzZXQsIHZhbHVlKSA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCwgY2xhbXAoKHZhbHVlICsgMSkgKiAxMjcuNSwgMCwgMjU1KSk7XG4gICAgICAgIGNhc2UgJ3MxNic6XG4gICAgICAgIGNhc2UgJ3MxNi1wbGFuYXInOlxuICAgICAgICAgICAgcmV0dXJuICh2aWV3LCBvZmZzZXQsIHZhbHVlKSA9PiB2aWV3LnNldEludDE2KG9mZnNldCwgY2xhbXAoTWF0aC5yb3VuZCh2YWx1ZSAqIDMyNzY3KSwgLTMyNzY4LCAzMjc2NyksIHRydWUpO1xuICAgICAgICBjYXNlICdzMzInOlxuICAgICAgICBjYXNlICdzMzItcGxhbmFyJzpcbiAgICAgICAgICAgIHJldHVybiAodmlldywgb2Zmc2V0LCB2YWx1ZSkgPT4gdmlldy5zZXRJbnQzMihvZmZzZXQsIGNsYW1wKE1hdGgucm91bmQodmFsdWUgKiAyMTQ3NDgzNjQ3KSwgLTIxNDc0ODM2NDgsIDIxNDc0ODM2NDcpLCB0cnVlKTtcbiAgICAgICAgY2FzZSAnZjMyJzpcbiAgICAgICAgY2FzZSAnZjMyLXBsYW5hcic6XG4gICAgICAgICAgICByZXR1cm4gKHZpZXcsIG9mZnNldCwgdmFsdWUpID0+IHZpZXcuc2V0RmxvYXQzMihvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICB9XG59O1xuY29uc3QgaXNBdWRpb0RhdGEgPSAoeCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgQXVkaW9EYXRhICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgQXVkaW9EYXRhO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/sample.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/subtitles.js":
/*!***************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/subtitles.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SubtitleParser: () => (/* binding */ SubtitleParser),\n/* harmony export */   formatSubtitleTimestamp: () => (/* binding */ formatSubtitleTimestamp),\n/* harmony export */   inlineTimestampRegex: () => (/* binding */ inlineTimestampRegex),\n/* harmony export */   parseSubtitleTimestamp: () => (/* binding */ parseSubtitleTimestamp)\n/* harmony export */ });\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nconst cueBlockHeaderRegex = /(?:(.+?)\\n)?((?:\\d{2}:)?\\d{2}:\\d{2}.\\d{3})\\s+-->\\s+((?:\\d{2}:)?\\d{2}:\\d{2}.\\d{3})/g;\nconst preambleStartRegex = /^WEBVTT(.|\\n)*?\\n{2}/;\nconst inlineTimestampRegex = /<(?:(\\d{2}):)?(\\d{2}):(\\d{2}).(\\d{3})>/g;\nclass SubtitleParser {\n    constructor(options) {\n        this.preambleText = null;\n        this.preambleEmitted = false;\n        this.options = options;\n    }\n    parse(text) {\n        text = text.replaceAll('\\r\\n', '\\n').replaceAll('\\r', '\\n');\n        cueBlockHeaderRegex.lastIndex = 0;\n        let match;\n        if (!this.preambleText) {\n            if (!preambleStartRegex.test(text)) {\n                throw new Error('WebVTT preamble incorrect.');\n            }\n            match = cueBlockHeaderRegex.exec(text);\n            const preamble = text.slice(0, match?.index ?? text.length).trimEnd();\n            if (!preamble) {\n                throw new Error('No WebVTT preamble provided.');\n            }\n            this.preambleText = preamble;\n            if (match) {\n                text = text.slice(match.index);\n                cueBlockHeaderRegex.lastIndex = 0;\n            }\n        }\n        while ((match = cueBlockHeaderRegex.exec(text))) {\n            const notes = text.slice(0, match.index);\n            const cueIdentifier = match[1];\n            const matchEnd = match.index + match[0].length;\n            const bodyStart = text.indexOf('\\n', matchEnd) + 1;\n            const cueSettings = text.slice(matchEnd, bodyStart).trim();\n            let bodyEnd = text.indexOf('\\n\\n', matchEnd);\n            if (bodyEnd === -1)\n                bodyEnd = text.length;\n            const startTime = parseSubtitleTimestamp(match[2]);\n            const endTime = parseSubtitleTimestamp(match[3]);\n            const duration = endTime - startTime;\n            const body = text.slice(bodyStart, bodyEnd).trim();\n            text = text.slice(bodyEnd).trimStart();\n            cueBlockHeaderRegex.lastIndex = 0;\n            const cue = {\n                timestamp: startTime / 1000,\n                duration: duration / 1000,\n                text: body,\n                identifier: cueIdentifier,\n                settings: cueSettings,\n                notes,\n            };\n            const meta = {};\n            if (!this.preambleEmitted) {\n                meta.config = {\n                    description: this.preambleText,\n                };\n                this.preambleEmitted = true;\n            }\n            this.options.output(cue, meta);\n        }\n    }\n}\nconst timestampRegex = /(?:(\\d{2}):)?(\\d{2}):(\\d{2}).(\\d{3})/;\nconst parseSubtitleTimestamp = (string) => {\n    const match = timestampRegex.exec(string);\n    if (!match)\n        throw new Error('Expected match.');\n    return 60 * 60 * 1000 * Number(match[1] || '0')\n        + 60 * 1000 * Number(match[2])\n        + 1000 * Number(match[3])\n        + Number(match[4]);\n};\nconst formatSubtitleTimestamp = (timestamp) => {\n    const hours = Math.floor(timestamp / (60 * 60 * 1000));\n    const minutes = Math.floor((timestamp % (60 * 60 * 1000)) / (60 * 1000));\n    const seconds = Math.floor((timestamp % (60 * 1000)) / 1000);\n    const milliseconds = timestamp % 1000;\n    return hours.toString().padStart(2, '0') + ':'\n        + minutes.toString().padStart(2, '0') + ':'\n        + seconds.toString().padStart(2, '0') + '.'\n        + milliseconds.toString().padStart(3, '0');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL3N1YnRpdGxlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxpQkFBaUIsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtBQUM3Ryw4Q0FBOEMsRUFBRTtBQUN6QyxzQ0FBc0MsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRTtBQUNsRTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUU7QUFDcEQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRjaC1jdXQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL21lZGlhYnVubnkvZGlzdC9tb2R1bGVzL3NyYy9zdWJ0aXRsZXMuanM/NDJlNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAyNS1wcmVzZW50LCBWYW5pbGFneSBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmNvbnN0IGN1ZUJsb2NrSGVhZGVyUmVnZXggPSAvKD86KC4rPylcXG4pPygoPzpcXGR7Mn06KT9cXGR7Mn06XFxkezJ9LlxcZHszfSlcXHMrLS0+XFxzKygoPzpcXGR7Mn06KT9cXGR7Mn06XFxkezJ9LlxcZHszfSkvZztcbmNvbnN0IHByZWFtYmxlU3RhcnRSZWdleCA9IC9eV0VCVlRUKC58XFxuKSo/XFxuezJ9LztcbmV4cG9ydCBjb25zdCBpbmxpbmVUaW1lc3RhbXBSZWdleCA9IC88KD86KFxcZHsyfSk6KT8oXFxkezJ9KTooXFxkezJ9KS4oXFxkezN9KT4vZztcbmV4cG9ydCBjbGFzcyBTdWJ0aXRsZVBhcnNlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLnByZWFtYmxlVGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJlYW1ibGVFbWl0dGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHBhcnNlKHRleHQpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbCgnXFxyXFxuJywgJ1xcbicpLnJlcGxhY2VBbGwoJ1xccicsICdcXG4nKTtcbiAgICAgICAgY3VlQmxvY2tIZWFkZXJSZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIGlmICghdGhpcy5wcmVhbWJsZVRleHQpIHtcbiAgICAgICAgICAgIGlmICghcHJlYW1ibGVTdGFydFJlZ2V4LnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlZUVCBwcmVhbWJsZSBpbmNvcnJlY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaCA9IGN1ZUJsb2NrSGVhZGVyUmVnZXguZXhlYyh0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IHByZWFtYmxlID0gdGV4dC5zbGljZSgwLCBtYXRjaD8uaW5kZXggPz8gdGV4dC5sZW5ndGgpLnRyaW1FbmQoKTtcbiAgICAgICAgICAgIGlmICghcHJlYW1ibGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFdlYlZUVCBwcmVhbWJsZSBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJlYW1ibGVUZXh0ID0gcHJlYW1ibGU7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShtYXRjaC5pbmRleCk7XG4gICAgICAgICAgICAgICAgY3VlQmxvY2tIZWFkZXJSZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBjdWVCbG9ja0hlYWRlclJlZ2V4LmV4ZWModGV4dCkpKSB7XG4gICAgICAgICAgICBjb25zdCBub3RlcyA9IHRleHQuc2xpY2UoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgY3VlSWRlbnRpZmllciA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hFbmQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJvZHlTdGFydCA9IHRleHQuaW5kZXhPZignXFxuJywgbWF0Y2hFbmQpICsgMTtcbiAgICAgICAgICAgIGNvbnN0IGN1ZVNldHRpbmdzID0gdGV4dC5zbGljZShtYXRjaEVuZCwgYm9keVN0YXJ0KS50cmltKCk7XG4gICAgICAgICAgICBsZXQgYm9keUVuZCA9IHRleHQuaW5kZXhPZignXFxuXFxuJywgbWF0Y2hFbmQpO1xuICAgICAgICAgICAgaWYgKGJvZHlFbmQgPT09IC0xKVxuICAgICAgICAgICAgICAgIGJvZHlFbmQgPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBhcnNlU3VidGl0bGVUaW1lc3RhbXAobWF0Y2hbMl0pO1xuICAgICAgICAgICAgY29uc3QgZW5kVGltZSA9IHBhcnNlU3VidGl0bGVUaW1lc3RhbXAobWF0Y2hbM10pO1xuICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHRleHQuc2xpY2UoYm9keVN0YXJ0LCBib2R5RW5kKS50cmltKCk7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShib2R5RW5kKS50cmltU3RhcnQoKTtcbiAgICAgICAgICAgIGN1ZUJsb2NrSGVhZGVyUmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGN1ZSA9IHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHN0YXJ0VGltZSAvIDEwMDAsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uIC8gMTAwMCxcbiAgICAgICAgICAgICAgICB0ZXh0OiBib2R5LFxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGN1ZUlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IGN1ZVNldHRpbmdzLFxuICAgICAgICAgICAgICAgIG5vdGVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGEgPSB7fTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmVhbWJsZUVtaXR0ZWQpIHtcbiAgICAgICAgICAgICAgICBtZXRhLmNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHRoaXMucHJlYW1ibGVUZXh0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVhbWJsZUVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm91dHB1dChjdWUsIG1ldGEpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgdGltZXN0YW1wUmVnZXggPSAvKD86KFxcZHsyfSk6KT8oXFxkezJ9KTooXFxkezJ9KS4oXFxkezN9KS87XG5leHBvcnQgY29uc3QgcGFyc2VTdWJ0aXRsZVRpbWVzdGFtcCA9IChzdHJpbmcpID0+IHtcbiAgICBjb25zdCBtYXRjaCA9IHRpbWVzdGFtcFJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG1hdGNoLicpO1xuICAgIHJldHVybiA2MCAqIDYwICogMTAwMCAqIE51bWJlcihtYXRjaFsxXSB8fCAnMCcpXG4gICAgICAgICsgNjAgKiAxMDAwICogTnVtYmVyKG1hdGNoWzJdKVxuICAgICAgICArIDEwMDAgKiBOdW1iZXIobWF0Y2hbM10pXG4gICAgICAgICsgTnVtYmVyKG1hdGNoWzRdKTtcbn07XG5leHBvcnQgY29uc3QgZm9ybWF0U3VidGl0bGVUaW1lc3RhbXAgPSAodGltZXN0YW1wKSA9PiB7XG4gICAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKHRpbWVzdGFtcCAvICg2MCAqIDYwICogMTAwMCkpO1xuICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKCh0aW1lc3RhbXAgJSAoNjAgKiA2MCAqIDEwMDApKSAvICg2MCAqIDEwMDApKTtcbiAgICBjb25zdCBzZWNvbmRzID0gTWF0aC5mbG9vcigodGltZXN0YW1wICUgKDYwICogMTAwMCkpIC8gMTAwMCk7XG4gICAgY29uc3QgbWlsbGlzZWNvbmRzID0gdGltZXN0YW1wICUgMTAwMDtcbiAgICByZXR1cm4gaG91cnMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpICsgJzonXG4gICAgICAgICsgbWludXRlcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJykgKyAnOidcbiAgICAgICAgKyBzZWNvbmRzLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKSArICcuJ1xuICAgICAgICArIG1pbGxpc2Vjb25kcy50b1N0cmluZygpLnBhZFN0YXJ0KDMsICcwJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/subtitles.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/tags.js":
/*!**********************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/tags.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RichImageData: () => (/* binding */ RichImageData),\n/* harmony export */   metadataTagsAreEmpty: () => (/* binding */ metadataTagsAreEmpty),\n/* harmony export */   validateMetadataTags: () => (/* binding */ validateMetadataTags)\n/* harmony export */ });\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/**\n * Image data with additional metadata.\n *\n * @group Metadata tags\n * @public\n */\nclass RichImageData {\n    /** Creates a new {@link RichImageData}. */\n    constructor(\n    /** The raw image data. */\n    data, \n    /** An RFC 6838 MIME type (e.g. image/jpeg, image/png, etc.) */\n    mimeType) {\n        this.data = data;\n        this.mimeType = mimeType;\n    }\n}\nconst validateMetadataTags = (tags) => {\n    if (!tags || typeof tags !== 'object') {\n        throw new TypeError('tags must be an object.');\n    }\n    if (tags.title !== undefined && typeof tags.title !== 'string') {\n        throw new TypeError('tags.title, when provided, must be a string.');\n    }\n    if (tags.description !== undefined && typeof tags.description !== 'string') {\n        throw new TypeError('tags.description, when provided, must be a string.');\n    }\n    if (tags.artist !== undefined && typeof tags.artist !== 'string') {\n        throw new TypeError('tags.artist, when provided, must be a string.');\n    }\n    if (tags.album !== undefined && typeof tags.album !== 'string') {\n        throw new TypeError('tags.album, when provided, must be a string.');\n    }\n    if (tags.albumArtist !== undefined && typeof tags.albumArtist !== 'string') {\n        throw new TypeError('tags.albumArtist, when provided, must be a string.');\n    }\n    if (tags.trackNumber !== undefined && (!Number.isInteger(tags.trackNumber) || tags.trackNumber <= 0)) {\n        throw new TypeError('tags.trackNumber, when provided, must be a positive integer.');\n    }\n    if (tags.tracksTotal !== undefined\n        && (!Number.isInteger(tags.tracksTotal) || tags.tracksTotal <= 0)) {\n        throw new TypeError('tags.tracksTotal, when provided, must be a positive integer.');\n    }\n    if (tags.discNumber !== undefined && (!Number.isInteger(tags.discNumber) || tags.discNumber <= 0)) {\n        throw new TypeError('tags.discNumber, when provided, must be a positive integer.');\n    }\n    if (tags.discsTotal !== undefined\n        && (!Number.isInteger(tags.discsTotal) || tags.discsTotal <= 0)) {\n        throw new TypeError('tags.discsTotal, when provided, must be a positive integer.');\n    }\n    if (tags.genre !== undefined && typeof tags.genre !== 'string') {\n        throw new TypeError('tags.genre, when provided, must be a string.');\n    }\n    if (tags.date !== undefined && (!(tags.date instanceof Date) || Number.isNaN(tags.date.getTime()))) {\n        throw new TypeError('tags.date, when provided, must be a valid Date.');\n    }\n    if (tags.lyrics !== undefined && typeof tags.lyrics !== 'string') {\n        throw new TypeError('tags.lyrics, when provided, must be a string.');\n    }\n    if (tags.images !== undefined) {\n        if (!Array.isArray(tags.images)) {\n            throw new TypeError('tags.images, when provided, must be an array.');\n        }\n        for (const image of tags.images) {\n            if (!image || typeof image !== 'object') {\n                throw new TypeError('Each image in tags.images must be an object.');\n            }\n            if (!(image.data instanceof Uint8Array)) {\n                throw new TypeError('Each image.data must be a Uint8Array.');\n            }\n            if (typeof image.mimeType !== 'string') {\n                throw new TypeError('Each image.mimeType must be a string.');\n            }\n            if (!['coverFront', 'coverBack', 'unknown'].includes(image.kind)) {\n                throw new TypeError('Each image.kind must be \\'coverFront\\', \\'coverBack\\', or \\'unknown\\'.');\n            }\n        }\n    }\n    if (tags.comment !== undefined && typeof tags.comment !== 'string') {\n        throw new TypeError('tags.comment, when provided, must be a string.');\n    }\n    if (tags.raw !== undefined) {\n        if (!tags.raw || typeof tags.raw !== 'object') {\n            throw new TypeError('tags.raw, when provided, must be an object.');\n        }\n        for (const value of Object.values(tags.raw)) {\n            if (value !== null\n                && typeof value !== 'string'\n                && !(value instanceof Uint8Array)\n                && !(value instanceof RichImageData)) {\n                throw new TypeError('Each value in tags.raw must be a string, Uint8Array, RichImageData, or null.');\n            }\n        }\n    }\n};\nconst metadataTagsAreEmpty = (tags) => {\n    return tags.title === undefined\n        && tags.description === undefined\n        && tags.artist === undefined\n        && tags.album === undefined\n        && tags.albumArtist === undefined\n        && tags.trackNumber === undefined\n        && tags.tracksTotal === undefined\n        && tags.discNumber === undefined\n        && tags.discsTotal === undefined\n        && tags.genre === undefined\n        && tags.date === undefined\n        && tags.lyrics === undefined\n        && (!tags.images || tags.images.length === 0)\n        && tags.comment === undefined\n        && (tags.raw === undefined || Object.keys(tags.raw).length === 0);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL3RhZ3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGNoLWN1dC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL3RhZ3MuanM/MTVkYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAyNS1wcmVzZW50LCBWYW5pbGFneSBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbi8qKlxuICogSW1hZ2UgZGF0YSB3aXRoIGFkZGl0aW9uYWwgbWV0YWRhdGEuXG4gKlxuICogQGdyb3VwIE1ldGFkYXRhIHRhZ3NcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFJpY2hJbWFnZURhdGEge1xuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHtAbGluayBSaWNoSW1hZ2VEYXRhfS4gKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVGhlIHJhdyBpbWFnZSBkYXRhLiAqL1xuICAgIGRhdGEsIFxuICAgIC8qKiBBbiBSRkMgNjgzOCBNSU1FIHR5cGUgKGUuZy4gaW1hZ2UvanBlZywgaW1hZ2UvcG5nLCBldGMuKSAqL1xuICAgIG1pbWVUeXBlKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMubWltZVR5cGUgPSBtaW1lVHlwZTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgdmFsaWRhdGVNZXRhZGF0YVRhZ3MgPSAodGFncykgPT4ge1xuICAgIGlmICghdGFncyB8fCB0eXBlb2YgdGFncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFncyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICB9XG4gICAgaWYgKHRhZ3MudGl0bGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdGFncy50aXRsZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFncy50aXRsZSwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG4gICAgaWYgKHRhZ3MuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdGFncy5kZXNjcmlwdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFncy5kZXNjcmlwdGlvbiwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG4gICAgaWYgKHRhZ3MuYXJ0aXN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHRhZ3MuYXJ0aXN0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YWdzLmFydGlzdCwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG4gICAgaWYgKHRhZ3MuYWxidW0gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdGFncy5hbGJ1bSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFncy5hbGJ1bSwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG4gICAgaWYgKHRhZ3MuYWxidW1BcnRpc3QgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdGFncy5hbGJ1bUFydGlzdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFncy5hbGJ1bUFydGlzdCwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG4gICAgaWYgKHRhZ3MudHJhY2tOdW1iZXIgIT09IHVuZGVmaW5lZCAmJiAoIU51bWJlci5pc0ludGVnZXIodGFncy50cmFja051bWJlcikgfHwgdGFncy50cmFja051bWJlciA8PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YWdzLnRyYWNrTnVtYmVyLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4nKTtcbiAgICB9XG4gICAgaWYgKHRhZ3MudHJhY2tzVG90YWwgIT09IHVuZGVmaW5lZFxuICAgICAgICAmJiAoIU51bWJlci5pc0ludGVnZXIodGFncy50cmFja3NUb3RhbCkgfHwgdGFncy50cmFja3NUb3RhbCA8PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YWdzLnRyYWNrc1RvdGFsLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4nKTtcbiAgICB9XG4gICAgaWYgKHRhZ3MuZGlzY051bWJlciAhPT0gdW5kZWZpbmVkICYmICghTnVtYmVyLmlzSW50ZWdlcih0YWdzLmRpc2NOdW1iZXIpIHx8IHRhZ3MuZGlzY051bWJlciA8PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YWdzLmRpc2NOdW1iZXIsIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLicpO1xuICAgIH1cbiAgICBpZiAodGFncy5kaXNjc1RvdGFsICE9PSB1bmRlZmluZWRcbiAgICAgICAgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKHRhZ3MuZGlzY3NUb3RhbCkgfHwgdGFncy5kaXNjc1RvdGFsIDw9IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhZ3MuZGlzY3NUb3RhbCwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuJyk7XG4gICAgfVxuICAgIGlmICh0YWdzLmdlbnJlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHRhZ3MuZ2VucmUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhZ3MuZ2VucmUsIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgfVxuICAgIGlmICh0YWdzLmRhdGUgIT09IHVuZGVmaW5lZCAmJiAoISh0YWdzLmRhdGUgaW5zdGFuY2VvZiBEYXRlKSB8fCBOdW1iZXIuaXNOYU4odGFncy5kYXRlLmdldFRpbWUoKSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhZ3MuZGF0ZSwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhIHZhbGlkIERhdGUuJyk7XG4gICAgfVxuICAgIGlmICh0YWdzLmx5cmljcyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0YWdzLmx5cmljcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFncy5seXJpY3MsIHdoZW4gcHJvdmlkZWQsIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgfVxuICAgIGlmICh0YWdzLmltYWdlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWdzLmltYWdlcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhZ3MuaW1hZ2VzLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaW1hZ2Ugb2YgdGFncy5pbWFnZXMpIHtcbiAgICAgICAgICAgIGlmICghaW1hZ2UgfHwgdHlwZW9mIGltYWdlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VhY2ggaW1hZ2UgaW4gdGFncy5pbWFnZXMgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShpbWFnZS5kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFYWNoIGltYWdlLmRhdGEgbXVzdCBiZSBhIFVpbnQ4QXJyYXkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGltYWdlLm1pbWVUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VhY2ggaW1hZ2UubWltZVR5cGUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghWydjb3ZlckZyb250JywgJ2NvdmVyQmFjaycsICd1bmtub3duJ10uaW5jbHVkZXMoaW1hZ2Uua2luZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFYWNoIGltYWdlLmtpbmQgbXVzdCBiZSBcXCdjb3ZlckZyb250XFwnLCBcXCdjb3ZlckJhY2tcXCcsIG9yIFxcJ3Vua25vd25cXCcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ3MuY29tbWVudCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0YWdzLmNvbW1lbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhZ3MuY29tbWVudCwgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG4gICAgaWYgKHRhZ3MucmF3ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCF0YWdzLnJhdyB8fCB0eXBlb2YgdGFncy5yYXcgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YWdzLnJhdywgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBPYmplY3QudmFsdWVzKHRhZ3MucmF3KSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICYmICEodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgICAgICYmICEodmFsdWUgaW5zdGFuY2VvZiBSaWNoSW1hZ2VEYXRhKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VhY2ggdmFsdWUgaW4gdGFncy5yYXcgbXVzdCBiZSBhIHN0cmluZywgVWludDhBcnJheSwgUmljaEltYWdlRGF0YSwgb3IgbnVsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgbWV0YWRhdGFUYWdzQXJlRW1wdHkgPSAodGFncykgPT4ge1xuICAgIHJldHVybiB0YWdzLnRpdGxlID09PSB1bmRlZmluZWRcbiAgICAgICAgJiYgdGFncy5kZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgICYmIHRhZ3MuYXJ0aXN0ID09PSB1bmRlZmluZWRcbiAgICAgICAgJiYgdGFncy5hbGJ1bSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICYmIHRhZ3MuYWxidW1BcnRpc3QgPT09IHVuZGVmaW5lZFxuICAgICAgICAmJiB0YWdzLnRyYWNrTnVtYmVyID09PSB1bmRlZmluZWRcbiAgICAgICAgJiYgdGFncy50cmFja3NUb3RhbCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICYmIHRhZ3MuZGlzY051bWJlciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICYmIHRhZ3MuZGlzY3NUb3RhbCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICYmIHRhZ3MuZ2VucmUgPT09IHVuZGVmaW5lZFxuICAgICAgICAmJiB0YWdzLmRhdGUgPT09IHVuZGVmaW5lZFxuICAgICAgICAmJiB0YWdzLmx5cmljcyA9PT0gdW5kZWZpbmVkXG4gICAgICAgICYmICghdGFncy5pbWFnZXMgfHwgdGFncy5pbWFnZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAmJiB0YWdzLmNvbW1lbnQgPT09IHVuZGVmaW5lZFxuICAgICAgICAmJiAodGFncy5yYXcgPT09IHVuZGVmaW5lZCB8fCBPYmplY3Qua2V5cyh0YWdzLnJhdykubGVuZ3RoID09PSAwKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/tags.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/target.js":
/*!************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/target.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BufferTarget: () => (/* binding */ BufferTarget),\n/* harmony export */   NullTarget: () => (/* binding */ NullTarget),\n/* harmony export */   StreamTarget: () => (/* binding */ StreamTarget),\n/* harmony export */   Target: () => (/* binding */ Target)\n/* harmony export */ });\n/* harmony import */ var _writer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./writer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/writer.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n/**\n * Base class for targets, specifying where output files are written.\n * @group Output targets\n * @public\n */\nclass Target {\n    constructor() {\n        /** @internal */\n        this._output = null;\n        /**\n         * Called each time data is written to the target. Will be called with the byte range into which data was written.\n         *\n         * Use this callback to track the size of the output file as it grows. But be warned, this function is chatty and\n         * gets called *extremely* often.\n         */\n        this.onwrite = null;\n    }\n}\n/**\n * A target that writes data directly into an ArrayBuffer in memory. Great for performance, but not suitable for very\n * large files. The buffer will be available once the output has been finalized.\n * @group Output targets\n * @public\n */\nclass BufferTarget extends Target {\n    constructor() {\n        super(...arguments);\n        /** Stores the final output buffer. Until the output is finalized, this will be `null`. */\n        this.buffer = null;\n    }\n    /** @internal */\n    _createWriter() {\n        return new _writer_js__WEBPACK_IMPORTED_MODULE_0__.BufferTargetWriter(this);\n    }\n}\n/**\n * This target writes data to a [`WritableStream`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream),\n * making it a general-purpose target for writing data anywhere. It is also compatible with\n * [`FileSystemWritableFileStream`](https://developer.mozilla.org/en-US/docs/Web/API/FileSystemWritableFileStream) for\n * use with the [File System Access API](https://developer.mozilla.org/en-US/docs/Web/API/File_System_API). The\n * `WritableStream` can also apply backpressure, which will propagate to the output and throttle the encoders.\n * @group Output targets\n * @public\n */\nclass StreamTarget extends Target {\n    /** Creates a new {@link StreamTarget} which writes to the specified `writable`. */\n    constructor(writable, options = {}) {\n        super();\n        if (!(writable instanceof WritableStream)) {\n            throw new TypeError('StreamTarget requires a WritableStream instance.');\n        }\n        if (options != null && typeof options !== 'object') {\n            throw new TypeError('StreamTarget options, when provided, must be an object.');\n        }\n        if (options.chunked !== undefined && typeof options.chunked !== 'boolean') {\n            throw new TypeError('options.chunked, when provided, must be a boolean.');\n        }\n        if (options.chunkSize !== undefined && (!Number.isInteger(options.chunkSize) || options.chunkSize < 1024)) {\n            throw new TypeError('options.chunkSize, when provided, must be an integer and not smaller than 1024.');\n        }\n        this._writable = writable;\n        this._options = options;\n    }\n    /** @internal */\n    _createWriter() {\n        return new _writer_js__WEBPACK_IMPORTED_MODULE_0__.StreamTargetWriter(this);\n    }\n}\n/**\n * This target just discards all incoming data. It is useful for when you need an {@link Output} but extract data from\n * it differently, for example through format-specific callbacks (`onMoof`, `onMdat`, ...) or encoder events.\n * @group Output targets\n * @public\n */\nclass NullTarget extends Target {\n    /** @internal */\n    _createWriter() {\n        return new _writer_js__WEBPACK_IMPORTED_MODULE_0__.NullTargetWriter(this);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL3RhcmdldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHVCQUF1QixvQkFBb0I7QUFDM0Msc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLGNBQWM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQWdCO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRjaC1jdXQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL21lZGlhYnVubnkvZGlzdC9tb2R1bGVzL3NyYy90YXJnZXQuanM/NTA3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAyNS1wcmVzZW50LCBWYW5pbGFneSBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmltcG9ydCB7IEJ1ZmZlclRhcmdldFdyaXRlciwgTnVsbFRhcmdldFdyaXRlciwgU3RyZWFtVGFyZ2V0V3JpdGVyIH0gZnJvbSAnLi93cml0ZXIuanMnO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciB0YXJnZXRzLCBzcGVjaWZ5aW5nIHdoZXJlIG91dHB1dCBmaWxlcyBhcmUgd3JpdHRlbi5cbiAqIEBncm91cCBPdXRwdXQgdGFyZ2V0c1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgVGFyZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9vdXRwdXQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGVhY2ggdGltZSBkYXRhIGlzIHdyaXR0ZW4gdG8gdGhlIHRhcmdldC4gV2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgYnl0ZSByYW5nZSBpbnRvIHdoaWNoIGRhdGEgd2FzIHdyaXR0ZW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZSB0aGlzIGNhbGxiYWNrIHRvIHRyYWNrIHRoZSBzaXplIG9mIHRoZSBvdXRwdXQgZmlsZSBhcyBpdCBncm93cy4gQnV0IGJlIHdhcm5lZCwgdGhpcyBmdW5jdGlvbiBpcyBjaGF0dHkgYW5kXG4gICAgICAgICAqIGdldHMgY2FsbGVkICpleHRyZW1lbHkqIG9mdGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbndyaXRlID0gbnVsbDtcbiAgICB9XG59XG4vKipcbiAqIEEgdGFyZ2V0IHRoYXQgd3JpdGVzIGRhdGEgZGlyZWN0bHkgaW50byBhbiBBcnJheUJ1ZmZlciBpbiBtZW1vcnkuIEdyZWF0IGZvciBwZXJmb3JtYW5jZSwgYnV0IG5vdCBzdWl0YWJsZSBmb3IgdmVyeVxuICogbGFyZ2UgZmlsZXMuIFRoZSBidWZmZXIgd2lsbCBiZSBhdmFpbGFibGUgb25jZSB0aGUgb3V0cHV0IGhhcyBiZWVuIGZpbmFsaXplZC5cbiAqIEBncm91cCBPdXRwdXQgdGFyZ2V0c1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQnVmZmVyVGFyZ2V0IGV4dGVuZHMgVGFyZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqIFN0b3JlcyB0aGUgZmluYWwgb3V0cHV0IGJ1ZmZlci4gVW50aWwgdGhlIG91dHB1dCBpcyBmaW5hbGl6ZWQsIHRoaXMgd2lsbCBiZSBgbnVsbGAuICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jcmVhdGVXcml0ZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyVGFyZ2V0V3JpdGVyKHRoaXMpO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyB0YXJnZXQgd3JpdGVzIGRhdGEgdG8gYSBbYFdyaXRhYmxlU3RyZWFtYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dyaXRhYmxlU3RyZWFtKSxcbiAqIG1ha2luZyBpdCBhIGdlbmVyYWwtcHVycG9zZSB0YXJnZXQgZm9yIHdyaXRpbmcgZGF0YSBhbnl3aGVyZS4gSXQgaXMgYWxzbyBjb21wYXRpYmxlIHdpdGhcbiAqIFtgRmlsZVN5c3RlbVdyaXRhYmxlRmlsZVN0cmVhbWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlU3lzdGVtV3JpdGFibGVGaWxlU3RyZWFtKSBmb3JcbiAqIHVzZSB3aXRoIHRoZSBbRmlsZSBTeXN0ZW0gQWNjZXNzIEFQSV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGVfU3lzdGVtX0FQSSkuIFRoZVxuICogYFdyaXRhYmxlU3RyZWFtYCBjYW4gYWxzbyBhcHBseSBiYWNrcHJlc3N1cmUsIHdoaWNoIHdpbGwgcHJvcGFnYXRlIHRvIHRoZSBvdXRwdXQgYW5kIHRocm90dGxlIHRoZSBlbmNvZGVycy5cbiAqIEBncm91cCBPdXRwdXQgdGFyZ2V0c1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtVGFyZ2V0IGV4dGVuZHMgVGFyZ2V0IHtcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgU3RyZWFtVGFyZ2V0fSB3aGljaCB3cml0ZXMgdG8gdGhlIHNwZWNpZmllZCBgd3JpdGFibGVgLiAqL1xuICAgIGNvbnN0cnVjdG9yKHdyaXRhYmxlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKCEod3JpdGFibGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0cmVhbVRhcmdldCByZXF1aXJlcyBhIFdyaXRhYmxlU3RyZWFtIGluc3RhbmNlLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdHJlYW1UYXJnZXQgb3B0aW9ucywgd2hlbiBwcm92aWRlZCwgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2h1bmtlZCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLmNodW5rZWQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5jaHVua2VkLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaHVua1NpemUgIT09IHVuZGVmaW5lZCAmJiAoIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5jaHVua1NpemUpIHx8IG9wdGlvbnMuY2h1bmtTaXplIDwgMTAyNCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuY2h1bmtTaXplLCB3aGVuIHByb3ZpZGVkLCBtdXN0IGJlIGFuIGludGVnZXIgYW5kIG5vdCBzbWFsbGVyIHRoYW4gMTAyNC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cml0YWJsZSA9IHdyaXRhYmxlO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jcmVhdGVXcml0ZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtVGFyZ2V0V3JpdGVyKHRoaXMpO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyB0YXJnZXQganVzdCBkaXNjYXJkcyBhbGwgaW5jb21pbmcgZGF0YS4gSXQgaXMgdXNlZnVsIGZvciB3aGVuIHlvdSBuZWVkIGFuIHtAbGluayBPdXRwdXR9IGJ1dCBleHRyYWN0IGRhdGEgZnJvbVxuICogaXQgZGlmZmVyZW50bHksIGZvciBleGFtcGxlIHRocm91Z2ggZm9ybWF0LXNwZWNpZmljIGNhbGxiYWNrcyAoYG9uTW9vZmAsIGBvbk1kYXRgLCAuLi4pIG9yIGVuY29kZXIgZXZlbnRzLlxuICogQGdyb3VwIE91dHB1dCB0YXJnZXRzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBOdWxsVGFyZ2V0IGV4dGVuZHMgVGFyZ2V0IHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2NyZWF0ZVdyaXRlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdWxsVGFyZ2V0V3JpdGVyKHRoaXMpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/target.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/wave/riff-writer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/wave/riff-writer.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RiffWriter: () => (/* binding */ RiffWriter)\n/* harmony export */ });\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nclass RiffWriter {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n    }\n    writeU16(value) {\n        this.helperView.setUint16(0, value, true);\n        this.writer.write(this.helper.subarray(0, 2));\n    }\n    writeU32(value) {\n        this.helperView.setUint32(0, value, true);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeU64(value) {\n        this.helperView.setUint32(0, value, true);\n        this.helperView.setUint32(4, Math.floor(value / 2 ** 32), true);\n        this.writer.write(this.helper);\n    }\n    writeAscii(text) {\n        this.writer.write(new TextEncoder().encode(text));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL3dhdmUvcmlmZi13cml0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGNoLWN1dC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL3dhdmUvcmlmZi13cml0ZXIuanM/NmViZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAyNS1wcmVzZW50LCBWYW5pbGFneSBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmV4cG9ydCBjbGFzcyBSaWZmV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih3cml0ZXIpIHtcbiAgICAgICAgdGhpcy53cml0ZXIgPSB3cml0ZXI7XG4gICAgICAgIHRoaXMuaGVscGVyID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgIHRoaXMuaGVscGVyVmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLmhlbHBlci5idWZmZXIpO1xuICAgIH1cbiAgICB3cml0ZVUxNih2YWx1ZSkge1xuICAgICAgICB0aGlzLmhlbHBlclZpZXcuc2V0VWludDE2KDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgdGhpcy53cml0ZXIud3JpdGUodGhpcy5oZWxwZXIuc3ViYXJyYXkoMCwgMikpO1xuICAgIH1cbiAgICB3cml0ZVUzMih2YWx1ZSkge1xuICAgICAgICB0aGlzLmhlbHBlclZpZXcuc2V0VWludDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgdGhpcy53cml0ZXIud3JpdGUodGhpcy5oZWxwZXIuc3ViYXJyYXkoMCwgNCkpO1xuICAgIH1cbiAgICB3cml0ZVU2NCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmhlbHBlclZpZXcuc2V0VWludDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5oZWxwZXJWaWV3LnNldFVpbnQzMig0LCBNYXRoLmZsb29yKHZhbHVlIC8gMiAqKiAzMiksIHRydWUpO1xuICAgICAgICB0aGlzLndyaXRlci53cml0ZSh0aGlzLmhlbHBlcik7XG4gICAgfVxuICAgIHdyaXRlQXNjaWkodGV4dCkge1xuICAgICAgICB0aGlzLndyaXRlci53cml0ZShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dCkpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/wave/riff-writer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/wave/wave-demuxer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/wave/wave-demuxer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WaveDemuxer: () => (/* binding */ WaveDemuxer),\n/* harmony export */   WaveFormat: () => (/* binding */ WaveFormat)\n/* harmony export */ });\n/* harmony import */ var _demuxer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../demuxer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/demuxer.js\");\n/* harmony import */ var _input_track_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../input-track.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/input-track.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/* harmony import */ var _packet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../packet.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/packet.js\");\n/* harmony import */ var _reader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../reader.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/reader.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\nvar WaveFormat;\n(function (WaveFormat) {\n    WaveFormat[WaveFormat[\"PCM\"] = 1] = \"PCM\";\n    WaveFormat[WaveFormat[\"IEEE_FLOAT\"] = 3] = \"IEEE_FLOAT\";\n    WaveFormat[WaveFormat[\"ALAW\"] = 6] = \"ALAW\";\n    WaveFormat[WaveFormat[\"MULAW\"] = 7] = \"MULAW\";\n    WaveFormat[WaveFormat[\"EXTENSIBLE\"] = 65534] = \"EXTENSIBLE\";\n})(WaveFormat || (WaveFormat = {}));\nclass WaveDemuxer extends _demuxer_js__WEBPACK_IMPORTED_MODULE_0__.Demuxer {\n    constructor(input) {\n        super(input);\n        this.metadataPromise = null;\n        this.dataStart = -1;\n        this.dataSize = -1;\n        this.audioInfo = null;\n        this.tracks = [];\n        this.lastKnownPacketIndex = 0;\n        this.metadataTags = {};\n        this.reader = input._reader;\n    }\n    async readMetadata() {\n        return this.metadataPromise ??= (async () => {\n            let slice = this.reader.requestSlice(0, 12);\n            if (slice instanceof Promise)\n                slice = await slice;\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(slice);\n            const riffType = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readAscii)(slice, 4);\n            const littleEndian = riffType !== 'RIFX';\n            const isRf64 = riffType === 'RF64';\n            const outerChunkSize = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readU32)(slice, littleEndian);\n            let totalFileSize = isRf64\n                ? this.reader.fileSize\n                : Math.min(outerChunkSize + 8, this.reader.fileSize ?? Infinity);\n            const format = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readAscii)(slice, 4);\n            if (format !== 'WAVE') {\n                throw new Error('Invalid WAVE file - wrong format');\n            }\n            let chunksRead = 0;\n            let dataChunkSize = null;\n            let currentPos = slice.filePos;\n            while (totalFileSize === null || currentPos < totalFileSize) {\n                let slice = this.reader.requestSlice(currentPos, 8);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                if (!slice)\n                    break;\n                const chunkId = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readAscii)(slice, 4);\n                const chunkSize = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readU32)(slice, littleEndian);\n                const startPos = slice.filePos;\n                if (isRf64 && chunksRead === 0 && chunkId !== 'ds64') {\n                    throw new Error('Invalid RF64 file: First chunk must be \"ds64\".');\n                }\n                if (chunkId === 'fmt ') {\n                    await this.parseFmtChunk(startPos, chunkSize, littleEndian);\n                }\n                else if (chunkId === 'data') {\n                    dataChunkSize ??= chunkSize;\n                    this.dataStart = slice.filePos;\n                    this.dataSize = Math.min(dataChunkSize, (totalFileSize ?? Infinity) - this.dataStart);\n                    if (this.reader.fileSize === null) {\n                        break; // Stop once we hit the data chunk\n                    }\n                }\n                else if (chunkId === 'ds64') {\n                    // File and data chunk sizes are defined in here instead\n                    const riffChunkSize = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readU64)(slice, littleEndian);\n                    dataChunkSize = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readU64)(slice, littleEndian);\n                    totalFileSize = Math.min(riffChunkSize + 8, this.reader.fileSize ?? Infinity);\n                }\n                else if (chunkId === 'LIST') {\n                    await this.parseListChunk(startPos, chunkSize, littleEndian);\n                }\n                currentPos = startPos + chunkSize + (chunkSize & 1); // Handle padding\n                chunksRead++;\n            }\n            if (!this.audioInfo) {\n                throw new Error('Invalid WAVE file - missing \"fmt \" chunk');\n            }\n            if (this.dataStart === -1) {\n                throw new Error('Invalid WAVE file - missing \"data\" chunk');\n            }\n            const blockSize = this.audioInfo.blockSizeInBytes;\n            this.dataSize = Math.floor(this.dataSize / blockSize) * blockSize;\n            this.tracks.push(new _input_track_js__WEBPACK_IMPORTED_MODULE_3__.InputAudioTrack(new WaveAudioTrackBacking(this)));\n        })();\n    }\n    async parseFmtChunk(startPos, size, littleEndian) {\n        let slice = this.reader.requestSlice(startPos, size);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            return; // File too short\n        let formatTag = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readU16)(slice, littleEndian);\n        const numChannels = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readU16)(slice, littleEndian);\n        const sampleRate = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readU32)(slice, littleEndian);\n        slice.skip(4); // Bytes per second\n        const blockAlign = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readU16)(slice, littleEndian);\n        let bitsPerSample;\n        if (size === 14) { // Plain WAVEFORMAT\n            bitsPerSample = 8;\n        }\n        else {\n            bitsPerSample = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readU16)(slice, littleEndian);\n        }\n        // Handle WAVEFORMATEXTENSIBLE\n        if (size >= 18 && formatTag !== 0x0165) {\n            const cbSize = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readU16)(slice, littleEndian);\n            const remainingSize = size - 18;\n            const extensionSize = Math.min(remainingSize, cbSize);\n            if (extensionSize >= 22 && formatTag === WaveFormat.EXTENSIBLE) {\n                // Parse WAVEFORMATEXTENSIBLE\n                slice.skip(2 + 4);\n                const subFormat = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readBytes)(slice, 16);\n                // Get actual format from subFormat GUID\n                formatTag = subFormat[0] | (subFormat[1] << 8);\n            }\n        }\n        if (formatTag === WaveFormat.MULAW || formatTag === WaveFormat.ALAW) {\n            bitsPerSample = 8;\n        }\n        this.audioInfo = {\n            format: formatTag,\n            numberOfChannels: numChannels,\n            sampleRate,\n            sampleSizeInBytes: Math.ceil(bitsPerSample / 8),\n            blockSizeInBytes: blockAlign,\n        };\n    }\n    async parseListChunk(startPos, size, littleEndian) {\n        let slice = this.reader.requestSlice(startPos, size);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            return; // File too short\n        const infoType = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readAscii)(slice, 4);\n        if (infoType !== 'INFO' && infoType !== 'INF0') { // exiftool.org claims INF0 can happen\n            return; // Not an INFO chunk\n        }\n        let currentPos = slice.filePos;\n        while (currentPos <= startPos + size - 8) {\n            slice.filePos = currentPos;\n            const chunkName = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readAscii)(slice, 4);\n            const chunkSize = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readU32)(slice, littleEndian);\n            const bytes = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readBytes)(slice, chunkSize);\n            let stringLength = 0;\n            for (let i = 0; i < bytes.length; i++) {\n                if (bytes[i] === 0) {\n                    break;\n                }\n                stringLength++;\n            }\n            const value = String.fromCharCode(...bytes.subarray(0, stringLength));\n            this.metadataTags.raw ??= {};\n            this.metadataTags.raw[chunkName] = value;\n            switch (chunkName) {\n                case 'INAM':\n                case 'TITL':\n                    {\n                        this.metadataTags.title ??= value;\n                    }\n                    ;\n                    break;\n                case 'TIT3':\n                    {\n                        this.metadataTags.description ??= value;\n                    }\n                    ;\n                    break;\n                case 'IART':\n                    {\n                        this.metadataTags.artist ??= value;\n                    }\n                    ;\n                    break;\n                case 'IPRD':\n                    {\n                        this.metadataTags.album ??= value;\n                    }\n                    ;\n                    break;\n                case 'IPRT':\n                case 'ITRK':\n                case 'TRCK':\n                    {\n                        const parts = value.split('/');\n                        const trackNum = Number.parseInt(parts[0], 10);\n                        const tracksTotal = parts[1] && Number.parseInt(parts[1], 10);\n                        if (Number.isInteger(trackNum) && trackNum > 0) {\n                            this.metadataTags.trackNumber ??= trackNum;\n                        }\n                        if (tracksTotal && Number.isInteger(tracksTotal) && tracksTotal > 0) {\n                            this.metadataTags.tracksTotal ??= tracksTotal;\n                        }\n                    }\n                    ;\n                    break;\n                case 'ICRD':\n                case 'IDIT':\n                    {\n                        const date = new Date(value);\n                        if (!Number.isNaN(date.getTime())) {\n                            this.metadataTags.date ??= date;\n                        }\n                    }\n                    ;\n                    break;\n                case 'YEAR':\n                    {\n                        const year = Number.parseInt(value, 10);\n                        if (Number.isInteger(year) && year > 0) {\n                            this.metadataTags.date ??= new Date(year, 0, 1);\n                        }\n                    }\n                    ;\n                    break;\n                case 'IGNR':\n                case 'GENR':\n                    {\n                        this.metadataTags.genre ??= value;\n                    }\n                    ;\n                    break;\n                case 'ICMT':\n                case 'CMNT':\n                case 'COMM':\n                    {\n                        this.metadataTags.comment ??= value;\n                    }\n                    ;\n                    break;\n            }\n            currentPos += 8 + chunkSize + (chunkSize & 1); // Handle padding\n        }\n    }\n    getCodec() {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.audioInfo);\n        if (this.audioInfo.format === WaveFormat.MULAW) {\n            return 'ulaw';\n        }\n        if (this.audioInfo.format === WaveFormat.ALAW) {\n            return 'alaw';\n        }\n        if (this.audioInfo.format === WaveFormat.PCM) {\n            // All formats are little-endian\n            if (this.audioInfo.sampleSizeInBytes === 1) {\n                return 'pcm-u8';\n            }\n            else if (this.audioInfo.sampleSizeInBytes === 2) {\n                return 'pcm-s16';\n            }\n            else if (this.audioInfo.sampleSizeInBytes === 3) {\n                return 'pcm-s24';\n            }\n            else if (this.audioInfo.sampleSizeInBytes === 4) {\n                return 'pcm-s32';\n            }\n        }\n        if (this.audioInfo.format === WaveFormat.IEEE_FLOAT) {\n            if (this.audioInfo.sampleSizeInBytes === 4) {\n                return 'pcm-f32';\n            }\n        }\n        return null;\n    }\n    async getMimeType() {\n        return 'audio/wav';\n    }\n    async computeDuration() {\n        await this.readMetadata();\n        const track = this.tracks[0];\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(track);\n        return track.computeDuration();\n    }\n    async getTracks() {\n        await this.readMetadata();\n        return this.tracks;\n    }\n    async getMetadataTags() {\n        await this.readMetadata();\n        return this.metadataTags;\n    }\n}\nconst PACKET_SIZE_IN_FRAMES = 2048;\nclass WaveAudioTrackBacking {\n    constructor(demuxer) {\n        this.demuxer = demuxer;\n    }\n    getId() {\n        return 1;\n    }\n    getCodec() {\n        return this.demuxer.getCodec();\n    }\n    getInternalCodecId() {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.demuxer.audioInfo);\n        return this.demuxer.audioInfo.format;\n    }\n    async getDecoderConfig() {\n        const codec = this.demuxer.getCodec();\n        if (!codec) {\n            return null;\n        }\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.demuxer.audioInfo);\n        return {\n            codec,\n            numberOfChannels: this.demuxer.audioInfo.numberOfChannels,\n            sampleRate: this.demuxer.audioInfo.sampleRate,\n        };\n    }\n    async computeDuration() {\n        const lastPacket = await this.getPacket(Infinity, { metadataOnly: true });\n        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);\n    }\n    getNumberOfChannels() {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.demuxer.audioInfo);\n        return this.demuxer.audioInfo.numberOfChannels;\n    }\n    getSampleRate() {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.demuxer.audioInfo);\n        return this.demuxer.audioInfo.sampleRate;\n    }\n    getTimeResolution() {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.demuxer.audioInfo);\n        return this.demuxer.audioInfo.sampleRate;\n    }\n    getName() {\n        return null;\n    }\n    getLanguageCode() {\n        return _misc_js__WEBPACK_IMPORTED_MODULE_1__.UNDETERMINED_LANGUAGE;\n    }\n    async getFirstTimestamp() {\n        return 0;\n    }\n    async getPacketAtIndex(packetIndex, options) {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.demuxer.audioInfo);\n        const startOffset = packetIndex * PACKET_SIZE_IN_FRAMES * this.demuxer.audioInfo.blockSizeInBytes;\n        if (startOffset >= this.demuxer.dataSize) {\n            return null;\n        }\n        const sizeInBytes = Math.min(PACKET_SIZE_IN_FRAMES * this.demuxer.audioInfo.blockSizeInBytes, this.demuxer.dataSize - startOffset);\n        if (this.demuxer.reader.fileSize === null) {\n            // If the file size is unknown, we weren't able to cap the dataSize in the init logic and we instead have to\n            // rely on the headers telling us how large the file is. But, these might be wrong, so let's check if the\n            // requested slice actually exists.\n            let slice = this.demuxer.reader.requestSlice(this.demuxer.dataStart + startOffset, sizeInBytes);\n            if (slice instanceof Promise)\n                slice = await slice;\n            if (!slice) {\n                return null;\n            }\n        }\n        let data;\n        if (options.metadataOnly) {\n            data = _packet_js__WEBPACK_IMPORTED_MODULE_4__.PLACEHOLDER_DATA;\n        }\n        else {\n            let slice = this.demuxer.reader.requestSlice(this.demuxer.dataStart + startOffset, sizeInBytes);\n            if (slice instanceof Promise)\n                slice = await slice;\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(slice);\n            data = (0,_reader_js__WEBPACK_IMPORTED_MODULE_2__.readBytes)(slice, sizeInBytes);\n        }\n        const timestamp = packetIndex * PACKET_SIZE_IN_FRAMES / this.demuxer.audioInfo.sampleRate;\n        const duration = sizeInBytes / this.demuxer.audioInfo.blockSizeInBytes / this.demuxer.audioInfo.sampleRate;\n        this.demuxer.lastKnownPacketIndex = Math.max(packetIndex, timestamp);\n        return new _packet_js__WEBPACK_IMPORTED_MODULE_4__.EncodedPacket(data, 'key', timestamp, duration, packetIndex, sizeInBytes);\n    }\n    getFirstPacket(options) {\n        return this.getPacketAtIndex(0, options);\n    }\n    async getPacket(timestamp, options) {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.demuxer.audioInfo);\n        const packetIndex = Math.floor(Math.min(timestamp * this.demuxer.audioInfo.sampleRate / PACKET_SIZE_IN_FRAMES, (this.demuxer.dataSize - 1) / (PACKET_SIZE_IN_FRAMES * this.demuxer.audioInfo.blockSizeInBytes)));\n        const packet = await this.getPacketAtIndex(packetIndex, options);\n        if (packet) {\n            return packet;\n        }\n        if (packetIndex === 0) {\n            return null; // Empty data chunk\n        }\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.demuxer.reader.fileSize === null);\n        // The file is shorter than we thought, meaning the packet we were looking for doesn't exist. So, let's find\n        // the last packet by doing a sequential scan, instead.\n        let currentPacket = await this.getPacketAtIndex(this.demuxer.lastKnownPacketIndex, options);\n        while (currentPacket) {\n            const nextPacket = await this.getNextPacket(currentPacket, options);\n            if (!nextPacket) {\n                break;\n            }\n            currentPacket = nextPacket;\n        }\n        return currentPacket;\n    }\n    getNextPacket(packet, options) {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.demuxer.audioInfo);\n        const packetIndex = Math.round(packet.timestamp * this.demuxer.audioInfo.sampleRate / PACKET_SIZE_IN_FRAMES);\n        return this.getPacketAtIndex(packetIndex + 1, options);\n    }\n    getKeyPacket(timestamp, options) {\n        return this.getPacket(timestamp, options);\n    }\n    getNextKeyPacket(packet, options) {\n        return this.getNextPacket(packet, options);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL3dhdmUvd2F2ZS1kZW11eGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN3QztBQUNZO0FBQ087QUFDSTtBQUNnQjtBQUN4RTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQzFCLDBCQUEwQixnREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQU07QUFDbEIsNkJBQTZCLHFEQUFTO0FBQ3RDO0FBQ0E7QUFDQSxtQ0FBbUMsbURBQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFEQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxREFBUztBQUN6QyxrQ0FBa0MsbURBQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1EQUFPO0FBQ2pELG9DQUFvQyxtREFBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDREQUFlO0FBQ2hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsd0JBQXdCLG1EQUFPO0FBQy9CLDRCQUE0QixtREFBTztBQUNuQywyQkFBMkIsbURBQU87QUFDbEMsdUJBQXVCO0FBQ3ZCLDJCQUEyQixt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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGNoLWN1dC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL3dhdmUvd2F2ZS1kZW11eGVyLmpzPzg2ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjUtcHJlc2VudCwgVmFuaWxhZ3kgYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgeyBEZW11eGVyIH0gZnJvbSAnLi4vZGVtdXhlci5qcyc7XG5pbXBvcnQgeyBJbnB1dEF1ZGlvVHJhY2sgfSBmcm9tICcuLi9pbnB1dC10cmFjay5qcyc7XG5pbXBvcnQgeyBhc3NlcnQsIFVOREVURVJNSU5FRF9MQU5HVUFHRSB9IGZyb20gJy4uL21pc2MuanMnO1xuaW1wb3J0IHsgRW5jb2RlZFBhY2tldCwgUExBQ0VIT0xERVJfREFUQSB9IGZyb20gJy4uL3BhY2tldC5qcyc7XG5pbXBvcnQgeyByZWFkQXNjaWksIHJlYWRCeXRlcywgcmVhZFUxNiwgcmVhZFUzMiwgcmVhZFU2NCB9IGZyb20gJy4uL3JlYWRlci5qcyc7XG5leHBvcnQgdmFyIFdhdmVGb3JtYXQ7XG4oZnVuY3Rpb24gKFdhdmVGb3JtYXQpIHtcbiAgICBXYXZlRm9ybWF0W1dhdmVGb3JtYXRbXCJQQ01cIl0gPSAxXSA9IFwiUENNXCI7XG4gICAgV2F2ZUZvcm1hdFtXYXZlRm9ybWF0W1wiSUVFRV9GTE9BVFwiXSA9IDNdID0gXCJJRUVFX0ZMT0FUXCI7XG4gICAgV2F2ZUZvcm1hdFtXYXZlRm9ybWF0W1wiQUxBV1wiXSA9IDZdID0gXCJBTEFXXCI7XG4gICAgV2F2ZUZvcm1hdFtXYXZlRm9ybWF0W1wiTVVMQVdcIl0gPSA3XSA9IFwiTVVMQVdcIjtcbiAgICBXYXZlRm9ybWF0W1dhdmVGb3JtYXRbXCJFWFRFTlNJQkxFXCJdID0gNjU1MzRdID0gXCJFWFRFTlNJQkxFXCI7XG59KShXYXZlRm9ybWF0IHx8IChXYXZlRm9ybWF0ID0ge30pKTtcbmV4cG9ydCBjbGFzcyBXYXZlRGVtdXhlciBleHRlbmRzIERlbXV4ZXIge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHN1cGVyKGlucHV0KTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YVByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGFTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmRhdGFTaXplID0gLTE7XG4gICAgICAgIHRoaXMuYXVkaW9JbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5sYXN0S25vd25QYWNrZXRJbmRleCA9IDA7XG4gICAgICAgIHRoaXMubWV0YWRhdGFUYWdzID0ge307XG4gICAgICAgIHRoaXMucmVhZGVyID0gaW5wdXQuX3JlYWRlcjtcbiAgICB9XG4gICAgYXN5bmMgcmVhZE1ldGFkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YVByb21pc2UgPz89IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnJlYWRlci5yZXF1ZXN0U2xpY2UoMCwgMTIpO1xuICAgICAgICAgICAgaWYgKHNsaWNlIGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgICAgICAgICBzbGljZSA9IGF3YWl0IHNsaWNlO1xuICAgICAgICAgICAgYXNzZXJ0KHNsaWNlKTtcbiAgICAgICAgICAgIGNvbnN0IHJpZmZUeXBlID0gcmVhZEFzY2lpKHNsaWNlLCA0KTtcbiAgICAgICAgICAgIGNvbnN0IGxpdHRsZUVuZGlhbiA9IHJpZmZUeXBlICE9PSAnUklGWCc7XG4gICAgICAgICAgICBjb25zdCBpc1JmNjQgPSByaWZmVHlwZSA9PT0gJ1JGNjQnO1xuICAgICAgICAgICAgY29uc3Qgb3V0ZXJDaHVua1NpemUgPSByZWFkVTMyKHNsaWNlLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgbGV0IHRvdGFsRmlsZVNpemUgPSBpc1JmNjRcbiAgICAgICAgICAgICAgICA/IHRoaXMucmVhZGVyLmZpbGVTaXplXG4gICAgICAgICAgICAgICAgOiBNYXRoLm1pbihvdXRlckNodW5rU2l6ZSArIDgsIHRoaXMucmVhZGVyLmZpbGVTaXplID8/IEluZmluaXR5KTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IHJlYWRBc2NpaShzbGljZSwgNCk7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ICE9PSAnV0FWRScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgV0FWRSBmaWxlIC0gd3JvbmcgZm9ybWF0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2h1bmtzUmVhZCA9IDA7XG4gICAgICAgICAgICBsZXQgZGF0YUNodW5rU2l6ZSA9IG51bGw7XG4gICAgICAgICAgICBsZXQgY3VycmVudFBvcyA9IHNsaWNlLmZpbGVQb3M7XG4gICAgICAgICAgICB3aGlsZSAodG90YWxGaWxlU2l6ZSA9PT0gbnVsbCB8fCBjdXJyZW50UG9zIDwgdG90YWxGaWxlU2l6ZSkge1xuICAgICAgICAgICAgICAgIGxldCBzbGljZSA9IHRoaXMucmVhZGVyLnJlcXVlc3RTbGljZShjdXJyZW50UG9zLCA4KTtcbiAgICAgICAgICAgICAgICBpZiAoc2xpY2UgaW5zdGFuY2VvZiBQcm9taXNlKVxuICAgICAgICAgICAgICAgICAgICBzbGljZSA9IGF3YWl0IHNsaWNlO1xuICAgICAgICAgICAgICAgIGlmICghc2xpY2UpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rSWQgPSByZWFkQXNjaWkoc2xpY2UsIDQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IHJlYWRVMzIoc2xpY2UsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSBzbGljZS5maWxlUG9zO1xuICAgICAgICAgICAgICAgIGlmIChpc1JmNjQgJiYgY2h1bmtzUmVhZCA9PT0gMCAmJiBjaHVua0lkICE9PSAnZHM2NCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFJGNjQgZmlsZTogRmlyc3QgY2h1bmsgbXVzdCBiZSBcImRzNjRcIi4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rSWQgPT09ICdmbXQgJykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBhcnNlRm10Q2h1bmsoc3RhcnRQb3MsIGNodW5rU2l6ZSwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2h1bmtJZCA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFDaHVua1NpemUgPz89IGNodW5rU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhU3RhcnQgPSBzbGljZS5maWxlUG9zO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFTaXplID0gTWF0aC5taW4oZGF0YUNodW5rU2l6ZSwgKHRvdGFsRmlsZVNpemUgPz8gSW5maW5pdHkpIC0gdGhpcy5kYXRhU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkZXIuZmlsZVNpemUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBTdG9wIG9uY2Ugd2UgaGl0IHRoZSBkYXRhIGNodW5rXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2h1bmtJZCA9PT0gJ2RzNjQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbGUgYW5kIGRhdGEgY2h1bmsgc2l6ZXMgYXJlIGRlZmluZWQgaW4gaGVyZSBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZmZDaHVua1NpemUgPSByZWFkVTY0KHNsaWNlLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICAgICAgICBkYXRhQ2h1bmtTaXplID0gcmVhZFU2NChzbGljZSwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxGaWxlU2l6ZSA9IE1hdGgubWluKHJpZmZDaHVua1NpemUgKyA4LCB0aGlzLnJlYWRlci5maWxlU2l6ZSA/PyBJbmZpbml0eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNodW5rSWQgPT09ICdMSVNUJykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBhcnNlTGlzdENodW5rKHN0YXJ0UG9zLCBjaHVua1NpemUsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBzdGFydFBvcyArIGNodW5rU2l6ZSArIChjaHVua1NpemUgJiAxKTsgLy8gSGFuZGxlIHBhZGRpbmdcbiAgICAgICAgICAgICAgICBjaHVua3NSZWFkKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXVkaW9JbmZvKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFdBVkUgZmlsZSAtIG1pc3NpbmcgXCJmbXQgXCIgY2h1bmsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFTdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgV0FWRSBmaWxlIC0gbWlzc2luZyBcImRhdGFcIiBjaHVuaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmxvY2tTaXplID0gdGhpcy5hdWRpb0luZm8uYmxvY2tTaXplSW5CeXRlcztcbiAgICAgICAgICAgIHRoaXMuZGF0YVNpemUgPSBNYXRoLmZsb29yKHRoaXMuZGF0YVNpemUgLyBibG9ja1NpemUpICogYmxvY2tTaXplO1xuICAgICAgICAgICAgdGhpcy50cmFja3MucHVzaChuZXcgSW5wdXRBdWRpb1RyYWNrKG5ldyBXYXZlQXVkaW9UcmFja0JhY2tpbmcodGhpcykpKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VGbXRDaHVuayhzdGFydFBvcywgc2l6ZSwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIGxldCBzbGljZSA9IHRoaXMucmVhZGVyLnJlcXVlc3RTbGljZShzdGFydFBvcywgc2l6ZSk7XG4gICAgICAgIGlmIChzbGljZSBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgICAgICAgICBzbGljZSA9IGF3YWl0IHNsaWNlO1xuICAgICAgICBpZiAoIXNsaWNlKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBGaWxlIHRvbyBzaG9ydFxuICAgICAgICBsZXQgZm9ybWF0VGFnID0gcmVhZFUxNihzbGljZSwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgY29uc3QgbnVtQ2hhbm5lbHMgPSByZWFkVTE2KHNsaWNlLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICBjb25zdCBzYW1wbGVSYXRlID0gcmVhZFUzMihzbGljZSwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgc2xpY2Uuc2tpcCg0KTsgLy8gQnl0ZXMgcGVyIHNlY29uZFxuICAgICAgICBjb25zdCBibG9ja0FsaWduID0gcmVhZFUxNihzbGljZSwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgbGV0IGJpdHNQZXJTYW1wbGU7XG4gICAgICAgIGlmIChzaXplID09PSAxNCkgeyAvLyBQbGFpbiBXQVZFRk9STUFUXG4gICAgICAgICAgICBiaXRzUGVyU2FtcGxlID0gODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJpdHNQZXJTYW1wbGUgPSByZWFkVTE2KHNsaWNlLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBXQVZFRk9STUFURVhURU5TSUJMRVxuICAgICAgICBpZiAoc2l6ZSA+PSAxOCAmJiBmb3JtYXRUYWcgIT09IDB4MDE2NSkge1xuICAgICAgICAgICAgY29uc3QgY2JTaXplID0gcmVhZFUxNihzbGljZSwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1NpemUgPSBzaXplIC0gMTg7XG4gICAgICAgICAgICBjb25zdCBleHRlbnNpb25TaXplID0gTWF0aC5taW4ocmVtYWluaW5nU2l6ZSwgY2JTaXplKTtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb25TaXplID49IDIyICYmIGZvcm1hdFRhZyA9PT0gV2F2ZUZvcm1hdC5FWFRFTlNJQkxFKSB7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgV0FWRUZPUk1BVEVYVEVOU0lCTEVcbiAgICAgICAgICAgICAgICBzbGljZS5za2lwKDIgKyA0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJGb3JtYXQgPSByZWFkQnl0ZXMoc2xpY2UsIDE2KTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYWN0dWFsIGZvcm1hdCBmcm9tIHN1YkZvcm1hdCBHVUlEXG4gICAgICAgICAgICAgICAgZm9ybWF0VGFnID0gc3ViRm9ybWF0WzBdIHwgKHN1YkZvcm1hdFsxXSA8PCA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0VGFnID09PSBXYXZlRm9ybWF0Lk1VTEFXIHx8IGZvcm1hdFRhZyA9PT0gV2F2ZUZvcm1hdC5BTEFXKSB7XG4gICAgICAgICAgICBiaXRzUGVyU2FtcGxlID0gODtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1ZGlvSW5mbyA9IHtcbiAgICAgICAgICAgIGZvcm1hdDogZm9ybWF0VGFnLFxuICAgICAgICAgICAgbnVtYmVyT2ZDaGFubmVsczogbnVtQ2hhbm5lbHMsXG4gICAgICAgICAgICBzYW1wbGVSYXRlLFxuICAgICAgICAgICAgc2FtcGxlU2l6ZUluQnl0ZXM6IE1hdGguY2VpbChiaXRzUGVyU2FtcGxlIC8gOCksXG4gICAgICAgICAgICBibG9ja1NpemVJbkJ5dGVzOiBibG9ja0FsaWduLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBwYXJzZUxpc3RDaHVuayhzdGFydFBvcywgc2l6ZSwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIGxldCBzbGljZSA9IHRoaXMucmVhZGVyLnJlcXVlc3RTbGljZShzdGFydFBvcywgc2l6ZSk7XG4gICAgICAgIGlmIChzbGljZSBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgICAgICAgICBzbGljZSA9IGF3YWl0IHNsaWNlO1xuICAgICAgICBpZiAoIXNsaWNlKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBGaWxlIHRvbyBzaG9ydFxuICAgICAgICBjb25zdCBpbmZvVHlwZSA9IHJlYWRBc2NpaShzbGljZSwgNCk7XG4gICAgICAgIGlmIChpbmZvVHlwZSAhPT0gJ0lORk8nICYmIGluZm9UeXBlICE9PSAnSU5GMCcpIHsgLy8gZXhpZnRvb2wub3JnIGNsYWltcyBJTkYwIGNhbiBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybjsgLy8gTm90IGFuIElORk8gY2h1bmtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudFBvcyA9IHNsaWNlLmZpbGVQb3M7XG4gICAgICAgIHdoaWxlIChjdXJyZW50UG9zIDw9IHN0YXJ0UG9zICsgc2l6ZSAtIDgpIHtcbiAgICAgICAgICAgIHNsaWNlLmZpbGVQb3MgPSBjdXJyZW50UG9zO1xuICAgICAgICAgICAgY29uc3QgY2h1bmtOYW1lID0gcmVhZEFzY2lpKHNsaWNlLCA0KTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IHJlYWRVMzIoc2xpY2UsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IHJlYWRCeXRlcyhzbGljZSwgY2h1bmtTaXplKTtcbiAgICAgICAgICAgIGxldCBzdHJpbmdMZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChieXRlc1tpXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nTGVuZ3RoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uYnl0ZXMuc3ViYXJyYXkoMCwgc3RyaW5nTGVuZ3RoKSk7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhVGFncy5yYXcgPz89IHt9O1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YVRhZ3MucmF3W2NodW5rTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2h1bmtOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnSU5BTSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnVElUTCc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGFUYWdzLnRpdGxlID8/PSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RJVDMnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhVGFncy5kZXNjcmlwdGlvbiA/Pz0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdJQVJUJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YVRhZ3MuYXJ0aXN0ID8/PSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0lQUkQnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhVGFncy5hbGJ1bSA/Pz0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdJUFJUJzpcbiAgICAgICAgICAgICAgICBjYXNlICdJVFJLJzpcbiAgICAgICAgICAgICAgICBjYXNlICdUUkNLJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSB2YWx1ZS5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhY2tOdW0gPSBOdW1iZXIucGFyc2VJbnQocGFydHNbMF0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrc1RvdGFsID0gcGFydHNbMV0gJiYgTnVtYmVyLnBhcnNlSW50KHBhcnRzWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih0cmFja051bSkgJiYgdHJhY2tOdW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YVRhZ3MudHJhY2tOdW1iZXIgPz89IHRyYWNrTnVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrc1RvdGFsICYmIE51bWJlci5pc0ludGVnZXIodHJhY2tzVG90YWwpICYmIHRyYWNrc1RvdGFsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGFUYWdzLnRyYWNrc1RvdGFsID8/PSB0cmFja3NUb3RhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0lDUkQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0lESVQnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YVRhZ3MuZGF0ZSA/Pz0gZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1lFQVInOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB5ZWFyID0gTnVtYmVyLnBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih5ZWFyKSAmJiB5ZWFyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGFUYWdzLmRhdGUgPz89IG5ldyBEYXRlKHllYXIsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnSUdOUic6XG4gICAgICAgICAgICAgICAgY2FzZSAnR0VOUic6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGFUYWdzLmdlbnJlID8/PSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0lDTVQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0NNTlQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0NPTU0nOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhVGFncy5jb21tZW50ID8/PSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFBvcyArPSA4ICsgY2h1bmtTaXplICsgKGNodW5rU2l6ZSAmIDEpOyAvLyBIYW5kbGUgcGFkZGluZ1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENvZGVjKCkge1xuICAgICAgICBhc3NlcnQodGhpcy5hdWRpb0luZm8pO1xuICAgICAgICBpZiAodGhpcy5hdWRpb0luZm8uZm9ybWF0ID09PSBXYXZlRm9ybWF0Lk1VTEFXKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3VsYXcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1ZGlvSW5mby5mb3JtYXQgPT09IFdhdmVGb3JtYXQuQUxBVykge1xuICAgICAgICAgICAgcmV0dXJuICdhbGF3JztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdWRpb0luZm8uZm9ybWF0ID09PSBXYXZlRm9ybWF0LlBDTSkge1xuICAgICAgICAgICAgLy8gQWxsIGZvcm1hdHMgYXJlIGxpdHRsZS1lbmRpYW5cbiAgICAgICAgICAgIGlmICh0aGlzLmF1ZGlvSW5mby5zYW1wbGVTaXplSW5CeXRlcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncGNtLXU4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYXVkaW9JbmZvLnNhbXBsZVNpemVJbkJ5dGVzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwY20tczE2JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYXVkaW9JbmZvLnNhbXBsZVNpemVJbkJ5dGVzID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwY20tczI0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYXVkaW9JbmZvLnNhbXBsZVNpemVJbkJ5dGVzID09PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwY20tczMyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdWRpb0luZm8uZm9ybWF0ID09PSBXYXZlRm9ybWF0LklFRUVfRkxPQVQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1ZGlvSW5mby5zYW1wbGVTaXplSW5CeXRlcyA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncGNtLWYzMic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGdldE1pbWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gJ2F1ZGlvL3dhdic7XG4gICAgfVxuICAgIGFzeW5jIGNvbXB1dGVEdXJhdGlvbigpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWFkTWV0YWRhdGEoKTtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrc1swXTtcbiAgICAgICAgYXNzZXJ0KHRyYWNrKTtcbiAgICAgICAgcmV0dXJuIHRyYWNrLmNvbXB1dGVEdXJhdGlvbigpO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFja3MoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVhZE1ldGFkYXRhKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrcztcbiAgICB9XG4gICAgYXN5bmMgZ2V0TWV0YWRhdGFUYWdzKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlYWRNZXRhZGF0YSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YVRhZ3M7XG4gICAgfVxufVxuY29uc3QgUEFDS0VUX1NJWkVfSU5fRlJBTUVTID0gMjA0ODtcbmNsYXNzIFdhdmVBdWRpb1RyYWNrQmFja2luZyB7XG4gICAgY29uc3RydWN0b3IoZGVtdXhlcikge1xuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBkZW11eGVyO1xuICAgIH1cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGdldENvZGVjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZW11eGVyLmdldENvZGVjKCk7XG4gICAgfVxuICAgIGdldEludGVybmFsQ29kZWNJZCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuZGVtdXhlci5hdWRpb0luZm8pO1xuICAgICAgICByZXR1cm4gdGhpcy5kZW11eGVyLmF1ZGlvSW5mby5mb3JtYXQ7XG4gICAgfVxuICAgIGFzeW5jIGdldERlY29kZXJDb25maWcoKSB7XG4gICAgICAgIGNvbnN0IGNvZGVjID0gdGhpcy5kZW11eGVyLmdldENvZGVjKCk7XG4gICAgICAgIGlmICghY29kZWMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCh0aGlzLmRlbXV4ZXIuYXVkaW9JbmZvKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGVjLFxuICAgICAgICAgICAgbnVtYmVyT2ZDaGFubmVsczogdGhpcy5kZW11eGVyLmF1ZGlvSW5mby5udW1iZXJPZkNoYW5uZWxzLFxuICAgICAgICAgICAgc2FtcGxlUmF0ZTogdGhpcy5kZW11eGVyLmF1ZGlvSW5mby5zYW1wbGVSYXRlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBjb21wdXRlRHVyYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGxhc3RQYWNrZXQgPSBhd2FpdCB0aGlzLmdldFBhY2tldChJbmZpbml0eSwgeyBtZXRhZGF0YU9ubHk6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiAobGFzdFBhY2tldD8udGltZXN0YW1wID8/IDApICsgKGxhc3RQYWNrZXQ/LmR1cmF0aW9uID8/IDApO1xuICAgIH1cbiAgICBnZXROdW1iZXJPZkNoYW5uZWxzKCkge1xuICAgICAgICBhc3NlcnQodGhpcy5kZW11eGVyLmF1ZGlvSW5mbyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbXV4ZXIuYXVkaW9JbmZvLm51bWJlck9mQ2hhbm5lbHM7XG4gICAgfVxuICAgIGdldFNhbXBsZVJhdGUoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmRlbXV4ZXIuYXVkaW9JbmZvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVtdXhlci5hdWRpb0luZm8uc2FtcGxlUmF0ZTtcbiAgICB9XG4gICAgZ2V0VGltZVJlc29sdXRpb24oKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmRlbXV4ZXIuYXVkaW9JbmZvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVtdXhlci5hdWRpb0luZm8uc2FtcGxlUmF0ZTtcbiAgICB9XG4gICAgZ2V0TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldExhbmd1YWdlQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIFVOREVURVJNSU5FRF9MQU5HVUFHRTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Rmlyc3RUaW1lc3RhbXAoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBhc3luYyBnZXRQYWNrZXRBdEluZGV4KHBhY2tldEluZGV4LCBvcHRpb25zKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmRlbXV4ZXIuYXVkaW9JbmZvKTtcbiAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBwYWNrZXRJbmRleCAqIFBBQ0tFVF9TSVpFX0lOX0ZSQU1FUyAqIHRoaXMuZGVtdXhlci5hdWRpb0luZm8uYmxvY2tTaXplSW5CeXRlcztcbiAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID49IHRoaXMuZGVtdXhlci5kYXRhU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZUluQnl0ZXMgPSBNYXRoLm1pbihQQUNLRVRfU0laRV9JTl9GUkFNRVMgKiB0aGlzLmRlbXV4ZXIuYXVkaW9JbmZvLmJsb2NrU2l6ZUluQnl0ZXMsIHRoaXMuZGVtdXhlci5kYXRhU2l6ZSAtIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgaWYgKHRoaXMuZGVtdXhlci5yZWFkZXIuZmlsZVNpemUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmaWxlIHNpemUgaXMgdW5rbm93biwgd2Ugd2VyZW4ndCBhYmxlIHRvIGNhcCB0aGUgZGF0YVNpemUgaW4gdGhlIGluaXQgbG9naWMgYW5kIHdlIGluc3RlYWQgaGF2ZSB0b1xuICAgICAgICAgICAgLy8gcmVseSBvbiB0aGUgaGVhZGVycyB0ZWxsaW5nIHVzIGhvdyBsYXJnZSB0aGUgZmlsZSBpcy4gQnV0LCB0aGVzZSBtaWdodCBiZSB3cm9uZywgc28gbGV0J3MgY2hlY2sgaWYgdGhlXG4gICAgICAgICAgICAvLyByZXF1ZXN0ZWQgc2xpY2UgYWN0dWFsbHkgZXhpc3RzLlxuICAgICAgICAgICAgbGV0IHNsaWNlID0gdGhpcy5kZW11eGVyLnJlYWRlci5yZXF1ZXN0U2xpY2UodGhpcy5kZW11eGVyLmRhdGFTdGFydCArIHN0YXJ0T2Zmc2V0LCBzaXplSW5CeXRlcyk7XG4gICAgICAgICAgICBpZiAoc2xpY2UgaW5zdGFuY2VvZiBQcm9taXNlKVxuICAgICAgICAgICAgICAgIHNsaWNlID0gYXdhaXQgc2xpY2U7XG4gICAgICAgICAgICBpZiAoIXNsaWNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGlmIChvcHRpb25zLm1ldGFkYXRhT25seSkge1xuICAgICAgICAgICAgZGF0YSA9IFBMQUNFSE9MREVSX0RBVEE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLmRlbXV4ZXIucmVhZGVyLnJlcXVlc3RTbGljZSh0aGlzLmRlbXV4ZXIuZGF0YVN0YXJ0ICsgc3RhcnRPZmZzZXQsIHNpemVJbkJ5dGVzKTtcbiAgICAgICAgICAgIGlmIChzbGljZSBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgICAgICAgICAgICAgc2xpY2UgPSBhd2FpdCBzbGljZTtcbiAgICAgICAgICAgIGFzc2VydChzbGljZSk7XG4gICAgICAgICAgICBkYXRhID0gcmVhZEJ5dGVzKHNsaWNlLCBzaXplSW5CeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gcGFja2V0SW5kZXggKiBQQUNLRVRfU0laRV9JTl9GUkFNRVMgLyB0aGlzLmRlbXV4ZXIuYXVkaW9JbmZvLnNhbXBsZVJhdGU7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gc2l6ZUluQnl0ZXMgLyB0aGlzLmRlbXV4ZXIuYXVkaW9JbmZvLmJsb2NrU2l6ZUluQnl0ZXMgLyB0aGlzLmRlbXV4ZXIuYXVkaW9JbmZvLnNhbXBsZVJhdGU7XG4gICAgICAgIHRoaXMuZGVtdXhlci5sYXN0S25vd25QYWNrZXRJbmRleCA9IE1hdGgubWF4KHBhY2tldEluZGV4LCB0aW1lc3RhbXApO1xuICAgICAgICByZXR1cm4gbmV3IEVuY29kZWRQYWNrZXQoZGF0YSwgJ2tleScsIHRpbWVzdGFtcCwgZHVyYXRpb24sIHBhY2tldEluZGV4LCBzaXplSW5CeXRlcyk7XG4gICAgfVxuICAgIGdldEZpcnN0UGFja2V0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFja2V0QXRJbmRleCgwLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UGFja2V0KHRpbWVzdGFtcCwgb3B0aW9ucykge1xuICAgICAgICBhc3NlcnQodGhpcy5kZW11eGVyLmF1ZGlvSW5mbyk7XG4gICAgICAgIGNvbnN0IHBhY2tldEluZGV4ID0gTWF0aC5mbG9vcihNYXRoLm1pbih0aW1lc3RhbXAgKiB0aGlzLmRlbXV4ZXIuYXVkaW9JbmZvLnNhbXBsZVJhdGUgLyBQQUNLRVRfU0laRV9JTl9GUkFNRVMsICh0aGlzLmRlbXV4ZXIuZGF0YVNpemUgLSAxKSAvIChQQUNLRVRfU0laRV9JTl9GUkFNRVMgKiB0aGlzLmRlbXV4ZXIuYXVkaW9JbmZvLmJsb2NrU2l6ZUluQnl0ZXMpKSk7XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IGF3YWl0IHRoaXMuZ2V0UGFja2V0QXRJbmRleChwYWNrZXRJbmRleCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChwYWNrZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYWNrZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhY2tldEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gRW1wdHkgZGF0YSBjaHVua1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCh0aGlzLmRlbXV4ZXIucmVhZGVyLmZpbGVTaXplID09PSBudWxsKTtcbiAgICAgICAgLy8gVGhlIGZpbGUgaXMgc2hvcnRlciB0aGFuIHdlIHRob3VnaHQsIG1lYW5pbmcgdGhlIHBhY2tldCB3ZSB3ZXJlIGxvb2tpbmcgZm9yIGRvZXNuJ3QgZXhpc3QuIFNvLCBsZXQncyBmaW5kXG4gICAgICAgIC8vIHRoZSBsYXN0IHBhY2tldCBieSBkb2luZyBhIHNlcXVlbnRpYWwgc2NhbiwgaW5zdGVhZC5cbiAgICAgICAgbGV0IGN1cnJlbnRQYWNrZXQgPSBhd2FpdCB0aGlzLmdldFBhY2tldEF0SW5kZXgodGhpcy5kZW11eGVyLmxhc3RLbm93blBhY2tldEluZGV4LCBvcHRpb25zKTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRQYWNrZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRQYWNrZXQgPSBhd2FpdCB0aGlzLmdldE5leHRQYWNrZXQoY3VycmVudFBhY2tldCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoIW5leHRQYWNrZXQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRQYWNrZXQgPSBuZXh0UGFja2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFja2V0O1xuICAgIH1cbiAgICBnZXROZXh0UGFja2V0KHBhY2tldCwgb3B0aW9ucykge1xuICAgICAgICBhc3NlcnQodGhpcy5kZW11eGVyLmF1ZGlvSW5mbyk7XG4gICAgICAgIGNvbnN0IHBhY2tldEluZGV4ID0gTWF0aC5yb3VuZChwYWNrZXQudGltZXN0YW1wICogdGhpcy5kZW11eGVyLmF1ZGlvSW5mby5zYW1wbGVSYXRlIC8gUEFDS0VUX1NJWkVfSU5fRlJBTUVTKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFja2V0QXRJbmRleChwYWNrZXRJbmRleCArIDEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXRLZXlQYWNrZXQodGltZXN0YW1wLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhY2tldCh0aW1lc3RhbXAsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXROZXh0S2V5UGFja2V0KHBhY2tldCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROZXh0UGFja2V0KHBhY2tldCwgb3B0aW9ucyk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/wave/wave-demuxer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/wave/wave-muxer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/wave/wave-muxer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WaveMuxer: () => (/* binding */ WaveMuxer)\n/* harmony export */ });\n/* harmony import */ var _muxer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../muxer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/muxer.js\");\n/* harmony import */ var _codec_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../codec.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/codec.js\");\n/* harmony import */ var _wave_demuxer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wave-demuxer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/wave/wave-demuxer.js\");\n/* harmony import */ var _riff_writer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./riff-writer.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/wave/riff-writer.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/* harmony import */ var _tags_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tags.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/tags.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n\nclass WaveMuxer extends _muxer_js__WEBPACK_IMPORTED_MODULE_0__.Muxer {\n    constructor(output, format) {\n        super(output);\n        this.headerWritten = false;\n        this.dataSize = 0;\n        this.sampleRate = null;\n        this.sampleCount = 0;\n        this.riffSizePos = null;\n        this.dataSizePos = null;\n        this.ds64RiffSizePos = null;\n        this.ds64DataSizePos = null;\n        this.ds64SampleCountPos = null;\n        this.format = format;\n        this.writer = output._writer;\n        this.riffWriter = new _riff_writer_js__WEBPACK_IMPORTED_MODULE_1__.RiffWriter(output._writer);\n        this.isRf64 = !!format._options.large;\n    }\n    async start() {\n        // Nothing needed here - we'll write the header with the first sample\n    }\n    async getMimeType() {\n        return 'audio/wav';\n    }\n    async addEncodedVideoPacket() {\n        throw new Error('WAVE does not support video.');\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            if (!this.headerWritten) {\n                (0,_codec_js__WEBPACK_IMPORTED_MODULE_2__.validateAudioChunkMetadata)(meta);\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(meta);\n                (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(meta.decoderConfig);\n                this.writeHeader(track, meta.decoderConfig);\n                this.sampleRate = meta.decoderConfig.sampleRate;\n                this.headerWritten = true;\n            }\n            this.validateAndNormalizeTimestamp(track, packet.timestamp, packet.type === 'key');\n            if (!this.isRf64 && this.writer.getPos() + packet.data.byteLength >= 2 ** 32) {\n                throw new Error('Adding more audio data would exceed the maximum RIFF size of 4 GiB. To write larger files, use'\n                    + ' RF64 by setting `large: true` in the WavOutputFormatOptions.');\n            }\n            this.writer.write(packet.data);\n            this.dataSize += packet.data.byteLength;\n            this.sampleCount += Math.round(packet.duration * this.sampleRate);\n            await this.writer.flush();\n        }\n        finally {\n            release();\n        }\n    }\n    async addSubtitleCue() {\n        throw new Error('WAVE does not support subtitles.');\n    }\n    writeHeader(track, config) {\n        if (this.format._options.onHeader) {\n            this.writer.startTrackingWrites();\n        }\n        let format;\n        const codec = track.source._codec;\n        const pcmInfo = (0,_codec_js__WEBPACK_IMPORTED_MODULE_2__.parsePcmCodec)(codec);\n        if (pcmInfo.dataType === 'ulaw') {\n            format = _wave_demuxer_js__WEBPACK_IMPORTED_MODULE_4__.WaveFormat.MULAW;\n        }\n        else if (pcmInfo.dataType === 'alaw') {\n            format = _wave_demuxer_js__WEBPACK_IMPORTED_MODULE_4__.WaveFormat.ALAW;\n        }\n        else if (pcmInfo.dataType === 'float') {\n            format = _wave_demuxer_js__WEBPACK_IMPORTED_MODULE_4__.WaveFormat.IEEE_FLOAT;\n        }\n        else {\n            format = _wave_demuxer_js__WEBPACK_IMPORTED_MODULE_4__.WaveFormat.PCM;\n        }\n        const channels = config.numberOfChannels;\n        const sampleRate = config.sampleRate;\n        const blockSize = pcmInfo.sampleSize * channels;\n        // RIFF header\n        this.riffWriter.writeAscii(this.isRf64 ? 'RF64' : 'RIFF');\n        if (this.isRf64) {\n            this.riffWriter.writeU32(0xffffffff); // Not used in RF64\n        }\n        else {\n            this.riffSizePos = this.writer.getPos();\n            this.riffWriter.writeU32(0); // File size placeholder\n        }\n        this.riffWriter.writeAscii('WAVE');\n        if (this.isRf64) {\n            this.riffWriter.writeAscii('ds64');\n            this.riffWriter.writeU32(28); // Chunk size\n            this.ds64RiffSizePos = this.writer.getPos();\n            this.riffWriter.writeU64(0); // RIFF size placeholder\n            this.ds64DataSizePos = this.writer.getPos();\n            this.riffWriter.writeU64(0); // Data size placeholder\n            this.ds64SampleCountPos = this.writer.getPos();\n            this.riffWriter.writeU64(0); // Sample count placeholder\n            this.riffWriter.writeU32(0); // Table length\n            // Empty table\n        }\n        // fmt chunk\n        this.riffWriter.writeAscii('fmt ');\n        this.riffWriter.writeU32(16); // Chunk size\n        this.riffWriter.writeU16(format);\n        this.riffWriter.writeU16(channels);\n        this.riffWriter.writeU32(sampleRate);\n        this.riffWriter.writeU32(sampleRate * blockSize); // Bytes per second\n        this.riffWriter.writeU16(blockSize);\n        this.riffWriter.writeU16(8 * pcmInfo.sampleSize);\n        if (!(0,_tags_js__WEBPACK_IMPORTED_MODULE_5__.metadataTagsAreEmpty)(this.output._metadataTags)) {\n            // Metadata exists, let's write an INFO chunk\n            this.writeInfoChunk(this.output._metadataTags);\n        }\n        // data chunk\n        this.riffWriter.writeAscii('data');\n        if (this.isRf64) {\n            this.riffWriter.writeU32(0xffffffff); // Not used in RF64\n        }\n        else {\n            this.dataSizePos = this.writer.getPos();\n            this.riffWriter.writeU32(0); // Data size placeholder\n        }\n        if (this.format._options.onHeader) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onHeader(data, start);\n        }\n    }\n    writeInfoChunk(metadata) {\n        const startPos = this.writer.getPos();\n        this.riffWriter.writeAscii('LIST');\n        this.riffWriter.writeU32(0); // Size placeholder\n        this.riffWriter.writeAscii('INFO');\n        const writtenTags = new Set();\n        const writeInfoTag = (tag, value) => {\n            if (!(0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.isIso88591Compatible)(value)) {\n                // No Unicode supported here\n                console.warn(`Didn't write tag '${tag}' because '${value}' is not ISO 8859-1-compatible.`);\n                return;\n            }\n            const size = value.length + 1; // +1 for null terminator\n            const bytes = new Uint8Array(size);\n            for (let i = 0; i < value.length; i++) {\n                bytes[i] = value.charCodeAt(i);\n            }\n            this.riffWriter.writeAscii(tag);\n            this.riffWriter.writeU32(size);\n            this.writer.write(bytes);\n            // Add padding byte if size is odd\n            if (size & 1) {\n                this.writer.write(new Uint8Array(1));\n            }\n            writtenTags.add(tag);\n        };\n        for (const { key, value } of (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.keyValueIterator)(metadata)) {\n            switch (key) {\n                case 'title':\n                    {\n                        writeInfoTag('INAM', value);\n                        writtenTags.add('INAM');\n                    }\n                    ;\n                    break;\n                case 'artist':\n                    {\n                        writeInfoTag('IART', value);\n                        writtenTags.add('IART');\n                    }\n                    ;\n                    break;\n                case 'album':\n                    {\n                        writeInfoTag('IPRD', value);\n                        writtenTags.add('IPRD');\n                    }\n                    ;\n                    break;\n                case 'trackNumber':\n                    {\n                        const string = metadata.tracksTotal !== undefined\n                            ? `${value}/${metadata.tracksTotal}`\n                            : value.toString();\n                        writeInfoTag('ITRK', string);\n                        writtenTags.add('ITRK');\n                    }\n                    ;\n                    break;\n                case 'genre':\n                    {\n                        writeInfoTag('IGNR', value);\n                        writtenTags.add('IGNR');\n                    }\n                    ;\n                    break;\n                case 'date':\n                    {\n                        writeInfoTag('ICRD', value.toISOString().slice(0, 10));\n                        writtenTags.add('ICRD');\n                    }\n                    ;\n                    break;\n                case 'comment':\n                    {\n                        writeInfoTag('ICMT', value);\n                        writtenTags.add('ICMT');\n                    }\n                    ;\n                    break;\n                case 'albumArtist':\n                case 'discNumber':\n                case 'tracksTotal':\n                case 'discsTotal':\n                case 'description':\n                case 'lyrics':\n                case 'images':\n                    {\n                        // Not supported in RIFF INFO\n                    }\n                    ;\n                    break;\n                case 'raw':\n                    {\n                        // Handled later\n                    }\n                    ;\n                    break;\n                default: (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assertNever)(key);\n            }\n        }\n        if (metadata.raw) {\n            for (const key in metadata.raw) {\n                const value = metadata.raw[key];\n                if (value == null || key.length !== 4 || writtenTags.has(key)) {\n                    continue;\n                }\n                if (typeof value === 'string') {\n                    writeInfoTag(key, value);\n                }\n            }\n        }\n        const endPos = this.writer.getPos();\n        const chunkSize = endPos - startPos - 8;\n        this.writer.seek(startPos + 4);\n        this.riffWriter.writeU32(chunkSize);\n        this.writer.seek(endPos);\n        // Add padding byte if chunk size is odd\n        if (chunkSize & 1) {\n            this.writer.write(new Uint8Array(1));\n        }\n    }\n    async finalize() {\n        const release = await this.mutex.acquire();\n        const endPos = this.writer.getPos();\n        if (this.isRf64) {\n            // Write riff size\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.ds64RiffSizePos !== null);\n            this.writer.seek(this.ds64RiffSizePos);\n            this.riffWriter.writeU64(endPos - 8);\n            // Write data size\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.ds64DataSizePos !== null);\n            this.writer.seek(this.ds64DataSizePos);\n            this.riffWriter.writeU64(this.dataSize);\n            // Write sample count\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.ds64SampleCountPos !== null);\n            this.writer.seek(this.ds64SampleCountPos);\n            this.riffWriter.writeU64(this.sampleCount);\n        }\n        else {\n            // Write file size\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.riffSizePos !== null);\n            this.writer.seek(this.riffSizePos);\n            this.riffWriter.writeU32(endPos - 8);\n            // Write data chunk size\n            (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.dataSizePos !== null);\n            this.writer.seek(this.dataSizePos);\n            this.riffWriter.writeU32(this.dataSize);\n        }\n        this.writer.seek(endPos);\n        release();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL3dhdmUvd2F2ZS1tdXhlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0M7QUFDb0M7QUFDekI7QUFDRDtBQUMyQztBQUN2QztBQUMzQyx3QkFBd0IsNENBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdURBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFFQUEwQjtBQUMxQyxnQkFBZ0IsZ0RBQU07QUFDdEIsZ0JBQWdCLGdEQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3REFBYTtBQUNyQztBQUNBLHFCQUFxQix3REFBVTtBQUMvQjtBQUNBO0FBQ0EscUJBQXFCLHdEQUFVO0FBQy9CO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQVU7QUFDL0I7QUFDQTtBQUNBLHFCQUFxQix3REFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsYUFBYSw4REFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4REFBb0I7QUFDckM7QUFDQSxrREFBa0QsSUFBSSxhQUFhLE1BQU07QUFDekU7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhLEdBQUcsMERBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU0sR0FBRyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGNoLWN1dC1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL3dhdmUvd2F2ZS1tdXhlci5qcz8wZjMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDI1LXByZXNlbnQsIFZhbmlsYWd5IGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgTXV4ZXIgfSBmcm9tICcuLi9tdXhlci5qcyc7XG5pbXBvcnQgeyBwYXJzZVBjbUNvZGVjLCB2YWxpZGF0ZUF1ZGlvQ2h1bmtNZXRhZGF0YSB9IGZyb20gJy4uL2NvZGVjLmpzJztcbmltcG9ydCB7IFdhdmVGb3JtYXQgfSBmcm9tICcuL3dhdmUtZGVtdXhlci5qcyc7XG5pbXBvcnQgeyBSaWZmV3JpdGVyIH0gZnJvbSAnLi9yaWZmLXdyaXRlci5qcyc7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydE5ldmVyLCBpc0lzbzg4NTkxQ29tcGF0aWJsZSwga2V5VmFsdWVJdGVyYXRvciB9IGZyb20gJy4uL21pc2MuanMnO1xuaW1wb3J0IHsgbWV0YWRhdGFUYWdzQXJlRW1wdHkgfSBmcm9tICcuLi90YWdzLmpzJztcbmV4cG9ydCBjbGFzcyBXYXZlTXV4ZXIgZXh0ZW5kcyBNdXhlciB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0LCBmb3JtYXQpIHtcbiAgICAgICAgc3VwZXIob3V0cHV0KTtcbiAgICAgICAgdGhpcy5oZWFkZXJXcml0dGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGF0YVNpemUgPSAwO1xuICAgICAgICB0aGlzLnNhbXBsZVJhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnNhbXBsZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5yaWZmU2l6ZVBvcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF0YVNpemVQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLmRzNjRSaWZmU2l6ZVBvcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZHM2NERhdGFTaXplUG9zID0gbnVsbDtcbiAgICAgICAgdGhpcy5kczY0U2FtcGxlQ291bnRQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgdGhpcy53cml0ZXIgPSBvdXRwdXQuX3dyaXRlcjtcbiAgICAgICAgdGhpcy5yaWZmV3JpdGVyID0gbmV3IFJpZmZXcml0ZXIob3V0cHV0Ll93cml0ZXIpO1xuICAgICAgICB0aGlzLmlzUmY2NCA9ICEhZm9ybWF0Ll9vcHRpb25zLmxhcmdlO1xuICAgIH1cbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgLy8gTm90aGluZyBuZWVkZWQgaGVyZSAtIHdlJ2xsIHdyaXRlIHRoZSBoZWFkZXIgd2l0aCB0aGUgZmlyc3Qgc2FtcGxlXG4gICAgfVxuICAgIGFzeW5jIGdldE1pbWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gJ2F1ZGlvL3dhdic7XG4gICAgfVxuICAgIGFzeW5jIGFkZEVuY29kZWRWaWRlb1BhY2tldCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXQVZFIGRvZXMgbm90IHN1cHBvcnQgdmlkZW8uJyk7XG4gICAgfVxuICAgIGFzeW5jIGFkZEVuY29kZWRBdWRpb1BhY2tldCh0cmFjaywgcGFja2V0LCBtZXRhKSB7XG4gICAgICAgIGNvbnN0IHJlbGVhc2UgPSBhd2FpdCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oZWFkZXJXcml0dGVuKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVBdWRpb0NodW5rTWV0YWRhdGEobWV0YSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KG1ldGEpO1xuICAgICAgICAgICAgICAgIGFzc2VydChtZXRhLmRlY29kZXJDb25maWcpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVIZWFkZXIodHJhY2ssIG1ldGEuZGVjb2RlckNvbmZpZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zYW1wbGVSYXRlID0gbWV0YS5kZWNvZGVyQ29uZmlnLnNhbXBsZVJhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJXcml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVBbmROb3JtYWxpemVUaW1lc3RhbXAodHJhY2ssIHBhY2tldC50aW1lc3RhbXAsIHBhY2tldC50eXBlID09PSAna2V5Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNSZjY0ICYmIHRoaXMud3JpdGVyLmdldFBvcygpICsgcGFja2V0LmRhdGEuYnl0ZUxlbmd0aCA+PSAyICoqIDMyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRpbmcgbW9yZSBhdWRpbyBkYXRhIHdvdWxkIGV4Y2VlZCB0aGUgbWF4aW11bSBSSUZGIHNpemUgb2YgNCBHaUIuIFRvIHdyaXRlIGxhcmdlciBmaWxlcywgdXNlJ1xuICAgICAgICAgICAgICAgICAgICArICcgUkY2NCBieSBzZXR0aW5nIGBsYXJnZTogdHJ1ZWAgaW4gdGhlIFdhdk91dHB1dEZvcm1hdE9wdGlvbnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndyaXRlci53cml0ZShwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmRhdGFTaXplICs9IHBhY2tldC5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnNhbXBsZUNvdW50ICs9IE1hdGgucm91bmQocGFja2V0LmR1cmF0aW9uICogdGhpcy5zYW1wbGVSYXRlKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgYWRkU3VidGl0bGVDdWUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV0FWRSBkb2VzIG5vdCBzdXBwb3J0IHN1YnRpdGxlcy4nKTtcbiAgICB9XG4gICAgd3JpdGVIZWFkZXIodHJhY2ssIGNvbmZpZykge1xuICAgICAgICBpZiAodGhpcy5mb3JtYXQuX29wdGlvbnMub25IZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVyLnN0YXJ0VHJhY2tpbmdXcml0ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm9ybWF0O1xuICAgICAgICBjb25zdCBjb2RlYyA9IHRyYWNrLnNvdXJjZS5fY29kZWM7XG4gICAgICAgIGNvbnN0IHBjbUluZm8gPSBwYXJzZVBjbUNvZGVjKGNvZGVjKTtcbiAgICAgICAgaWYgKHBjbUluZm8uZGF0YVR5cGUgPT09ICd1bGF3Jykge1xuICAgICAgICAgICAgZm9ybWF0ID0gV2F2ZUZvcm1hdC5NVUxBVztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwY21JbmZvLmRhdGFUeXBlID09PSAnYWxhdycpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFdhdmVGb3JtYXQuQUxBVztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwY21JbmZvLmRhdGFUeXBlID09PSAnZmxvYXQnKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBXYXZlRm9ybWF0LklFRUVfRkxPQVQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBXYXZlRm9ybWF0LlBDTTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFubmVscyA9IGNvbmZpZy5udW1iZXJPZkNoYW5uZWxzO1xuICAgICAgICBjb25zdCBzYW1wbGVSYXRlID0gY29uZmlnLnNhbXBsZVJhdGU7XG4gICAgICAgIGNvbnN0IGJsb2NrU2l6ZSA9IHBjbUluZm8uc2FtcGxlU2l6ZSAqIGNoYW5uZWxzO1xuICAgICAgICAvLyBSSUZGIGhlYWRlclxuICAgICAgICB0aGlzLnJpZmZXcml0ZXIud3JpdGVBc2NpaSh0aGlzLmlzUmY2NCA/ICdSRjY0JyA6ICdSSUZGJyk7XG4gICAgICAgIGlmICh0aGlzLmlzUmY2NCkge1xuICAgICAgICAgICAgdGhpcy5yaWZmV3JpdGVyLndyaXRlVTMyKDB4ZmZmZmZmZmYpOyAvLyBOb3QgdXNlZCBpbiBSRjY0XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJpZmZTaXplUG9zID0gdGhpcy53cml0ZXIuZ2V0UG9zKCk7XG4gICAgICAgICAgICB0aGlzLnJpZmZXcml0ZXIud3JpdGVVMzIoMCk7IC8vIEZpbGUgc2l6ZSBwbGFjZWhvbGRlclxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmlmZldyaXRlci53cml0ZUFzY2lpKCdXQVZFJyk7XG4gICAgICAgIGlmICh0aGlzLmlzUmY2NCkge1xuICAgICAgICAgICAgdGhpcy5yaWZmV3JpdGVyLndyaXRlQXNjaWkoJ2RzNjQnKTtcbiAgICAgICAgICAgIHRoaXMucmlmZldyaXRlci53cml0ZVUzMigyOCk7IC8vIENodW5rIHNpemVcbiAgICAgICAgICAgIHRoaXMuZHM2NFJpZmZTaXplUG9zID0gdGhpcy53cml0ZXIuZ2V0UG9zKCk7XG4gICAgICAgICAgICB0aGlzLnJpZmZXcml0ZXIud3JpdGVVNjQoMCk7IC8vIFJJRkYgc2l6ZSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgdGhpcy5kczY0RGF0YVNpemVQb3MgPSB0aGlzLndyaXRlci5nZXRQb3MoKTtcbiAgICAgICAgICAgIHRoaXMucmlmZldyaXRlci53cml0ZVU2NCgwKTsgLy8gRGF0YSBzaXplIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICB0aGlzLmRzNjRTYW1wbGVDb3VudFBvcyA9IHRoaXMud3JpdGVyLmdldFBvcygpO1xuICAgICAgICAgICAgdGhpcy5yaWZmV3JpdGVyLndyaXRlVTY0KDApOyAvLyBTYW1wbGUgY291bnQgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIHRoaXMucmlmZldyaXRlci53cml0ZVUzMigwKTsgLy8gVGFibGUgbGVuZ3RoXG4gICAgICAgICAgICAvLyBFbXB0eSB0YWJsZVxuICAgICAgICB9XG4gICAgICAgIC8vIGZtdCBjaHVua1xuICAgICAgICB0aGlzLnJpZmZXcml0ZXIud3JpdGVBc2NpaSgnZm10ICcpO1xuICAgICAgICB0aGlzLnJpZmZXcml0ZXIud3JpdGVVMzIoMTYpOyAvLyBDaHVuayBzaXplXG4gICAgICAgIHRoaXMucmlmZldyaXRlci53cml0ZVUxNihmb3JtYXQpO1xuICAgICAgICB0aGlzLnJpZmZXcml0ZXIud3JpdGVVMTYoY2hhbm5lbHMpO1xuICAgICAgICB0aGlzLnJpZmZXcml0ZXIud3JpdGVVMzIoc2FtcGxlUmF0ZSk7XG4gICAgICAgIHRoaXMucmlmZldyaXRlci53cml0ZVUzMihzYW1wbGVSYXRlICogYmxvY2tTaXplKTsgLy8gQnl0ZXMgcGVyIHNlY29uZFxuICAgICAgICB0aGlzLnJpZmZXcml0ZXIud3JpdGVVMTYoYmxvY2tTaXplKTtcbiAgICAgICAgdGhpcy5yaWZmV3JpdGVyLndyaXRlVTE2KDggKiBwY21JbmZvLnNhbXBsZVNpemUpO1xuICAgICAgICBpZiAoIW1ldGFkYXRhVGFnc0FyZUVtcHR5KHRoaXMub3V0cHV0Ll9tZXRhZGF0YVRhZ3MpKSB7XG4gICAgICAgICAgICAvLyBNZXRhZGF0YSBleGlzdHMsIGxldCdzIHdyaXRlIGFuIElORk8gY2h1bmtcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbmZvQ2h1bmsodGhpcy5vdXRwdXQuX21ldGFkYXRhVGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGF0YSBjaHVua1xuICAgICAgICB0aGlzLnJpZmZXcml0ZXIud3JpdGVBc2NpaSgnZGF0YScpO1xuICAgICAgICBpZiAodGhpcy5pc1JmNjQpIHtcbiAgICAgICAgICAgIHRoaXMucmlmZldyaXRlci53cml0ZVUzMigweGZmZmZmZmZmKTsgLy8gTm90IHVzZWQgaW4gUkY2NFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhU2l6ZVBvcyA9IHRoaXMud3JpdGVyLmdldFBvcygpO1xuICAgICAgICAgICAgdGhpcy5yaWZmV3JpdGVyLndyaXRlVTMyKDApOyAvLyBEYXRhIHNpemUgcGxhY2Vob2xkZXJcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mb3JtYXQuX29wdGlvbnMub25IZWFkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgc3RhcnQgfSA9IHRoaXMud3JpdGVyLnN0b3BUcmFja2luZ1dyaXRlcygpO1xuICAgICAgICAgICAgdGhpcy5mb3JtYXQuX29wdGlvbnMub25IZWFkZXIoZGF0YSwgc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdyaXRlSW5mb0NodW5rKG1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy53cml0ZXIuZ2V0UG9zKCk7XG4gICAgICAgIHRoaXMucmlmZldyaXRlci53cml0ZUFzY2lpKCdMSVNUJyk7XG4gICAgICAgIHRoaXMucmlmZldyaXRlci53cml0ZVUzMigwKTsgLy8gU2l6ZSBwbGFjZWhvbGRlclxuICAgICAgICB0aGlzLnJpZmZXcml0ZXIud3JpdGVBc2NpaSgnSU5GTycpO1xuICAgICAgICBjb25zdCB3cml0dGVuVGFncyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3Qgd3JpdGVJbmZvVGFnID0gKHRhZywgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNJc284ODU5MUNvbXBhdGlibGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gVW5pY29kZSBzdXBwb3J0ZWQgaGVyZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRGlkbid0IHdyaXRlIHRhZyAnJHt0YWd9JyBiZWNhdXNlICcke3ZhbHVlfScgaXMgbm90IElTTyA4ODU5LTEtY29tcGF0aWJsZS5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaXplID0gdmFsdWUubGVuZ3RoICsgMTsgLy8gKzEgZm9yIG51bGwgdGVybWluYXRvclxuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBieXRlc1tpXSA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJpZmZXcml0ZXIud3JpdGVBc2NpaSh0YWcpO1xuICAgICAgICAgICAgdGhpcy5yaWZmV3JpdGVyLndyaXRlVTMyKHNpemUpO1xuICAgICAgICAgICAgdGhpcy53cml0ZXIud3JpdGUoYnl0ZXMpO1xuICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmcgYnl0ZSBpZiBzaXplIGlzIG9kZFxuICAgICAgICAgICAgaWYgKHNpemUgJiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZXIud3JpdGUobmV3IFVpbnQ4QXJyYXkoMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdHRlblRhZ3MuYWRkKHRhZyk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgeyBrZXksIHZhbHVlIH0gb2Yga2V5VmFsdWVJdGVyYXRvcihtZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndGl0bGUnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUluZm9UYWcoJ0lOQU0nLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0dGVuVGFncy5hZGQoJ0lOQU0nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FydGlzdCc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlSW5mb1RhZygnSUFSVCcsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXR0ZW5UYWdzLmFkZCgnSUFSVCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYWxidW0nOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUluZm9UYWcoJ0lQUkQnLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0dGVuVGFncy5hZGQoJ0lQUkQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYWNrTnVtYmVyJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nID0gbWV0YWRhdGEudHJhY2tzVG90YWwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7dmFsdWV9LyR7bWV0YWRhdGEudHJhY2tzVG90YWx9YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlSW5mb1RhZygnSVRSSycsIHN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0dGVuVGFncy5hZGQoJ0lUUksnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2dlbnJlJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVJbmZvVGFnKCdJR05SJywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlblRhZ3MuYWRkKCdJR05SJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVJbmZvVGFnKCdJQ1JEJywgdmFsdWUudG9JU09TdHJpbmcoKS5zbGljZSgwLCAxMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlblRhZ3MuYWRkKCdJQ1JEJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVJbmZvVGFnKCdJQ01UJywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlblRhZ3MuYWRkKCdJQ01UJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdhbGJ1bUFydGlzdCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY051bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndHJhY2tzVG90YWwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2NzVG90YWwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICAgICAgICAgICBjYXNlICdseXJpY3MnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2ltYWdlcyc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBzdXBwb3J0ZWQgaW4gUklGRiBJTkZPXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyYXcnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGVkIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBhc3NlcnROZXZlcihrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YS5yYXcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1ldGFkYXRhLnJhdykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWV0YWRhdGEucmF3W2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwga2V5Lmxlbmd0aCAhPT0gNCB8fCB3cml0dGVuVGFncy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVJbmZvVGFnKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmRQb3MgPSB0aGlzLndyaXRlci5nZXRQb3MoKTtcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gZW5kUG9zIC0gc3RhcnRQb3MgLSA4O1xuICAgICAgICB0aGlzLndyaXRlci5zZWVrKHN0YXJ0UG9zICsgNCk7XG4gICAgICAgIHRoaXMucmlmZldyaXRlci53cml0ZVUzMihjaHVua1NpemUpO1xuICAgICAgICB0aGlzLndyaXRlci5zZWVrKGVuZFBvcyk7XG4gICAgICAgIC8vIEFkZCBwYWRkaW5nIGJ5dGUgaWYgY2h1bmsgc2l6ZSBpcyBvZGRcbiAgICAgICAgaWYgKGNodW5rU2l6ZSAmIDEpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVyLndyaXRlKG5ldyBVaW50OEFycmF5KDEpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmaW5hbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmVsZWFzZSA9IGF3YWl0IHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICBjb25zdCBlbmRQb3MgPSB0aGlzLndyaXRlci5nZXRQb3MoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNSZjY0KSB7XG4gICAgICAgICAgICAvLyBXcml0ZSByaWZmIHNpemVcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLmRzNjRSaWZmU2l6ZVBvcyAhPT0gbnVsbCk7XG4gICAgICAgICAgICB0aGlzLndyaXRlci5zZWVrKHRoaXMuZHM2NFJpZmZTaXplUG9zKTtcbiAgICAgICAgICAgIHRoaXMucmlmZldyaXRlci53cml0ZVU2NChlbmRQb3MgLSA4KTtcbiAgICAgICAgICAgIC8vIFdyaXRlIGRhdGEgc2l6ZVxuICAgICAgICAgICAgYXNzZXJ0KHRoaXMuZHM2NERhdGFTaXplUG9zICE9PSBudWxsKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVyLnNlZWsodGhpcy5kczY0RGF0YVNpemVQb3MpO1xuICAgICAgICAgICAgdGhpcy5yaWZmV3JpdGVyLndyaXRlVTY0KHRoaXMuZGF0YVNpemUpO1xuICAgICAgICAgICAgLy8gV3JpdGUgc2FtcGxlIGNvdW50XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5kczY0U2FtcGxlQ291bnRQb3MgIT09IG51bGwpO1xuICAgICAgICAgICAgdGhpcy53cml0ZXIuc2Vlayh0aGlzLmRzNjRTYW1wbGVDb3VudFBvcyk7XG4gICAgICAgICAgICB0aGlzLnJpZmZXcml0ZXIud3JpdGVVNjQodGhpcy5zYW1wbGVDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXcml0ZSBmaWxlIHNpemVcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLnJpZmZTaXplUG9zICE9PSBudWxsKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVyLnNlZWsodGhpcy5yaWZmU2l6ZVBvcyk7XG4gICAgICAgICAgICB0aGlzLnJpZmZXcml0ZXIud3JpdGVVMzIoZW5kUG9zIC0gOCk7XG4gICAgICAgICAgICAvLyBXcml0ZSBkYXRhIGNodW5rIHNpemVcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLmRhdGFTaXplUG9zICE9PSBudWxsKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVyLnNlZWsodGhpcy5kYXRhU2l6ZVBvcyk7XG4gICAgICAgICAgICB0aGlzLnJpZmZXcml0ZXIud3JpdGVVMzIodGhpcy5kYXRhU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZXIuc2VlayhlbmRQb3MpO1xuICAgICAgICByZWxlYXNlKCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/wave/wave-muxer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mediabunny/dist/modules/src/writer.js":
/*!************************************************************!*\
  !*** ./node_modules/mediabunny/dist/modules/src/writer.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BufferTargetWriter: () => (/* binding */ BufferTargetWriter),\n/* harmony export */   NullTargetWriter: () => (/* binding */ NullTargetWriter),\n/* harmony export */   StreamTargetWriter: () => (/* binding */ StreamTargetWriter),\n/* harmony export */   Writer: () => (/* binding */ Writer)\n/* harmony export */ });\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/mediabunny/dist/modules/src/misc.js\");\n/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\nclass Writer {\n    constructor() {\n        /** Setting this to true will cause the writer to ensure data is written in a strictly monotonic, streamable way. */\n        this.ensureMonotonicity = false;\n        this.trackedWrites = null;\n        this.trackedStart = -1;\n        this.trackedEnd = -1;\n    }\n    start() { }\n    maybeTrackWrites(data) {\n        if (!this.trackedWrites) {\n            return;\n        }\n        // Handle negative relative write positions\n        let pos = this.getPos();\n        if (pos < this.trackedStart) {\n            if (pos + data.byteLength <= this.trackedStart) {\n                return;\n            }\n            data = data.subarray(this.trackedStart - pos);\n            pos = 0;\n        }\n        const neededSize = pos + data.byteLength - this.trackedStart;\n        let newLength = this.trackedWrites.byteLength;\n        while (newLength < neededSize) {\n            newLength *= 2;\n        }\n        // Check if we need to resize the buffer\n        if (newLength !== this.trackedWrites.byteLength) {\n            const copy = new Uint8Array(newLength);\n            copy.set(this.trackedWrites, 0);\n            this.trackedWrites = copy;\n        }\n        this.trackedWrites.set(data, pos - this.trackedStart);\n        this.trackedEnd = Math.max(this.trackedEnd, pos + data.byteLength);\n    }\n    startTrackingWrites() {\n        this.trackedWrites = new Uint8Array(2 ** 10);\n        this.trackedStart = this.getPos();\n        this.trackedEnd = this.trackedStart;\n    }\n    stopTrackingWrites() {\n        if (!this.trackedWrites) {\n            throw new Error('Internal error: Can\\'t get tracked writes since nothing was tracked.');\n        }\n        const slice = this.trackedWrites.subarray(0, this.trackedEnd - this.trackedStart);\n        const result = {\n            data: slice,\n            start: this.trackedStart,\n            end: this.trackedEnd,\n        };\n        this.trackedWrites = null;\n        return result;\n    }\n}\nconst ARRAY_BUFFER_INITIAL_SIZE = 2 ** 16;\nconst ARRAY_BUFFER_MAX_SIZE = 2 ** 32;\nclass BufferTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.pos = 0;\n        this.maxPos = 0;\n        this.target = target;\n        this.supportsResize = 'resize' in new ArrayBuffer(0);\n        if (this.supportsResize) {\n            try {\n                // @ts-expect-error Don't want to bump \"lib\" in tsconfig\n                this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE, { maxByteLength: ARRAY_BUFFER_MAX_SIZE });\n            }\n            catch {\n                this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE);\n                this.supportsResize = false;\n            }\n        }\n        else {\n            this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE);\n        }\n        this.bytes = new Uint8Array(this.buffer);\n    }\n    ensureSize(size) {\n        let newLength = this.buffer.byteLength;\n        while (newLength < size)\n            newLength *= 2;\n        if (newLength === this.buffer.byteLength)\n            return;\n        if (newLength > ARRAY_BUFFER_MAX_SIZE) {\n            throw new Error(`ArrayBuffer exceeded maximum size of ${ARRAY_BUFFER_MAX_SIZE} bytes. Please consider using another`\n                + ` target.`);\n        }\n        if (this.supportsResize) {\n            // Use resize if it exists\n            // @ts-expect-error Don't want to bump \"lib\" in tsconfig\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            this.buffer.resize(newLength);\n            // The Uint8Array scales automatically\n        }\n        else {\n            const newBuffer = new ArrayBuffer(newLength);\n            const newBytes = new Uint8Array(newBuffer);\n            newBytes.set(this.bytes, 0);\n            this.buffer = newBuffer;\n            this.bytes = newBytes;\n        }\n    }\n    write(data) {\n        this.maybeTrackWrites(data);\n        this.ensureSize(this.pos + data.byteLength);\n        this.bytes.set(data, this.pos);\n        this.target.onwrite?.(this.pos, this.pos + data.byteLength);\n        this.pos += data.byteLength;\n        this.maxPos = Math.max(this.maxPos, this.pos);\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    getPos() {\n        return this.pos;\n    }\n    async flush() { }\n    async finalize() {\n        this.ensureSize(this.pos);\n        this.target.buffer = this.buffer.slice(0, Math.max(this.maxPos, this.pos));\n    }\n    async close() { }\n    getSlice(start, end) {\n        return this.bytes.slice(start, end);\n    }\n}\nconst DEFAULT_CHUNK_SIZE = 2 ** 24;\nconst MAX_CHUNKS_AT_ONCE = 2;\n/**\n * Writes to a StreamTarget every time it is flushed, sending out all of the new data written since the\n * last flush. This is useful for streaming applications, like piping the output to disk. When using the chunked mode,\n * data will first be accumulated in larger chunks, and then the entire chunk will be flushed out at once when ready.\n */\nclass StreamTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.pos = 0;\n        this.sections = [];\n        this.lastWriteEnd = 0;\n        this.lastFlushEnd = 0;\n        this.writer = null;\n        /**\n         * The data is divided up into fixed-size chunks, whose contents are first filled in RAM and then flushed out.\n         * A chunk is flushed if all of its contents have been written.\n         */\n        this.chunks = [];\n        this.target = target;\n        this.chunked = target._options.chunked ?? false;\n        this.chunkSize = target._options.chunkSize ?? DEFAULT_CHUNK_SIZE;\n    }\n    start() {\n        this.writer = this.target._writable.getWriter();\n    }\n    write(data) {\n        if (this.pos > this.lastWriteEnd) {\n            const paddingBytesNeeded = this.pos - this.lastWriteEnd;\n            this.pos = this.lastWriteEnd;\n            this.write(new Uint8Array(paddingBytesNeeded));\n        }\n        this.maybeTrackWrites(data);\n        this.sections.push({\n            data: data.slice(),\n            start: this.pos,\n        });\n        this.target.onwrite?.(this.pos, this.pos + data.byteLength);\n        this.pos += data.byteLength;\n        this.lastWriteEnd = Math.max(this.lastWriteEnd, this.pos);\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    getPos() {\n        return this.pos;\n    }\n    async flush() {\n        if (this.pos > this.lastWriteEnd) {\n            // There's a \"void\" between the last written byte and the next byte we're about to write. Let's pad that\n            // void with zeroes explicitly.\n            const paddingBytesNeeded = this.pos - this.lastWriteEnd;\n            this.pos = this.lastWriteEnd;\n            this.write(new Uint8Array(paddingBytesNeeded));\n        }\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.writer);\n        if (this.sections.length === 0)\n            return;\n        const chunks = [];\n        const sorted = [...this.sections].sort((a, b) => a.start - b.start);\n        chunks.push({\n            start: sorted[0].start,\n            size: sorted[0].data.byteLength,\n        });\n        // Figure out how many contiguous chunks we have\n        for (let i = 1; i < sorted.length; i++) {\n            const lastChunk = chunks[chunks.length - 1];\n            const section = sorted[i];\n            if (section.start <= lastChunk.start + lastChunk.size) {\n                lastChunk.size = Math.max(lastChunk.size, section.start + section.data.byteLength - lastChunk.start);\n            }\n            else {\n                chunks.push({\n                    start: section.start,\n                    size: section.data.byteLength,\n                });\n            }\n        }\n        for (const chunk of chunks) {\n            chunk.data = new Uint8Array(chunk.size);\n            // Make sure to write the data in the correct order for correct overwriting\n            for (const section of this.sections) {\n                // Check if the section is in the chunk\n                if (chunk.start <= section.start && section.start < chunk.start + chunk.size) {\n                    chunk.data.set(section.data, section.start - chunk.start);\n                }\n            }\n            if (this.writer.desiredSize !== null && this.writer.desiredSize <= 0) {\n                await this.writer.ready; // Allow the writer to apply backpressure\n            }\n            if (this.chunked) {\n                // Let's first gather the data into bigger chunks before writing it\n                this.writeDataIntoChunks(chunk.data, chunk.start);\n                this.tryToFlushChunks();\n            }\n            else {\n                if (this.ensureMonotonicity && chunk.start !== this.lastFlushEnd) {\n                    throw new Error('Internal error: Monotonicity violation.');\n                }\n                // Write out the data immediately\n                void this.writer.write({\n                    type: 'write',\n                    data: chunk.data,\n                    position: chunk.start,\n                });\n                this.lastFlushEnd = chunk.start + chunk.data.byteLength;\n            }\n        }\n        this.sections.length = 0;\n    }\n    writeDataIntoChunks(data, position) {\n        // First, find the chunk to write the data into, or create one if none exists\n        let chunkIndex = this.chunks.findIndex(x => x.start <= position && position < x.start + this.chunkSize);\n        if (chunkIndex === -1)\n            chunkIndex = this.createChunk(position);\n        const chunk = this.chunks[chunkIndex];\n        // Figure out how much to write to the chunk, and then write to the chunk\n        const relativePosition = position - chunk.start;\n        const toWrite = data.subarray(0, Math.min(this.chunkSize - relativePosition, data.byteLength));\n        chunk.data.set(toWrite, relativePosition);\n        // Create a section describing the region of data that was just written to\n        const section = {\n            start: relativePosition,\n            end: relativePosition + toWrite.byteLength,\n        };\n        this.insertSectionIntoChunk(chunk, section);\n        // Queue chunk for flushing to target if it has been fully written to\n        if (chunk.written[0].start === 0 && chunk.written[0].end === this.chunkSize) {\n            chunk.shouldFlush = true;\n        }\n        // Make sure we don't hold too many chunks in memory at once to keep memory usage down\n        if (this.chunks.length > MAX_CHUNKS_AT_ONCE) {\n            // Flush all but the last chunk\n            for (let i = 0; i < this.chunks.length - 1; i++) {\n                this.chunks[i].shouldFlush = true;\n            }\n            this.tryToFlushChunks();\n        }\n        // If the data didn't fit in one chunk, recurse with the remaining data\n        if (toWrite.byteLength < data.byteLength) {\n            this.writeDataIntoChunks(data.subarray(toWrite.byteLength), position + toWrite.byteLength);\n        }\n    }\n    insertSectionIntoChunk(chunk, section) {\n        let low = 0;\n        let high = chunk.written.length - 1;\n        let index = -1;\n        // Do a binary search to find the last section with a start not larger than `section`'s start\n        while (low <= high) {\n            const mid = Math.floor(low + (high - low + 1) / 2);\n            if (chunk.written[mid].start <= section.start) {\n                low = mid + 1;\n                index = mid;\n            }\n            else {\n                high = mid - 1;\n            }\n        }\n        // Insert the new section\n        chunk.written.splice(index + 1, 0, section);\n        if (index === -1 || chunk.written[index].end < section.start)\n            index++;\n        // Merge overlapping sections\n        while (index < chunk.written.length - 1 && chunk.written[index].end >= chunk.written[index + 1].start) {\n            chunk.written[index].end = Math.max(chunk.written[index].end, chunk.written[index + 1].end);\n            chunk.written.splice(index + 1, 1);\n        }\n    }\n    createChunk(includesPosition) {\n        const start = Math.floor(includesPosition / this.chunkSize) * this.chunkSize;\n        const chunk = {\n            start,\n            data: new Uint8Array(this.chunkSize),\n            written: [],\n            shouldFlush: false,\n        };\n        this.chunks.push(chunk);\n        this.chunks.sort((a, b) => a.start - b.start);\n        return this.chunks.indexOf(chunk);\n    }\n    tryToFlushChunks(force = false) {\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.writer);\n        for (let i = 0; i < this.chunks.length; i++) {\n            const chunk = this.chunks[i];\n            if (!chunk.shouldFlush && !force)\n                continue;\n            for (const section of chunk.written) {\n                const position = chunk.start + section.start;\n                if (this.ensureMonotonicity && position !== this.lastFlushEnd) {\n                    throw new Error('Internal error: Monotonicity violation.');\n                }\n                void this.writer.write({\n                    type: 'write',\n                    data: chunk.data.subarray(section.start, section.end),\n                    position,\n                });\n                this.lastFlushEnd = chunk.start + section.end;\n            }\n            this.chunks.splice(i--, 1);\n        }\n    }\n    finalize() {\n        if (this.chunked) {\n            this.tryToFlushChunks(true);\n        }\n        (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.writer);\n        return this.writer.close();\n    }\n    async close() {\n        return this.writer?.close();\n    }\n}\nclass NullTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.target = target;\n        this.pos = 0;\n    }\n    write(data) {\n        this.maybeTrackWrites(data);\n        this.target.onwrite?.(this.pos, this.pos + data.byteLength);\n        this.pos += data.byteLength;\n    }\n    getPos() {\n        return this.pos;\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    async flush() { }\n    async finalize() { }\n    async close() { }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWFidW5ueS9kaXN0L21vZHVsZXMvc3JjL3dyaXRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ21DO0FBQzVCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHNDQUFzQztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsdUJBQXVCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBTTtBQUNkLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRjaC1jdXQtZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL21lZGlhYnVubnkvZGlzdC9tb2R1bGVzL3NyYy93cml0ZXIuanM/ZGVjNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAyNS1wcmVzZW50LCBWYW5pbGFneSBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4vbWlzYy5qcyc7XG5leHBvcnQgY2xhc3MgV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqIFNldHRpbmcgdGhpcyB0byB0cnVlIHdpbGwgY2F1c2UgdGhlIHdyaXRlciB0byBlbnN1cmUgZGF0YSBpcyB3cml0dGVuIGluIGEgc3RyaWN0bHkgbW9ub3RvbmljLCBzdHJlYW1hYmxlIHdheS4gKi9cbiAgICAgICAgdGhpcy5lbnN1cmVNb25vdG9uaWNpdHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50cmFja2VkV3JpdGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmFja2VkU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy50cmFja2VkRW5kID0gLTE7XG4gICAgfVxuICAgIHN0YXJ0KCkgeyB9XG4gICAgbWF5YmVUcmFja1dyaXRlcyhkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy50cmFja2VkV3JpdGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIG5lZ2F0aXZlIHJlbGF0aXZlIHdyaXRlIHBvc2l0aW9uc1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5nZXRQb3MoKTtcbiAgICAgICAgaWYgKHBvcyA8IHRoaXMudHJhY2tlZFN0YXJ0KSB7XG4gICAgICAgICAgICBpZiAocG9zICsgZGF0YS5ieXRlTGVuZ3RoIDw9IHRoaXMudHJhY2tlZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3ViYXJyYXkodGhpcy50cmFja2VkU3RhcnQgLSBwb3MpO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZWVkZWRTaXplID0gcG9zICsgZGF0YS5ieXRlTGVuZ3RoIC0gdGhpcy50cmFja2VkU3RhcnQ7XG4gICAgICAgIGxldCBuZXdMZW5ndGggPSB0aGlzLnRyYWNrZWRXcml0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgICAgd2hpbGUgKG5ld0xlbmd0aCA8IG5lZWRlZFNpemUpIHtcbiAgICAgICAgICAgIG5ld0xlbmd0aCAqPSAyO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gcmVzaXplIHRoZSBidWZmZXJcbiAgICAgICAgaWYgKG5ld0xlbmd0aCAhPT0gdGhpcy50cmFja2VkV3JpdGVzLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xuICAgICAgICAgICAgY29weS5zZXQodGhpcy50cmFja2VkV3JpdGVzLCAwKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tlZFdyaXRlcyA9IGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja2VkV3JpdGVzLnNldChkYXRhLCBwb3MgLSB0aGlzLnRyYWNrZWRTdGFydCk7XG4gICAgICAgIHRoaXMudHJhY2tlZEVuZCA9IE1hdGgubWF4KHRoaXMudHJhY2tlZEVuZCwgcG9zICsgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgc3RhcnRUcmFja2luZ1dyaXRlcygpIHtcbiAgICAgICAgdGhpcy50cmFja2VkV3JpdGVzID0gbmV3IFVpbnQ4QXJyYXkoMiAqKiAxMCk7XG4gICAgICAgIHRoaXMudHJhY2tlZFN0YXJ0ID0gdGhpcy5nZXRQb3MoKTtcbiAgICAgICAgdGhpcy50cmFja2VkRW5kID0gdGhpcy50cmFja2VkU3RhcnQ7XG4gICAgfVxuICAgIHN0b3BUcmFja2luZ1dyaXRlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRyYWNrZWRXcml0ZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWwgZXJyb3I6IENhblxcJ3QgZ2V0IHRyYWNrZWQgd3JpdGVzIHNpbmNlIG5vdGhpbmcgd2FzIHRyYWNrZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2xpY2UgPSB0aGlzLnRyYWNrZWRXcml0ZXMuc3ViYXJyYXkoMCwgdGhpcy50cmFja2VkRW5kIC0gdGhpcy50cmFja2VkU3RhcnQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBkYXRhOiBzbGljZSxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnRyYWNrZWRTdGFydCxcbiAgICAgICAgICAgIGVuZDogdGhpcy50cmFja2VkRW5kLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYWNrZWRXcml0ZXMgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmNvbnN0IEFSUkFZX0JVRkZFUl9JTklUSUFMX1NJWkUgPSAyICoqIDE2O1xuY29uc3QgQVJSQVlfQlVGRkVSX01BWF9TSVpFID0gMiAqKiAzMjtcbmV4cG9ydCBjbGFzcyBCdWZmZXJUYXJnZXRXcml0ZXIgZXh0ZW5kcyBXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMubWF4UG9zID0gMDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuc3VwcG9ydHNSZXNpemUgPSAncmVzaXplJyBpbiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRzUmVzaXplKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgRG9uJ3Qgd2FudCB0byBidW1wIFwibGliXCIgaW4gdHNjb25maWdcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihBUlJBWV9CVUZGRVJfSU5JVElBTF9TSVpFLCB7IG1heEJ5dGVMZW5ndGg6IEFSUkFZX0JVRkZFUl9NQVhfU0laRSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihBUlJBWV9CVUZGRVJfSU5JVElBTF9TSVpFKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1cHBvcnRzUmVzaXplID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihBUlJBWV9CVUZGRVJfSU5JVElBTF9TSVpFKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICBlbnN1cmVTaXplKHNpemUpIHtcbiAgICAgICAgbGV0IG5ld0xlbmd0aCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIHdoaWxlIChuZXdMZW5ndGggPCBzaXplKVxuICAgICAgICAgICAgbmV3TGVuZ3RoICo9IDI7XG4gICAgICAgIGlmIChuZXdMZW5ndGggPT09IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChuZXdMZW5ndGggPiBBUlJBWV9CVUZGRVJfTUFYX1NJWkUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXJyYXlCdWZmZXIgZXhjZWVkZWQgbWF4aW11bSBzaXplIG9mICR7QVJSQVlfQlVGRkVSX01BWF9TSVpFfSBieXRlcy4gUGxlYXNlIGNvbnNpZGVyIHVzaW5nIGFub3RoZXJgXG4gICAgICAgICAgICAgICAgKyBgIHRhcmdldC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1Jlc2l6ZSkge1xuICAgICAgICAgICAgLy8gVXNlIHJlc2l6ZSBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgRG9uJ3Qgd2FudCB0byBidW1wIFwibGliXCIgaW4gdHNjb25maWdcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnJlc2l6ZShuZXdMZW5ndGgpO1xuICAgICAgICAgICAgLy8gVGhlIFVpbnQ4QXJyYXkgc2NhbGVzIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0J1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihuZXdMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgbmV3Qnl0ZXMgPSBuZXcgVWludDhBcnJheShuZXdCdWZmZXIpO1xuICAgICAgICAgICAgbmV3Qnl0ZXMuc2V0KHRoaXMuYnl0ZXMsIDApO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XG4gICAgICAgICAgICB0aGlzLmJ5dGVzID0gbmV3Qnl0ZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGUoZGF0YSkge1xuICAgICAgICB0aGlzLm1heWJlVHJhY2tXcml0ZXMoZGF0YSk7XG4gICAgICAgIHRoaXMuZW5zdXJlU2l6ZSh0aGlzLnBvcyArIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMuYnl0ZXMuc2V0KGRhdGEsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy50YXJnZXQub253cml0ZT8uKHRoaXMucG9zLCB0aGlzLnBvcyArIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMucG9zICs9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgdGhpcy5tYXhQb3MgPSBNYXRoLm1heCh0aGlzLm1heFBvcywgdGhpcy5wb3MpO1xuICAgIH1cbiAgICBzZWVrKG5ld1Bvcykge1xuICAgICAgICB0aGlzLnBvcyA9IG5ld1BvcztcbiAgICB9XG4gICAgZ2V0UG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3M7XG4gICAgfVxuICAgIGFzeW5jIGZsdXNoKCkgeyB9XG4gICAgYXN5bmMgZmluYWxpemUoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlU2l6ZSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMudGFyZ2V0LmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnNsaWNlKDAsIE1hdGgubWF4KHRoaXMubWF4UG9zLCB0aGlzLnBvcykpO1xuICAgIH1cbiAgICBhc3luYyBjbG9zZSgpIHsgfVxuICAgIGdldFNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxufVxuY29uc3QgREVGQVVMVF9DSFVOS19TSVpFID0gMiAqKiAyNDtcbmNvbnN0IE1BWF9DSFVOS1NfQVRfT05DRSA9IDI7XG4vKipcbiAqIFdyaXRlcyB0byBhIFN0cmVhbVRhcmdldCBldmVyeSB0aW1lIGl0IGlzIGZsdXNoZWQsIHNlbmRpbmcgb3V0IGFsbCBvZiB0aGUgbmV3IGRhdGEgd3JpdHRlbiBzaW5jZSB0aGVcbiAqIGxhc3QgZmx1c2guIFRoaXMgaXMgdXNlZnVsIGZvciBzdHJlYW1pbmcgYXBwbGljYXRpb25zLCBsaWtlIHBpcGluZyB0aGUgb3V0cHV0IHRvIGRpc2suIFdoZW4gdXNpbmcgdGhlIGNodW5rZWQgbW9kZSxcbiAqIGRhdGEgd2lsbCBmaXJzdCBiZSBhY2N1bXVsYXRlZCBpbiBsYXJnZXIgY2h1bmtzLCBhbmQgdGhlbiB0aGUgZW50aXJlIGNodW5rIHdpbGwgYmUgZmx1c2hlZCBvdXQgYXQgb25jZSB3aGVuIHJlYWR5LlxuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtVGFyZ2V0V3JpdGVyIGV4dGVuZHMgV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnNlY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMubGFzdFdyaXRlRW5kID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Rmx1c2hFbmQgPSAwO1xuICAgICAgICB0aGlzLndyaXRlciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0YSBpcyBkaXZpZGVkIHVwIGludG8gZml4ZWQtc2l6ZSBjaHVua3MsIHdob3NlIGNvbnRlbnRzIGFyZSBmaXJzdCBmaWxsZWQgaW4gUkFNIGFuZCB0aGVuIGZsdXNoZWQgb3V0LlxuICAgICAgICAgKiBBIGNodW5rIGlzIGZsdXNoZWQgaWYgYWxsIG9mIGl0cyBjb250ZW50cyBoYXZlIGJlZW4gd3JpdHRlbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmNodW5rZWQgPSB0YXJnZXQuX29wdGlvbnMuY2h1bmtlZCA/PyBmYWxzZTtcbiAgICAgICAgdGhpcy5jaHVua1NpemUgPSB0YXJnZXQuX29wdGlvbnMuY2h1bmtTaXplID8/IERFRkFVTFRfQ0hVTktfU0laRTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMud3JpdGVyID0gdGhpcy50YXJnZXQuX3dyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgIH1cbiAgICB3cml0ZShkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA+IHRoaXMubGFzdFdyaXRlRW5kKSB7XG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nQnl0ZXNOZWVkZWQgPSB0aGlzLnBvcyAtIHRoaXMubGFzdFdyaXRlRW5kO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmxhc3RXcml0ZUVuZDtcbiAgICAgICAgICAgIHRoaXMud3JpdGUobmV3IFVpbnQ4QXJyYXkocGFkZGluZ0J5dGVzTmVlZGVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXliZVRyYWNrV3JpdGVzKGRhdGEpO1xuICAgICAgICB0aGlzLnNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgZGF0YTogZGF0YS5zbGljZSgpLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMucG9zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50YXJnZXQub253cml0ZT8uKHRoaXMucG9zLCB0aGlzLnBvcyArIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMucG9zICs9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgdGhpcy5sYXN0V3JpdGVFbmQgPSBNYXRoLm1heCh0aGlzLmxhc3RXcml0ZUVuZCwgdGhpcy5wb3MpO1xuICAgIH1cbiAgICBzZWVrKG5ld1Bvcykge1xuICAgICAgICB0aGlzLnBvcyA9IG5ld1BvcztcbiAgICB9XG4gICAgZ2V0UG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3M7XG4gICAgfVxuICAgIGFzeW5jIGZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPiB0aGlzLmxhc3RXcml0ZUVuZCkge1xuICAgICAgICAgICAgLy8gVGhlcmUncyBhIFwidm9pZFwiIGJldHdlZW4gdGhlIGxhc3Qgd3JpdHRlbiBieXRlIGFuZCB0aGUgbmV4dCBieXRlIHdlJ3JlIGFib3V0IHRvIHdyaXRlLiBMZXQncyBwYWQgdGhhdFxuICAgICAgICAgICAgLy8gdm9pZCB3aXRoIHplcm9lcyBleHBsaWNpdGx5LlxuICAgICAgICAgICAgY29uc3QgcGFkZGluZ0J5dGVzTmVlZGVkID0gdGhpcy5wb3MgLSB0aGlzLmxhc3RXcml0ZUVuZDtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5sYXN0V3JpdGVFbmQ7XG4gICAgICAgICAgICB0aGlzLndyaXRlKG5ldyBVaW50OEFycmF5KHBhZGRpbmdCeXRlc05lZWRlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCh0aGlzLndyaXRlcik7XG4gICAgICAgIGlmICh0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgIGNvbnN0IHNvcnRlZCA9IFsuLi50aGlzLnNlY3Rpb25zXS5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0IC0gYi5zdGFydCk7XG4gICAgICAgIGNodW5rcy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0OiBzb3J0ZWRbMF0uc3RhcnQsXG4gICAgICAgICAgICBzaXplOiBzb3J0ZWRbMF0uZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRmlndXJlIG91dCBob3cgbWFueSBjb250aWd1b3VzIGNodW5rcyB3ZSBoYXZlXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc29ydGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0Q2h1bmsgPSBjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3Qgc2VjdGlvbiA9IHNvcnRlZFtpXTtcbiAgICAgICAgICAgIGlmIChzZWN0aW9uLnN0YXJ0IDw9IGxhc3RDaHVuay5zdGFydCArIGxhc3RDaHVuay5zaXplKSB7XG4gICAgICAgICAgICAgICAgbGFzdENodW5rLnNpemUgPSBNYXRoLm1heChsYXN0Q2h1bmsuc2l6ZSwgc2VjdGlvbi5zdGFydCArIHNlY3Rpb24uZGF0YS5ieXRlTGVuZ3RoIC0gbGFzdENodW5rLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlY3Rpb24uc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHNlY3Rpb24uZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICAgICAgICBjaHVuay5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuc2l6ZSk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdG8gd3JpdGUgdGhlIGRhdGEgaW4gdGhlIGNvcnJlY3Qgb3JkZXIgZm9yIGNvcnJlY3Qgb3ZlcndyaXRpbmdcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2VjdGlvbiBvZiB0aGlzLnNlY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHNlY3Rpb24gaXMgaW4gdGhlIGNodW5rXG4gICAgICAgICAgICAgICAgaWYgKGNodW5rLnN0YXJ0IDw9IHNlY3Rpb24uc3RhcnQgJiYgc2VjdGlvbi5zdGFydCA8IGNodW5rLnN0YXJ0ICsgY2h1bmsuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaHVuay5kYXRhLnNldChzZWN0aW9uLmRhdGEsIHNlY3Rpb24uc3RhcnQgLSBjaHVuay5zdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMud3JpdGVyLmRlc2lyZWRTaXplICE9PSBudWxsICYmIHRoaXMud3JpdGVyLmRlc2lyZWRTaXplIDw9IDApIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci5yZWFkeTsgLy8gQWxsb3cgdGhlIHdyaXRlciB0byBhcHBseSBiYWNrcHJlc3N1cmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNodW5rZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBMZXQncyBmaXJzdCBnYXRoZXIgdGhlIGRhdGEgaW50byBiaWdnZXIgY2h1bmtzIGJlZm9yZSB3cml0aW5nIGl0XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZURhdGFJbnRvQ2h1bmtzKGNodW5rLmRhdGEsIGNodW5rLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVRvRmx1c2hDaHVua3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuc3VyZU1vbm90b25pY2l0eSAmJiBjaHVuay5zdGFydCAhPT0gdGhpcy5sYXN0Rmx1c2hFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBlcnJvcjogTW9ub3RvbmljaXR5IHZpb2xhdGlvbi4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV3JpdGUgb3V0IHRoZSBkYXRhIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLndyaXRlci53cml0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3cml0ZScsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBjaHVuay5zdGFydCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RGbHVzaEVuZCA9IGNodW5rLnN0YXJ0ICsgY2h1bmsuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VjdGlvbnMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgd3JpdGVEYXRhSW50b0NodW5rcyhkYXRhLCBwb3NpdGlvbikge1xuICAgICAgICAvLyBGaXJzdCwgZmluZCB0aGUgY2h1bmsgdG8gd3JpdGUgdGhlIGRhdGEgaW50bywgb3IgY3JlYXRlIG9uZSBpZiBub25lIGV4aXN0c1xuICAgICAgICBsZXQgY2h1bmtJbmRleCA9IHRoaXMuY2h1bmtzLmZpbmRJbmRleCh4ID0+IHguc3RhcnQgPD0gcG9zaXRpb24gJiYgcG9zaXRpb24gPCB4LnN0YXJ0ICsgdGhpcy5jaHVua1NpemUpO1xuICAgICAgICBpZiAoY2h1bmtJbmRleCA9PT0gLTEpXG4gICAgICAgICAgICBjaHVua0luZGV4ID0gdGhpcy5jcmVhdGVDaHVuayhwb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5jaHVua3NbY2h1bmtJbmRleF07XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgaG93IG11Y2ggdG8gd3JpdGUgdG8gdGhlIGNodW5rLCBhbmQgdGhlbiB3cml0ZSB0byB0aGUgY2h1bmtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQb3NpdGlvbiA9IHBvc2l0aW9uIC0gY2h1bmsuc3RhcnQ7XG4gICAgICAgIGNvbnN0IHRvV3JpdGUgPSBkYXRhLnN1YmFycmF5KDAsIE1hdGgubWluKHRoaXMuY2h1bmtTaXplIC0gcmVsYXRpdmVQb3NpdGlvbiwgZGF0YS5ieXRlTGVuZ3RoKSk7XG4gICAgICAgIGNodW5rLmRhdGEuc2V0KHRvV3JpdGUsIHJlbGF0aXZlUG9zaXRpb24pO1xuICAgICAgICAvLyBDcmVhdGUgYSBzZWN0aW9uIGRlc2NyaWJpbmcgdGhlIHJlZ2lvbiBvZiBkYXRhIHRoYXQgd2FzIGp1c3Qgd3JpdHRlbiB0b1xuICAgICAgICBjb25zdCBzZWN0aW9uID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHJlbGF0aXZlUG9zaXRpb24sXG4gICAgICAgICAgICBlbmQ6IHJlbGF0aXZlUG9zaXRpb24gKyB0b1dyaXRlLmJ5dGVMZW5ndGgsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5zZXJ0U2VjdGlvbkludG9DaHVuayhjaHVuaywgc2VjdGlvbik7XG4gICAgICAgIC8vIFF1ZXVlIGNodW5rIGZvciBmbHVzaGluZyB0byB0YXJnZXQgaWYgaXQgaGFzIGJlZW4gZnVsbHkgd3JpdHRlbiB0b1xuICAgICAgICBpZiAoY2h1bmsud3JpdHRlblswXS5zdGFydCA9PT0gMCAmJiBjaHVuay53cml0dGVuWzBdLmVuZCA9PT0gdGhpcy5jaHVua1NpemUpIHtcbiAgICAgICAgICAgIGNodW5rLnNob3VsZEZsdXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgaG9sZCB0b28gbWFueSBjaHVua3MgaW4gbWVtb3J5IGF0IG9uY2UgdG8ga2VlcCBtZW1vcnkgdXNhZ2UgZG93blxuICAgICAgICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID4gTUFYX0NIVU5LU19BVF9PTkNFKSB7XG4gICAgICAgICAgICAvLyBGbHVzaCBhbGwgYnV0IHRoZSBsYXN0IGNodW5rXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtzW2ldLnNob3VsZEZsdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJ5VG9GbHVzaENodW5rcygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBkYXRhIGRpZG4ndCBmaXQgaW4gb25lIGNodW5rLCByZWN1cnNlIHdpdGggdGhlIHJlbWFpbmluZyBkYXRhXG4gICAgICAgIGlmICh0b1dyaXRlLmJ5dGVMZW5ndGggPCBkYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVEYXRhSW50b0NodW5rcyhkYXRhLnN1YmFycmF5KHRvV3JpdGUuYnl0ZUxlbmd0aCksIHBvc2l0aW9uICsgdG9Xcml0ZS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRTZWN0aW9uSW50b0NodW5rKGNodW5rLCBzZWN0aW9uKSB7XG4gICAgICAgIGxldCBsb3cgPSAwO1xuICAgICAgICBsZXQgaGlnaCA9IGNodW5rLndyaXR0ZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XG4gICAgICAgIC8vIERvIGEgYmluYXJ5IHNlYXJjaCB0byBmaW5kIHRoZSBsYXN0IHNlY3Rpb24gd2l0aCBhIHN0YXJ0IG5vdCBsYXJnZXIgdGhhbiBgc2VjdGlvbmAncyBzdGFydFxuICAgICAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IobG93ICsgKGhpZ2ggLSBsb3cgKyAxKSAvIDIpO1xuICAgICAgICAgICAgaWYgKGNodW5rLndyaXR0ZW5bbWlkXS5zdGFydCA8PSBzZWN0aW9uLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluc2VydCB0aGUgbmV3IHNlY3Rpb25cbiAgICAgICAgY2h1bmsud3JpdHRlbi5zcGxpY2UoaW5kZXggKyAxLCAwLCBzZWN0aW9uKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSB8fCBjaHVuay53cml0dGVuW2luZGV4XS5lbmQgPCBzZWN0aW9uLnN0YXJ0KVxuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgLy8gTWVyZ2Ugb3ZlcmxhcHBpbmcgc2VjdGlvbnNcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgY2h1bmsud3JpdHRlbi5sZW5ndGggLSAxICYmIGNodW5rLndyaXR0ZW5baW5kZXhdLmVuZCA+PSBjaHVuay53cml0dGVuW2luZGV4ICsgMV0uc3RhcnQpIHtcbiAgICAgICAgICAgIGNodW5rLndyaXR0ZW5baW5kZXhdLmVuZCA9IE1hdGgubWF4KGNodW5rLndyaXR0ZW5baW5kZXhdLmVuZCwgY2h1bmsud3JpdHRlbltpbmRleCArIDFdLmVuZCk7XG4gICAgICAgICAgICBjaHVuay53cml0dGVuLnNwbGljZShpbmRleCArIDEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUNodW5rKGluY2x1ZGVzUG9zaXRpb24pIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLmZsb29yKGluY2x1ZGVzUG9zaXRpb24gLyB0aGlzLmNodW5rU2l6ZSkgKiB0aGlzLmNodW5rU2l6ZTtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB7XG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KHRoaXMuY2h1bmtTaXplKSxcbiAgICAgICAgICAgIHdyaXR0ZW46IFtdLFxuICAgICAgICAgICAgc2hvdWxkRmx1c2g6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgdGhpcy5jaHVua3Muc29ydCgoYSwgYikgPT4gYS5zdGFydCAtIGIuc3RhcnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaHVua3MuaW5kZXhPZihjaHVuayk7XG4gICAgfVxuICAgIHRyeVRvRmx1c2hDaHVua3MoZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICBhc3NlcnQodGhpcy53cml0ZXIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuY2h1bmtzW2ldO1xuICAgICAgICAgICAgaWYgKCFjaHVuay5zaG91bGRGbHVzaCAmJiAhZm9yY2UpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlY3Rpb24gb2YgY2h1bmsud3JpdHRlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gY2h1bmsuc3RhcnQgKyBzZWN0aW9uLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuc3VyZU1vbm90b25pY2l0eSAmJiBwb3NpdGlvbiAhPT0gdGhpcy5sYXN0Rmx1c2hFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBlcnJvcjogTW9ub3RvbmljaXR5IHZpb2xhdGlvbi4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLndyaXRlci53cml0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3cml0ZScsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNodW5rLmRhdGEuc3ViYXJyYXkoc2VjdGlvbi5zdGFydCwgc2VjdGlvbi5lbmQpLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RGbHVzaEVuZCA9IGNodW5rLnN0YXJ0ICsgc2VjdGlvbi5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNodW5rcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5hbGl6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtlZCkge1xuICAgICAgICAgICAgdGhpcy50cnlUb0ZsdXNoQ2h1bmtzKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCh0aGlzLndyaXRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlci5jbG9zZSgpO1xuICAgIH1cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVyPy5jbG9zZSgpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBOdWxsVGFyZ2V0V3JpdGVyIGV4dGVuZHMgV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgd3JpdGUoZGF0YSkge1xuICAgICAgICB0aGlzLm1heWJlVHJhY2tXcml0ZXMoZGF0YSk7XG4gICAgICAgIHRoaXMudGFyZ2V0Lm9ud3JpdGU/Lih0aGlzLnBvcywgdGhpcy5wb3MgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLnBvcyArPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGdldFBvcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zO1xuICAgIH1cbiAgICBzZWVrKG5ld1Bvcykge1xuICAgICAgICB0aGlzLnBvcyA9IG5ld1BvcztcbiAgICB9XG4gICAgYXN5bmMgZmx1c2goKSB7IH1cbiAgICBhc3luYyBmaW5hbGl6ZSgpIHsgfVxuICAgIGFzeW5jIGNsb3NlKCkgeyB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mediabunny/dist/modules/src/writer.js\n");

/***/ })

};
;