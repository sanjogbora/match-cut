"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/imageAlignment.ts":
/*!*******************************!*\
  !*** ./lib/imageAlignment.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImageAligner: function() { return /* binding */ ImageAligner; }\n/* harmony export */ });\nclass ImageAligner {\n    // Enhanced eye center calculation using pupil approximation\n    calculatePreciseEyeCenter(landmarks, eyeIndices) {\n        const validLandmarks = eyeIndices.map((idx)=>landmarks[idx]).filter((landmark)=>landmark);\n        if (validLandmarks.length === 0) {\n            throw new Error(\"No valid eye landmarks found\");\n        }\n        // Weight inner eye landmarks more heavily (closer to actual pupil position)\n        let weightedX = 0, weightedY = 0, totalWeight = 0;\n        validLandmarks.forEach((landmark, i)=>{\n            // Inner landmarks get higher weight for better pupil approximation\n            const isCorner = eyeIndices[i] === 33 || eyeIndices[i] === 133 || eyeIndices[i] === 362 || eyeIndices[i] === 263;\n            const weight = isCorner ? 0.5 : 1.5; // Reduce weight of corner points\n            weightedX += landmark.x * weight;\n            weightedY += landmark.y * weight;\n            totalWeight += weight;\n        });\n        return [\n            weightedX / totalWeight,\n            weightedY / totalWeight\n        ];\n    }\n    alignImage(sourceImage, eyePoints, targetResolution) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = targetResolution.width;\n        canvas.height = targetResolution.height;\n        const ctx = canvas.getContext(\"2d\");\n        // Calculate alignment transform\n        const transform = this.calculateAlignmentTransform(eyePoints, targetResolution);\n        // Apply transformation and draw image\n        ctx.save();\n        ctx.setTransform(transform.matrix[0][0], transform.matrix[0][1], transform.matrix[1][0], transform.matrix[1][1], transform.matrix[0][2], transform.matrix[1][2]);\n        ctx.drawImage(sourceImage, 0, 0);\n        ctx.restore();\n        return canvas;\n    }\n    calculateAlignmentTransform(eyePoints, targetResolution) {\n        const { left, right } = eyePoints;\n        const { width, height } = targetResolution;\n        // Calculate current eye properties with higher precision\n        const eyeCenterX = (left[0] + right[0]) / 2;\n        const eyeCenterY = (left[1] + right[1]) / 2;\n        const currentEyeDistance = Math.sqrt(Math.pow(right[0] - left[0], 2) + Math.pow(right[1] - left[1], 2));\n        const eyeAngle = Math.atan2(right[1] - left[1], right[0] - left[0]);\n        // Calculate target eye properties\n        const targetEyeDistancePixels = width * this.targetEyeDistance;\n        const targetEyeCenterX = width / 2;\n        const targetEyeCenterY = height * this.targetEyeY;\n        // Calculate transformations\n        const scale = targetEyeDistancePixels / currentEyeDistance;\n        const rotation = -eyeAngle; // Negative to counter-rotate\n        // Create base transform\n        const transform = {\n            rotation: rotation * (180 / Math.PI),\n            scale,\n            translation: [\n                targetEyeCenterX - eyeCenterX * scale,\n                targetEyeCenterY - eyeCenterY * scale\n            ],\n            matrix: this.createTransformMatrix(scale, rotation, targetEyeCenterX - eyeCenterX * scale, targetEyeCenterY - eyeCenterY * scale)\n        };\n        // Apply temporal smoothing to reduce jitter between frames\n        return this.applySmoothingToTransform(transform);\n    }\n    createTransformMatrix(scale, rotation, tx, ty) {\n        const cos = Math.cos(rotation);\n        const sin = Math.sin(rotation);\n        return [\n            [\n                scale * cos,\n                -scale * sin,\n                tx\n            ],\n            [\n                scale * sin,\n                scale * cos,\n                ty\n            ]\n        ];\n    }\n    applySmoothingToTransform(transform) {\n        if (this.previousTransforms.length === 0) {\n            this.previousTransforms.push(transform);\n            return transform;\n        }\n        const recent = this.previousTransforms[this.previousTransforms.length - 1];\n        const alpha = this.smoothingFactor;\n        const smoothed = {\n            rotation: this.interpolateAngle(recent.rotation, transform.rotation, alpha),\n            scale: recent.scale * (1 - alpha) + transform.scale * alpha,\n            translation: [\n                recent.translation[0] * (1 - alpha) + transform.translation[0] * alpha,\n                recent.translation[1] * (1 - alpha) + transform.translation[1] * alpha\n            ],\n            matrix: transform.matrix // Recalculate matrix after smoothing\n        };\n        // Recalculate matrix with smoothed values\n        const radians = smoothed.rotation * (Math.PI / 180);\n        smoothed.matrix = this.createTransformMatrix(smoothed.scale, radians, smoothed.translation[0], smoothed.translation[1]);\n        this.previousTransforms.push(smoothed);\n        // Keep only recent transforms for memory efficiency\n        if (this.previousTransforms.length > 3) {\n            this.previousTransforms.shift();\n        }\n        return smoothed;\n    }\n    interpolateAngle(angle1, angle2, alpha) {\n        // Handle angle wraparound for smooth rotation interpolation\n        let diff = angle2 - angle1;\n        if (diff > 180) diff -= 360;\n        if (diff < -180) diff += 360;\n        return angle1 + diff * alpha;\n    }\n    // Reset smoothing state (call when processing a new set of images)\n    resetSmoothingState() {\n        this.previousTransforms = [];\n    }\n    // Full image alignment method that preserves entire image on canvas\n    alignImageFull(sourceImage, eyePoints, targetResolution) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = targetResolution.width;\n        canvas.height = targetResolution.height;\n        const ctx = canvas.getContext(\"2d\");\n        const { left, right } = eyePoints;\n        const { width: canvasWidth, height: canvasHeight } = targetResolution;\n        // Calculate eye properties in source image\n        const eyeCenterX = (left[0] + right[0]) / 2;\n        const eyeCenterY = (left[1] + right[1]) / 2;\n        const eyeAngle = Math.atan2(right[1] - left[1], right[0] - left[0]);\n        const currentEyeDistance = Math.sqrt(Math.pow(right[0] - left[0], 2) + Math.pow(right[1] - left[1], 2));\n        // Target eye properties on canvas\n        const targetEyeDistance = canvasWidth * this.targetEyeDistance;\n        const targetEyeCenterX = canvasWidth / 2;\n        const targetEyeCenterY = canvasHeight * this.targetEyeY;\n        // Calculate scale based on eye distance\n        const eyeScale = targetEyeDistance / currentEyeDistance;\n        // Calculate the scaled image dimensions\n        const scaledImageWidth = sourceImage.width * eyeScale;\n        const scaledImageHeight = sourceImage.height * eyeScale;\n        // Calculate final scale to fit entire image on canvas if needed\n        const canvasFitScaleX = canvasWidth / scaledImageWidth;\n        const canvasFitScaleY = canvasHeight / scaledImageHeight;\n        const canvasFitScale = Math.min(canvasFitScaleX, canvasFitScaleY, 1); // Don't upscale beyond eye scale\n        // Final scale combines eye alignment and canvas fitting\n        const finalScale = eyeScale * canvasFitScale;\n        // Calculate where the image should be positioned to keep eyes at target position\n        const scaledEyeCenterX = eyeCenterX * finalScale;\n        const scaledEyeCenterY = eyeCenterY * finalScale;\n        // Calculate image position (top-left corner) to place eyes at target position\n        const cos = Math.cos(-eyeAngle);\n        const sin = Math.sin(-eyeAngle);\n        // Apply transformations\n        ctx.save();\n        // Clear canvas with transparent background\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        console.log(\"alignImageFull debug:\", {\n            sourceImageSize: {\n                width: sourceImage.width,\n                height: sourceImage.height\n            },\n            canvasSize: {\n                width: canvasWidth,\n                height: canvasHeight\n            },\n            eyeScale,\n            canvasFitScale,\n            finalScale,\n            eyeCenterX,\n            eyeCenterY,\n            targetEyeCenterX,\n            targetEyeCenterY,\n            eyeAngle: eyeAngle * (180 / Math.PI) + \" degrees\",\n            imageComplete: sourceImage.complete,\n            imageSrc: sourceImage.src.substring(0, 50) + \"...\"\n        });\n        // Verify source image has content by drawing to a test canvas\n        const testCanvas = document.createElement(\"canvas\");\n        testCanvas.width = sourceImage.width;\n        testCanvas.height = sourceImage.height;\n        const testCtx = testCanvas.getContext(\"2d\");\n        testCtx.drawImage(sourceImage, 0, 0);\n        const testImageData = testCtx.getImageData(0, 0, sourceImage.width, sourceImage.height);\n        const sourceHasContent = testImageData.data.some((value, index)=>{\n            return index % 4 === 3 && value > 0; // Check alpha channel\n        });\n        console.log(\"Source image has content:\", sourceHasContent);\n        // Move to target eye center\n        ctx.translate(targetEyeCenterX, targetEyeCenterY);\n        // Rotate to align eyes horizontally\n        ctx.rotate(-eyeAngle);\n        // Scale to match target eye distance and fit canvas\n        ctx.scale(finalScale, finalScale);\n        // Draw image centered on eye center in the scaled/rotated coordinate system\n        ctx.drawImage(sourceImage, -eyeCenterX, -eyeCenterY, sourceImage.width, sourceImage.height);\n        console.log(\"DrawImage parameters:\", {\n            dx: -eyeCenterX,\n            dy: -eyeCenterY,\n            dWidth: sourceImage.width,\n            dHeight: sourceImage.height,\n            currentTransform: ctx.getTransform()\n        });\n        // Check immediately if drawing worked within the transform\n        const immediateCheck = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n        const drewSomething = immediateCheck.data.some((value, index)=>{\n            return index % 4 === 3 && value > 0;\n        });\n        console.log(\"Content exists immediately after drawImage (within transform):\", drewSomething);\n        ctx.restore();\n        // Debug: Check if canvas has content\n        const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n        const hasContent = imageData.data.some((value, index)=>{\n            return index % 4 === 3 && value > 0; // Check alpha channel for non-transparent pixels\n        });\n        console.log(\"Canvas has content after drawing:\", hasContent);\n        if (!hasContent) {\n            console.warn(\"WARNING: Canvas appears to be empty after alignment\");\n            // Debug: Try a simple red rectangle to verify canvas is working\n            ctx.fillStyle = \"red\";\n            ctx.fillRect(10, 10, 50, 50);\n            console.log(\"Added debug red rectangle to empty canvas\");\n        }\n        return canvas;\n    }\n    // Smart face cropping alignment - focuses on face region while maintaining eye alignment\n    alignImageFaceCrop(sourceImage, faceResult, targetResolution) {\n        let padding = arguments.length > 3 && arguments[3] !== void 0 // 60% padding around face for better framing\n         ? arguments[3] : 0.6;\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = targetResolution.width;\n        canvas.height = targetResolution.height;\n        const ctx = canvas.getContext(\"2d\");\n        const { eyePoints, faceBounds } = faceResult;\n        const { width: canvasWidth, height: canvasHeight } = targetResolution;\n        if (!faceBounds) {\n            // Fallback to full alignment if no face bounds\n            return this.alignImageFull(sourceImage, eyePoints, targetResolution);\n        }\n        // Calculate padded face region with extra vertical padding\n        const faceWidth = faceBounds.width;\n        const faceHeight = faceBounds.height;\n        const paddingX = faceWidth * padding;\n        const paddingY = faceHeight * (padding + 0.2); // Extra 20% vertical padding for forehead/chin\n        const cropLeft = Math.max(0, faceBounds.left - paddingX);\n        const cropTop = Math.max(0, faceBounds.top - paddingY);\n        const cropRight = Math.min(sourceImage.width, faceBounds.right + paddingX);\n        const cropBottom = Math.min(sourceImage.height, faceBounds.bottom + paddingY);\n        const cropWidth = cropRight - cropLeft;\n        const cropHeight = cropBottom - cropTop;\n        // Adjust eye points relative to crop region\n        const adjustedEyePoints = {\n            left: [\n                eyePoints.left[0] - cropLeft,\n                eyePoints.left[1] - cropTop\n            ],\n            right: [\n                eyePoints.right[0] - cropLeft,\n                eyePoints.right[1] - cropTop\n            ]\n        };\n        // Calculate eye properties in cropped region\n        const eyeCenterX = (adjustedEyePoints.left[0] + adjustedEyePoints.right[0]) / 2;\n        const eyeCenterY = (adjustedEyePoints.left[1] + adjustedEyePoints.right[1]) / 2;\n        const eyeAngle = Math.atan2(adjustedEyePoints.right[1] - adjustedEyePoints.left[1], adjustedEyePoints.right[0] - adjustedEyePoints.left[0]);\n        const currentEyeDistance = Math.sqrt(Math.pow(adjustedEyePoints.right[0] - adjustedEyePoints.left[0], 2) + Math.pow(adjustedEyePoints.right[1] - adjustedEyePoints.left[1], 2));\n        // Target eye properties\n        const targetEyeDistance = canvasWidth * this.targetEyeDistance;\n        const targetEyeCenterX = canvasWidth / 2;\n        const targetEyeCenterY = canvasHeight * this.targetEyeY;\n        // Calculate scale to fit cropped region to canvas\n        const eyeScale = targetEyeDistance / currentEyeDistance;\n        const scaleToFitX = canvasWidth / cropWidth;\n        const scaleToFitY = canvasHeight / cropHeight;\n        const fitScale = Math.min(scaleToFitX, scaleToFitY);\n        // Use the more appropriate scale\n        const finalScale = Math.min(eyeScale, fitScale * 1.2); // Allow slight overflow for better framing\n        // Apply transformations\n        ctx.save();\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        console.log(\"alignImageFaceCrop debug:\", {\n            cropRegion: {\n                left: cropLeft,\n                top: cropTop,\n                width: cropWidth,\n                height: cropHeight\n            },\n            canvasSize: {\n                width: canvasWidth,\n                height: canvasHeight\n            },\n            eyeScale,\n            fitScale,\n            finalScale,\n            eyeCenterX,\n            eyeCenterY,\n            targetEyeCenterX,\n            targetEyeCenterY,\n            eyeAngle: eyeAngle * (180 / Math.PI) + \" degrees\"\n        });\n        // Move to target eye center\n        ctx.translate(targetEyeCenterX, targetEyeCenterY);\n        // Rotate to align eyes horizontally\n        ctx.rotate(-eyeAngle);\n        // Scale the cropped region\n        ctx.scale(finalScale, finalScale);\n        // Draw the cropped region centered on eye center\n        ctx.drawImage(sourceImage, cropLeft, cropTop, cropWidth, cropHeight, -eyeCenterX, -eyeCenterY, cropWidth, cropHeight // Destination\n        );\n        ctx.restore();\n        // Debug: Check if canvas has content\n        const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n        const hasContent = imageData.data.some((value, index)=>{\n            return index % 4 === 3 && value > 0; // Check alpha channel for non-transparent pixels\n        });\n        console.log(\"Canvas has content after face crop drawing:\", hasContent);\n        if (!hasContent) {\n            console.warn(\"WARNING: Face crop canvas appears to be empty after alignment\");\n            // Debug: Try a simple blue rectangle to verify canvas is working\n            ctx.fillStyle = \"blue\";\n            ctx.fillRect(10, 10, 50, 50);\n            console.log(\"Added debug blue rectangle to empty face crop canvas\");\n        }\n        return canvas;\n    }\n    // Alternative simpler alignment method using canvas transforms\n    alignImageSimple(sourceImage, eyePoints, targetResolution) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = targetResolution.width;\n        canvas.height = targetResolution.height;\n        const ctx = canvas.getContext(\"2d\");\n        const { left, right } = eyePoints;\n        const { width, height } = targetResolution;\n        // Calculate eye center and angle\n        const eyeCenterX = (left[0] + right[0]) / 2;\n        const eyeCenterY = (left[1] + right[1]) / 2;\n        const eyeAngle = Math.atan2(right[1] - left[1], right[0] - left[0]);\n        const currentEyeDistance = Math.sqrt(Math.pow(right[0] - left[0], 2) + Math.pow(right[1] - left[1], 2));\n        // Target properties\n        const targetEyeDistance = width * this.targetEyeDistance;\n        const targetCenterX = width / 2;\n        const targetCenterY = height * this.targetEyeY;\n        const scale = targetEyeDistance / currentEyeDistance;\n        // Apply transformations\n        ctx.save();\n        // Move to target center\n        ctx.translate(targetCenterX, targetCenterY);\n        // Rotate to align eyes horizontally\n        ctx.rotate(-eyeAngle);\n        // Scale to match target eye distance\n        ctx.scale(scale, scale);\n        // Draw image centered on eye center\n        ctx.drawImage(sourceImage, -eyeCenterX, -eyeCenterY);\n        ctx.restore();\n        return canvas;\n    }\n    // Method to check if eye points are valid for alignment\n    validateEyePoints(eyePoints, imageWidth, imageHeight) {\n        const { left, right } = eyePoints;\n        // Check if points are within image bounds\n        if (left[0] < 0 || left[0] > imageWidth || left[1] < 0 || left[1] > imageHeight) {\n            return false;\n        }\n        if (right[0] < 0 || right[0] > imageWidth || right[1] < 0 || right[1] > imageHeight) {\n            return false;\n        }\n        // Check if eyes are reasonably far apart\n        const eyeDistance = Math.sqrt(Math.pow(right[0] - left[0], 2) + Math.pow(right[1] - left[1], 2));\n        const minEyeDistance = Math.min(imageWidth, imageHeight) * 0.05; // 5% of smaller dimension\n        const maxEyeDistance = Math.max(imageWidth, imageHeight) * 0.8; // 80% of larger dimension\n        return eyeDistance >= minEyeDistance && eyeDistance <= maxEyeDistance;\n    }\n    // Get preview of alignment transformation\n    getAlignmentPreview(sourceImage, eyePoints, targetResolution) {\n        let previewSize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 200;\n        // Create smaller preview\n        const previewResolution = {\n            width: previewSize,\n            height: previewSize * targetResolution.height / targetResolution.width\n        };\n        return this.alignImageFull(sourceImage, eyePoints, previewResolution);\n    }\n    constructor(targetEyeDistance = 0.35, targetEyeY = 0.4){\n        this.targetEyeDistance = 0.35 // Target eye distance as proportion of canvas width\n        ;\n        this.targetEyeY = 0.4 // Target eye Y position as proportion of canvas height\n        ;\n        // Enhanced alignment features\n        this.previousTransforms = [];\n        this.smoothingFactor = 0.15 // Temporal smoothing to reduce jitter\n        ;\n        this.useSubPixelPrecision = true;\n        this.targetEyeDistance = targetEyeDistance;\n        this.targetEyeY = targetEyeY;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9pbWFnZUFsaWdubWVudC50cyIsIm1hcHBpbmdzIjoiOzs7O0FBSU8sTUFBTUE7SUFjWCw0REFBNEQ7SUFDcERDLDBCQUEwQkMsU0FBeUIsRUFBRUMsVUFBb0IsRUFBb0I7UUFDbkcsTUFBTUMsaUJBQWlCRCxXQUNwQkUsR0FBRyxDQUFDQyxDQUFBQSxNQUFPSixTQUFTLENBQUNJLElBQUksRUFDekJDLE1BQU0sQ0FBQ0MsQ0FBQUEsV0FBWUE7UUFFdEIsSUFBSUosZUFBZUssTUFBTSxLQUFLLEdBQUc7WUFDL0IsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsNEVBQTRFO1FBQzVFLElBQUlDLFlBQVksR0FBR0MsWUFBWSxHQUFHQyxjQUFjO1FBRWhEVCxlQUFlVSxPQUFPLENBQUMsQ0FBQ04sVUFBVU87WUFDaEMsbUVBQW1FO1lBQ25FLE1BQU1DLFdBQVdiLFVBQVUsQ0FBQ1ksRUFBRSxLQUFLLE1BQU1aLFVBQVUsQ0FBQ1ksRUFBRSxLQUFLLE9BQU9aLFVBQVUsQ0FBQ1ksRUFBRSxLQUFLLE9BQU9aLFVBQVUsQ0FBQ1ksRUFBRSxLQUFLO1lBQzdHLE1BQU1FLFNBQVNELFdBQVcsTUFBTSxLQUFLLGlDQUFpQztZQUV0RUwsYUFBYUgsU0FBU1UsQ0FBQyxHQUFHRDtZQUMxQkwsYUFBYUosU0FBU1csQ0FBQyxHQUFHRjtZQUMxQkosZUFBZUk7UUFDakI7UUFFQSxPQUFPO1lBQUNOLFlBQVlFO1lBQWFELFlBQVlDO1NBQVk7SUFDM0Q7SUFFQU8sV0FDRUMsV0FBNkIsRUFDN0JDLFNBQW9CLEVBQ3BCQyxnQkFBa0MsRUFDZjtRQUNuQixNQUFNQyxTQUFTQyxTQUFTQyxhQUFhLENBQUM7UUFDdENGLE9BQU9HLEtBQUssR0FBR0osaUJBQWlCSSxLQUFLO1FBQ3JDSCxPQUFPSSxNQUFNLEdBQUdMLGlCQUFpQkssTUFBTTtRQUN2QyxNQUFNQyxNQUFNTCxPQUFPTSxVQUFVLENBQUM7UUFFOUIsZ0NBQWdDO1FBQ2hDLE1BQU1D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a0JELGVBQWVFO0lBQ3pEO0lBRUEsMENBQTBDO0lBQzFDQyxvQkFDRXJJLFdBQTZCLEVBQzdCQyxTQUFvQixFQUNwQkMsZ0JBQWtDLEVBRWY7WUFEbkJvSSxjQUFBQSxpRUFBYztRQUVkLHlCQUF5QjtRQUN6QixNQUFNQyxvQkFBb0I7WUFDeEJqSSxPQUFPZ0k7WUFDUC9ILFFBQVEsY0FBZUwsaUJBQWlCSyxNQUFNLEdBQUlMLGlCQUFpQkksS0FBSztRQUMxRTtRQUVBLE9BQU8sSUFBSSxDQUFDaUQsY0FBYyxDQUFDdkQsYUFBYUMsV0FBV3NJO0lBQ3JEO0lBaGZBQyxZQUFZNUcsb0JBQW9CLElBQUksRUFBRUcsYUFBYSxHQUFHLENBQUU7YUFSaERILG9CQUFvQixLQUFNLG9EQUFvRDs7YUFDOUVHLGFBQWEsSUFBSyx1REFBdUQ7O1FBRWpGLDhCQUE4QjthQUN0QlcscUJBQTJDLEVBQUU7YUFDN0NJLGtCQUFrQixLQUFNLHNDQUFzQzs7YUFDOUQyRix1QkFBdUI7UUFHN0IsSUFBSSxDQUFDN0csaUJBQWlCLEdBQUdBO1FBQ3pCLElBQUksQ0FBQ0csVUFBVSxHQUFHQTtJQUNwQjtBQThlRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvaW1hZ2VBbGlnbm1lbnQudHM/MWQ0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeWVQb2ludHMsIEFsaWdubWVudFRyYW5zZm9ybSwgUmVzb2x1dGlvbkNvbmZpZywgRmFjZURldGVjdGlvblJlc3VsdCwgRmFjZUxhbmRtYXJrIH0gZnJvbSAnLi90eXBlcyc7XHJcblxyXG5leHBvcnQgdHlwZSBBbGlnbm1lbnRNb2RlID0gJ2Z1bGwnIHwgJ2ZhY2UtY3JvcCcgfCAnc21hcnQtZnJhbWUnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEltYWdlQWxpZ25lciB7XHJcbiAgcHJpdmF0ZSB0YXJnZXRFeWVEaXN0YW5jZSA9IDAuMzU7IC8vIFRhcmdldCBleWUgZGlzdGFuY2UgYXMgcHJvcG9ydGlvbiBvZiBjYW52YXMgd2lkdGhcclxuICBwcml2YXRlIHRhcmdldEV5ZVkgPSAwLjQ7IC8vIFRhcmdldCBleWUgWSBwb3NpdGlvbiBhcyBwcm9wb3J0aW9uIG9mIGNhbnZhcyBoZWlnaHRcclxuICBcclxuICAvLyBFbmhhbmNlZCBhbGlnbm1lbnQgZmVhdHVyZXNcclxuICBwcml2YXRlIHByZXZpb3VzVHJhbnNmb3JtczogQWxpZ25tZW50VHJhbnNmb3JtW10gPSBbXTtcclxuICBwcml2YXRlIHNtb290aGluZ0ZhY3RvciA9IDAuMTU7IC8vIFRlbXBvcmFsIHNtb290aGluZyB0byByZWR1Y2Ugaml0dGVyXHJcbiAgcHJpdmF0ZSB1c2VTdWJQaXhlbFByZWNpc2lvbiA9IHRydWU7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHRhcmdldEV5ZURpc3RhbmNlID0gMC4zNSwgdGFyZ2V0RXllWSA9IDAuNCkge1xyXG4gICAgdGhpcy50YXJnZXRFeWVEaXN0YW5jZSA9IHRhcmdldEV5ZURpc3RhbmNlO1xyXG4gICAgdGhpcy50YXJnZXRFeWVZID0gdGFyZ2V0RXllWTtcclxuICB9XHJcblxyXG4gIC8vIEVuaGFuY2VkIGV5ZSBjZW50ZXIgY2FsY3VsYXRpb24gdXNpbmcgcHVwaWwgYXBwcm94aW1hdGlvblxyXG4gIHByaXZhdGUgY2FsY3VsYXRlUHJlY2lzZUV5ZUNlbnRlcihsYW5kbWFya3M6IEZhY2VMYW5kbWFya1tdLCBleWVJbmRpY2VzOiBudW1iZXJbXSk6IFtudW1iZXIsIG51bWJlcl0ge1xyXG4gICAgY29uc3QgdmFsaWRMYW5kbWFya3MgPSBleWVJbmRpY2VzXHJcbiAgICAgIC5tYXAoaWR4ID0+IGxhbmRtYXJrc1tpZHhdKVxyXG4gICAgICAuZmlsdGVyKGxhbmRtYXJrID0+IGxhbmRtYXJrKTtcclxuXHJcbiAgICBpZiAodmFsaWRMYW5kbWFya3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgZXllIGxhbmRtYXJrcyBmb3VuZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFdlaWdodCBpbm5lciBleWUgbGFuZG1hcmtzIG1vcmUgaGVhdmlseSAoY2xvc2VyIHRvIGFjdHVhbCBwdXBpbCBwb3NpdGlvbilcclxuICAgIGxldCB3ZWlnaHRlZFggPSAwLCB3ZWlnaHRlZFkgPSAwLCB0b3RhbFdlaWdodCA9IDA7XHJcblxyXG4gICAgdmFsaWRMYW5kbWFya3MuZm9yRWFjaCgobGFuZG1hcmssIGkpID0+IHtcclxuICAgICAgLy8gSW5uZXIgbGFuZG1hcmtzIGdldCBoaWdoZXIgd2VpZ2h0IGZvciBiZXR0ZXIgcHVwaWwgYXBwcm94aW1hdGlvblxyXG4gICAgICBjb25zdCBpc0Nvcm5lciA9IGV5ZUluZGljZXNbaV0gPT09IDMzIHx8IGV5ZUluZGljZXNbaV0gPT09IDEzMyB8fCBleWVJbmRpY2VzW2ldID09PSAzNjIgfHwgZXllSW5kaWNlc1tpXSA9PT0gMjYzO1xyXG4gICAgICBjb25zdCB3ZWlnaHQgPSBpc0Nvcm5lciA/IDAuNSA6IDEuNTsgLy8gUmVkdWNlIHdlaWdodCBvZiBjb3JuZXIgcG9pbnRzXHJcbiAgICAgIFxyXG4gICAgICB3ZWlnaHRlZFggKz0gbGFuZG1hcmsueCAqIHdlaWdodDtcclxuICAgICAgd2VpZ2h0ZWRZICs9IGxhbmRtYXJrLnkgKiB3ZWlnaHQ7XHJcbiAgICAgIHRvdGFsV2VpZ2h0ICs9IHdlaWdodDtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBbd2VpZ2h0ZWRYIC8gdG90YWxXZWlnaHQsIHdlaWdodGVkWSAvIHRvdGFsV2VpZ2h0XTtcclxuICB9XHJcblxyXG4gIGFsaWduSW1hZ2UoXHJcbiAgICBzb3VyY2VJbWFnZTogSFRNTEltYWdlRWxlbWVudCxcclxuICAgIGV5ZVBvaW50czogRXllUG9pbnRzLFxyXG4gICAgdGFyZ2V0UmVzb2x1dGlvbjogUmVzb2x1dGlvbkNvbmZpZ1xyXG4gICk6IEhUTUxDYW52YXNFbGVtZW50IHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgY2FudmFzLndpZHRoID0gdGFyZ2V0UmVzb2x1dGlvbi53aWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSB0YXJnZXRSZXNvbHV0aW9uLmhlaWdodDtcclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpITtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgYWxpZ25tZW50IHRyYW5zZm9ybVxyXG4gICAgY29uc3QgdHJhbnNmb3JtID0gdGhpcy5jYWxjdWxhdGVBbGlnbm1lbnRUcmFuc2Zvcm0oXHJcbiAgICAgIGV5ZVBvaW50cyxcclxuICAgICAgdGFyZ2V0UmVzb2x1dGlvblxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBBcHBseSB0cmFuc2Zvcm1hdGlvbiBhbmQgZHJhdyBpbWFnZVxyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIGN0eC5zZXRUcmFuc2Zvcm0oXHJcbiAgICAgIHRyYW5zZm9ybS5tYXRyaXhbMF1bMF0sIHRyYW5zZm9ybS5tYXRyaXhbMF1bMV0sXHJcbiAgICAgIHRyYW5zZm9ybS5tYXRyaXhbMV1bMF0sIHRyYW5zZm9ybS5tYXRyaXhbMV1bMV0sXHJcbiAgICAgIHRyYW5zZm9ybS5tYXRyaXhbMF1bMl0sIHRyYW5zZm9ybS5tYXRyaXhbMV1bMl1cclxuICAgICk7XHJcblxyXG4gICAgY3R4LmRyYXdJbWFnZShzb3VyY2VJbWFnZSwgMCwgMCk7XHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG5cclxuICAgIHJldHVybiBjYW52YXM7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNhbGN1bGF0ZUFsaWdubWVudFRyYW5zZm9ybShcclxuICAgIGV5ZVBvaW50czogRXllUG9pbnRzLFxyXG4gICAgdGFyZ2V0UmVzb2x1dGlvbjogUmVzb2x1dGlvbkNvbmZpZ1xyXG4gICk6IEFsaWdubWVudFRyYW5zZm9ybSB7XHJcbiAgICBjb25zdCB7IGxlZnQsIHJpZ2h0IH0gPSBleWVQb2ludHM7XHJcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRhcmdldFJlc29sdXRpb247XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGN1cnJlbnQgZXllIHByb3BlcnRpZXMgd2l0aCBoaWdoZXIgcHJlY2lzaW9uXHJcbiAgICBjb25zdCBleWVDZW50ZXJYID0gKGxlZnRbMF0gKyByaWdodFswXSkgLyAyO1xyXG4gICAgY29uc3QgZXllQ2VudGVyWSA9IChsZWZ0WzFdICsgcmlnaHRbMV0pIC8gMjtcclxuICAgIGNvbnN0IGN1cnJlbnRFeWVEaXN0YW5jZSA9IE1hdGguc3FydChcclxuICAgICAgTWF0aC5wb3cocmlnaHRbMF0gLSBsZWZ0WzBdLCAyKSArIE1hdGgucG93KHJpZ2h0WzFdIC0gbGVmdFsxXSwgMilcclxuICAgICk7XHJcbiAgICBjb25zdCBleWVBbmdsZSA9IE1hdGguYXRhbjIocmlnaHRbMV0gLSBsZWZ0WzFdLCByaWdodFswXSAtIGxlZnRbMF0pO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0YXJnZXQgZXllIHByb3BlcnRpZXNcclxuICAgIGNvbnN0IHRhcmdldEV5ZURpc3RhbmNlUGl4ZWxzID0gd2lkdGggKiB0aGlzLnRhcmdldEV5ZURpc3RhbmNlO1xyXG4gICAgY29uc3QgdGFyZ2V0RXllQ2VudGVyWCA9IHdpZHRoIC8gMjtcclxuICAgIGNvbnN0IHRhcmdldEV5ZUNlbnRlclkgPSBoZWlnaHQgKiB0aGlzLnRhcmdldEV5ZVk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgY29uc3Qgc2NhbGUgPSB0YXJnZXRFeWVEaXN0YW5jZVBpeGVscyAvIGN1cnJlbnRFeWVEaXN0YW5jZTtcclxuICAgIGNvbnN0IHJvdGF0aW9uID0gLWV5ZUFuZ2xlOyAvLyBOZWdhdGl2ZSB0byBjb3VudGVyLXJvdGF0ZVxyXG5cclxuICAgIC8vIENyZWF0ZSBiYXNlIHRyYW5zZm9ybVxyXG4gICAgY29uc3QgdHJhbnNmb3JtOiBBbGlnbm1lbnRUcmFuc2Zvcm0gPSB7XHJcbiAgICAgIHJvdGF0aW9uOiByb3RhdGlvbiAqICgxODAgLyBNYXRoLlBJKSwgLy8gQ29udmVydCB0byBkZWdyZWVzXHJcbiAgICAgIHNjYWxlLFxyXG4gICAgICB0cmFuc2xhdGlvbjogW3RhcmdldEV5ZUNlbnRlclggLSBleWVDZW50ZXJYICogc2NhbGUsIHRhcmdldEV5ZUNlbnRlclkgLSBleWVDZW50ZXJZICogc2NhbGVdLFxyXG4gICAgICBtYXRyaXg6IHRoaXMuY3JlYXRlVHJhbnNmb3JtTWF0cml4KHNjYWxlLCByb3RhdGlvbiwgdGFyZ2V0RXllQ2VudGVyWCAtIGV5ZUNlbnRlclggKiBzY2FsZSwgdGFyZ2V0RXllQ2VudGVyWSAtIGV5ZUNlbnRlclkgKiBzY2FsZSlcclxuICAgIH07XHJcblxyXG4gICAgLy8gQXBwbHkgdGVtcG9yYWwgc21vb3RoaW5nIHRvIHJlZHVjZSBqaXR0ZXIgYmV0d2VlbiBmcmFtZXNcclxuICAgIHJldHVybiB0aGlzLmFwcGx5U21vb3RoaW5nVG9UcmFuc2Zvcm0odHJhbnNmb3JtKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY3JlYXRlVHJhbnNmb3JtTWF0cml4KHNjYWxlOiBudW1iZXIsIHJvdGF0aW9uOiBudW1iZXIsIHR4OiBudW1iZXIsIHR5OiBudW1iZXIpOiBudW1iZXJbXVtdIHtcclxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHJvdGF0aW9uKTtcclxuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKHJvdGF0aW9uKTtcclxuXHJcbiAgICByZXR1cm4gW1xyXG4gICAgICBbc2NhbGUgKiBjb3MsIC1zY2FsZSAqIHNpbiwgdHhdLFxyXG4gICAgICBbc2NhbGUgKiBzaW4sIHNjYWxlICogY29zLCB0eV1cclxuICAgIF07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFwcGx5U21vb3RoaW5nVG9UcmFuc2Zvcm0odHJhbnNmb3JtOiBBbGlnbm1lbnRUcmFuc2Zvcm0pOiBBbGlnbm1lbnRUcmFuc2Zvcm0ge1xyXG4gICAgaWYgKHRoaXMucHJldmlvdXNUcmFuc2Zvcm1zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aGlzLnByZXZpb3VzVHJhbnNmb3Jtcy5wdXNoKHRyYW5zZm9ybSk7XHJcbiAgICAgIHJldHVybiB0cmFuc2Zvcm07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVjZW50ID0gdGhpcy5wcmV2aW91c1RyYW5zZm9ybXNbdGhpcy5wcmV2aW91c1RyYW5zZm9ybXMubGVuZ3RoIC0gMV07XHJcbiAgICBjb25zdCBhbHBoYSA9IHRoaXMuc21vb3RoaW5nRmFjdG9yO1xyXG5cclxuICAgIGNvbnN0IHNtb290aGVkOiBBbGlnbm1lbnRUcmFuc2Zvcm0gPSB7XHJcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmludGVycG9sYXRlQW5nbGUocmVjZW50LnJvdGF0aW9uLCB0cmFuc2Zvcm0ucm90YXRpb24sIGFscGhhKSxcclxuICAgICAgc2NhbGU6IHJlY2VudC5zY2FsZSAqICgxIC0gYWxwaGEpICsgdHJhbnNmb3JtLnNjYWxlICogYWxwaGEsXHJcbiAgICAgIHRyYW5zbGF0aW9uOiBbXHJcbiAgICAgICAgcmVjZW50LnRyYW5zbGF0aW9uWzBdICogKDEgLSBhbHBoYSkgKyB0cmFuc2Zvcm0udHJhbnNsYXRpb25bMF0gKiBhbHBoYSxcclxuICAgICAgICByZWNlbnQudHJhbnNsYXRpb25bMV0gKiAoMSAtIGFscGhhKSArIHRyYW5zZm9ybS50cmFuc2xhdGlvblsxXSAqIGFscGhhXHJcbiAgICAgIF0sXHJcbiAgICAgIG1hdHJpeDogdHJhbnNmb3JtLm1hdHJpeCAvLyBSZWNhbGN1bGF0ZSBtYXRyaXggYWZ0ZXIgc21vb3RoaW5nXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJlY2FsY3VsYXRlIG1hdHJpeCB3aXRoIHNtb290aGVkIHZhbHVlc1xyXG4gICAgY29uc3QgcmFkaWFucyA9IHNtb290aGVkLnJvdGF0aW9uICogKE1hdGguUEkgLyAxODApO1xyXG4gICAgc21vb3RoZWQubWF0cml4ID0gdGhpcy5jcmVhdGVUcmFuc2Zvcm1NYXRyaXgoc21vb3RoZWQuc2NhbGUsIHJhZGlhbnMsIHNtb290aGVkLnRyYW5zbGF0aW9uWzBdLCBzbW9vdGhlZC50cmFuc2xhdGlvblsxXSk7XHJcblxyXG4gICAgdGhpcy5wcmV2aW91c1RyYW5zZm9ybXMucHVzaChzbW9vdGhlZCk7XHJcbiAgICBcclxuICAgIC8vIEtlZXAgb25seSByZWNlbnQgdHJhbnNmb3JtcyBmb3IgbWVtb3J5IGVmZmljaWVuY3lcclxuICAgIGlmICh0aGlzLnByZXZpb3VzVHJhbnNmb3Jtcy5sZW5ndGggPiAzKSB7XHJcbiAgICAgIHRoaXMucHJldmlvdXNUcmFuc2Zvcm1zLnNoaWZ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNtb290aGVkO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBpbnRlcnBvbGF0ZUFuZ2xlKGFuZ2xlMTogbnVtYmVyLCBhbmdsZTI6IG51bWJlciwgYWxwaGE6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAvLyBIYW5kbGUgYW5nbGUgd3JhcGFyb3VuZCBmb3Igc21vb3RoIHJvdGF0aW9uIGludGVycG9sYXRpb25cclxuICAgIGxldCBkaWZmID0gYW5nbGUyIC0gYW5nbGUxO1xyXG4gICAgaWYgKGRpZmYgPiAxODApIGRpZmYgLT0gMzYwO1xyXG4gICAgaWYgKGRpZmYgPCAtMTgwKSBkaWZmICs9IDM2MDtcclxuICAgIHJldHVybiBhbmdsZTEgKyBkaWZmICogYWxwaGE7XHJcbiAgfVxyXG5cclxuICAvLyBSZXNldCBzbW9vdGhpbmcgc3RhdGUgKGNhbGwgd2hlbiBwcm9jZXNzaW5nIGEgbmV3IHNldCBvZiBpbWFnZXMpXHJcbiAgcmVzZXRTbW9vdGhpbmdTdGF0ZSgpOiB2b2lkIHtcclxuICAgIHRoaXMucHJldmlvdXNUcmFuc2Zvcm1zID0gW107XHJcbiAgfVxyXG5cclxuICAvLyBGdWxsIGltYWdlIGFsaWdubWVudCBtZXRob2QgdGhhdCBwcmVzZXJ2ZXMgZW50aXJlIGltYWdlIG9uIGNhbnZhc1xyXG4gIGFsaWduSW1hZ2VGdWxsKFxyXG4gICAgc291cmNlSW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQsXHJcbiAgICBleWVQb2ludHM6IEV5ZVBvaW50cyxcclxuICAgIHRhcmdldFJlc29sdXRpb246IFJlc29sdXRpb25Db25maWdcclxuICApOiBIVE1MQ2FudmFzRWxlbWVudCB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIGNhbnZhcy53aWR0aCA9IHRhcmdldFJlc29sdXRpb24ud2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gdGFyZ2V0UmVzb2x1dGlvbi5oZWlnaHQ7XHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSE7XHJcblxyXG4gICAgY29uc3QgeyBsZWZ0LCByaWdodCB9ID0gZXllUG9pbnRzO1xyXG4gICAgY29uc3QgeyB3aWR0aDogY2FudmFzV2lkdGgsIGhlaWdodDogY2FudmFzSGVpZ2h0IH0gPSB0YXJnZXRSZXNvbHV0aW9uO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBleWUgcHJvcGVydGllcyBpbiBzb3VyY2UgaW1hZ2VcclxuICAgIGNvbnN0IGV5ZUNlbnRlclggPSAobGVmdFswXSArIHJpZ2h0WzBdKSAvIDI7XHJcbiAgICBjb25zdCBleWVDZW50ZXJZID0gKGxlZnRbMV0gKyByaWdodFsxXSkgLyAyO1xyXG4gICAgY29uc3QgZXllQW5nbGUgPSBNYXRoLmF0YW4yKHJpZ2h0WzFdIC0gbGVmdFsxXSwgcmlnaHRbMF0gLSBsZWZ0WzBdKTtcclxuICAgIGNvbnN0IGN1cnJlbnRFeWVEaXN0YW5jZSA9IE1hdGguc3FydChcclxuICAgICAgTWF0aC5wb3cocmlnaHRbMF0gLSBsZWZ0WzBdLCAyKSArIE1hdGgucG93KHJpZ2h0WzFdIC0gbGVmdFsxXSwgMilcclxuICAgICk7XHJcblxyXG4gICAgLy8gVGFyZ2V0IGV5ZSBwcm9wZXJ0aWVzIG9uIGNhbnZhc1xyXG4gICAgY29uc3QgdGFyZ2V0RXllRGlzdGFuY2UgPSBjYW52YXNXaWR0aCAqIHRoaXMudGFyZ2V0RXllRGlzdGFuY2U7XHJcbiAgICBjb25zdCB0YXJnZXRFeWVDZW50ZXJYID0gY2FudmFzV2lkdGggLyAyO1xyXG4gICAgY29uc3QgdGFyZ2V0RXllQ2VudGVyWSA9IGNhbnZhc0hlaWdodCAqIHRoaXMudGFyZ2V0RXllWTtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIHNjYWxlIGJhc2VkIG9uIGV5ZSBkaXN0YW5jZVxyXG4gICAgY29uc3QgZXllU2NhbGUgPSB0YXJnZXRFeWVEaXN0YW5jZSAvIGN1cnJlbnRFeWVEaXN0YW5jZTtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzY2FsZWQgaW1hZ2UgZGltZW5zaW9uc1xyXG4gICAgY29uc3Qgc2NhbGVkSW1hZ2VXaWR0aCA9IHNvdXJjZUltYWdlLndpZHRoICogZXllU2NhbGU7XHJcbiAgICBjb25zdCBzY2FsZWRJbWFnZUhlaWdodCA9IHNvdXJjZUltYWdlLmhlaWdodCAqIGV5ZVNjYWxlO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgZmluYWwgc2NhbGUgdG8gZml0IGVudGlyZSBpbWFnZSBvbiBjYW52YXMgaWYgbmVlZGVkXHJcbiAgICBjb25zdCBjYW52YXNGaXRTY2FsZVggPSBjYW52YXNXaWR0aCAvIHNjYWxlZEltYWdlV2lkdGg7XHJcbiAgICBjb25zdCBjYW52YXNGaXRTY2FsZVkgPSBjYW52YXNIZWlnaHQgLyBzY2FsZWRJbWFnZUhlaWdodDtcclxuICAgIGNvbnN0IGNhbnZhc0ZpdFNjYWxlID0gTWF0aC5taW4oY2FudmFzRml0U2NhbGVYLCBjYW52YXNGaXRTY2FsZVksIDEpOyAvLyBEb24ndCB1cHNjYWxlIGJleW9uZCBleWUgc2NhbGVcclxuICAgIFxyXG4gICAgLy8gRmluYWwgc2NhbGUgY29tYmluZXMgZXllIGFsaWdubWVudCBhbmQgY2FudmFzIGZpdHRpbmdcclxuICAgIGNvbnN0IGZpbmFsU2NhbGUgPSBleWVTY2FsZSAqIGNhbnZhc0ZpdFNjYWxlO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgd2hlcmUgdGhlIGltYWdlIHNob3VsZCBiZSBwb3NpdGlvbmVkIHRvIGtlZXAgZXllcyBhdCB0YXJnZXQgcG9zaXRpb25cclxuICAgIGNvbnN0IHNjYWxlZEV5ZUNlbnRlclggPSBleWVDZW50ZXJYICogZmluYWxTY2FsZTtcclxuICAgIGNvbnN0IHNjYWxlZEV5ZUNlbnRlclkgPSBleWVDZW50ZXJZICogZmluYWxTY2FsZTtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIGltYWdlIHBvc2l0aW9uICh0b3AtbGVmdCBjb3JuZXIpIHRvIHBsYWNlIGV5ZXMgYXQgdGFyZ2V0IHBvc2l0aW9uXHJcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcygtZXllQW5nbGUpO1xyXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4oLWV5ZUFuZ2xlKTtcclxuICAgIFxyXG4gICAgLy8gQXBwbHkgdHJhbnNmb3JtYXRpb25zXHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgXHJcbiAgICAvLyBDbGVhciBjYW52YXMgd2l0aCB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kXHJcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnYWxpZ25JbWFnZUZ1bGwgZGVidWc6Jywge1xyXG4gICAgICBzb3VyY2VJbWFnZVNpemU6IHsgd2lkdGg6IHNvdXJjZUltYWdlLndpZHRoLCBoZWlnaHQ6IHNvdXJjZUltYWdlLmhlaWdodCB9LFxyXG4gICAgICBjYW52YXNTaXplOiB7IHdpZHRoOiBjYW52YXNXaWR0aCwgaGVpZ2h0OiBjYW52YXNIZWlnaHQgfSxcclxuICAgICAgZXllU2NhbGUsXHJcbiAgICAgIGNhbnZhc0ZpdFNjYWxlLFxyXG4gICAgICBmaW5hbFNjYWxlLFxyXG4gICAgICBleWVDZW50ZXJYLFxyXG4gICAgICBleWVDZW50ZXJZLFxyXG4gICAgICB0YXJnZXRFeWVDZW50ZXJYLFxyXG4gICAgICB0YXJnZXRFeWVDZW50ZXJZLFxyXG4gICAgICBleWVBbmdsZTogZXllQW5nbGUgKiAoMTgwIC8gTWF0aC5QSSkgKyAnIGRlZ3JlZXMnLFxyXG4gICAgICBpbWFnZUNvbXBsZXRlOiBzb3VyY2VJbWFnZS5jb21wbGV0ZSxcclxuICAgICAgaW1hZ2VTcmM6IHNvdXJjZUltYWdlLnNyYy5zdWJzdHJpbmcoMCwgNTApICsgJy4uLidcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBWZXJpZnkgc291cmNlIGltYWdlIGhhcyBjb250ZW50IGJ5IGRyYXdpbmcgdG8gYSB0ZXN0IGNhbnZhc1xyXG4gICAgY29uc3QgdGVzdENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgdGVzdENhbnZhcy53aWR0aCA9IHNvdXJjZUltYWdlLndpZHRoO1xyXG4gICAgdGVzdENhbnZhcy5oZWlnaHQgPSBzb3VyY2VJbWFnZS5oZWlnaHQ7XHJcbiAgICBjb25zdCB0ZXN0Q3R4ID0gdGVzdENhbnZhcy5nZXRDb250ZXh0KCcyZCcpITtcclxuICAgIHRlc3RDdHguZHJhd0ltYWdlKHNvdXJjZUltYWdlLCAwLCAwKTtcclxuICAgIGNvbnN0IHRlc3RJbWFnZURhdGEgPSB0ZXN0Q3R4LmdldEltYWdlRGF0YSgwLCAwLCBzb3VyY2VJbWFnZS53aWR0aCwgc291cmNlSW1hZ2UuaGVpZ2h0KTtcclxuICAgIGNvbnN0IHNvdXJjZUhhc0NvbnRlbnQgPSB0ZXN0SW1hZ2VEYXRhLmRhdGEuc29tZSgodmFsdWUsIGluZGV4KSA9PiB7XHJcbiAgICAgIHJldHVybiBpbmRleCAlIDQgPT09IDMgJiYgdmFsdWUgPiAwOyAvLyBDaGVjayBhbHBoYSBjaGFubmVsXHJcbiAgICB9KTtcclxuICAgIGNvbnNvbGUubG9nKCdTb3VyY2UgaW1hZ2UgaGFzIGNvbnRlbnQ6Jywgc291cmNlSGFzQ29udGVudCk7XHJcbiAgICBcclxuICAgIC8vIE1vdmUgdG8gdGFyZ2V0IGV5ZSBjZW50ZXJcclxuICAgIGN0eC50cmFuc2xhdGUodGFyZ2V0RXllQ2VudGVyWCwgdGFyZ2V0RXllQ2VudGVyWSk7XHJcbiAgICBcclxuICAgIC8vIFJvdGF0ZSB0byBhbGlnbiBleWVzIGhvcml6b250YWxseVxyXG4gICAgY3R4LnJvdGF0ZSgtZXllQW5nbGUpO1xyXG4gICAgXHJcbiAgICAvLyBTY2FsZSB0byBtYXRjaCB0YXJnZXQgZXllIGRpc3RhbmNlIGFuZCBmaXQgY2FudmFzXHJcbiAgICBjdHguc2NhbGUoZmluYWxTY2FsZSwgZmluYWxTY2FsZSk7XHJcbiAgICBcclxuICAgIC8vIERyYXcgaW1hZ2UgY2VudGVyZWQgb24gZXllIGNlbnRlciBpbiB0aGUgc2NhbGVkL3JvdGF0ZWQgY29vcmRpbmF0ZSBzeXN0ZW1cclxuICAgIGN0eC5kcmF3SW1hZ2UoXHJcbiAgICAgIHNvdXJjZUltYWdlLFxyXG4gICAgICAtZXllQ2VudGVyWCxcclxuICAgICAgLWV5ZUNlbnRlclksXHJcbiAgICAgIHNvdXJjZUltYWdlLndpZHRoLFxyXG4gICAgICBzb3VyY2VJbWFnZS5oZWlnaHRcclxuICAgICk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdEcmF3SW1hZ2UgcGFyYW1ldGVyczonLCB7XHJcbiAgICAgIGR4OiAtZXllQ2VudGVyWCxcclxuICAgICAgZHk6IC1leWVDZW50ZXJZLCBcclxuICAgICAgZFdpZHRoOiBzb3VyY2VJbWFnZS53aWR0aCxcclxuICAgICAgZEhlaWdodDogc291cmNlSW1hZ2UuaGVpZ2h0LFxyXG4gICAgICBjdXJyZW50VHJhbnNmb3JtOiBjdHguZ2V0VHJhbnNmb3JtKClcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpbW1lZGlhdGVseSBpZiBkcmF3aW5nIHdvcmtlZCB3aXRoaW4gdGhlIHRyYW5zZm9ybVxyXG4gICAgY29uc3QgaW1tZWRpYXRlQ2hlY2sgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xyXG4gICAgY29uc3QgZHJld1NvbWV0aGluZyA9IGltbWVkaWF0ZUNoZWNrLmRhdGEuc29tZSgodmFsdWUsIGluZGV4KSA9PiB7XHJcbiAgICAgIHJldHVybiBpbmRleCAlIDQgPT09IDMgJiYgdmFsdWUgPiAwO1xyXG4gICAgfSk7XHJcbiAgICBjb25zb2xlLmxvZygnQ29udGVudCBleGlzdHMgaW1tZWRpYXRlbHkgYWZ0ZXIgZHJhd0ltYWdlICh3aXRoaW4gdHJhbnNmb3JtKTonLCBkcmV3U29tZXRoaW5nKTtcclxuICAgIFxyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIFxyXG4gICAgLy8gRGVidWc6IENoZWNrIGlmIGNhbnZhcyBoYXMgY29udGVudFxyXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcclxuICAgIGNvbnN0IGhhc0NvbnRlbnQgPSBpbWFnZURhdGEuZGF0YS5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgcmV0dXJuIGluZGV4ICUgNCA9PT0gMyAmJiB2YWx1ZSA+IDA7IC8vIENoZWNrIGFscGhhIGNoYW5uZWwgZm9yIG5vbi10cmFuc3BhcmVudCBwaXhlbHNcclxuICAgIH0pO1xyXG4gICAgY29uc29sZS5sb2coJ0NhbnZhcyBoYXMgY29udGVudCBhZnRlciBkcmF3aW5nOicsIGhhc0NvbnRlbnQpO1xyXG4gICAgXHJcbiAgICBpZiAoIWhhc0NvbnRlbnQpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBDYW52YXMgYXBwZWFycyB0byBiZSBlbXB0eSBhZnRlciBhbGlnbm1lbnQnKTtcclxuICAgICAgLy8gRGVidWc6IFRyeSBhIHNpbXBsZSByZWQgcmVjdGFuZ2xlIHRvIHZlcmlmeSBjYW52YXMgaXMgd29ya2luZ1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XHJcbiAgICAgIGN0eC5maWxsUmVjdCgxMCwgMTAsIDUwLCA1MCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRlZCBkZWJ1ZyByZWQgcmVjdGFuZ2xlIHRvIGVtcHR5IGNhbnZhcycpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjYW52YXM7XHJcbiAgfVxyXG5cclxuICAvLyBTbWFydCBmYWNlIGNyb3BwaW5nIGFsaWdubWVudCAtIGZvY3VzZXMgb24gZmFjZSByZWdpb24gd2hpbGUgbWFpbnRhaW5pbmcgZXllIGFsaWdubWVudFxyXG4gIGFsaWduSW1hZ2VGYWNlQ3JvcChcclxuICAgIHNvdXJjZUltYWdlOiBIVE1MSW1hZ2VFbGVtZW50LFxyXG4gICAgZmFjZVJlc3VsdDogRmFjZURldGVjdGlvblJlc3VsdCxcclxuICAgIHRhcmdldFJlc29sdXRpb246IFJlc29sdXRpb25Db25maWcsXHJcbiAgICBwYWRkaW5nOiBudW1iZXIgPSAwLjYgLy8gNjAlIHBhZGRpbmcgYXJvdW5kIGZhY2UgZm9yIGJldHRlciBmcmFtaW5nXHJcbiAgKTogSFRNTENhbnZhc0VsZW1lbnQge1xyXG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICBjYW52YXMud2lkdGggPSB0YXJnZXRSZXNvbHV0aW9uLndpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IHRhcmdldFJlc29sdXRpb24uaGVpZ2h0O1xyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykhO1xyXG5cclxuICAgIGNvbnN0IHsgZXllUG9pbnRzLCBmYWNlQm91bmRzIH0gPSBmYWNlUmVzdWx0O1xyXG4gICAgY29uc3QgeyB3aWR0aDogY2FudmFzV2lkdGgsIGhlaWdodDogY2FudmFzSGVpZ2h0IH0gPSB0YXJnZXRSZXNvbHV0aW9uO1xyXG5cclxuICAgIGlmICghZmFjZUJvdW5kcykge1xyXG4gICAgICAvLyBGYWxsYmFjayB0byBmdWxsIGFsaWdubWVudCBpZiBubyBmYWNlIGJvdW5kc1xyXG4gICAgICByZXR1cm4gdGhpcy5hbGlnbkltYWdlRnVsbChzb3VyY2VJbWFnZSwgZXllUG9pbnRzLCB0YXJnZXRSZXNvbHV0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgcGFkZGVkIGZhY2UgcmVnaW9uIHdpdGggZXh0cmEgdmVydGljYWwgcGFkZGluZ1xyXG4gICAgY29uc3QgZmFjZVdpZHRoID0gZmFjZUJvdW5kcy53aWR0aDtcclxuICAgIGNvbnN0IGZhY2VIZWlnaHQgPSBmYWNlQm91bmRzLmhlaWdodDtcclxuICAgIGNvbnN0IHBhZGRpbmdYID0gZmFjZVdpZHRoICogcGFkZGluZztcclxuICAgIGNvbnN0IHBhZGRpbmdZID0gZmFjZUhlaWdodCAqIChwYWRkaW5nICsgMC4yKTsgLy8gRXh0cmEgMjAlIHZlcnRpY2FsIHBhZGRpbmcgZm9yIGZvcmVoZWFkL2NoaW5cclxuXHJcbiAgICBjb25zdCBjcm9wTGVmdCA9IE1hdGgubWF4KDAsIGZhY2VCb3VuZHMubGVmdCAtIHBhZGRpbmdYKTtcclxuICAgIGNvbnN0IGNyb3BUb3AgPSBNYXRoLm1heCgwLCBmYWNlQm91bmRzLnRvcCAtIHBhZGRpbmdZKTtcclxuICAgIGNvbnN0IGNyb3BSaWdodCA9IE1hdGgubWluKHNvdXJjZUltYWdlLndpZHRoLCBmYWNlQm91bmRzLnJpZ2h0ICsgcGFkZGluZ1gpO1xyXG4gICAgY29uc3QgY3JvcEJvdHRvbSA9IE1hdGgubWluKHNvdXJjZUltYWdlLmhlaWdodCwgZmFjZUJvdW5kcy5ib3R0b20gKyBwYWRkaW5nWSk7XHJcblxyXG4gICAgY29uc3QgY3JvcFdpZHRoID0gY3JvcFJpZ2h0IC0gY3JvcExlZnQ7XHJcbiAgICBjb25zdCBjcm9wSGVpZ2h0ID0gY3JvcEJvdHRvbSAtIGNyb3BUb3A7XHJcblxyXG4gICAgLy8gQWRqdXN0IGV5ZSBwb2ludHMgcmVsYXRpdmUgdG8gY3JvcCByZWdpb25cclxuICAgIGNvbnN0IGFkanVzdGVkRXllUG9pbnRzOiBFeWVQb2ludHMgPSB7XHJcbiAgICAgIGxlZnQ6IFtleWVQb2ludHMubGVmdFswXSAtIGNyb3BMZWZ0LCBleWVQb2ludHMubGVmdFsxXSAtIGNyb3BUb3BdLFxyXG4gICAgICByaWdodDogW2V5ZVBvaW50cy5yaWdodFswXSAtIGNyb3BMZWZ0LCBleWVQb2ludHMucmlnaHRbMV0gLSBjcm9wVG9wXVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgZXllIHByb3BlcnRpZXMgaW4gY3JvcHBlZCByZWdpb25cclxuICAgIGNvbnN0IGV5ZUNlbnRlclggPSAoYWRqdXN0ZWRFeWVQb2ludHMubGVmdFswXSArIGFkanVzdGVkRXllUG9pbnRzLnJpZ2h0WzBdKSAvIDI7XHJcbiAgICBjb25zdCBleWVDZW50ZXJZID0gKGFkanVzdGVkRXllUG9pbnRzLmxlZnRbMV0gKyBhZGp1c3RlZEV5ZVBvaW50cy5yaWdodFsxXSkgLyAyO1xyXG4gICAgY29uc3QgZXllQW5nbGUgPSBNYXRoLmF0YW4yKFxyXG4gICAgICBhZGp1c3RlZEV5ZVBvaW50cy5yaWdodFsxXSAtIGFkanVzdGVkRXllUG9pbnRzLmxlZnRbMV0sXHJcbiAgICAgIGFkanVzdGVkRXllUG9pbnRzLnJpZ2h0WzBdIC0gYWRqdXN0ZWRFeWVQb2ludHMubGVmdFswXVxyXG4gICAgKTtcclxuICAgIGNvbnN0IGN1cnJlbnRFeWVEaXN0YW5jZSA9IE1hdGguc3FydChcclxuICAgICAgTWF0aC5wb3coYWRqdXN0ZWRFeWVQb2ludHMucmlnaHRbMF0gLSBhZGp1c3RlZEV5ZVBvaW50cy5sZWZ0WzBdLCAyKSArXHJcbiAgICAgIE1hdGgucG93KGFkanVzdGVkRXllUG9pbnRzLnJpZ2h0WzFdIC0gYWRqdXN0ZWRFeWVQb2ludHMubGVmdFsxXSwgMilcclxuICAgICk7XHJcblxyXG4gICAgLy8gVGFyZ2V0IGV5ZSBwcm9wZXJ0aWVzXHJcbiAgICBjb25zdCB0YXJnZXRFeWVEaXN0YW5jZSA9IGNhbnZhc1dpZHRoICogdGhpcy50YXJnZXRFeWVEaXN0YW5jZTtcclxuICAgIGNvbnN0IHRhcmdldEV5ZUNlbnRlclggPSBjYW52YXNXaWR0aCAvIDI7XHJcbiAgICBjb25zdCB0YXJnZXRFeWVDZW50ZXJZID0gY2FudmFzSGVpZ2h0ICogdGhpcy50YXJnZXRFeWVZO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBzY2FsZSB0byBmaXQgY3JvcHBlZCByZWdpb24gdG8gY2FudmFzXHJcbiAgICBjb25zdCBleWVTY2FsZSA9IHRhcmdldEV5ZURpc3RhbmNlIC8gY3VycmVudEV5ZURpc3RhbmNlO1xyXG4gICAgY29uc3Qgc2NhbGVUb0ZpdFggPSBjYW52YXNXaWR0aCAvIGNyb3BXaWR0aDtcclxuICAgIGNvbnN0IHNjYWxlVG9GaXRZID0gY2FudmFzSGVpZ2h0IC8gY3JvcEhlaWdodDtcclxuICAgIGNvbnN0IGZpdFNjYWxlID0gTWF0aC5taW4oc2NhbGVUb0ZpdFgsIHNjYWxlVG9GaXRZKTtcclxuICAgIFxyXG4gICAgLy8gVXNlIHRoZSBtb3JlIGFwcHJvcHJpYXRlIHNjYWxlXHJcbiAgICBjb25zdCBmaW5hbFNjYWxlID0gTWF0aC5taW4oZXllU2NhbGUsIGZpdFNjYWxlICogMS4yKTsgLy8gQWxsb3cgc2xpZ2h0IG92ZXJmbG93IGZvciBiZXR0ZXIgZnJhbWluZ1xyXG5cclxuICAgIC8vIEFwcGx5IHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdhbGlnbkltYWdlRmFjZUNyb3AgZGVidWc6Jywge1xyXG4gICAgICBjcm9wUmVnaW9uOiB7IGxlZnQ6IGNyb3BMZWZ0LCB0b3A6IGNyb3BUb3AsIHdpZHRoOiBjcm9wV2lkdGgsIGhlaWdodDogY3JvcEhlaWdodCB9LFxyXG4gICAgICBjYW52YXNTaXplOiB7IHdpZHRoOiBjYW52YXNXaWR0aCwgaGVpZ2h0OiBjYW52YXNIZWlnaHQgfSxcclxuICAgICAgZXllU2NhbGUsXHJcbiAgICAgIGZpdFNjYWxlLFxyXG4gICAgICBmaW5hbFNjYWxlLFxyXG4gICAgICBleWVDZW50ZXJYLFxyXG4gICAgICBleWVDZW50ZXJZLFxyXG4gICAgICB0YXJnZXRFeWVDZW50ZXJYLFxyXG4gICAgICB0YXJnZXRFeWVDZW50ZXJZLFxyXG4gICAgICBleWVBbmdsZTogZXllQW5nbGUgKiAoMTgwIC8gTWF0aC5QSSkgKyAnIGRlZ3JlZXMnXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBNb3ZlIHRvIHRhcmdldCBleWUgY2VudGVyXHJcbiAgICBjdHgudHJhbnNsYXRlKHRhcmdldEV5ZUNlbnRlclgsIHRhcmdldEV5ZUNlbnRlclkpO1xyXG5cclxuICAgIC8vIFJvdGF0ZSB0byBhbGlnbiBleWVzIGhvcml6b250YWxseVxyXG4gICAgY3R4LnJvdGF0ZSgtZXllQW5nbGUpO1xyXG5cclxuICAgIC8vIFNjYWxlIHRoZSBjcm9wcGVkIHJlZ2lvblxyXG4gICAgY3R4LnNjYWxlKGZpbmFsU2NhbGUsIGZpbmFsU2NhbGUpO1xyXG5cclxuICAgIC8vIERyYXcgdGhlIGNyb3BwZWQgcmVnaW9uIGNlbnRlcmVkIG9uIGV5ZSBjZW50ZXJcclxuICAgIGN0eC5kcmF3SW1hZ2UoXHJcbiAgICAgIHNvdXJjZUltYWdlLFxyXG4gICAgICBjcm9wTGVmdCwgY3JvcFRvcCwgY3JvcFdpZHRoLCBjcm9wSGVpZ2h0LCAvLyBTb3VyY2UgY3JvcFxyXG4gICAgICAtZXllQ2VudGVyWCwgLWV5ZUNlbnRlclksIGNyb3BXaWR0aCwgY3JvcEhlaWdodCAvLyBEZXN0aW5hdGlvblxyXG4gICAgKTtcclxuXHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgXHJcbiAgICAvLyBEZWJ1ZzogQ2hlY2sgaWYgY2FudmFzIGhhcyBjb250ZW50XHJcbiAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xyXG4gICAgY29uc3QgaGFzQ29udGVudCA9IGltYWdlRGF0YS5kYXRhLnNvbWUoKHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICByZXR1cm4gaW5kZXggJSA0ID09PSAzICYmIHZhbHVlID4gMDsgLy8gQ2hlY2sgYWxwaGEgY2hhbm5lbCBmb3Igbm9uLXRyYW5zcGFyZW50IHBpeGVsc1xyXG4gICAgfSk7XHJcbiAgICBjb25zb2xlLmxvZygnQ2FudmFzIGhhcyBjb250ZW50IGFmdGVyIGZhY2UgY3JvcCBkcmF3aW5nOicsIGhhc0NvbnRlbnQpO1xyXG4gICAgXHJcbiAgICBpZiAoIWhhc0NvbnRlbnQpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBGYWNlIGNyb3AgY2FudmFzIGFwcGVhcnMgdG8gYmUgZW1wdHkgYWZ0ZXIgYWxpZ25tZW50Jyk7XHJcbiAgICAgIC8vIERlYnVnOiBUcnkgYSBzaW1wbGUgYmx1ZSByZWN0YW5nbGUgdG8gdmVyaWZ5IGNhbnZhcyBpcyB3b3JraW5nXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnYmx1ZSc7XHJcbiAgICAgIGN0eC5maWxsUmVjdCgxMCwgMTAsIDUwLCA1MCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRlZCBkZWJ1ZyBibHVlIHJlY3RhbmdsZSB0byBlbXB0eSBmYWNlIGNyb3AgY2FudmFzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNhbnZhcztcclxuICB9XHJcblxyXG4gIC8vIEFsdGVybmF0aXZlIHNpbXBsZXIgYWxpZ25tZW50IG1ldGhvZCB1c2luZyBjYW52YXMgdHJhbnNmb3Jtc1xyXG4gIGFsaWduSW1hZ2VTaW1wbGUoXHJcbiAgICBzb3VyY2VJbWFnZTogSFRNTEltYWdlRWxlbWVudCxcclxuICAgIGV5ZVBvaW50czogRXllUG9pbnRzLFxyXG4gICAgdGFyZ2V0UmVzb2x1dGlvbjogUmVzb2x1dGlvbkNvbmZpZ1xyXG4gICk6IEhUTUxDYW52YXNFbGVtZW50IHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgY2FudmFzLndpZHRoID0gdGFyZ2V0UmVzb2x1dGlvbi53aWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSB0YXJnZXRSZXNvbHV0aW9uLmhlaWdodDtcclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpITtcclxuXHJcbiAgICBjb25zdCB7IGxlZnQsIHJpZ2h0IH0gPSBleWVQb2ludHM7XHJcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRhcmdldFJlc29sdXRpb247XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGV5ZSBjZW50ZXIgYW5kIGFuZ2xlXHJcbiAgICBjb25zdCBleWVDZW50ZXJYID0gKGxlZnRbMF0gKyByaWdodFswXSkgLyAyO1xyXG4gICAgY29uc3QgZXllQ2VudGVyWSA9IChsZWZ0WzFdICsgcmlnaHRbMV0pIC8gMjtcclxuICAgIGNvbnN0IGV5ZUFuZ2xlID0gTWF0aC5hdGFuMihyaWdodFsxXSAtIGxlZnRbMV0sIHJpZ2h0WzBdIC0gbGVmdFswXSk7XHJcbiAgICBjb25zdCBjdXJyZW50RXllRGlzdGFuY2UgPSBNYXRoLnNxcnQoXHJcbiAgICAgIE1hdGgucG93KHJpZ2h0WzBdIC0gbGVmdFswXSwgMikgKyBNYXRoLnBvdyhyaWdodFsxXSAtIGxlZnRbMV0sIDIpXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFRhcmdldCBwcm9wZXJ0aWVzXHJcbiAgICBjb25zdCB0YXJnZXRFeWVEaXN0YW5jZSA9IHdpZHRoICogdGhpcy50YXJnZXRFeWVEaXN0YW5jZTtcclxuICAgIGNvbnN0IHRhcmdldENlbnRlclggPSB3aWR0aCAvIDI7XHJcbiAgICBjb25zdCB0YXJnZXRDZW50ZXJZID0gaGVpZ2h0ICogdGhpcy50YXJnZXRFeWVZO1xyXG4gICAgY29uc3Qgc2NhbGUgPSB0YXJnZXRFeWVEaXN0YW5jZSAvIGN1cnJlbnRFeWVEaXN0YW5jZTtcclxuXHJcbiAgICAvLyBBcHBseSB0cmFuc2Zvcm1hdGlvbnNcclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBcclxuICAgIC8vIE1vdmUgdG8gdGFyZ2V0IGNlbnRlclxyXG4gICAgY3R4LnRyYW5zbGF0ZSh0YXJnZXRDZW50ZXJYLCB0YXJnZXRDZW50ZXJZKTtcclxuICAgIFxyXG4gICAgLy8gUm90YXRlIHRvIGFsaWduIGV5ZXMgaG9yaXpvbnRhbGx5XHJcbiAgICBjdHgucm90YXRlKC1leWVBbmdsZSk7XHJcbiAgICBcclxuICAgIC8vIFNjYWxlIHRvIG1hdGNoIHRhcmdldCBleWUgZGlzdGFuY2VcclxuICAgIGN0eC5zY2FsZShzY2FsZSwgc2NhbGUpO1xyXG4gICAgXHJcbiAgICAvLyBEcmF3IGltYWdlIGNlbnRlcmVkIG9uIGV5ZSBjZW50ZXJcclxuICAgIGN0eC5kcmF3SW1hZ2UoXHJcbiAgICAgIHNvdXJjZUltYWdlLFxyXG4gICAgICAtZXllQ2VudGVyWCxcclxuICAgICAgLWV5ZUNlbnRlcllcclxuICAgICk7XHJcbiAgICBcclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcblxyXG4gICAgcmV0dXJuIGNhbnZhcztcclxuICB9XHJcblxyXG4gIC8vIE1ldGhvZCB0byBjaGVjayBpZiBleWUgcG9pbnRzIGFyZSB2YWxpZCBmb3IgYWxpZ25tZW50XHJcbiAgdmFsaWRhdGVFeWVQb2ludHMoZXllUG9pbnRzOiBFeWVQb2ludHMsIGltYWdlV2lkdGg6IG51bWJlciwgaW1hZ2VIZWlnaHQ6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgeyBsZWZ0LCByaWdodCB9ID0gZXllUG9pbnRzO1xyXG5cclxuICAgIC8vIENoZWNrIGlmIHBvaW50cyBhcmUgd2l0aGluIGltYWdlIGJvdW5kc1xyXG4gICAgaWYgKGxlZnRbMF0gPCAwIHx8IGxlZnRbMF0gPiBpbWFnZVdpZHRoIHx8IGxlZnRbMV0gPCAwIHx8IGxlZnRbMV0gPiBpbWFnZUhlaWdodCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAocmlnaHRbMF0gPCAwIHx8IHJpZ2h0WzBdID4gaW1hZ2VXaWR0aCB8fCByaWdodFsxXSA8IDAgfHwgcmlnaHRbMV0gPiBpbWFnZUhlaWdodCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgZXllcyBhcmUgcmVhc29uYWJseSBmYXIgYXBhcnRcclxuICAgIGNvbnN0IGV5ZURpc3RhbmNlID0gTWF0aC5zcXJ0KFxyXG4gICAgICBNYXRoLnBvdyhyaWdodFswXSAtIGxlZnRbMF0sIDIpICsgTWF0aC5wb3cocmlnaHRbMV0gLSBsZWZ0WzFdLCAyKVxyXG4gICAgKTtcclxuICAgIGNvbnN0IG1pbkV5ZURpc3RhbmNlID0gTWF0aC5taW4oaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQpICogMC4wNTsgLy8gNSUgb2Ygc21hbGxlciBkaW1lbnNpb25cclxuICAgIGNvbnN0IG1heEV5ZURpc3RhbmNlID0gTWF0aC5tYXgoaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQpICogMC44OyAgLy8gODAlIG9mIGxhcmdlciBkaW1lbnNpb25cclxuXHJcbiAgICByZXR1cm4gZXllRGlzdGFuY2UgPj0gbWluRXllRGlzdGFuY2UgJiYgZXllRGlzdGFuY2UgPD0gbWF4RXllRGlzdGFuY2U7XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgcHJldmlldyBvZiBhbGlnbm1lbnQgdHJhbnNmb3JtYXRpb25cclxuICBnZXRBbGlnbm1lbnRQcmV2aWV3KFxyXG4gICAgc291cmNlSW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQsXHJcbiAgICBleWVQb2ludHM6IEV5ZVBvaW50cyxcclxuICAgIHRhcmdldFJlc29sdXRpb246IFJlc29sdXRpb25Db25maWcsXHJcbiAgICBwcmV2aWV3U2l6ZSA9IDIwMFxyXG4gICk6IEhUTUxDYW52YXNFbGVtZW50IHtcclxuICAgIC8vIENyZWF0ZSBzbWFsbGVyIHByZXZpZXdcclxuICAgIGNvbnN0IHByZXZpZXdSZXNvbHV0aW9uID0ge1xyXG4gICAgICB3aWR0aDogcHJldmlld1NpemUsXHJcbiAgICAgIGhlaWdodDogKHByZXZpZXdTaXplICogdGFyZ2V0UmVzb2x1dGlvbi5oZWlnaHQpIC8gdGFyZ2V0UmVzb2x1dGlvbi53aWR0aFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5hbGlnbkltYWdlRnVsbChzb3VyY2VJbWFnZSwgZXllUG9pbnRzLCBwcmV2aWV3UmVzb2x1dGlvbik7XHJcbiAgfVxyXG59Il0sIm5hbWVzIjpbIkltYWdlQWxpZ25lciIsImNhbGN1bGF0ZVByZWNpc2VFeWVDZW50ZXIiLCJsYW5kbWFya3MiLCJleWVJbmRpY2VzIiwidmFsaWRMYW5kbWFya3MiLCJtYXAiLCJpZHgiLCJmaWx0ZXIiLCJsYW5kbWFyayIsImxlbmd0aCIsIkVycm9yIiwid2VpZ2h0ZWRYIiwid2VpZ2h0ZWRZIiwidG90YWxXZWlnaHQiLCJmb3JFYWNoIiwiaSIsImlzQ29ybmVyIiwid2VpZ2h0IiwieCIsInkiLCJhbGlnbkltYWdlIiwic291cmNlSW1hZ2UiLCJleWVQb2ludHMiLCJ0YXJnZXRSZXNvbHV0aW9uIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwid2lkdGgiLCJoZWlnaHQiLCJjdHgiLCJnZXRDb250ZXh0IiwidHJhbnNmb3JtIiwiY2FsY3VsYXRlQWxpZ25tZW50VHJhbnNmb3JtIiwic2F2ZSIsInNldFRyYW5zZm9ybSIsIm1hdHJpeCIsImRyYXdJbWFnZSIsInJlc3RvcmUiLCJsZWZ0IiwicmlnaHQiLCJleWVDZW50ZXJYIiwiZXllQ2VudGVyWSIsImN1cnJlbnRFeWVEaXN0YW5jZSIsIk1hdGgiLCJzcXJ0IiwicG93IiwiZXllQW5nbGUiLCJhdGFuMiIsInRhcmdldEV5ZURpc3RhbmNlUGl4ZWxzIiwidGFyZ2V0RXllRGlzdGFuY2UiLCJ0YXJnZXRFeWVDZW50ZXJYIiwidGFyZ2V0RXllQ2VudGVyWSIsInRhcmdldEV5ZVkiLCJzY2FsZSIsInJvdGF0aW9uIiwiUEkiLCJ0cmFuc2xhdGlvbiIsImNyZWF0ZVRyYW5zZm9ybU1hdHJpeCIsImFwcGx5U21vb3RoaW5nVG9UcmFuc2Zvcm0iLCJ0eCIsInR5IiwiY29zIiwic2luIiwicHJldmlvdXNUcmFuc2Zvcm1zIiwicHVzaCIsInJlY2VudCIsImFscGhhIiwic21vb3RoaW5nRmFjdG9yIiwic21vb3RoZWQiLCJpbnRlcnBvbGF0ZUFuZ2xlIiwicmFkaWFucyIsInNoaWZ0IiwiYW5nbGUxIiwiYW5nbGUyIiwiZGlmZiIsInJlc2V0U21vb3RoaW5nU3RhdGUiLCJhbGlnbkltYWdlRnVsbCIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiZXllU2NhbGUiLCJzY2FsZWRJbWFnZVdpZHRoIiwic2NhbGVkSW1hZ2VIZWlnaHQiLCJjYW52YXNGaXRTY2FsZVgiLCJjYW52YXNGaXRTY2FsZVkiLCJjYW52YXNGaXRTY2FsZSIsIm1pbiIsImZpbmFsU2NhbGUiLCJzY2FsZWRFeWVDZW50ZXJYIiwic2NhbGVkRXllQ2VudGVyWSIsImNsZWFyUmVjdCIsImNvbnNvbGUiLCJsb2ciLCJzb3VyY2VJbWFnZVNpemUiLCJjYW52YXNTaXplIiwiaW1hZ2VDb21wbGV0ZSIsImNvbXBsZXRlIiwiaW1hZ2VTcmMiLCJzcmMiLCJzdWJzdHJpbmciLCJ0ZXN0Q2FudmFzIiwidGVzdEN0eCIsInRlc3RJbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJzb3VyY2VIYXNDb250ZW50IiwiZGF0YSIsInNvbWUiLCJ2YWx1ZSIsImluZGV4IiwidHJhbnNsYXRlIiwicm90YXRlIiwiZHgiLCJkeSIsImRXaWR0aCIsImRIZWlnaHQiLCJjdXJyZW50VHJhbnNmb3JtIiwiZ2V0VHJhbnNmb3JtIiwiaW1tZWRpYXRlQ2hlY2siLCJkcmV3U29tZXRoaW5nIiwiaW1hZ2VEYXRhIiwiaGFzQ29udGVudCIsIndhcm4iLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImFsaWduSW1hZ2VGYWNlQ3JvcCIsImZhY2VSZXN1bHQiLCJwYWRkaW5nIiwiZmFjZUJvdW5kcyIsImZhY2VXaWR0aCIsImZhY2VIZWlnaHQiLCJwYWRkaW5nWCIsInBhZGRpbmdZIiwiY3JvcExlZnQiLCJtYXgiLCJjcm9wVG9wIiwidG9wIiwiY3JvcFJpZ2h0IiwiY3JvcEJvdHRvbSIsImJvdHRvbSIsImNyb3BXaWR0aCIsImNyb3BIZWlnaHQiLCJhZGp1c3RlZEV5ZVBvaW50cyIsInNjYWxlVG9GaXRYIiwic2NhbGVUb0ZpdFkiLCJmaXRTY2FsZSIsImNyb3BSZWdpb24iLCJhbGlnbkltYWdlU2ltcGxlIiwidGFyZ2V0Q2VudGVyWCIsInRhcmdldENlbnRlclkiLCJ2YWxpZGF0ZUV5ZVBvaW50cyIsImltYWdlV2lkdGgiLCJpbWFnZUhlaWdodCIsImV5ZURpc3RhbmNlIiwibWluRXllRGlzdGFuY2UiLCJtYXhFeWVEaXN0YW5jZSIsImdldEFsaWdubWVudFByZXZpZXciLCJwcmV2aWV3U2l6ZSIsInByZXZpZXdSZXNvbHV0aW9uIiwiY29uc3RydWN0b3IiLCJ1c2VTdWJQaXhlbFByZWNpc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/imageAlignment.ts\n"));

/***/ })

});