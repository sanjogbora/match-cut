"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/imageAlignment.ts":
/*!*******************************!*\
  !*** ./lib/imageAlignment.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImageAligner: function() { return /* binding */ ImageAligner; }\n/* harmony export */ });\nclass ImageAligner {\n    // Enhanced eye center calculation using pupil approximation\n    calculatePreciseEyeCenter(landmarks, eyeIndices) {\n        const validLandmarks = eyeIndices.map((idx)=>landmarks[idx]).filter((landmark)=>landmark);\n        if (validLandmarks.length === 0) {\n            throw new Error(\"No valid eye landmarks found\");\n        }\n        // Weight inner eye landmarks more heavily (closer to actual pupil position)\n        let weightedX = 0, weightedY = 0, totalWeight = 0;\n        validLandmarks.forEach((landmark, i)=>{\n            // Inner landmarks get higher weight for better pupil approximation\n            const isCorner = eyeIndices[i] === 33 || eyeIndices[i] === 133 || eyeIndices[i] === 362 || eyeIndices[i] === 263;\n            const weight = isCorner ? 0.5 : 1.5; // Reduce weight of corner points\n            weightedX += landmark.x * weight;\n            weightedY += landmark.y * weight;\n            totalWeight += weight;\n        });\n        return [\n            weightedX / totalWeight,\n            weightedY / totalWeight\n        ];\n    }\n    alignImage(sourceImage, eyePoints, targetResolution) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = targetResolution.width;\n        canvas.height = targetResolution.height;\n        const ctx = canvas.getContext(\"2d\");\n        // Calculate alignment transform\n        const transform = this.calculateAlignmentTransform(eyePoints, targetResolution);\n        // Apply transformation and draw image\n        ctx.save();\n        ctx.setTransform(transform.matrix[0][0], transform.matrix[0][1], transform.matrix[1][0], transform.matrix[1][1], transform.matrix[0][2], transform.matrix[1][2]);\n        ctx.drawImage(sourceImage, 0, 0);\n        ctx.restore();\n        return canvas;\n    }\n    calculateAlignmentTransform(eyePoints, targetResolution) {\n        const { left, right } = eyePoints;\n        const { width, height } = targetResolution;\n        // Calculate current eye properties\n        const eyeCenterX = (left[0] + right[0]) / 2;\n        const eyeCenterY = (left[1] + right[1]) / 2;\n        const currentEyeDistance = Math.sqrt(Math.pow(right[0] - left[0], 2) + Math.pow(right[1] - left[1], 2));\n        const eyeAngle = Math.atan2(right[1] - left[1], right[0] - left[0]);\n        // Calculate target eye properties\n        const targetEyeDistancePixels = width * this.targetEyeDistance;\n        const targetEyeCenterX = width / 2;\n        const targetEyeCenterY = height * this.targetEyeY;\n        // Calculate transformations\n        const scale = targetEyeDistancePixels / currentEyeDistance;\n        const rotation = -eyeAngle; // Negative to counter-rotate\n        // Create transformation matrix\n        const cos = Math.cos(rotation);\n        const sin = Math.sin(rotation);\n        // Translation to center eyes at origin\n        const tx1 = -eyeCenterX;\n        const ty1 = -eyeCenterY;\n        // Scale and rotate\n        const scaleRotateMatrix = [\n            [\n                scale * cos,\n                -scale * sin\n            ],\n            [\n                scale * sin,\n                scale * cos\n            ]\n        ];\n        // Translation to target position\n        const tx2 = targetEyeCenterX;\n        const ty2 = targetEyeCenterY;\n        // Combine transformations: translate -> scale/rotate -> translate\n        const matrix = [\n            [\n                scaleRotateMatrix[0][0],\n                scaleRotateMatrix[0][1],\n                scaleRotateMatrix[0][0] * tx1 + scaleRotateMatrix[0][1] * ty1 + tx2\n            ],\n            [\n                scaleRotateMatrix[1][0],\n                scaleRotateMatrix[1][1],\n                scaleRotateMatrix[1][0] * tx1 + scaleRotateMatrix[1][1] * ty1 + ty2\n            ]\n        ];\n        return {\n            rotation: rotation * (180 / Math.PI),\n            scale,\n            translation: [\n                tx2 - eyeCenterX * scale,\n                ty2 - eyeCenterY * scale\n            ],\n            matrix\n        };\n    }\n    // Full image alignment method that preserves entire image on canvas\n    alignImageFull(sourceImage, eyePoints, targetResolution) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = targetResolution.width;\n        canvas.height = targetResolution.height;\n        const ctx = canvas.getContext(\"2d\");\n        const { left, right } = eyePoints;\n        const { width: canvasWidth, height: canvasHeight } = targetResolution;\n        // Calculate eye properties in source image\n        const eyeCenterX = (left[0] + right[0]) / 2;\n        const eyeCenterY = (left[1] + right[1]) / 2;\n        const eyeAngle = Math.atan2(right[1] - left[1], right[0] - left[0]);\n        const currentEyeDistance = Math.sqrt(Math.pow(right[0] - left[0], 2) + Math.pow(right[1] - left[1], 2));\n        // Target eye properties on canvas\n        const targetEyeDistance = canvasWidth * this.targetEyeDistance;\n        const targetEyeCenterX = canvasWidth / 2;\n        const targetEyeCenterY = canvasHeight * this.targetEyeY;\n        // Calculate scale based on eye distance\n        const eyeScale = targetEyeDistance / currentEyeDistance;\n        // Calculate the scaled image dimensions\n        const scaledImageWidth = sourceImage.width * eyeScale;\n        const scaledImageHeight = sourceImage.height * eyeScale;\n        // Calculate final scale to fit entire image on canvas if needed\n        const canvasFitScaleX = canvasWidth / scaledImageWidth;\n        const canvasFitScaleY = canvasHeight / scaledImageHeight;\n        const canvasFitScale = Math.min(canvasFitScaleX, canvasFitScaleY, 1); // Don't upscale beyond eye scale\n        // Final scale combines eye alignment and canvas fitting\n        const finalScale = eyeScale * canvasFitScale;\n        // Calculate where the image should be positioned to keep eyes at target position\n        const scaledEyeCenterX = eyeCenterX * finalScale;\n        const scaledEyeCenterY = eyeCenterY * finalScale;\n        // Calculate image position (top-left corner) to place eyes at target position\n        const cos = Math.cos(-eyeAngle);\n        const sin = Math.sin(-eyeAngle);\n        // Apply transformations\n        ctx.save();\n        // Clear canvas with transparent background\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        console.log(\"alignImageFull debug:\", {\n            sourceImageSize: {\n                width: sourceImage.width,\n                height: sourceImage.height\n            },\n            canvasSize: {\n                width: canvasWidth,\n                height: canvasHeight\n            },\n            eyeScale,\n            canvasFitScale,\n            finalScale,\n            eyeCenterX,\n            eyeCenterY,\n            targetEyeCenterX,\n            targetEyeCenterY,\n            eyeAngle: eyeAngle * (180 / Math.PI) + \" degrees\",\n            imageComplete: sourceImage.complete,\n            imageSrc: sourceImage.src.substring(0, 50) + \"...\"\n        });\n        // Verify source image has content by drawing to a test canvas\n        const testCanvas = document.createElement(\"canvas\");\n        testCanvas.width = sourceImage.width;\n        testCanvas.height = sourceImage.height;\n        const testCtx = testCanvas.getContext(\"2d\");\n        testCtx.drawImage(sourceImage, 0, 0);\n        const testImageData = testCtx.getImageData(0, 0, sourceImage.width, sourceImage.height);\n        const sourceHasContent = testImageData.data.some((value, index)=>{\n            return index % 4 === 3 && value > 0; // Check alpha channel\n        });\n        console.log(\"Source image has content:\", sourceHasContent);\n        // Move to target eye center\n        ctx.translate(targetEyeCenterX, targetEyeCenterY);\n        // Rotate to align eyes horizontally\n        ctx.rotate(-eyeAngle);\n        // Scale to match target eye distance and fit canvas\n        ctx.scale(finalScale, finalScale);\n        // Draw image centered on eye center in the scaled/rotated coordinate system\n        ctx.drawImage(sourceImage, -eyeCenterX, -eyeCenterY, sourceImage.width, sourceImage.height);\n        console.log(\"DrawImage parameters:\", {\n            dx: -eyeCenterX,\n            dy: -eyeCenterY,\n            dWidth: sourceImage.width,\n            dHeight: sourceImage.height,\n            currentTransform: ctx.getTransform()\n        });\n        // Check immediately if drawing worked within the transform\n        const immediateCheck = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n        const drewSomething = immediateCheck.data.some((value, index)=>{\n            return index % 4 === 3 && value > 0;\n        });\n        console.log(\"Content exists immediately after drawImage (within transform):\", drewSomething);\n        ctx.restore();\n        // Debug: Check if canvas has content\n        const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n        const hasContent = imageData.data.some((value, index)=>{\n            return index % 4 === 3 && value > 0; // Check alpha channel for non-transparent pixels\n        });\n        console.log(\"Canvas has content after drawing:\", hasContent);\n        if (!hasContent) {\n            console.warn(\"WARNING: Canvas appears to be empty after alignment\");\n            // Debug: Try a simple red rectangle to verify canvas is working\n            ctx.fillStyle = \"red\";\n            ctx.fillRect(10, 10, 50, 50);\n            console.log(\"Added debug red rectangle to empty canvas\");\n        }\n        return canvas;\n    }\n    // Smart face cropping alignment - focuses on face region while maintaining eye alignment\n    alignImageFaceCrop(sourceImage, faceResult, targetResolution) {\n        let padding = arguments.length > 3 && arguments[3] !== void 0 // 60% padding around face for better framing\n         ? arguments[3] : 0.6;\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = targetResolution.width;\n        canvas.height = targetResolution.height;\n        const ctx = canvas.getContext(\"2d\");\n        const { eyePoints, faceBounds } = faceResult;\n        const { width: canvasWidth, height: canvasHeight } = targetResolution;\n        if (!faceBounds) {\n            // Fallback to full alignment if no face bounds\n            return this.alignImageFull(sourceImage, eyePoints, targetResolution);\n        }\n        // Calculate padded face region with extra vertical padding\n        const faceWidth = faceBounds.width;\n        const faceHeight = faceBounds.height;\n        const paddingX = faceWidth * padding;\n        const paddingY = faceHeight * (padding + 0.2); // Extra 20% vertical padding for forehead/chin\n        const cropLeft = Math.max(0, faceBounds.left - paddingX);\n        const cropTop = Math.max(0, faceBounds.top - paddingY);\n        const cropRight = Math.min(sourceImage.width, faceBounds.right + paddingX);\n        const cropBottom = Math.min(sourceImage.height, faceBounds.bottom + paddingY);\n        const cropWidth = cropRight - cropLeft;\n        const cropHeight = cropBottom - cropTop;\n        // Adjust eye points relative to crop region\n        const adjustedEyePoints = {\n            left: [\n                eyePoints.left[0] - cropLeft,\n                eyePoints.left[1] - cropTop\n            ],\n            right: [\n                eyePoints.right[0] - cropLeft,\n                eyePoints.right[1] - cropTop\n            ]\n        };\n        // Calculate eye properties in cropped region\n        const eyeCenterX = (adjustedEyePoints.left[0] + adjustedEyePoints.right[0]) / 2;\n        const eyeCenterY = (adjustedEyePoints.left[1] + adjustedEyePoints.right[1]) / 2;\n        const eyeAngle = Math.atan2(adjustedEyePoints.right[1] - adjustedEyePoints.left[1], adjustedEyePoints.right[0] - adjustedEyePoints.left[0]);\n        const currentEyeDistance = Math.sqrt(Math.pow(adjustedEyePoints.right[0] - adjustedEyePoints.left[0], 2) + Math.pow(adjustedEyePoints.right[1] - adjustedEyePoints.left[1], 2));\n        // Target eye properties\n        const targetEyeDistance = canvasWidth * this.targetEyeDistance;\n        const targetEyeCenterX = canvasWidth / 2;\n        const targetEyeCenterY = canvasHeight * this.targetEyeY;\n        // Calculate scale to fit cropped region to canvas\n        const eyeScale = targetEyeDistance / currentEyeDistance;\n        const scaleToFitX = canvasWidth / cropWidth;\n        const scaleToFitY = canvasHeight / cropHeight;\n        const fitScale = Math.min(scaleToFitX, scaleToFitY);\n        // Use the more appropriate scale\n        const finalScale = Math.min(eyeScale, fitScale * 1.2); // Allow slight overflow for better framing\n        // Apply transformations\n        ctx.save();\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        console.log(\"alignImageFaceCrop debug:\", {\n            cropRegion: {\n                left: cropLeft,\n                top: cropTop,\n                width: cropWidth,\n                height: cropHeight\n            },\n            canvasSize: {\n                width: canvasWidth,\n                height: canvasHeight\n            },\n            eyeScale,\n            fitScale,\n            finalScale,\n            eyeCenterX,\n            eyeCenterY,\n            targetEyeCenterX,\n            targetEyeCenterY,\n            eyeAngle: eyeAngle * (180 / Math.PI) + \" degrees\"\n        });\n        // Move to target eye center\n        ctx.translate(targetEyeCenterX, targetEyeCenterY);\n        // Rotate to align eyes horizontally\n        ctx.rotate(-eyeAngle);\n        // Scale the cropped region\n        ctx.scale(finalScale, finalScale);\n        // Draw the cropped region centered on eye center\n        ctx.drawImage(sourceImage, cropLeft, cropTop, cropWidth, cropHeight, -eyeCenterX, -eyeCenterY, cropWidth, cropHeight // Destination\n        );\n        ctx.restore();\n        // Debug: Check if canvas has content\n        const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n        const hasContent = imageData.data.some((value, index)=>{\n            return index % 4 === 3 && value > 0; // Check alpha channel for non-transparent pixels\n        });\n        console.log(\"Canvas has content after face crop drawing:\", hasContent);\n        if (!hasContent) {\n            console.warn(\"WARNING: Face crop canvas appears to be empty after alignment\");\n            // Debug: Try a simple blue rectangle to verify canvas is working\n            ctx.fillStyle = \"blue\";\n            ctx.fillRect(10, 10, 50, 50);\n            console.log(\"Added debug blue rectangle to empty face crop canvas\");\n        }\n        return canvas;\n    }\n    // Alternative simpler alignment method using canvas transforms\n    alignImageSimple(sourceImage, eyePoints, targetResolution) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = targetResolution.width;\n        canvas.height = targetResolution.height;\n        const ctx = canvas.getContext(\"2d\");\n        const { left, right } = eyePoints;\n        const { width, height } = targetResolution;\n        // Calculate eye center and angle\n        const eyeCenterX = (left[0] + right[0]) / 2;\n        const eyeCenterY = (left[1] + right[1]) / 2;\n        const eyeAngle = Math.atan2(right[1] - left[1], right[0] - left[0]);\n        const currentEyeDistance = Math.sqrt(Math.pow(right[0] - left[0], 2) + Math.pow(right[1] - left[1], 2));\n        // Target properties\n        const targetEyeDistance = width * this.targetEyeDistance;\n        const targetCenterX = width / 2;\n        const targetCenterY = height * this.targetEyeY;\n        const scale = targetEyeDistance / currentEyeDistance;\n        // Apply transformations\n        ctx.save();\n        // Move to target center\n        ctx.translate(targetCenterX, targetCenterY);\n        // Rotate to align eyes horizontally\n        ctx.rotate(-eyeAngle);\n        // Scale to match target eye distance\n        ctx.scale(scale, scale);\n        // Draw image centered on eye center\n        ctx.drawImage(sourceImage, -eyeCenterX, -eyeCenterY);\n        ctx.restore();\n        return canvas;\n    }\n    // Method to check if eye points are valid for alignment\n    validateEyePoints(eyePoints, imageWidth, imageHeight) {\n        const { left, right } = eyePoints;\n        // Check if points are within image bounds\n        if (left[0] < 0 || left[0] > imageWidth || left[1] < 0 || left[1] > imageHeight) {\n            return false;\n        }\n        if (right[0] < 0 || right[0] > imageWidth || right[1] < 0 || right[1] > imageHeight) {\n            return false;\n        }\n        // Check if eyes are reasonably far apart\n        const eyeDistance = Math.sqrt(Math.pow(right[0] - left[0], 2) + Math.pow(right[1] - left[1], 2));\n        const minEyeDistance = Math.min(imageWidth, imageHeight) * 0.05; // 5% of smaller dimension\n        const maxEyeDistance = Math.max(imageWidth, imageHeight) * 0.8; // 80% of larger dimension\n        return eyeDistance >= minEyeDistance && eyeDistance <= maxEyeDistance;\n    }\n    // Get preview of alignment transformation\n    getAlignmentPreview(sourceImage, eyePoints, targetResolution) {\n        let previewSize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 200;\n        // Create smaller preview\n        const previewResolution = {\n            width: previewSize,\n            height: previewSize * targetResolution.height / targetResolution.width\n        };\n        return this.alignImageFull(sourceImage, eyePoints, previewResolution);\n    }\n    constructor(targetEyeDistance = 0.35, targetEyeY = 0.4){\n        this.targetEyeDistance = 0.35 // Target eye distance as proportion of canvas width\n        ;\n        this.targetEyeY = 0.4 // Target eye Y position as proportion of canvas height\n        ;\n        // Enhanced alignment features\n        this.previousTransforms = [];\n        this.smoothingFactor = 0.15 // Temporal smoothing to reduce jitter\n        ;\n        this.useSubPixelPrecision = true;\n        this.targetEyeDistance = targetEyeDistance;\n        this.targetEyeY = targetEyeY;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9pbWFnZUFsaWdubWVudC50cyIsIm1hcHBpbmdzIjoiOzs7O0FBSU8sTUFBTUE7SUFjWCw0REFBNEQ7SUFDcERDLDBCQUEwQkMsU0FBeUIsRUFBRUMsVUFBb0IsRUFBb0I7UUFDbkcsTUFBTUMsaUJBQWlCRCxXQUNwQkUsR0FBRyxDQUFDQyxDQUFBQSxNQUFPSixTQUFTLENBQUNJLElBQUksRUFDekJDLE1BQU0sQ0FBQ0MsQ0FBQUEsV0FBWUE7UUFFdEIsSUFBSUosZUFBZUssTUFBTSxLQUFLLEdBQUc7WUFDL0IsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsNEVBQTRFO1FBQzVFLElBQUlDLFlBQVksR0FBR0MsWUFBWSxHQUFHQyxjQUFjO1FBRWhEVCxlQUFlVSxPQUFPLENBQUMsQ0FBQ04sVUFBVU87WUFDaEMsbUVBQW1FO1lBQ25FLE1BQU1DLFdBQVdiLFVBQVUsQ0FBQ1ksRUFBRSxLQUFLLE1BQU1aLFVBQVUsQ0FBQ1ksRUFBRSxLQUFLLE9BQU9aLFVBQVUsQ0FBQ1ksRUFBRSxLQUFLLE9BQU9aLFVBQVUsQ0FBQ1ksRUFBRSxLQUFLO1lBQzdHLE1BQU1FLFNBQVNELFdBQVcsTUFBTSxLQUFLLGlDQUFpQztZQUV0RUwsYUFBYUgsU0FBU1UsQ0FBQyxHQUFHRDtZQUMxQkwsYUFBYUosU0FBU1csQ0FBQyxHQUFHRjtZQUMxQkosZUFBZUk7UUFDakI7UUFFQSxPQUFPO1lBQUNOLFlBQVlFO1lBQWFELFlBQVlDO1NBQVk7SUFDM0Q7SUFFQU8sV0FDRUMsV0FBNkIsRUFDN0JDLFNBQW9CLEVBQ3BCQyxnQkFBa0MsRUFDZjtRQUNuQixNQUFNQyxTQUFTQyxTQUFTQyxhQUFhLENBQUM7UUFDdENGLE9BQU9HLEtBQUssR0FBR0osaUJBQWlCSSxLQUFLO1FBQ3JDSCxPQUFPSSxNQUFNLEdBQUdMLGlCQUFpQkssTUFBTTtRQUN2QyxNQUFNQyxNQUFNTCxPQUFPTSxVQUFVLENBQUM7UUFFOUIsZ0NBQWdDO1FBQ2hDLE1BQU1D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RUFDcEJDLGdCQUFrQyxFQUVmO1lBRG5Cd0gsY0FBQUEsaUVBQWM7UUFFZCx5QkFBeUI7UUFDekIsTUFBTUMsb0JBQW9CO1lBQ3hCckgsT0FBT29IO1lBQ1BuSCxRQUFRLGNBQWVMLGlCQUFpQkssTUFBTSxHQUFJTCxpQkFBaUJJLEtBQUs7UUFDMUU7UUFFQSxPQUFPLElBQUksQ0FBQ3FDLGNBQWMsQ0FBQzNDLGFBQWFDLFdBQVcwSDtJQUNyRDtJQTljQUMsWUFBWWhHLG9CQUFvQixJQUFJLEVBQUVHLGFBQWEsR0FBRyxDQUFFO2FBUmhESCxvQkFBb0IsS0FBTSxvREFBb0Q7O2FBQzlFRyxhQUFhLElBQUssdURBQXVEOztRQUVqRiw4QkFBOEI7YUFDdEI4RixxQkFBMkMsRUFBRTthQUM3Q0Msa0JBQWtCLEtBQU0sc0NBQXNDOzthQUM5REMsdUJBQXVCO1FBRzdCLElBQUksQ0FBQ25HLGlCQUFpQixHQUFHQTtRQUN6QixJQUFJLENBQUNHLFVBQVUsR0FBR0E7SUFDcEI7QUE0Y0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2ltYWdlQWxpZ25tZW50LnRzPzFkNDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXllUG9pbnRzLCBBbGlnbm1lbnRUcmFuc2Zvcm0sIFJlc29sdXRpb25Db25maWcsIEZhY2VEZXRlY3Rpb25SZXN1bHQsIEZhY2VMYW5kbWFyayB9IGZyb20gJy4vdHlwZXMnO1xyXG5cclxuZXhwb3J0IHR5cGUgQWxpZ25tZW50TW9kZSA9ICdmdWxsJyB8ICdmYWNlLWNyb3AnIHwgJ3NtYXJ0LWZyYW1lJztcclxuXHJcbmV4cG9ydCBjbGFzcyBJbWFnZUFsaWduZXIge1xyXG4gIHByaXZhdGUgdGFyZ2V0RXllRGlzdGFuY2UgPSAwLjM1OyAvLyBUYXJnZXQgZXllIGRpc3RhbmNlIGFzIHByb3BvcnRpb24gb2YgY2FudmFzIHdpZHRoXHJcbiAgcHJpdmF0ZSB0YXJnZXRFeWVZID0gMC40OyAvLyBUYXJnZXQgZXllIFkgcG9zaXRpb24gYXMgcHJvcG9ydGlvbiBvZiBjYW52YXMgaGVpZ2h0XHJcbiAgXHJcbiAgLy8gRW5oYW5jZWQgYWxpZ25tZW50IGZlYXR1cmVzXHJcbiAgcHJpdmF0ZSBwcmV2aW91c1RyYW5zZm9ybXM6IEFsaWdubWVudFRyYW5zZm9ybVtdID0gW107XHJcbiAgcHJpdmF0ZSBzbW9vdGhpbmdGYWN0b3IgPSAwLjE1OyAvLyBUZW1wb3JhbCBzbW9vdGhpbmcgdG8gcmVkdWNlIGppdHRlclxyXG4gIHByaXZhdGUgdXNlU3ViUGl4ZWxQcmVjaXNpb24gPSB0cnVlO1xyXG5cclxuICBjb25zdHJ1Y3Rvcih0YXJnZXRFeWVEaXN0YW5jZSA9IDAuMzUsIHRhcmdldEV5ZVkgPSAwLjQpIHtcclxuICAgIHRoaXMudGFyZ2V0RXllRGlzdGFuY2UgPSB0YXJnZXRFeWVEaXN0YW5jZTtcclxuICAgIHRoaXMudGFyZ2V0RXllWSA9IHRhcmdldEV5ZVk7XHJcbiAgfVxyXG5cclxuICAvLyBFbmhhbmNlZCBleWUgY2VudGVyIGNhbGN1bGF0aW9uIHVzaW5nIHB1cGlsIGFwcHJveGltYXRpb25cclxuICBwcml2YXRlIGNhbGN1bGF0ZVByZWNpc2VFeWVDZW50ZXIobGFuZG1hcmtzOiBGYWNlTGFuZG1hcmtbXSwgZXllSW5kaWNlczogbnVtYmVyW10pOiBbbnVtYmVyLCBudW1iZXJdIHtcclxuICAgIGNvbnN0IHZhbGlkTGFuZG1hcmtzID0gZXllSW5kaWNlc1xyXG4gICAgICAubWFwKGlkeCA9PiBsYW5kbWFya3NbaWR4XSlcclxuICAgICAgLmZpbHRlcihsYW5kbWFyayA9PiBsYW5kbWFyayk7XHJcblxyXG4gICAgaWYgKHZhbGlkTGFuZG1hcmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIGV5ZSBsYW5kbWFya3MgZm91bmQnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBXZWlnaHQgaW5uZXIgZXllIGxhbmRtYXJrcyBtb3JlIGhlYXZpbHkgKGNsb3NlciB0byBhY3R1YWwgcHVwaWwgcG9zaXRpb24pXHJcbiAgICBsZXQgd2VpZ2h0ZWRYID0gMCwgd2VpZ2h0ZWRZID0gMCwgdG90YWxXZWlnaHQgPSAwO1xyXG5cclxuICAgIHZhbGlkTGFuZG1hcmtzLmZvckVhY2goKGxhbmRtYXJrLCBpKSA9PiB7XHJcbiAgICAgIC8vIElubmVyIGxhbmRtYXJrcyBnZXQgaGlnaGVyIHdlaWdodCBmb3IgYmV0dGVyIHB1cGlsIGFwcHJveGltYXRpb25cclxuICAgICAgY29uc3QgaXNDb3JuZXIgPSBleWVJbmRpY2VzW2ldID09PSAzMyB8fCBleWVJbmRpY2VzW2ldID09PSAxMzMgfHwgZXllSW5kaWNlc1tpXSA9PT0gMzYyIHx8IGV5ZUluZGljZXNbaV0gPT09IDI2MztcclxuICAgICAgY29uc3Qgd2VpZ2h0ID0gaXNDb3JuZXIgPyAwLjUgOiAxLjU7IC8vIFJlZHVjZSB3ZWlnaHQgb2YgY29ybmVyIHBvaW50c1xyXG4gICAgICBcclxuICAgICAgd2VpZ2h0ZWRYICs9IGxhbmRtYXJrLnggKiB3ZWlnaHQ7XHJcbiAgICAgIHdlaWdodGVkWSArPSBsYW5kbWFyay55ICogd2VpZ2h0O1xyXG4gICAgICB0b3RhbFdlaWdodCArPSB3ZWlnaHQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gW3dlaWdodGVkWCAvIHRvdGFsV2VpZ2h0LCB3ZWlnaHRlZFkgLyB0b3RhbFdlaWdodF07XHJcbiAgfVxyXG5cclxuICBhbGlnbkltYWdlKFxyXG4gICAgc291cmNlSW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQsXHJcbiAgICBleWVQb2ludHM6IEV5ZVBvaW50cyxcclxuICAgIHRhcmdldFJlc29sdXRpb246IFJlc29sdXRpb25Db25maWdcclxuICApOiBIVE1MQ2FudmFzRWxlbWVudCB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIGNhbnZhcy53aWR0aCA9IHRhcmdldFJlc29sdXRpb24ud2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gdGFyZ2V0UmVzb2x1dGlvbi5oZWlnaHQ7XHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSE7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGFsaWdubWVudCB0cmFuc2Zvcm1cclxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRoaXMuY2FsY3VsYXRlQWxpZ25tZW50VHJhbnNmb3JtKFxyXG4gICAgICBleWVQb2ludHMsXHJcbiAgICAgIHRhcmdldFJlc29sdXRpb25cclxuICAgICk7XHJcblxyXG4gICAgLy8gQXBwbHkgdHJhbnNmb3JtYXRpb24gYW5kIGRyYXcgaW1hZ2VcclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBjdHguc2V0VHJhbnNmb3JtKFxyXG4gICAgICB0cmFuc2Zvcm0ubWF0cml4WzBdWzBdLCB0cmFuc2Zvcm0ubWF0cml4WzBdWzFdLFxyXG4gICAgICB0cmFuc2Zvcm0ubWF0cml4WzFdWzBdLCB0cmFuc2Zvcm0ubWF0cml4WzFdWzFdLFxyXG4gICAgICB0cmFuc2Zvcm0ubWF0cml4WzBdWzJdLCB0cmFuc2Zvcm0ubWF0cml4WzFdWzJdXHJcbiAgICApO1xyXG5cclxuICAgIGN0eC5kcmF3SW1hZ2Uoc291cmNlSW1hZ2UsIDAsIDApO1xyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuXHJcbiAgICByZXR1cm4gY2FudmFzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjYWxjdWxhdGVBbGlnbm1lbnRUcmFuc2Zvcm0oXHJcbiAgICBleWVQb2ludHM6IEV5ZVBvaW50cyxcclxuICAgIHRhcmdldFJlc29sdXRpb246IFJlc29sdXRpb25Db25maWdcclxuICApOiBBbGlnbm1lbnRUcmFuc2Zvcm0ge1xyXG4gICAgY29uc3QgeyBsZWZ0LCByaWdodCB9ID0gZXllUG9pbnRzO1xyXG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0YXJnZXRSZXNvbHV0aW9uO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBjdXJyZW50IGV5ZSBwcm9wZXJ0aWVzXHJcbiAgICBjb25zdCBleWVDZW50ZXJYID0gKGxlZnRbMF0gKyByaWdodFswXSkgLyAyO1xyXG4gICAgY29uc3QgZXllQ2VudGVyWSA9IChsZWZ0WzFdICsgcmlnaHRbMV0pIC8gMjtcclxuICAgIGNvbnN0IGN1cnJlbnRFeWVEaXN0YW5jZSA9IE1hdGguc3FydChcclxuICAgICAgTWF0aC5wb3cocmlnaHRbMF0gLSBsZWZ0WzBdLCAyKSArIE1hdGgucG93KHJpZ2h0WzFdIC0gbGVmdFsxXSwgMilcclxuICAgICk7XHJcbiAgICBjb25zdCBleWVBbmdsZSA9IE1hdGguYXRhbjIocmlnaHRbMV0gLSBsZWZ0WzFdLCByaWdodFswXSAtIGxlZnRbMF0pO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0YXJnZXQgZXllIHByb3BlcnRpZXNcclxuICAgIGNvbnN0IHRhcmdldEV5ZURpc3RhbmNlUGl4ZWxzID0gd2lkdGggKiB0aGlzLnRhcmdldEV5ZURpc3RhbmNlO1xyXG4gICAgY29uc3QgdGFyZ2V0RXllQ2VudGVyWCA9IHdpZHRoIC8gMjtcclxuICAgIGNvbnN0IHRhcmdldEV5ZUNlbnRlclkgPSBoZWlnaHQgKiB0aGlzLnRhcmdldEV5ZVk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgY29uc3Qgc2NhbGUgPSB0YXJnZXRFeWVEaXN0YW5jZVBpeGVscyAvIGN1cnJlbnRFeWVEaXN0YW5jZTtcclxuICAgIGNvbnN0IHJvdGF0aW9uID0gLWV5ZUFuZ2xlOyAvLyBOZWdhdGl2ZSB0byBjb3VudGVyLXJvdGF0ZVxyXG5cclxuICAgIC8vIENyZWF0ZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcclxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHJvdGF0aW9uKTtcclxuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKHJvdGF0aW9uKTtcclxuXHJcbiAgICAvLyBUcmFuc2xhdGlvbiB0byBjZW50ZXIgZXllcyBhdCBvcmlnaW5cclxuICAgIGNvbnN0IHR4MSA9IC1leWVDZW50ZXJYO1xyXG4gICAgY29uc3QgdHkxID0gLWV5ZUNlbnRlclk7XHJcblxyXG4gICAgLy8gU2NhbGUgYW5kIHJvdGF0ZVxyXG4gICAgY29uc3Qgc2NhbGVSb3RhdGVNYXRyaXggPSBbXHJcbiAgICAgIFtzY2FsZSAqIGNvcywgLXNjYWxlICogc2luXSxcclxuICAgICAgW3NjYWxlICogc2luLCBzY2FsZSAqIGNvc11cclxuICAgIF07XHJcblxyXG4gICAgLy8gVHJhbnNsYXRpb24gdG8gdGFyZ2V0IHBvc2l0aW9uXHJcbiAgICBjb25zdCB0eDIgPSB0YXJnZXRFeWVDZW50ZXJYO1xyXG4gICAgY29uc3QgdHkyID0gdGFyZ2V0RXllQ2VudGVyWTtcclxuXHJcbiAgICAvLyBDb21iaW5lIHRyYW5zZm9ybWF0aW9uczogdHJhbnNsYXRlIC0+IHNjYWxlL3JvdGF0ZSAtPiB0cmFuc2xhdGVcclxuICAgIGNvbnN0IG1hdHJpeCA9IFtcclxuICAgICAgW3NjYWxlUm90YXRlTWF0cml4WzBdWzBdLCBzY2FsZVJvdGF0ZU1hdHJpeFswXVsxXSwgXHJcbiAgICAgICBzY2FsZVJvdGF0ZU1hdHJpeFswXVswXSAqIHR4MSArIHNjYWxlUm90YXRlTWF0cml4WzBdWzFdICogdHkxICsgdHgyXSxcclxuICAgICAgW3NjYWxlUm90YXRlTWF0cml4WzFdWzBdLCBzY2FsZVJvdGF0ZU1hdHJpeFsxXVsxXSwgXHJcbiAgICAgICBzY2FsZVJvdGF0ZU1hdHJpeFsxXVswXSAqIHR4MSArIHNjYWxlUm90YXRlTWF0cml4WzFdWzFdICogdHkxICsgdHkyXVxyXG4gICAgXTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByb3RhdGlvbjogcm90YXRpb24gKiAoMTgwIC8gTWF0aC5QSSksIC8vIENvbnZlcnQgdG8gZGVncmVlc1xyXG4gICAgICBzY2FsZSxcclxuICAgICAgdHJhbnNsYXRpb246IFt0eDIgLSBleWVDZW50ZXJYICogc2NhbGUsIHR5MiAtIGV5ZUNlbnRlclkgKiBzY2FsZV0sXHJcbiAgICAgIG1hdHJpeFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIEZ1bGwgaW1hZ2UgYWxpZ25tZW50IG1ldGhvZCB0aGF0IHByZXNlcnZlcyBlbnRpcmUgaW1hZ2Ugb24gY2FudmFzXHJcbiAgYWxpZ25JbWFnZUZ1bGwoXHJcbiAgICBzb3VyY2VJbWFnZTogSFRNTEltYWdlRWxlbWVudCxcclxuICAgIGV5ZVBvaW50czogRXllUG9pbnRzLFxyXG4gICAgdGFyZ2V0UmVzb2x1dGlvbjogUmVzb2x1dGlvbkNvbmZpZ1xyXG4gICk6IEhUTUxDYW52YXNFbGVtZW50IHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgY2FudmFzLndpZHRoID0gdGFyZ2V0UmVzb2x1dGlvbi53aWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSB0YXJnZXRSZXNvbHV0aW9uLmhlaWdodDtcclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpITtcclxuXHJcbiAgICBjb25zdCB7IGxlZnQsIHJpZ2h0IH0gPSBleWVQb2ludHM7XHJcbiAgICBjb25zdCB7IHdpZHRoOiBjYW52YXNXaWR0aCwgaGVpZ2h0OiBjYW52YXNIZWlnaHQgfSA9IHRhcmdldFJlc29sdXRpb247XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGV5ZSBwcm9wZXJ0aWVzIGluIHNvdXJjZSBpbWFnZVxyXG4gICAgY29uc3QgZXllQ2VudGVyWCA9IChsZWZ0WzBdICsgcmlnaHRbMF0pIC8gMjtcclxuICAgIGNvbnN0IGV5ZUNlbnRlclkgPSAobGVmdFsxXSArIHJpZ2h0WzFdKSAvIDI7XHJcbiAgICBjb25zdCBleWVBbmdsZSA9IE1hdGguYXRhbjIocmlnaHRbMV0gLSBsZWZ0WzFdLCByaWdodFswXSAtIGxlZnRbMF0pO1xyXG4gICAgY29uc3QgY3VycmVudEV5ZURpc3RhbmNlID0gTWF0aC5zcXJ0KFxyXG4gICAgICBNYXRoLnBvdyhyaWdodFswXSAtIGxlZnRbMF0sIDIpICsgTWF0aC5wb3cocmlnaHRbMV0gLSBsZWZ0WzFdLCAyKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBUYXJnZXQgZXllIHByb3BlcnRpZXMgb24gY2FudmFzXHJcbiAgICBjb25zdCB0YXJnZXRFeWVEaXN0YW5jZSA9IGNhbnZhc1dpZHRoICogdGhpcy50YXJnZXRFeWVEaXN0YW5jZTtcclxuICAgIGNvbnN0IHRhcmdldEV5ZUNlbnRlclggPSBjYW52YXNXaWR0aCAvIDI7XHJcbiAgICBjb25zdCB0YXJnZXRFeWVDZW50ZXJZID0gY2FudmFzSGVpZ2h0ICogdGhpcy50YXJnZXRFeWVZO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgc2NhbGUgYmFzZWQgb24gZXllIGRpc3RhbmNlXHJcbiAgICBjb25zdCBleWVTY2FsZSA9IHRhcmdldEV5ZURpc3RhbmNlIC8gY3VycmVudEV5ZURpc3RhbmNlO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHNjYWxlZCBpbWFnZSBkaW1lbnNpb25zXHJcbiAgICBjb25zdCBzY2FsZWRJbWFnZVdpZHRoID0gc291cmNlSW1hZ2Uud2lkdGggKiBleWVTY2FsZTtcclxuICAgIGNvbnN0IHNjYWxlZEltYWdlSGVpZ2h0ID0gc291cmNlSW1hZ2UuaGVpZ2h0ICogZXllU2NhbGU7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBmaW5hbCBzY2FsZSB0byBmaXQgZW50aXJlIGltYWdlIG9uIGNhbnZhcyBpZiBuZWVkZWRcclxuICAgIGNvbnN0IGNhbnZhc0ZpdFNjYWxlWCA9IGNhbnZhc1dpZHRoIC8gc2NhbGVkSW1hZ2VXaWR0aDtcclxuICAgIGNvbnN0IGNhbnZhc0ZpdFNjYWxlWSA9IGNhbnZhc0hlaWdodCAvIHNjYWxlZEltYWdlSGVpZ2h0O1xyXG4gICAgY29uc3QgY2FudmFzRml0U2NhbGUgPSBNYXRoLm1pbihjYW52YXNGaXRTY2FsZVgsIGNhbnZhc0ZpdFNjYWxlWSwgMSk7IC8vIERvbid0IHVwc2NhbGUgYmV5b25kIGV5ZSBzY2FsZVxyXG4gICAgXHJcbiAgICAvLyBGaW5hbCBzY2FsZSBjb21iaW5lcyBleWUgYWxpZ25tZW50IGFuZCBjYW52YXMgZml0dGluZ1xyXG4gICAgY29uc3QgZmluYWxTY2FsZSA9IGV5ZVNjYWxlICogY2FudmFzRml0U2NhbGU7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSB3aGVyZSB0aGUgaW1hZ2Ugc2hvdWxkIGJlIHBvc2l0aW9uZWQgdG8ga2VlcCBleWVzIGF0IHRhcmdldCBwb3NpdGlvblxyXG4gICAgY29uc3Qgc2NhbGVkRXllQ2VudGVyWCA9IGV5ZUNlbnRlclggKiBmaW5hbFNjYWxlO1xyXG4gICAgY29uc3Qgc2NhbGVkRXllQ2VudGVyWSA9IGV5ZUNlbnRlclkgKiBmaW5hbFNjYWxlO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgaW1hZ2UgcG9zaXRpb24gKHRvcC1sZWZ0IGNvcm5lcikgdG8gcGxhY2UgZXllcyBhdCB0YXJnZXQgcG9zaXRpb25cclxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKC1leWVBbmdsZSk7XHJcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbigtZXllQW5nbGUpO1xyXG4gICAgXHJcbiAgICAvLyBBcHBseSB0cmFuc2Zvcm1hdGlvbnNcclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBcclxuICAgIC8vIENsZWFyIGNhbnZhcyB3aXRoIHRyYW5zcGFyZW50IGJhY2tncm91bmRcclxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdhbGlnbkltYWdlRnVsbCBkZWJ1ZzonLCB7XHJcbiAgICAgIHNvdXJjZUltYWdlU2l6ZTogeyB3aWR0aDogc291cmNlSW1hZ2Uud2lkdGgsIGhlaWdodDogc291cmNlSW1hZ2UuaGVpZ2h0IH0sXHJcbiAgICAgIGNhbnZhc1NpemU6IHsgd2lkdGg6IGNhbnZhc1dpZHRoLCBoZWlnaHQ6IGNhbnZhc0hlaWdodCB9LFxyXG4gICAgICBleWVTY2FsZSxcclxuICAgICAgY2FudmFzRml0U2NhbGUsXHJcbiAgICAgIGZpbmFsU2NhbGUsXHJcbiAgICAgIGV5ZUNlbnRlclgsXHJcbiAgICAgIGV5ZUNlbnRlclksXHJcbiAgICAgIHRhcmdldEV5ZUNlbnRlclgsXHJcbiAgICAgIHRhcmdldEV5ZUNlbnRlclksXHJcbiAgICAgIGV5ZUFuZ2xlOiBleWVBbmdsZSAqICgxODAgLyBNYXRoLlBJKSArICcgZGVncmVlcycsXHJcbiAgICAgIGltYWdlQ29tcGxldGU6IHNvdXJjZUltYWdlLmNvbXBsZXRlLFxyXG4gICAgICBpbWFnZVNyYzogc291cmNlSW1hZ2Uuc3JjLnN1YnN0cmluZygwLCA1MCkgKyAnLi4uJ1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIFZlcmlmeSBzb3VyY2UgaW1hZ2UgaGFzIGNvbnRlbnQgYnkgZHJhd2luZyB0byBhIHRlc3QgY2FudmFzXHJcbiAgICBjb25zdCB0ZXN0Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICB0ZXN0Q2FudmFzLndpZHRoID0gc291cmNlSW1hZ2Uud2lkdGg7XHJcbiAgICB0ZXN0Q2FudmFzLmhlaWdodCA9IHNvdXJjZUltYWdlLmhlaWdodDtcclxuICAgIGNvbnN0IHRlc3RDdHggPSB0ZXN0Q2FudmFzLmdldENvbnRleHQoJzJkJykhO1xyXG4gICAgdGVzdEN0eC5kcmF3SW1hZ2Uoc291cmNlSW1hZ2UsIDAsIDApO1xyXG4gICAgY29uc3QgdGVzdEltYWdlRGF0YSA9IHRlc3RDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNvdXJjZUltYWdlLndpZHRoLCBzb3VyY2VJbWFnZS5oZWlnaHQpO1xyXG4gICAgY29uc3Qgc291cmNlSGFzQ29udGVudCA9IHRlc3RJbWFnZURhdGEuZGF0YS5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgcmV0dXJuIGluZGV4ICUgNCA9PT0gMyAmJiB2YWx1ZSA+IDA7IC8vIENoZWNrIGFscGhhIGNoYW5uZWxcclxuICAgIH0pO1xyXG4gICAgY29uc29sZS5sb2coJ1NvdXJjZSBpbWFnZSBoYXMgY29udGVudDonLCBzb3VyY2VIYXNDb250ZW50KTtcclxuICAgIFxyXG4gICAgLy8gTW92ZSB0byB0YXJnZXQgZXllIGNlbnRlclxyXG4gICAgY3R4LnRyYW5zbGF0ZSh0YXJnZXRFeWVDZW50ZXJYLCB0YXJnZXRFeWVDZW50ZXJZKTtcclxuICAgIFxyXG4gICAgLy8gUm90YXRlIHRvIGFsaWduIGV5ZXMgaG9yaXpvbnRhbGx5XHJcbiAgICBjdHgucm90YXRlKC1leWVBbmdsZSk7XHJcbiAgICBcclxuICAgIC8vIFNjYWxlIHRvIG1hdGNoIHRhcmdldCBleWUgZGlzdGFuY2UgYW5kIGZpdCBjYW52YXNcclxuICAgIGN0eC5zY2FsZShmaW5hbFNjYWxlLCBmaW5hbFNjYWxlKTtcclxuICAgIFxyXG4gICAgLy8gRHJhdyBpbWFnZSBjZW50ZXJlZCBvbiBleWUgY2VudGVyIGluIHRoZSBzY2FsZWQvcm90YXRlZCBjb29yZGluYXRlIHN5c3RlbVxyXG4gICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgc291cmNlSW1hZ2UsXHJcbiAgICAgIC1leWVDZW50ZXJYLFxyXG4gICAgICAtZXllQ2VudGVyWSxcclxuICAgICAgc291cmNlSW1hZ2Uud2lkdGgsXHJcbiAgICAgIHNvdXJjZUltYWdlLmhlaWdodFxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ0RyYXdJbWFnZSBwYXJhbWV0ZXJzOicsIHtcclxuICAgICAgZHg6IC1leWVDZW50ZXJYLFxyXG4gICAgICBkeTogLWV5ZUNlbnRlclksIFxyXG4gICAgICBkV2lkdGg6IHNvdXJjZUltYWdlLndpZHRoLFxyXG4gICAgICBkSGVpZ2h0OiBzb3VyY2VJbWFnZS5oZWlnaHQsXHJcbiAgICAgIGN1cnJlbnRUcmFuc2Zvcm06IGN0eC5nZXRUcmFuc2Zvcm0oKVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGltbWVkaWF0ZWx5IGlmIGRyYXdpbmcgd29ya2VkIHdpdGhpbiB0aGUgdHJhbnNmb3JtXHJcbiAgICBjb25zdCBpbW1lZGlhdGVDaGVjayA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XHJcbiAgICBjb25zdCBkcmV3U29tZXRoaW5nID0gaW1tZWRpYXRlQ2hlY2suZGF0YS5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgcmV0dXJuIGluZGV4ICUgNCA9PT0gMyAmJiB2YWx1ZSA+IDA7XHJcbiAgICB9KTtcclxuICAgIGNvbnNvbGUubG9nKCdDb250ZW50IGV4aXN0cyBpbW1lZGlhdGVseSBhZnRlciBkcmF3SW1hZ2UgKHdpdGhpbiB0cmFuc2Zvcm0pOicsIGRyZXdTb21ldGhpbmcpO1xyXG4gICAgXHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgXHJcbiAgICAvLyBEZWJ1ZzogQ2hlY2sgaWYgY2FudmFzIGhhcyBjb250ZW50XHJcbiAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xyXG4gICAgY29uc3QgaGFzQ29udGVudCA9IGltYWdlRGF0YS5kYXRhLnNvbWUoKHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICByZXR1cm4gaW5kZXggJSA0ID09PSAzICYmIHZhbHVlID4gMDsgLy8gQ2hlY2sgYWxwaGEgY2hhbm5lbCBmb3Igbm9uLXRyYW5zcGFyZW50IHBpeGVsc1xyXG4gICAgfSk7XHJcbiAgICBjb25zb2xlLmxvZygnQ2FudmFzIGhhcyBjb250ZW50IGFmdGVyIGRyYXdpbmc6JywgaGFzQ29udGVudCk7XHJcbiAgICBcclxuICAgIGlmICghaGFzQ29udGVudCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IENhbnZhcyBhcHBlYXJzIHRvIGJlIGVtcHR5IGFmdGVyIGFsaWdubWVudCcpO1xyXG4gICAgICAvLyBEZWJ1ZzogVHJ5IGEgc2ltcGxlIHJlZCByZWN0YW5nbGUgdG8gdmVyaWZ5IGNhbnZhcyBpcyB3b3JraW5nXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAncmVkJztcclxuICAgICAgY3R4LmZpbGxSZWN0KDEwLCAxMCwgNTAsIDUwKTtcclxuICAgICAgY29uc29sZS5sb2coJ0FkZGVkIGRlYnVnIHJlZCByZWN0YW5nbGUgdG8gZW1wdHkgY2FudmFzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNhbnZhcztcclxuICB9XHJcblxyXG4gIC8vIFNtYXJ0IGZhY2UgY3JvcHBpbmcgYWxpZ25tZW50IC0gZm9jdXNlcyBvbiBmYWNlIHJlZ2lvbiB3aGlsZSBtYWludGFpbmluZyBleWUgYWxpZ25tZW50XHJcbiAgYWxpZ25JbWFnZUZhY2VDcm9wKFxyXG4gICAgc291cmNlSW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQsXHJcbiAgICBmYWNlUmVzdWx0OiBGYWNlRGV0ZWN0aW9uUmVzdWx0LFxyXG4gICAgdGFyZ2V0UmVzb2x1dGlvbjogUmVzb2x1dGlvbkNvbmZpZyxcclxuICAgIHBhZGRpbmc6IG51bWJlciA9IDAuNiAvLyA2MCUgcGFkZGluZyBhcm91bmQgZmFjZSBmb3IgYmV0dGVyIGZyYW1pbmdcclxuICApOiBIVE1MQ2FudmFzRWxlbWVudCB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIGNhbnZhcy53aWR0aCA9IHRhcmdldFJlc29sdXRpb24ud2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gdGFyZ2V0UmVzb2x1dGlvbi5oZWlnaHQ7XHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSE7XHJcblxyXG4gICAgY29uc3QgeyBleWVQb2ludHMsIGZhY2VCb3VuZHMgfSA9IGZhY2VSZXN1bHQ7XHJcbiAgICBjb25zdCB7IHdpZHRoOiBjYW52YXNXaWR0aCwgaGVpZ2h0OiBjYW52YXNIZWlnaHQgfSA9IHRhcmdldFJlc29sdXRpb247XHJcblxyXG4gICAgaWYgKCFmYWNlQm91bmRzKSB7XHJcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGZ1bGwgYWxpZ25tZW50IGlmIG5vIGZhY2UgYm91bmRzXHJcbiAgICAgIHJldHVybiB0aGlzLmFsaWduSW1hZ2VGdWxsKHNvdXJjZUltYWdlLCBleWVQb2ludHMsIHRhcmdldFJlc29sdXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBwYWRkZWQgZmFjZSByZWdpb24gd2l0aCBleHRyYSB2ZXJ0aWNhbCBwYWRkaW5nXHJcbiAgICBjb25zdCBmYWNlV2lkdGggPSBmYWNlQm91bmRzLndpZHRoO1xyXG4gICAgY29uc3QgZmFjZUhlaWdodCA9IGZhY2VCb3VuZHMuaGVpZ2h0O1xyXG4gICAgY29uc3QgcGFkZGluZ1ggPSBmYWNlV2lkdGggKiBwYWRkaW5nO1xyXG4gICAgY29uc3QgcGFkZGluZ1kgPSBmYWNlSGVpZ2h0ICogKHBhZGRpbmcgKyAwLjIpOyAvLyBFeHRyYSAyMCUgdmVydGljYWwgcGFkZGluZyBmb3IgZm9yZWhlYWQvY2hpblxyXG5cclxuICAgIGNvbnN0IGNyb3BMZWZ0ID0gTWF0aC5tYXgoMCwgZmFjZUJvdW5kcy5sZWZ0IC0gcGFkZGluZ1gpO1xyXG4gICAgY29uc3QgY3JvcFRvcCA9IE1hdGgubWF4KDAsIGZhY2VCb3VuZHMudG9wIC0gcGFkZGluZ1kpO1xyXG4gICAgY29uc3QgY3JvcFJpZ2h0ID0gTWF0aC5taW4oc291cmNlSW1hZ2Uud2lkdGgsIGZhY2VCb3VuZHMucmlnaHQgKyBwYWRkaW5nWCk7XHJcbiAgICBjb25zdCBjcm9wQm90dG9tID0gTWF0aC5taW4oc291cmNlSW1hZ2UuaGVpZ2h0LCBmYWNlQm91bmRzLmJvdHRvbSArIHBhZGRpbmdZKTtcclxuXHJcbiAgICBjb25zdCBjcm9wV2lkdGggPSBjcm9wUmlnaHQgLSBjcm9wTGVmdDtcclxuICAgIGNvbnN0IGNyb3BIZWlnaHQgPSBjcm9wQm90dG9tIC0gY3JvcFRvcDtcclxuXHJcbiAgICAvLyBBZGp1c3QgZXllIHBvaW50cyByZWxhdGl2ZSB0byBjcm9wIHJlZ2lvblxyXG4gICAgY29uc3QgYWRqdXN0ZWRFeWVQb2ludHM6IEV5ZVBvaW50cyA9IHtcclxuICAgICAgbGVmdDogW2V5ZVBvaW50cy5sZWZ0WzBdIC0gY3JvcExlZnQsIGV5ZVBvaW50cy5sZWZ0WzFdIC0gY3JvcFRvcF0sXHJcbiAgICAgIHJpZ2h0OiBbZXllUG9pbnRzLnJpZ2h0WzBdIC0gY3JvcExlZnQsIGV5ZVBvaW50cy5yaWdodFsxXSAtIGNyb3BUb3BdXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBleWUgcHJvcGVydGllcyBpbiBjcm9wcGVkIHJlZ2lvblxyXG4gICAgY29uc3QgZXllQ2VudGVyWCA9IChhZGp1c3RlZEV5ZVBvaW50cy5sZWZ0WzBdICsgYWRqdXN0ZWRFeWVQb2ludHMucmlnaHRbMF0pIC8gMjtcclxuICAgIGNvbnN0IGV5ZUNlbnRlclkgPSAoYWRqdXN0ZWRFeWVQb2ludHMubGVmdFsxXSArIGFkanVzdGVkRXllUG9pbnRzLnJpZ2h0WzFdKSAvIDI7XHJcbiAgICBjb25zdCBleWVBbmdsZSA9IE1hdGguYXRhbjIoXHJcbiAgICAgIGFkanVzdGVkRXllUG9pbnRzLnJpZ2h0WzFdIC0gYWRqdXN0ZWRFeWVQb2ludHMubGVmdFsxXSxcclxuICAgICAgYWRqdXN0ZWRFeWVQb2ludHMucmlnaHRbMF0gLSBhZGp1c3RlZEV5ZVBvaW50cy5sZWZ0WzBdXHJcbiAgICApO1xyXG4gICAgY29uc3QgY3VycmVudEV5ZURpc3RhbmNlID0gTWF0aC5zcXJ0KFxyXG4gICAgICBNYXRoLnBvdyhhZGp1c3RlZEV5ZVBvaW50cy5yaWdodFswXSAtIGFkanVzdGVkRXllUG9pbnRzLmxlZnRbMF0sIDIpICtcclxuICAgICAgTWF0aC5wb3coYWRqdXN0ZWRFeWVQb2ludHMucmlnaHRbMV0gLSBhZGp1c3RlZEV5ZVBvaW50cy5sZWZ0WzFdLCAyKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBUYXJnZXQgZXllIHByb3BlcnRpZXNcclxuICAgIGNvbnN0IHRhcmdldEV5ZURpc3RhbmNlID0gY2FudmFzV2lkdGggKiB0aGlzLnRhcmdldEV5ZURpc3RhbmNlO1xyXG4gICAgY29uc3QgdGFyZ2V0RXllQ2VudGVyWCA9IGNhbnZhc1dpZHRoIC8gMjtcclxuICAgIGNvbnN0IHRhcmdldEV5ZUNlbnRlclkgPSBjYW52YXNIZWlnaHQgKiB0aGlzLnRhcmdldEV5ZVk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHNjYWxlIHRvIGZpdCBjcm9wcGVkIHJlZ2lvbiB0byBjYW52YXNcclxuICAgIGNvbnN0IGV5ZVNjYWxlID0gdGFyZ2V0RXllRGlzdGFuY2UgLyBjdXJyZW50RXllRGlzdGFuY2U7XHJcbiAgICBjb25zdCBzY2FsZVRvRml0WCA9IGNhbnZhc1dpZHRoIC8gY3JvcFdpZHRoO1xyXG4gICAgY29uc3Qgc2NhbGVUb0ZpdFkgPSBjYW52YXNIZWlnaHQgLyBjcm9wSGVpZ2h0O1xyXG4gICAgY29uc3QgZml0U2NhbGUgPSBNYXRoLm1pbihzY2FsZVRvRml0WCwgc2NhbGVUb0ZpdFkpO1xyXG4gICAgXHJcbiAgICAvLyBVc2UgdGhlIG1vcmUgYXBwcm9wcmlhdGUgc2NhbGVcclxuICAgIGNvbnN0IGZpbmFsU2NhbGUgPSBNYXRoLm1pbihleWVTY2FsZSwgZml0U2NhbGUgKiAxLjIpOyAvLyBBbGxvdyBzbGlnaHQgb3ZlcmZsb3cgZm9yIGJldHRlciBmcmFtaW5nXHJcblxyXG4gICAgLy8gQXBwbHkgdHJhbnNmb3JtYXRpb25zXHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ2FsaWduSW1hZ2VGYWNlQ3JvcCBkZWJ1ZzonLCB7XHJcbiAgICAgIGNyb3BSZWdpb246IHsgbGVmdDogY3JvcExlZnQsIHRvcDogY3JvcFRvcCwgd2lkdGg6IGNyb3BXaWR0aCwgaGVpZ2h0OiBjcm9wSGVpZ2h0IH0sXHJcbiAgICAgIGNhbnZhc1NpemU6IHsgd2lkdGg6IGNhbnZhc1dpZHRoLCBoZWlnaHQ6IGNhbnZhc0hlaWdodCB9LFxyXG4gICAgICBleWVTY2FsZSxcclxuICAgICAgZml0U2NhbGUsXHJcbiAgICAgIGZpbmFsU2NhbGUsXHJcbiAgICAgIGV5ZUNlbnRlclgsXHJcbiAgICAgIGV5ZUNlbnRlclksXHJcbiAgICAgIHRhcmdldEV5ZUNlbnRlclgsXHJcbiAgICAgIHRhcmdldEV5ZUNlbnRlclksXHJcbiAgICAgIGV5ZUFuZ2xlOiBleWVBbmdsZSAqICgxODAgLyBNYXRoLlBJKSArICcgZGVncmVlcydcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIE1vdmUgdG8gdGFyZ2V0IGV5ZSBjZW50ZXJcclxuICAgIGN0eC50cmFuc2xhdGUodGFyZ2V0RXllQ2VudGVyWCwgdGFyZ2V0RXllQ2VudGVyWSk7XHJcblxyXG4gICAgLy8gUm90YXRlIHRvIGFsaWduIGV5ZXMgaG9yaXpvbnRhbGx5XHJcbiAgICBjdHgucm90YXRlKC1leWVBbmdsZSk7XHJcblxyXG4gICAgLy8gU2NhbGUgdGhlIGNyb3BwZWQgcmVnaW9uXHJcbiAgICBjdHguc2NhbGUoZmluYWxTY2FsZSwgZmluYWxTY2FsZSk7XHJcblxyXG4gICAgLy8gRHJhdyB0aGUgY3JvcHBlZCByZWdpb24gY2VudGVyZWQgb24gZXllIGNlbnRlclxyXG4gICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgc291cmNlSW1hZ2UsXHJcbiAgICAgIGNyb3BMZWZ0LCBjcm9wVG9wLCBjcm9wV2lkdGgsIGNyb3BIZWlnaHQsIC8vIFNvdXJjZSBjcm9wXHJcbiAgICAgIC1leWVDZW50ZXJYLCAtZXllQ2VudGVyWSwgY3JvcFdpZHRoLCBjcm9wSGVpZ2h0IC8vIERlc3RpbmF0aW9uXHJcbiAgICApO1xyXG5cclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICBcclxuICAgIC8vIERlYnVnOiBDaGVjayBpZiBjYW52YXMgaGFzIGNvbnRlbnRcclxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XHJcbiAgICBjb25zdCBoYXNDb250ZW50ID0gaW1hZ2VEYXRhLmRhdGEuc29tZSgodmFsdWUsIGluZGV4KSA9PiB7XHJcbiAgICAgIHJldHVybiBpbmRleCAlIDQgPT09IDMgJiYgdmFsdWUgPiAwOyAvLyBDaGVjayBhbHBoYSBjaGFubmVsIGZvciBub24tdHJhbnNwYXJlbnQgcGl4ZWxzXHJcbiAgICB9KTtcclxuICAgIGNvbnNvbGUubG9nKCdDYW52YXMgaGFzIGNvbnRlbnQgYWZ0ZXIgZmFjZSBjcm9wIGRyYXdpbmc6JywgaGFzQ29udGVudCk7XHJcbiAgICBcclxuICAgIGlmICghaGFzQ29udGVudCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IEZhY2UgY3JvcCBjYW52YXMgYXBwZWFycyB0byBiZSBlbXB0eSBhZnRlciBhbGlnbm1lbnQnKTtcclxuICAgICAgLy8gRGVidWc6IFRyeSBhIHNpbXBsZSBibHVlIHJlY3RhbmdsZSB0byB2ZXJpZnkgY2FudmFzIGlzIHdvcmtpbmdcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9ICdibHVlJztcclxuICAgICAgY3R4LmZpbGxSZWN0KDEwLCAxMCwgNTAsIDUwKTtcclxuICAgICAgY29uc29sZS5sb2coJ0FkZGVkIGRlYnVnIGJsdWUgcmVjdGFuZ2xlIHRvIGVtcHR5IGZhY2UgY3JvcCBjYW52YXMnKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2FudmFzO1xyXG4gIH1cclxuXHJcbiAgLy8gQWx0ZXJuYXRpdmUgc2ltcGxlciBhbGlnbm1lbnQgbWV0aG9kIHVzaW5nIGNhbnZhcyB0cmFuc2Zvcm1zXHJcbiAgYWxpZ25JbWFnZVNpbXBsZShcclxuICAgIHNvdXJjZUltYWdlOiBIVE1MSW1hZ2VFbGVtZW50LFxyXG4gICAgZXllUG9pbnRzOiBFeWVQb2ludHMsXHJcbiAgICB0YXJnZXRSZXNvbHV0aW9uOiBSZXNvbHV0aW9uQ29uZmlnXHJcbiAgKTogSFRNTENhbnZhc0VsZW1lbnQge1xyXG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICBjYW52YXMud2lkdGggPSB0YXJnZXRSZXNvbHV0aW9uLndpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IHRhcmdldFJlc29sdXRpb24uaGVpZ2h0O1xyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykhO1xyXG5cclxuICAgIGNvbnN0IHsgbGVmdCwgcmlnaHQgfSA9IGV5ZVBvaW50cztcclxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGFyZ2V0UmVzb2x1dGlvbjtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgZXllIGNlbnRlciBhbmQgYW5nbGVcclxuICAgIGNvbnN0IGV5ZUNlbnRlclggPSAobGVmdFswXSArIHJpZ2h0WzBdKSAvIDI7XHJcbiAgICBjb25zdCBleWVDZW50ZXJZID0gKGxlZnRbMV0gKyByaWdodFsxXSkgLyAyO1xyXG4gICAgY29uc3QgZXllQW5nbGUgPSBNYXRoLmF0YW4yKHJpZ2h0WzFdIC0gbGVmdFsxXSwgcmlnaHRbMF0gLSBsZWZ0WzBdKTtcclxuICAgIGNvbnN0IGN1cnJlbnRFeWVEaXN0YW5jZSA9IE1hdGguc3FydChcclxuICAgICAgTWF0aC5wb3cocmlnaHRbMF0gLSBsZWZ0WzBdLCAyKSArIE1hdGgucG93KHJpZ2h0WzFdIC0gbGVmdFsxXSwgMilcclxuICAgICk7XHJcblxyXG4gICAgLy8gVGFyZ2V0IHByb3BlcnRpZXNcclxuICAgIGNvbnN0IHRhcmdldEV5ZURpc3RhbmNlID0gd2lkdGggKiB0aGlzLnRhcmdldEV5ZURpc3RhbmNlO1xyXG4gICAgY29uc3QgdGFyZ2V0Q2VudGVyWCA9IHdpZHRoIC8gMjtcclxuICAgIGNvbnN0IHRhcmdldENlbnRlclkgPSBoZWlnaHQgKiB0aGlzLnRhcmdldEV5ZVk7XHJcbiAgICBjb25zdCBzY2FsZSA9IHRhcmdldEV5ZURpc3RhbmNlIC8gY3VycmVudEV5ZURpc3RhbmNlO1xyXG5cclxuICAgIC8vIEFwcGx5IHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIFxyXG4gICAgLy8gTW92ZSB0byB0YXJnZXQgY2VudGVyXHJcbiAgICBjdHgudHJhbnNsYXRlKHRhcmdldENlbnRlclgsIHRhcmdldENlbnRlclkpO1xyXG4gICAgXHJcbiAgICAvLyBSb3RhdGUgdG8gYWxpZ24gZXllcyBob3Jpem9udGFsbHlcclxuICAgIGN0eC5yb3RhdGUoLWV5ZUFuZ2xlKTtcclxuICAgIFxyXG4gICAgLy8gU2NhbGUgdG8gbWF0Y2ggdGFyZ2V0IGV5ZSBkaXN0YW5jZVxyXG4gICAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSk7XHJcbiAgICBcclxuICAgIC8vIERyYXcgaW1hZ2UgY2VudGVyZWQgb24gZXllIGNlbnRlclxyXG4gICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgc291cmNlSW1hZ2UsXHJcbiAgICAgIC1leWVDZW50ZXJYLFxyXG4gICAgICAtZXllQ2VudGVyWVxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuXHJcbiAgICByZXR1cm4gY2FudmFzO1xyXG4gIH1cclxuXHJcbiAgLy8gTWV0aG9kIHRvIGNoZWNrIGlmIGV5ZSBwb2ludHMgYXJlIHZhbGlkIGZvciBhbGlnbm1lbnRcclxuICB2YWxpZGF0ZUV5ZVBvaW50cyhleWVQb2ludHM6IEV5ZVBvaW50cywgaW1hZ2VXaWR0aDogbnVtYmVyLCBpbWFnZUhlaWdodDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCB7IGxlZnQsIHJpZ2h0IH0gPSBleWVQb2ludHM7XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgcG9pbnRzIGFyZSB3aXRoaW4gaW1hZ2UgYm91bmRzXHJcbiAgICBpZiAobGVmdFswXSA8IDAgfHwgbGVmdFswXSA+IGltYWdlV2lkdGggfHwgbGVmdFsxXSA8IDAgfHwgbGVmdFsxXSA+IGltYWdlSGVpZ2h0KSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChyaWdodFswXSA8IDAgfHwgcmlnaHRbMF0gPiBpbWFnZVdpZHRoIHx8IHJpZ2h0WzFdIDwgMCB8fCByaWdodFsxXSA+IGltYWdlSGVpZ2h0KSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiBleWVzIGFyZSByZWFzb25hYmx5IGZhciBhcGFydFxyXG4gICAgY29uc3QgZXllRGlzdGFuY2UgPSBNYXRoLnNxcnQoXHJcbiAgICAgIE1hdGgucG93KHJpZ2h0WzBdIC0gbGVmdFswXSwgMikgKyBNYXRoLnBvdyhyaWdodFsxXSAtIGxlZnRbMV0sIDIpXHJcbiAgICApO1xyXG4gICAgY29uc3QgbWluRXllRGlzdGFuY2UgPSBNYXRoLm1pbihpbWFnZVdpZHRoLCBpbWFnZUhlaWdodCkgKiAwLjA1OyAvLyA1JSBvZiBzbWFsbGVyIGRpbWVuc2lvblxyXG4gICAgY29uc3QgbWF4RXllRGlzdGFuY2UgPSBNYXRoLm1heChpbWFnZVdpZHRoLCBpbWFnZUhlaWdodCkgKiAwLjg7ICAvLyA4MCUgb2YgbGFyZ2VyIGRpbWVuc2lvblxyXG5cclxuICAgIHJldHVybiBleWVEaXN0YW5jZSA+PSBtaW5FeWVEaXN0YW5jZSAmJiBleWVEaXN0YW5jZSA8PSBtYXhFeWVEaXN0YW5jZTtcclxuICB9XHJcblxyXG4gIC8vIEdldCBwcmV2aWV3IG9mIGFsaWdubWVudCB0cmFuc2Zvcm1hdGlvblxyXG4gIGdldEFsaWdubWVudFByZXZpZXcoXHJcbiAgICBzb3VyY2VJbWFnZTogSFRNTEltYWdlRWxlbWVudCxcclxuICAgIGV5ZVBvaW50czogRXllUG9pbnRzLFxyXG4gICAgdGFyZ2V0UmVzb2x1dGlvbjogUmVzb2x1dGlvbkNvbmZpZyxcclxuICAgIHByZXZpZXdTaXplID0gMjAwXHJcbiAgKTogSFRNTENhbnZhc0VsZW1lbnQge1xyXG4gICAgLy8gQ3JlYXRlIHNtYWxsZXIgcHJldmlld1xyXG4gICAgY29uc3QgcHJldmlld1Jlc29sdXRpb24gPSB7XHJcbiAgICAgIHdpZHRoOiBwcmV2aWV3U2l6ZSxcclxuICAgICAgaGVpZ2h0OiAocHJldmlld1NpemUgKiB0YXJnZXRSZXNvbHV0aW9uLmhlaWdodCkgLyB0YXJnZXRSZXNvbHV0aW9uLndpZHRoXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiB0aGlzLmFsaWduSW1hZ2VGdWxsKHNvdXJjZUltYWdlLCBleWVQb2ludHMsIHByZXZpZXdSZXNvbHV0aW9uKTtcclxuICB9XHJcbn0iXSwibmFtZXMiOlsiSW1hZ2VBbGlnbmVyIiwiY2FsY3VsYXRlUHJlY2lzZUV5ZUNlbnRlciIsImxhbmRtYXJrcyIsImV5ZUluZGljZXMiLCJ2YWxpZExhbmRtYXJrcyIsIm1hcCIsImlkeCIsImZpbHRlciIsImxhbmRtYXJrIiwibGVuZ3RoIiwiRXJyb3IiLCJ3ZWlnaHRlZFgiLCJ3ZWlnaHRlZFkiLCJ0b3RhbFdlaWdodCIsImZvckVhY2giLCJpIiwiaXNDb3JuZXIiLCJ3ZWlnaHQiLCJ4IiwieSIsImFsaWduSW1hZ2UiLCJzb3VyY2VJbWFnZSIsImV5ZVBvaW50cyIsInRhcmdldFJlc29sdXRpb24iLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ3aWR0aCIsImhlaWdodCIsImN0eCIsImdldENvbnRleHQiLCJ0cmFuc2Zvcm0iLCJjYWxjdWxhdGVBbGlnbm1lbnRUcmFuc2Zvcm0iLCJzYXZlIiwic2V0VHJhbnNmb3JtIiwibWF0cml4IiwiZHJhd0ltYWdlIiwicmVzdG9yZSIsImxlZnQiLCJyaWdodCIsImV5ZUNlbnRlclgiLCJleWVDZW50ZXJZIiwiY3VycmVudEV5ZURpc3RhbmNlIiwiTWF0aCIsInNxcnQiLCJwb3ciLCJleWVBbmdsZSIsImF0YW4yIiwidGFyZ2V0RXllRGlzdGFuY2VQaXhlbHMiLCJ0YXJnZXRFeWVEaXN0YW5jZSIsInRhcmdldEV5ZUNlbnRlclgiLCJ0YXJnZXRFeWVDZW50ZXJZIiwidGFyZ2V0RXllWSIsInNjYWxlIiwicm90YXRpb24iLCJjb3MiLCJzaW4iLCJ0eDEiLCJ0eTEiLCJzY2FsZVJvdGF0ZU1hdHJpeCIsInR4MiIsInR5MiIsIlBJIiwidHJhbnNsYXRpb24iLCJhbGlnbkltYWdlRnVsbCIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiZXllU2NhbGUiLCJzY2FsZWRJbWFnZVdpZHRoIiwic2NhbGVkSW1hZ2VIZWlnaHQiLCJjYW52YXNGaXRTY2FsZVgiLCJjYW52YXNGaXRTY2FsZVkiLCJjYW52YXNGaXRTY2FsZSIsIm1pbiIsImZpbmFsU2NhbGUiLCJzY2FsZWRFeWVDZW50ZXJYIiwic2NhbGVkRXllQ2VudGVyWSIsImNsZWFyUmVjdCIsImNvbnNvbGUiLCJsb2ciLCJzb3VyY2VJbWFnZVNpemUiLCJjYW52YXNTaXplIiwiaW1hZ2VDb21wbGV0ZSIsImNvbXBsZXRlIiwiaW1hZ2VTcmMiLCJzcmMiLCJzdWJzdHJpbmciLCJ0ZXN0Q2FudmFzIiwidGVzdEN0eCIsInRlc3RJbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJzb3VyY2VIYXNDb250ZW50IiwiZGF0YSIsInNvbWUiLCJ2YWx1ZSIsImluZGV4IiwidHJhbnNsYXRlIiwicm90YXRlIiwiZHgiLCJkeSIsImRXaWR0aCIsImRIZWlnaHQiLCJjdXJyZW50VHJhbnNmb3JtIiwiZ2V0VHJhbnNmb3JtIiwiaW1tZWRpYXRlQ2hlY2siLCJkcmV3U29tZXRoaW5nIiwiaW1hZ2VEYXRhIiwiaGFzQ29udGVudCIsIndhcm4iLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImFsaWduSW1hZ2VGYWNlQ3JvcCIsImZhY2VSZXN1bHQiLCJwYWRkaW5nIiwiZmFjZUJvdW5kcyIsImZhY2VXaWR0aCIsImZhY2VIZWlnaHQiLCJwYWRkaW5nWCIsInBhZGRpbmdZIiwiY3JvcExlZnQiLCJtYXgiLCJjcm9wVG9wIiwidG9wIiwiY3JvcFJpZ2h0IiwiY3JvcEJvdHRvbSIsImJvdHRvbSIsImNyb3BXaWR0aCIsImNyb3BIZWlnaHQiLCJhZGp1c3RlZEV5ZVBvaW50cyIsInNjYWxlVG9GaXRYIiwic2NhbGVUb0ZpdFkiLCJmaXRTY2FsZSIsImNyb3BSZWdpb24iLCJhbGlnbkltYWdlU2ltcGxlIiwidGFyZ2V0Q2VudGVyWCIsInRhcmdldENlbnRlclkiLCJ2YWxpZGF0ZUV5ZVBvaW50cyIsImltYWdlV2lkdGgiLCJpbWFnZUhlaWdodCIsImV5ZURpc3RhbmNlIiwibWluRXllRGlzdGFuY2UiLCJtYXhFeWVEaXN0YW5jZSIsImdldEFsaWdubWVudFByZXZpZXciLCJwcmV2aWV3U2l6ZSIsInByZXZpZXdSZXNvbHV0aW9uIiwiY29uc3RydWN0b3IiLCJwcmV2aW91c1RyYW5zZm9ybXMiLCJzbW9vdGhpbmdGYWN0b3IiLCJ1c2VTdWJQaXhlbFByZWNpc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/imageAlignment.ts\n"));

/***/ })

});