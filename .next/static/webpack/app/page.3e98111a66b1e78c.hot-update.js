"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/imageAlignment.ts":
/*!*******************************!*\
  !*** ./lib/imageAlignment.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImageAligner: function() { return /* binding */ ImageAligner; }\n/* harmony export */ });\nclass ImageAligner {\n    // Enhanced eye center calculation using pupil approximation\n    calculatePreciseEyeCenter(landmarks, eyeIndices) {\n        const validLandmarks = eyeIndices.map((idx)=>landmarks[idx]).filter((landmark)=>landmark);\n        if (validLandmarks.length === 0) {\n            throw new Error(\"No valid eye landmarks found\");\n        }\n        // Weight inner eye landmarks more heavily (closer to actual pupil position)\n        let weightedX = 0, weightedY = 0, totalWeight = 0;\n        validLandmarks.forEach((landmark, i)=>{\n            // Inner landmarks get higher weight for better pupil approximation\n            const isCorner = eyeIndices[i] === 33 || eyeIndices[i] === 133 || eyeIndices[i] === 362 || eyeIndices[i] === 263;\n            const weight = isCorner ? 0.5 : 1.5; // Reduce weight of corner points\n            weightedX += landmark.x * weight;\n            weightedY += landmark.y * weight;\n            totalWeight += weight;\n        });\n        return [\n            weightedX / totalWeight,\n            weightedY / totalWeight\n        ];\n    }\n    alignImage(sourceImage, eyePoints, targetResolution) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = targetResolution.width;\n        canvas.height = targetResolution.height;\n        const ctx = canvas.getContext(\"2d\");\n        // Calculate alignment transform\n        const transform = this.calculateAlignmentTransform(eyePoints, targetResolution);\n        // Apply transformation and draw image\n        ctx.save();\n        ctx.setTransform(transform.matrix[0][0], transform.matrix[0][1], transform.matrix[1][0], transform.matrix[1][1], transform.matrix[0][2], transform.matrix[1][2]);\n        ctx.drawImage(sourceImage, 0, 0);\n        ctx.restore();\n        return canvas;\n    }\n    calculateAlignmentTransform(eyePoints, targetResolution) {\n        const { left, right } = eyePoints;\n        const { width, height } = targetResolution;\n        // Calculate current eye properties with higher precision\n        const eyeCenterX = (left[0] + right[0]) / 2;\n        const eyeCenterY = (left[1] + right[1]) / 2;\n        const currentEyeDistance = Math.sqrt(Math.pow(right[0] - left[0], 2) + Math.pow(right[1] - left[1], 2));\n        const eyeAngle = Math.atan2(right[1] - left[1], right[0] - left[0]);\n        // Calculate target eye properties\n        const targetEyeDistancePixels = width * this.targetEyeDistance;\n        const targetEyeCenterX = width / 2;\n        const targetEyeCenterY = height * this.targetEyeY;\n        // Calculate transformations\n        const scale = targetEyeDistancePixels / currentEyeDistance;\n        const rotation = -eyeAngle; // Negative to counter-rotate\n        // Create base transform\n        const transform = {\n            rotation: rotation * (180 / Math.PI),\n            scale,\n            translation: [\n                targetEyeCenterX - eyeCenterX * scale,\n                targetEyeCenterY - eyeCenterY * scale\n            ],\n            matrix: this.createTransformMatrix(scale, rotation, targetEyeCenterX - eyeCenterX * scale, targetEyeCenterY - eyeCenterY * scale)\n        };\n        // Apply temporal smoothing to reduce jitter between frames\n        return this.applySmoothingToTransform(transform);\n    }\n    createTransformMatrix(scale, rotation, tx, ty) {\n        const cos = Math.cos(rotation);\n        const sin = Math.sin(rotation);\n        return [\n            [\n                scale * cos,\n                -scale * sin,\n                tx\n            ],\n            [\n                scale * sin,\n                scale * cos,\n                ty\n            ]\n        ];\n    }\n    applySmoothingToTransform(transform) {\n        if (this.previousTransforms.length === 0) {\n            this.previousTransforms.push(transform);\n            return transform;\n        }\n        const recent = this.previousTransforms[this.previousTransforms.length - 1];\n        const alpha = this.smoothingFactor;\n        const smoothed = {\n            rotation: this.interpolateAngle(recent.rotation, transform.rotation, alpha),\n            scale: recent.scale * (1 - alpha) + transform.scale * alpha,\n            translation: [\n                recent.translation[0] * (1 - alpha) + transform.translation[0] * alpha,\n                recent.translation[1] * (1 - alpha) + transform.translation[1] * alpha\n            ],\n            matrix: transform.matrix // Recalculate matrix after smoothing\n        };\n        // Recalculate matrix with smoothed values\n        const radians = smoothed.rotation * (Math.PI / 180);\n        smoothed.matrix = this.createTransformMatrix(smoothed.scale, radians, smoothed.translation[0], smoothed.translation[1]);\n        this.previousTransforms.push(smoothed);\n        // Keep only recent transforms for memory efficiency\n        if (this.previousTransforms.length > 3) {\n            this.previousTransforms.shift();\n        }\n        return smoothed;\n    }\n    interpolateAngle(angle1, angle2, alpha) {\n        // Handle angle wraparound for smooth rotation interpolation\n        let diff = angle2 - angle1;\n        if (diff > 180) diff -= 360;\n        if (diff < -180) diff += 360;\n        return angle1 + diff * alpha;\n    }\n    // Reset smoothing state (call when processing a new set of images)\n    resetSmoothingState() {\n        this.previousTransforms = [];\n    }\n    // Full image alignment method that preserves entire image on canvas\n    alignImageFull(sourceImage, eyePoints, targetResolution) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = targetResolution.width;\n        canvas.height = targetResolution.height;\n        const ctx = canvas.getContext(\"2d\");\n        const { left, right } = eyePoints;\n        const { width: canvasWidth, height: canvasHeight } = targetResolution;\n        // Calculate eye properties in source image\n        const eyeCenterX = (left[0] + right[0]) / 2;\n        const eyeCenterY = (left[1] + right[1]) / 2;\n        const eyeAngle = Math.atan2(right[1] - left[1], right[0] - left[0]);\n        const currentEyeDistance = Math.sqrt(Math.pow(right[0] - left[0], 2) + Math.pow(right[1] - left[1], 2));\n        // Target eye properties on canvas\n        const targetEyeDistance = canvasWidth * this.targetEyeDistance;\n        const targetEyeCenterX = canvasWidth / 2;\n        const targetEyeCenterY = canvasHeight * this.targetEyeY;\n        // Calculate scale based on eye distance\n        const eyeScale = targetEyeDistance / currentEyeDistance;\n        // Calculate the scaled image dimensions\n        const scaledImageWidth = sourceImage.width * eyeScale;\n        const scaledImageHeight = sourceImage.height * eyeScale;\n        // Calculate final scale to fit entire image on canvas if needed\n        const canvasFitScaleX = canvasWidth / scaledImageWidth;\n        const canvasFitScaleY = canvasHeight / scaledImageHeight;\n        const canvasFitScale = Math.min(canvasFitScaleX, canvasFitScaleY, 1); // Don't upscale beyond eye scale\n        // Final scale combines eye alignment and canvas fitting\n        const finalScale = eyeScale * canvasFitScale;\n        // Calculate where the image should be positioned to keep eyes at target position\n        const scaledEyeCenterX = eyeCenterX * finalScale;\n        const scaledEyeCenterY = eyeCenterY * finalScale;\n        // Calculate image position (top-left corner) to place eyes at target position\n        const cos = Math.cos(-eyeAngle);\n        const sin = Math.sin(-eyeAngle);\n        // Apply transformations\n        ctx.save();\n        // Clear canvas with transparent background\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        console.log(\"alignImageFull debug:\", {\n            sourceImageSize: {\n                width: sourceImage.width,\n                height: sourceImage.height\n            },\n            canvasSize: {\n                width: canvasWidth,\n                height: canvasHeight\n            },\n            eyeScale,\n            canvasFitScale,\n            finalScale,\n            eyeCenterX,\n            eyeCenterY,\n            targetEyeCenterX,\n            targetEyeCenterY,\n            eyeAngle: eyeAngle * (180 / Math.PI) + \" degrees\",\n            imageComplete: sourceImage.complete,\n            imageSrc: sourceImage.src.substring(0, 50) + \"...\"\n        });\n        // Verify source image has content by drawing to a test canvas\n        const testCanvas = document.createElement(\"canvas\");\n        testCanvas.width = sourceImage.width;\n        testCanvas.height = sourceImage.height;\n        const testCtx = testCanvas.getContext(\"2d\");\n        testCtx.drawImage(sourceImage, 0, 0);\n        const testImageData = testCtx.getImageData(0, 0, sourceImage.width, sourceImage.height);\n        const sourceHasContent = testImageData.data.some((value, index)=>{\n            return index % 4 === 3 && value > 0; // Check alpha channel\n        });\n        console.log(\"Source image has content:\", sourceHasContent);\n        // Move to target eye center\n        ctx.translate(targetEyeCenterX, targetEyeCenterY);\n        // Rotate to align eyes horizontally\n        ctx.rotate(-eyeAngle);\n        // Scale to match target eye distance and fit canvas\n        ctx.scale(finalScale, finalScale);\n        // Draw image centered on eye center in the scaled/rotated coordinate system\n        ctx.drawImage(sourceImage, -eyeCenterX, -eyeCenterY, sourceImage.width, sourceImage.height);\n        console.log(\"DrawImage parameters:\", {\n            dx: -eyeCenterX,\n            dy: -eyeCenterY,\n            dWidth: sourceImage.width,\n            dHeight: sourceImage.height,\n            currentTransform: ctx.getTransform()\n        });\n        // Check immediately if drawing worked within the transform\n        const immediateCheck = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n        const drewSomething = immediateCheck.data.some((value, index)=>{\n            return index % 4 === 3 && value > 0;\n        });\n        console.log(\"Content exists immediately after drawImage (within transform):\", drewSomething);\n        ctx.restore();\n        // Debug: Check if canvas has content\n        const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n        const hasContent = imageData.data.some((value, index)=>{\n            return index % 4 === 3 && value > 0; // Check alpha channel for non-transparent pixels\n        });\n        console.log(\"Canvas has content after drawing:\", hasContent);\n        if (!hasContent) {\n            console.warn(\"WARNING: Canvas appears to be empty after alignment\");\n            // Debug: Try a simple red rectangle to verify canvas is working\n            ctx.fillStyle = \"red\";\n            ctx.fillRect(10, 10, 50, 50);\n            console.log(\"Added debug red rectangle to empty canvas\");\n        }\n        return canvas;\n    }\n    // Enhanced face cropping alignment with improved eye detection\n    alignImageFaceCrop(sourceImage, faceResult, targetResolution) {\n        let padding = arguments.length > 3 && arguments[3] !== void 0 // 60% padding around face for better framing\n         ? arguments[3] : 0.6;\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = targetResolution.width;\n        canvas.height = targetResolution.height;\n        const ctx = canvas.getContext(\"2d\");\n        // Enable high-quality rendering for better results\n        if (this.useSubPixelPrecision) {\n            ctx.imageSmoothingEnabled = true;\n            ctx.imageSmoothingQuality = \"high\";\n        }\n        const { eyePoints, faceBounds, landmarks } = faceResult;\n        const { width: canvasWidth, height: canvasHeight } = targetResolution;\n        if (!faceBounds) {\n            // Fallback to full alignment if no face bounds\n            return this.alignImageFull(sourceImage, eyePoints, targetResolution);\n        }\n        // Try to use enhanced eye detection if landmarks are available\n        let enhancedEyePoints = eyePoints;\n        if (landmarks && landmarks.length > 0) {\n            try {\n                const leftEyeIndices = [\n                    33,\n                    7,\n                    163,\n                    144,\n                    145,\n                    153,\n                    154,\n                    155,\n                    133,\n                    173,\n                    157,\n                    158,\n                    159,\n                    160,\n                    161\n                ];\n                const rightEyeIndices = [\n                    362,\n                    382,\n                    381,\n                    380,\n                    374,\n                    373,\n                    390,\n                    249,\n                    263,\n                    466,\n                    388,\n                    387,\n                    386,\n                    385,\n                    384\n                ];\n                const leftEyeCenter = this.calculatePreciseEyeCenter(landmarks, leftEyeIndices);\n                const rightEyeCenter = this.calculatePreciseEyeCenter(landmarks, rightEyeIndices);\n                enhancedEyePoints = {\n                    left: [\n                        leftEyeCenter[0] * sourceImage.width,\n                        leftEyeCenter[1] * sourceImage.height\n                    ],\n                    right: [\n                        rightEyeCenter[0] * sourceImage.width,\n                        rightEyeCenter[1] * sourceImage.height\n                    ]\n                };\n            } catch (error) {\n                console.log(\"Enhanced eye detection failed, using fallback:\", error);\n            // Continue with original eye points\n            }\n        }\n        // Calculate padded face region with extra vertical padding\n        const faceWidth = faceBounds.width;\n        const faceHeight = faceBounds.height;\n        const paddingX = faceWidth * padding;\n        const paddingY = faceHeight * (padding + 0.2); // Extra 20% vertical padding for forehead/chin\n        const cropLeft = Math.max(0, faceBounds.left - paddingX);\n        const cropTop = Math.max(0, faceBounds.top - paddingY);\n        const cropRight = Math.min(sourceImage.width, faceBounds.right + paddingX);\n        const cropBottom = Math.min(sourceImage.height, faceBounds.bottom + paddingY);\n        const cropWidth = cropRight - cropLeft;\n        const cropHeight = cropBottom - cropTop;\n        // Adjust eye points relative to crop region\n        const adjustedEyePoints = {\n            left: [\n                eyePoints.left[0] - cropLeft,\n                eyePoints.left[1] - cropTop\n            ],\n            right: [\n                eyePoints.right[0] - cropLeft,\n                eyePoints.right[1] - cropTop\n            ]\n        };\n        // Calculate eye properties in cropped region\n        const eyeCenterX = (adjustedEyePoints.left[0] + adjustedEyePoints.right[0]) / 2;\n        const eyeCenterY = (adjustedEyePoints.left[1] + adjustedEyePoints.right[1]) / 2;\n        const eyeAngle = Math.atan2(adjustedEyePoints.right[1] - adjustedEyePoints.left[1], adjustedEyePoints.right[0] - adjustedEyePoints.left[0]);\n        const currentEyeDistance = Math.sqrt(Math.pow(adjustedEyePoints.right[0] - adjustedEyePoints.left[0], 2) + Math.pow(adjustedEyePoints.right[1] - adjustedEyePoints.left[1], 2));\n        // Target eye properties\n        const targetEyeDistance = canvasWidth * this.targetEyeDistance;\n        const targetEyeCenterX = canvasWidth / 2;\n        const targetEyeCenterY = canvasHeight * this.targetEyeY;\n        // Calculate scale to fit cropped region to canvas\n        const eyeScale = targetEyeDistance / currentEyeDistance;\n        const scaleToFitX = canvasWidth / cropWidth;\n        const scaleToFitY = canvasHeight / cropHeight;\n        const fitScale = Math.min(scaleToFitX, scaleToFitY);\n        // Use the more appropriate scale\n        const finalScale = Math.min(eyeScale, fitScale * 1.2); // Allow slight overflow for better framing\n        // Apply transformations\n        ctx.save();\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        console.log(\"alignImageFaceCrop debug:\", {\n            cropRegion: {\n                left: cropLeft,\n                top: cropTop,\n                width: cropWidth,\n                height: cropHeight\n            },\n            canvasSize: {\n                width: canvasWidth,\n                height: canvasHeight\n            },\n            eyeScale,\n            fitScale,\n            finalScale,\n            eyeCenterX,\n            eyeCenterY,\n            targetEyeCenterX,\n            targetEyeCenterY,\n            eyeAngle: eyeAngle * (180 / Math.PI) + \" degrees\"\n        });\n        // Move to target eye center\n        ctx.translate(targetEyeCenterX, targetEyeCenterY);\n        // Rotate to align eyes horizontally\n        ctx.rotate(-eyeAngle);\n        // Scale the cropped region\n        ctx.scale(finalScale, finalScale);\n        // Draw the cropped region centered on eye center\n        ctx.drawImage(sourceImage, cropLeft, cropTop, cropWidth, cropHeight, -eyeCenterX, -eyeCenterY, cropWidth, cropHeight // Destination\n        );\n        ctx.restore();\n        // Debug: Check if canvas has content\n        const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n        const hasContent = imageData.data.some((value, index)=>{\n            return index % 4 === 3 && value > 0; // Check alpha channel for non-transparent pixels\n        });\n        console.log(\"Canvas has content after face crop drawing:\", hasContent);\n        if (!hasContent) {\n            console.warn(\"WARNING: Face crop canvas appears to be empty after alignment\");\n            // Debug: Try a simple blue rectangle to verify canvas is working\n            ctx.fillStyle = \"blue\";\n            ctx.fillRect(10, 10, 50, 50);\n            console.log(\"Added debug blue rectangle to empty face crop canvas\");\n        }\n        return canvas;\n    }\n    // Alternative simpler alignment method using canvas transforms\n    alignImageSimple(sourceImage, eyePoints, targetResolution) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = targetResolution.width;\n        canvas.height = targetResolution.height;\n        const ctx = canvas.getContext(\"2d\");\n        const { left, right } = eyePoints;\n        const { width, height } = targetResolution;\n        // Calculate eye center and angle\n        const eyeCenterX = (left[0] + right[0]) / 2;\n        const eyeCenterY = (left[1] + right[1]) / 2;\n        const eyeAngle = Math.atan2(right[1] - left[1], right[0] - left[0]);\n        const currentEyeDistance = Math.sqrt(Math.pow(right[0] - left[0], 2) + Math.pow(right[1] - left[1], 2));\n        // Target properties\n        const targetEyeDistance = width * this.targetEyeDistance;\n        const targetCenterX = width / 2;\n        const targetCenterY = height * this.targetEyeY;\n        const scale = targetEyeDistance / currentEyeDistance;\n        // Apply transformations\n        ctx.save();\n        // Move to target center\n        ctx.translate(targetCenterX, targetCenterY);\n        // Rotate to align eyes horizontally\n        ctx.rotate(-eyeAngle);\n        // Scale to match target eye distance\n        ctx.scale(scale, scale);\n        // Draw image centered on eye center\n        ctx.drawImage(sourceImage, -eyeCenterX, -eyeCenterY);\n        ctx.restore();\n        return canvas;\n    }\n    // Method to check if eye points are valid for alignment\n    validateEyePoints(eyePoints, imageWidth, imageHeight) {\n        const { left, right } = eyePoints;\n        // Check if points are within image bounds\n        if (left[0] < 0 || left[0] > imageWidth || left[1] < 0 || left[1] > imageHeight) {\n            return false;\n        }\n        if (right[0] < 0 || right[0] > imageWidth || right[1] < 0 || right[1] > imageHeight) {\n            return false;\n        }\n        // Check if eyes are reasonably far apart\n        const eyeDistance = Math.sqrt(Math.pow(right[0] - left[0], 2) + Math.pow(right[1] - left[1], 2));\n        const minEyeDistance = Math.min(imageWidth, imageHeight) * 0.05; // 5% of smaller dimension\n        const maxEyeDistance = Math.max(imageWidth, imageHeight) * 0.8; // 80% of larger dimension\n        return eyeDistance >= minEyeDistance && eyeDistance <= maxEyeDistance;\n    }\n    // Get preview of alignment transformation\n    getAlignmentPreview(sourceImage, eyePoints, targetResolution) {\n        let previewSize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 200;\n        // Create smaller preview\n        const previewResolution = {\n            width: previewSize,\n            height: previewSize * targetResolution.height / targetResolution.width\n        };\n        return this.alignImageFull(sourceImage, eyePoints, previewResolution);\n    }\n    constructor(targetEyeDistance = 0.35, targetEyeY = 0.4){\n        this.targetEyeDistance = 0.35 // Target eye distance as proportion of canvas width\n        ;\n        this.targetEyeY = 0.4 // Target eye Y position as proportion of canvas height\n        ;\n        // Enhanced alignment features\n        this.previousTransforms = [];\n        this.smoothingFactor = 0.15 // Temporal smoothing to reduce jitter\n        ;\n        this.useSubPixelPrecision = true;\n        this.targetEyeDistance = targetEyeDistance;\n        this.targetEyeY = targetEyeY;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9pbWFnZUFsaWdubWVudC50cyIsIm1hcHBpbmdzIjoiOzs7O0FBSU8sTUFBTUE7SUFjWCw0REFBNEQ7SUFDcERDLDBCQUEwQkMsU0FBeUIsRUFBRUMsVUFBb0IsRUFBb0I7UUFDbkcsTUFBTUMsaUJBQWlCRCxXQUNwQkUsR0FBRyxDQUFDQyxDQUFBQSxNQUFPSixTQUFTLENBQUNJLElBQUksRUFDekJDLE1BQU0sQ0FBQ0MsQ0FBQUEsV0FBWUE7UUFFdEIsSUFBSUosZUFBZUssTUFBTSxLQUFLLEdBQUc7WUFDL0IsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsNEVBQTRFO1FBQzVFLElBQUlDLFlBQVksR0FBR0MsWUFBWSxHQUFHQyxjQUFjO1FBRWhEVCxlQUFlVSxPQUFPLENBQUMsQ0FBQ04sVUFBVU87WUFDaEMsbUVBQW1FO1lBQ25FLE1BQU1DLFdBQVdiLFVBQVUsQ0FBQ1ksRUFBRSxLQUFLLE1BQU1aLFVBQVUsQ0FBQ1ksRUFBRSxLQUFLLE9BQU9aLFVBQVUsQ0FBQ1ksRUFBRSxLQUFLLE9BQU9aLFVBQVUsQ0FBQ1ksRUFBRSxLQUFLO1lBQzdHLE1BQU1FLFNBQVNELFdBQVcsTUFBTSxLQUFLLGlDQUFpQztZQUV0RUwsYUFBYUgsU0FBU1UsQ0FBQyxHQUFHRDtZQUMxQkwsYUFBYUosU0FBU1csQ0FBQyxHQUFHRjtZQUMxQkosZUFBZUk7UUFDakI7UUFFQSxPQUFPO1lBQUNOLFlBQVlFO1lBQWFELFlBQVlDO1NBQVk7SUFDM0Q7SUFFQU8sV0FDRUMsV0FBNkIsRUFDN0JDLFNBQW9CLEVBQ3BCQyxnQkFBa0MsRUFDZjtRQUNuQixNQUFNQyxTQUFTQyxTQUFTQyxhQUFhLENBQUM7UUFDdENGLE9BQU9HLEtBQUssR0FBR0osaUJBQWlCSSxLQUFLO1FBQ3JDSCxPQUFPSSxNQUFNLEdBQUdMLGlCQUFpQkssTUFBTTtRQUN2QyxNQUFNQyxNQUFNTCxPQUFPTSxVQUFVLENBQUM7UUFFOUIsZ0NBQWdDO1FBQ2hDLE1BQU1D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QyxTQUFvQixFQUNwQkMsZ0JBQWtDLEVBRWY7WUFEbkI2SSxjQUFBQSxpRUFBYztRQUVkLHlCQUF5QjtRQUN6QixNQUFNQyxvQkFBb0I7WUFDeEIxSSxPQUFPeUk7WUFDUHhJLFFBQVEsY0FBZUwsaUJBQWlCSyxNQUFNLEdBQUlMLGlCQUFpQkksS0FBSztRQUMxRTtRQUVBLE9BQU8sSUFBSSxDQUFDaUQsY0FBYyxDQUFDdkQsYUFBYUMsV0FBVytJO0lBQ3JEO0lBMWdCQUMsWUFBWXJILG9CQUFvQixJQUFJLEVBQUVHLGFBQWEsR0FBRyxDQUFFO2FBUmhESCxvQkFBb0IsS0FBTSxvREFBb0Q7O2FBQzlFRyxhQUFhLElBQUssdURBQXVEOztRQUVqRiw4QkFBOEI7YUFDdEJXLHFCQUEyQyxFQUFFO2FBQzdDSSxrQkFBa0IsS0FBTSxzQ0FBc0M7O2FBQzlEMkQsdUJBQXVCO1FBRzdCLElBQUksQ0FBQzdFLGlCQUFpQixHQUFHQTtRQUN6QixJQUFJLENBQUNHLFVBQVUsR0FBR0E7SUFDcEI7QUF3Z0JGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9pbWFnZUFsaWdubWVudC50cz8xZDQ1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV5ZVBvaW50cywgQWxpZ25tZW50VHJhbnNmb3JtLCBSZXNvbHV0aW9uQ29uZmlnLCBGYWNlRGV0ZWN0aW9uUmVzdWx0LCBGYWNlTGFuZG1hcmsgfSBmcm9tICcuL3R5cGVzJztcclxuXHJcbmV4cG9ydCB0eXBlIEFsaWdubWVudE1vZGUgPSAnZnVsbCcgfCAnZmFjZS1jcm9wJyB8ICdzbWFydC1mcmFtZSc7XHJcblxyXG5leHBvcnQgY2xhc3MgSW1hZ2VBbGlnbmVyIHtcclxuICBwcml2YXRlIHRhcmdldEV5ZURpc3RhbmNlID0gMC4zNTsgLy8gVGFyZ2V0IGV5ZSBkaXN0YW5jZSBhcyBwcm9wb3J0aW9uIG9mIGNhbnZhcyB3aWR0aFxyXG4gIHByaXZhdGUgdGFyZ2V0RXllWSA9IDAuNDsgLy8gVGFyZ2V0IGV5ZSBZIHBvc2l0aW9uIGFzIHByb3BvcnRpb24gb2YgY2FudmFzIGhlaWdodFxyXG4gIFxyXG4gIC8vIEVuaGFuY2VkIGFsaWdubWVudCBmZWF0dXJlc1xyXG4gIHByaXZhdGUgcHJldmlvdXNUcmFuc2Zvcm1zOiBBbGlnbm1lbnRUcmFuc2Zvcm1bXSA9IFtdO1xyXG4gIHByaXZhdGUgc21vb3RoaW5nRmFjdG9yID0gMC4xNTsgLy8gVGVtcG9yYWwgc21vb3RoaW5nIHRvIHJlZHVjZSBqaXR0ZXJcclxuICBwcml2YXRlIHVzZVN1YlBpeGVsUHJlY2lzaW9uID0gdHJ1ZTtcclxuXHJcbiAgY29uc3RydWN0b3IodGFyZ2V0RXllRGlzdGFuY2UgPSAwLjM1LCB0YXJnZXRFeWVZID0gMC40KSB7XHJcbiAgICB0aGlzLnRhcmdldEV5ZURpc3RhbmNlID0gdGFyZ2V0RXllRGlzdGFuY2U7XHJcbiAgICB0aGlzLnRhcmdldEV5ZVkgPSB0YXJnZXRFeWVZO1xyXG4gIH1cclxuXHJcbiAgLy8gRW5oYW5jZWQgZXllIGNlbnRlciBjYWxjdWxhdGlvbiB1c2luZyBwdXBpbCBhcHByb3hpbWF0aW9uXHJcbiAgcHJpdmF0ZSBjYWxjdWxhdGVQcmVjaXNlRXllQ2VudGVyKGxhbmRtYXJrczogRmFjZUxhbmRtYXJrW10sIGV5ZUluZGljZXM6IG51bWJlcltdKTogW251bWJlciwgbnVtYmVyXSB7XHJcbiAgICBjb25zdCB2YWxpZExhbmRtYXJrcyA9IGV5ZUluZGljZXNcclxuICAgICAgLm1hcChpZHggPT4gbGFuZG1hcmtzW2lkeF0pXHJcbiAgICAgIC5maWx0ZXIobGFuZG1hcmsgPT4gbGFuZG1hcmspO1xyXG5cclxuICAgIGlmICh2YWxpZExhbmRtYXJrcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBleWUgbGFuZG1hcmtzIGZvdW5kJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2VpZ2h0IGlubmVyIGV5ZSBsYW5kbWFya3MgbW9yZSBoZWF2aWx5IChjbG9zZXIgdG8gYWN0dWFsIHB1cGlsIHBvc2l0aW9uKVxyXG4gICAgbGV0IHdlaWdodGVkWCA9IDAsIHdlaWdodGVkWSA9IDAsIHRvdGFsV2VpZ2h0ID0gMDtcclxuXHJcbiAgICB2YWxpZExhbmRtYXJrcy5mb3JFYWNoKChsYW5kbWFyaywgaSkgPT4ge1xyXG4gICAgICAvLyBJbm5lciBsYW5kbWFya3MgZ2V0IGhpZ2hlciB3ZWlnaHQgZm9yIGJldHRlciBwdXBpbCBhcHByb3hpbWF0aW9uXHJcbiAgICAgIGNvbnN0IGlzQ29ybmVyID0gZXllSW5kaWNlc1tpXSA9PT0gMzMgfHwgZXllSW5kaWNlc1tpXSA9PT0gMTMzIHx8IGV5ZUluZGljZXNbaV0gPT09IDM2MiB8fCBleWVJbmRpY2VzW2ldID09PSAyNjM7XHJcbiAgICAgIGNvbnN0IHdlaWdodCA9IGlzQ29ybmVyID8gMC41IDogMS41OyAvLyBSZWR1Y2Ugd2VpZ2h0IG9mIGNvcm5lciBwb2ludHNcclxuICAgICAgXHJcbiAgICAgIHdlaWdodGVkWCArPSBsYW5kbWFyay54ICogd2VpZ2h0O1xyXG4gICAgICB3ZWlnaHRlZFkgKz0gbGFuZG1hcmsueSAqIHdlaWdodDtcclxuICAgICAgdG90YWxXZWlnaHQgKz0gd2VpZ2h0O1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIFt3ZWlnaHRlZFggLyB0b3RhbFdlaWdodCwgd2VpZ2h0ZWRZIC8gdG90YWxXZWlnaHRdO1xyXG4gIH1cclxuXHJcbiAgYWxpZ25JbWFnZShcclxuICAgIHNvdXJjZUltYWdlOiBIVE1MSW1hZ2VFbGVtZW50LFxyXG4gICAgZXllUG9pbnRzOiBFeWVQb2ludHMsXHJcbiAgICB0YXJnZXRSZXNvbHV0aW9uOiBSZXNvbHV0aW9uQ29uZmlnXHJcbiAgKTogSFRNTENhbnZhc0VsZW1lbnQge1xyXG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICBjYW52YXMud2lkdGggPSB0YXJnZXRSZXNvbHV0aW9uLndpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IHRhcmdldFJlc29sdXRpb24uaGVpZ2h0O1xyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykhO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBhbGlnbm1lbnQgdHJhbnNmb3JtXHJcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSB0aGlzLmNhbGN1bGF0ZUFsaWdubWVudFRyYW5zZm9ybShcclxuICAgICAgZXllUG9pbnRzLFxyXG4gICAgICB0YXJnZXRSZXNvbHV0aW9uXHJcbiAgICApO1xyXG5cclxuICAgIC8vIEFwcGx5IHRyYW5zZm9ybWF0aW9uIGFuZCBkcmF3IGltYWdlXHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgY3R4LnNldFRyYW5zZm9ybShcclxuICAgICAgdHJhbnNmb3JtLm1hdHJpeFswXVswXSwgdHJhbnNmb3JtLm1hdHJpeFswXVsxXSxcclxuICAgICAgdHJhbnNmb3JtLm1hdHJpeFsxXVswXSwgdHJhbnNmb3JtLm1hdHJpeFsxXVsxXSxcclxuICAgICAgdHJhbnNmb3JtLm1hdHJpeFswXVsyXSwgdHJhbnNmb3JtLm1hdHJpeFsxXVsyXVxyXG4gICAgKTtcclxuXHJcbiAgICBjdHguZHJhd0ltYWdlKHNvdXJjZUltYWdlLCAwLCAwKTtcclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcblxyXG4gICAgcmV0dXJuIGNhbnZhcztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2FsY3VsYXRlQWxpZ25tZW50VHJhbnNmb3JtKFxyXG4gICAgZXllUG9pbnRzOiBFeWVQb2ludHMsXHJcbiAgICB0YXJnZXRSZXNvbHV0aW9uOiBSZXNvbHV0aW9uQ29uZmlnXHJcbiAgKTogQWxpZ25tZW50VHJhbnNmb3JtIHtcclxuICAgIGNvbnN0IHsgbGVmdCwgcmlnaHQgfSA9IGV5ZVBvaW50cztcclxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGFyZ2V0UmVzb2x1dGlvbjtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgY3VycmVudCBleWUgcHJvcGVydGllcyB3aXRoIGhpZ2hlciBwcmVjaXNpb25cclxuICAgIGNvbnN0IGV5ZUNlbnRlclggPSAobGVmdFswXSArIHJpZ2h0WzBdKSAvIDI7XHJcbiAgICBjb25zdCBleWVDZW50ZXJZID0gKGxlZnRbMV0gKyByaWdodFsxXSkgLyAyO1xyXG4gICAgY29uc3QgY3VycmVudEV5ZURpc3RhbmNlID0gTWF0aC5zcXJ0KFxyXG4gICAgICBNYXRoLnBvdyhyaWdodFswXSAtIGxlZnRbMF0sIDIpICsgTWF0aC5wb3cocmlnaHRbMV0gLSBsZWZ0WzFdLCAyKVxyXG4gICAgKTtcclxuICAgIGNvbnN0IGV5ZUFuZ2xlID0gTWF0aC5hdGFuMihyaWdodFsxXSAtIGxlZnRbMV0sIHJpZ2h0WzBdIC0gbGVmdFswXSk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRhcmdldCBleWUgcHJvcGVydGllc1xyXG4gICAgY29uc3QgdGFyZ2V0RXllRGlzdGFuY2VQaXhlbHMgPSB3aWR0aCAqIHRoaXMudGFyZ2V0RXllRGlzdGFuY2U7XHJcbiAgICBjb25zdCB0YXJnZXRFeWVDZW50ZXJYID0gd2lkdGggLyAyO1xyXG4gICAgY29uc3QgdGFyZ2V0RXllQ2VudGVyWSA9IGhlaWdodCAqIHRoaXMudGFyZ2V0RXllWTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdHJhbnNmb3JtYXRpb25zXHJcbiAgICBjb25zdCBzY2FsZSA9IHRhcmdldEV5ZURpc3RhbmNlUGl4ZWxzIC8gY3VycmVudEV5ZURpc3RhbmNlO1xyXG4gICAgY29uc3Qgcm90YXRpb24gPSAtZXllQW5nbGU7IC8vIE5lZ2F0aXZlIHRvIGNvdW50ZXItcm90YXRlXHJcblxyXG4gICAgLy8gQ3JlYXRlIGJhc2UgdHJhbnNmb3JtXHJcbiAgICBjb25zdCB0cmFuc2Zvcm06IEFsaWdubWVudFRyYW5zZm9ybSA9IHtcclxuICAgICAgcm90YXRpb246IHJvdGF0aW9uICogKDE4MCAvIE1hdGguUEkpLCAvLyBDb252ZXJ0IHRvIGRlZ3JlZXNcclxuICAgICAgc2NhbGUsXHJcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGFyZ2V0RXllQ2VudGVyWCAtIGV5ZUNlbnRlclggKiBzY2FsZSwgdGFyZ2V0RXllQ2VudGVyWSAtIGV5ZUNlbnRlclkgKiBzY2FsZV0sXHJcbiAgICAgIG1hdHJpeDogdGhpcy5jcmVhdGVUcmFuc2Zvcm1NYXRyaXgoc2NhbGUsIHJvdGF0aW9uLCB0YXJnZXRFeWVDZW50ZXJYIC0gZXllQ2VudGVyWCAqIHNjYWxlLCB0YXJnZXRFeWVDZW50ZXJZIC0gZXllQ2VudGVyWSAqIHNjYWxlKVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBcHBseSB0ZW1wb3JhbCBzbW9vdGhpbmcgdG8gcmVkdWNlIGppdHRlciBiZXR3ZWVuIGZyYW1lc1xyXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlTbW9vdGhpbmdUb1RyYW5zZm9ybSh0cmFuc2Zvcm0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjcmVhdGVUcmFuc2Zvcm1NYXRyaXgoc2NhbGU6IG51bWJlciwgcm90YXRpb246IG51bWJlciwgdHg6IG51bWJlciwgdHk6IG51bWJlcik6IG51bWJlcltdW10ge1xyXG4gICAgY29uc3QgY29zID0gTWF0aC5jb3Mocm90YXRpb24pO1xyXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4ocm90YXRpb24pO1xyXG5cclxuICAgIHJldHVybiBbXHJcbiAgICAgIFtzY2FsZSAqIGNvcywgLXNjYWxlICogc2luLCB0eF0sXHJcbiAgICAgIFtzY2FsZSAqIHNpbiwgc2NhbGUgKiBjb3MsIHR5XVxyXG4gICAgXTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXBwbHlTbW9vdGhpbmdUb1RyYW5zZm9ybSh0cmFuc2Zvcm06IEFsaWdubWVudFRyYW5zZm9ybSk6IEFsaWdubWVudFRyYW5zZm9ybSB7XHJcbiAgICBpZiAodGhpcy5wcmV2aW91c1RyYW5zZm9ybXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHRoaXMucHJldmlvdXNUcmFuc2Zvcm1zLnB1c2godHJhbnNmb3JtKTtcclxuICAgICAgcmV0dXJuIHRyYW5zZm9ybTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZWNlbnQgPSB0aGlzLnByZXZpb3VzVHJhbnNmb3Jtc1t0aGlzLnByZXZpb3VzVHJhbnNmb3Jtcy5sZW5ndGggLSAxXTtcclxuICAgIGNvbnN0IGFscGhhID0gdGhpcy5zbW9vdGhpbmdGYWN0b3I7XHJcblxyXG4gICAgY29uc3Qgc21vb3RoZWQ6IEFsaWdubWVudFRyYW5zZm9ybSA9IHtcclxuICAgICAgcm90YXRpb246IHRoaXMuaW50ZXJwb2xhdGVBbmdsZShyZWNlbnQucm90YXRpb24sIHRyYW5zZm9ybS5yb3RhdGlvbiwgYWxwaGEpLFxyXG4gICAgICBzY2FsZTogcmVjZW50LnNjYWxlICogKDEgLSBhbHBoYSkgKyB0cmFuc2Zvcm0uc2NhbGUgKiBhbHBoYSxcclxuICAgICAgdHJhbnNsYXRpb246IFtcclxuICAgICAgICByZWNlbnQudHJhbnNsYXRpb25bMF0gKiAoMSAtIGFscGhhKSArIHRyYW5zZm9ybS50cmFuc2xhdGlvblswXSAqIGFscGhhLFxyXG4gICAgICAgIHJlY2VudC50cmFuc2xhdGlvblsxXSAqICgxIC0gYWxwaGEpICsgdHJhbnNmb3JtLnRyYW5zbGF0aW9uWzFdICogYWxwaGFcclxuICAgICAgXSxcclxuICAgICAgbWF0cml4OiB0cmFuc2Zvcm0ubWF0cml4IC8vIFJlY2FsY3VsYXRlIG1hdHJpeCBhZnRlciBzbW9vdGhpbmdcclxuICAgIH07XHJcblxyXG4gICAgLy8gUmVjYWxjdWxhdGUgbWF0cml4IHdpdGggc21vb3RoZWQgdmFsdWVzXHJcbiAgICBjb25zdCByYWRpYW5zID0gc21vb3RoZWQucm90YXRpb24gKiAoTWF0aC5QSSAvIDE4MCk7XHJcbiAgICBzbW9vdGhlZC5tYXRyaXggPSB0aGlzLmNyZWF0ZVRyYW5zZm9ybU1hdHJpeChzbW9vdGhlZC5zY2FsZSwgcmFkaWFucywgc21vb3RoZWQudHJhbnNsYXRpb25bMF0sIHNtb290aGVkLnRyYW5zbGF0aW9uWzFdKTtcclxuXHJcbiAgICB0aGlzLnByZXZpb3VzVHJhbnNmb3Jtcy5wdXNoKHNtb290aGVkKTtcclxuICAgIFxyXG4gICAgLy8gS2VlcCBvbmx5IHJlY2VudCB0cmFuc2Zvcm1zIGZvciBtZW1vcnkgZWZmaWNpZW5jeVxyXG4gICAgaWYgKHRoaXMucHJldmlvdXNUcmFuc2Zvcm1zLmxlbmd0aCA+IDMpIHtcclxuICAgICAgdGhpcy5wcmV2aW91c1RyYW5zZm9ybXMuc2hpZnQoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc21vb3RoZWQ7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGludGVycG9sYXRlQW5nbGUoYW5nbGUxOiBudW1iZXIsIGFuZ2xlMjogbnVtYmVyLCBhbHBoYTogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIC8vIEhhbmRsZSBhbmdsZSB3cmFwYXJvdW5kIGZvciBzbW9vdGggcm90YXRpb24gaW50ZXJwb2xhdGlvblxyXG4gICAgbGV0IGRpZmYgPSBhbmdsZTIgLSBhbmdsZTE7XHJcbiAgICBpZiAoZGlmZiA+IDE4MCkgZGlmZiAtPSAzNjA7XHJcbiAgICBpZiAoZGlmZiA8IC0xODApIGRpZmYgKz0gMzYwO1xyXG4gICAgcmV0dXJuIGFuZ2xlMSArIGRpZmYgKiBhbHBoYTtcclxuICB9XHJcblxyXG4gIC8vIFJlc2V0IHNtb290aGluZyBzdGF0ZSAoY2FsbCB3aGVuIHByb2Nlc3NpbmcgYSBuZXcgc2V0IG9mIGltYWdlcylcclxuICByZXNldFNtb290aGluZ1N0YXRlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5wcmV2aW91c1RyYW5zZm9ybXMgPSBbXTtcclxuICB9XHJcblxyXG4gIC8vIEZ1bGwgaW1hZ2UgYWxpZ25tZW50IG1ldGhvZCB0aGF0IHByZXNlcnZlcyBlbnRpcmUgaW1hZ2Ugb24gY2FudmFzXHJcbiAgYWxpZ25JbWFnZUZ1bGwoXHJcbiAgICBzb3VyY2VJbWFnZTogSFRNTEltYWdlRWxlbWVudCxcclxuICAgIGV5ZVBvaW50czogRXllUG9pbnRzLFxyXG4gICAgdGFyZ2V0UmVzb2x1dGlvbjogUmVzb2x1dGlvbkNvbmZpZ1xyXG4gICk6IEhUTUxDYW52YXNFbGVtZW50IHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgY2FudmFzLndpZHRoID0gdGFyZ2V0UmVzb2x1dGlvbi53aWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSB0YXJnZXRSZXNvbHV0aW9uLmhlaWdodDtcclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpITtcclxuXHJcbiAgICBjb25zdCB7IGxlZnQsIHJpZ2h0IH0gPSBleWVQb2ludHM7XHJcbiAgICBjb25zdCB7IHdpZHRoOiBjYW52YXNXaWR0aCwgaGVpZ2h0OiBjYW52YXNIZWlnaHQgfSA9IHRhcmdldFJlc29sdXRpb247XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGV5ZSBwcm9wZXJ0aWVzIGluIHNvdXJjZSBpbWFnZVxyXG4gICAgY29uc3QgZXllQ2VudGVyWCA9IChsZWZ0WzBdICsgcmlnaHRbMF0pIC8gMjtcclxuICAgIGNvbnN0IGV5ZUNlbnRlclkgPSAobGVmdFsxXSArIHJpZ2h0WzFdKSAvIDI7XHJcbiAgICBjb25zdCBleWVBbmdsZSA9IE1hdGguYXRhbjIocmlnaHRbMV0gLSBsZWZ0WzFdLCByaWdodFswXSAtIGxlZnRbMF0pO1xyXG4gICAgY29uc3QgY3VycmVudEV5ZURpc3RhbmNlID0gTWF0aC5zcXJ0KFxyXG4gICAgICBNYXRoLnBvdyhyaWdodFswXSAtIGxlZnRbMF0sIDIpICsgTWF0aC5wb3cocmlnaHRbMV0gLSBsZWZ0WzFdLCAyKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBUYXJnZXQgZXllIHByb3BlcnRpZXMgb24gY2FudmFzXHJcbiAgICBjb25zdCB0YXJnZXRFeWVEaXN0YW5jZSA9IGNhbnZhc1dpZHRoICogdGhpcy50YXJnZXRFeWVEaXN0YW5jZTtcclxuICAgIGNvbnN0IHRhcmdldEV5ZUNlbnRlclggPSBjYW52YXNXaWR0aCAvIDI7XHJcbiAgICBjb25zdCB0YXJnZXRFeWVDZW50ZXJZID0gY2FudmFzSGVpZ2h0ICogdGhpcy50YXJnZXRFeWVZO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgc2NhbGUgYmFzZWQgb24gZXllIGRpc3RhbmNlXHJcbiAgICBjb25zdCBleWVTY2FsZSA9IHRhcmdldEV5ZURpc3RhbmNlIC8gY3VycmVudEV5ZURpc3RhbmNlO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHNjYWxlZCBpbWFnZSBkaW1lbnNpb25zXHJcbiAgICBjb25zdCBzY2FsZWRJbWFnZVdpZHRoID0gc291cmNlSW1hZ2Uud2lkdGggKiBleWVTY2FsZTtcclxuICAgIGNvbnN0IHNjYWxlZEltYWdlSGVpZ2h0ID0gc291cmNlSW1hZ2UuaGVpZ2h0ICogZXllU2NhbGU7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBmaW5hbCBzY2FsZSB0byBmaXQgZW50aXJlIGltYWdlIG9uIGNhbnZhcyBpZiBuZWVkZWRcclxuICAgIGNvbnN0IGNhbnZhc0ZpdFNjYWxlWCA9IGNhbnZhc1dpZHRoIC8gc2NhbGVkSW1hZ2VXaWR0aDtcclxuICAgIGNvbnN0IGNhbnZhc0ZpdFNjYWxlWSA9IGNhbnZhc0hlaWdodCAvIHNjYWxlZEltYWdlSGVpZ2h0O1xyXG4gICAgY29uc3QgY2FudmFzRml0U2NhbGUgPSBNYXRoLm1pbihjYW52YXNGaXRTY2FsZVgsIGNhbnZhc0ZpdFNjYWxlWSwgMSk7IC8vIERvbid0IHVwc2NhbGUgYmV5b25kIGV5ZSBzY2FsZVxyXG4gICAgXHJcbiAgICAvLyBGaW5hbCBzY2FsZSBjb21iaW5lcyBleWUgYWxpZ25tZW50IGFuZCBjYW52YXMgZml0dGluZ1xyXG4gICAgY29uc3QgZmluYWxTY2FsZSA9IGV5ZVNjYWxlICogY2FudmFzRml0U2NhbGU7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSB3aGVyZSB0aGUgaW1hZ2Ugc2hvdWxkIGJlIHBvc2l0aW9uZWQgdG8ga2VlcCBleWVzIGF0IHRhcmdldCBwb3NpdGlvblxyXG4gICAgY29uc3Qgc2NhbGVkRXllQ2VudGVyWCA9IGV5ZUNlbnRlclggKiBmaW5hbFNjYWxlO1xyXG4gICAgY29uc3Qgc2NhbGVkRXllQ2VudGVyWSA9IGV5ZUNlbnRlclkgKiBmaW5hbFNjYWxlO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgaW1hZ2UgcG9zaXRpb24gKHRvcC1sZWZ0IGNvcm5lcikgdG8gcGxhY2UgZXllcyBhdCB0YXJnZXQgcG9zaXRpb25cclxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKC1leWVBbmdsZSk7XHJcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbigtZXllQW5nbGUpO1xyXG4gICAgXHJcbiAgICAvLyBBcHBseSB0cmFuc2Zvcm1hdGlvbnNcclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBcclxuICAgIC8vIENsZWFyIGNhbnZhcyB3aXRoIHRyYW5zcGFyZW50IGJhY2tncm91bmRcclxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdhbGlnbkltYWdlRnVsbCBkZWJ1ZzonLCB7XHJcbiAgICAgIHNvdXJjZUltYWdlU2l6ZTogeyB3aWR0aDogc291cmNlSW1hZ2Uud2lkdGgsIGhlaWdodDogc291cmNlSW1hZ2UuaGVpZ2h0IH0sXHJcbiAgICAgIGNhbnZhc1NpemU6IHsgd2lkdGg6IGNhbnZhc1dpZHRoLCBoZWlnaHQ6IGNhbnZhc0hlaWdodCB9LFxyXG4gICAgICBleWVTY2FsZSxcclxuICAgICAgY2FudmFzRml0U2NhbGUsXHJcbiAgICAgIGZpbmFsU2NhbGUsXHJcbiAgICAgIGV5ZUNlbnRlclgsXHJcbiAgICAgIGV5ZUNlbnRlclksXHJcbiAgICAgIHRhcmdldEV5ZUNlbnRlclgsXHJcbiAgICAgIHRhcmdldEV5ZUNlbnRlclksXHJcbiAgICAgIGV5ZUFuZ2xlOiBleWVBbmdsZSAqICgxODAgLyBNYXRoLlBJKSArICcgZGVncmVlcycsXHJcbiAgICAgIGltYWdlQ29tcGxldGU6IHNvdXJjZUltYWdlLmNvbXBsZXRlLFxyXG4gICAgICBpbWFnZVNyYzogc291cmNlSW1hZ2Uuc3JjLnN1YnN0cmluZygwLCA1MCkgKyAnLi4uJ1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIFZlcmlmeSBzb3VyY2UgaW1hZ2UgaGFzIGNvbnRlbnQgYnkgZHJhd2luZyB0byBhIHRlc3QgY2FudmFzXHJcbiAgICBjb25zdCB0ZXN0Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICB0ZXN0Q2FudmFzLndpZHRoID0gc291cmNlSW1hZ2Uud2lkdGg7XHJcbiAgICB0ZXN0Q2FudmFzLmhlaWdodCA9IHNvdXJjZUltYWdlLmhlaWdodDtcclxuICAgIGNvbnN0IHRlc3RDdHggPSB0ZXN0Q2FudmFzLmdldENvbnRleHQoJzJkJykhO1xyXG4gICAgdGVzdEN0eC5kcmF3SW1hZ2Uoc291cmNlSW1hZ2UsIDAsIDApO1xyXG4gICAgY29uc3QgdGVzdEltYWdlRGF0YSA9IHRlc3RDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNvdXJjZUltYWdlLndpZHRoLCBzb3VyY2VJbWFnZS5oZWlnaHQpO1xyXG4gICAgY29uc3Qgc291cmNlSGFzQ29udGVudCA9IHRlc3RJbWFnZURhdGEuZGF0YS5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgcmV0dXJuIGluZGV4ICUgNCA9PT0gMyAmJiB2YWx1ZSA+IDA7IC8vIENoZWNrIGFscGhhIGNoYW5uZWxcclxuICAgIH0pO1xyXG4gICAgY29uc29sZS5sb2coJ1NvdXJjZSBpbWFnZSBoYXMgY29udGVudDonLCBzb3VyY2VIYXNDb250ZW50KTtcclxuICAgIFxyXG4gICAgLy8gTW92ZSB0byB0YXJnZXQgZXllIGNlbnRlclxyXG4gICAgY3R4LnRyYW5zbGF0ZSh0YXJnZXRFeWVDZW50ZXJYLCB0YXJnZXRFeWVDZW50ZXJZKTtcclxuICAgIFxyXG4gICAgLy8gUm90YXRlIHRvIGFsaWduIGV5ZXMgaG9yaXpvbnRhbGx5XHJcbiAgICBjdHgucm90YXRlKC1leWVBbmdsZSk7XHJcbiAgICBcclxuICAgIC8vIFNjYWxlIHRvIG1hdGNoIHRhcmdldCBleWUgZGlzdGFuY2UgYW5kIGZpdCBjYW52YXNcclxuICAgIGN0eC5zY2FsZShmaW5hbFNjYWxlLCBmaW5hbFNjYWxlKTtcclxuICAgIFxyXG4gICAgLy8gRHJhdyBpbWFnZSBjZW50ZXJlZCBvbiBleWUgY2VudGVyIGluIHRoZSBzY2FsZWQvcm90YXRlZCBjb29yZGluYXRlIHN5c3RlbVxyXG4gICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgc291cmNlSW1hZ2UsXHJcbiAgICAgIC1leWVDZW50ZXJYLFxyXG4gICAgICAtZXllQ2VudGVyWSxcclxuICAgICAgc291cmNlSW1hZ2Uud2lkdGgsXHJcbiAgICAgIHNvdXJjZUltYWdlLmhlaWdodFxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ0RyYXdJbWFnZSBwYXJhbWV0ZXJzOicsIHtcclxuICAgICAgZHg6IC1leWVDZW50ZXJYLFxyXG4gICAgICBkeTogLWV5ZUNlbnRlclksIFxyXG4gICAgICBkV2lkdGg6IHNvdXJjZUltYWdlLndpZHRoLFxyXG4gICAgICBkSGVpZ2h0OiBzb3VyY2VJbWFnZS5oZWlnaHQsXHJcbiAgICAgIGN1cnJlbnRUcmFuc2Zvcm06IGN0eC5nZXRUcmFuc2Zvcm0oKVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGltbWVkaWF0ZWx5IGlmIGRyYXdpbmcgd29ya2VkIHdpdGhpbiB0aGUgdHJhbnNmb3JtXHJcbiAgICBjb25zdCBpbW1lZGlhdGVDaGVjayA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XHJcbiAgICBjb25zdCBkcmV3U29tZXRoaW5nID0gaW1tZWRpYXRlQ2hlY2suZGF0YS5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgcmV0dXJuIGluZGV4ICUgNCA9PT0gMyAmJiB2YWx1ZSA+IDA7XHJcbiAgICB9KTtcclxuICAgIGNvbnNvbGUubG9nKCdDb250ZW50IGV4aXN0cyBpbW1lZGlhdGVseSBhZnRlciBkcmF3SW1hZ2UgKHdpdGhpbiB0cmFuc2Zvcm0pOicsIGRyZXdTb21ldGhpbmcpO1xyXG4gICAgXHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgXHJcbiAgICAvLyBEZWJ1ZzogQ2hlY2sgaWYgY2FudmFzIGhhcyBjb250ZW50XHJcbiAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xyXG4gICAgY29uc3QgaGFzQ29udGVudCA9IGltYWdlRGF0YS5kYXRhLnNvbWUoKHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICByZXR1cm4gaW5kZXggJSA0ID09PSAzICYmIHZhbHVlID4gMDsgLy8gQ2hlY2sgYWxwaGEgY2hhbm5lbCBmb3Igbm9uLXRyYW5zcGFyZW50IHBpeGVsc1xyXG4gICAgfSk7XHJcbiAgICBjb25zb2xlLmxvZygnQ2FudmFzIGhhcyBjb250ZW50IGFmdGVyIGRyYXdpbmc6JywgaGFzQ29udGVudCk7XHJcbiAgICBcclxuICAgIGlmICghaGFzQ29udGVudCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IENhbnZhcyBhcHBlYXJzIHRvIGJlIGVtcHR5IGFmdGVyIGFsaWdubWVudCcpO1xyXG4gICAgICAvLyBEZWJ1ZzogVHJ5IGEgc2ltcGxlIHJlZCByZWN0YW5nbGUgdG8gdmVyaWZ5IGNhbnZhcyBpcyB3b3JraW5nXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAncmVkJztcclxuICAgICAgY3R4LmZpbGxSZWN0KDEwLCAxMCwgNTAsIDUwKTtcclxuICAgICAgY29uc29sZS5sb2coJ0FkZGVkIGRlYnVnIHJlZCByZWN0YW5nbGUgdG8gZW1wdHkgY2FudmFzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNhbnZhcztcclxuICB9XHJcblxyXG4gIC8vIEVuaGFuY2VkIGZhY2UgY3JvcHBpbmcgYWxpZ25tZW50IHdpdGggaW1wcm92ZWQgZXllIGRldGVjdGlvblxyXG4gIGFsaWduSW1hZ2VGYWNlQ3JvcChcclxuICAgIHNvdXJjZUltYWdlOiBIVE1MSW1hZ2VFbGVtZW50LFxyXG4gICAgZmFjZVJlc3VsdDogRmFjZURldGVjdGlvblJlc3VsdCxcclxuICAgIHRhcmdldFJlc29sdXRpb246IFJlc29sdXRpb25Db25maWcsXHJcbiAgICBwYWRkaW5nOiBudW1iZXIgPSAwLjYgLy8gNjAlIHBhZGRpbmcgYXJvdW5kIGZhY2UgZm9yIGJldHRlciBmcmFtaW5nXHJcbiAgKTogSFRNTENhbnZhc0VsZW1lbnQge1xyXG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICBjYW52YXMud2lkdGggPSB0YXJnZXRSZXNvbHV0aW9uLndpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IHRhcmdldFJlc29sdXRpb24uaGVpZ2h0O1xyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykhO1xyXG5cclxuICAgIC8vIEVuYWJsZSBoaWdoLXF1YWxpdHkgcmVuZGVyaW5nIGZvciBiZXR0ZXIgcmVzdWx0c1xyXG4gICAgaWYgKHRoaXMudXNlU3ViUGl4ZWxQcmVjaXNpb24pIHtcclxuICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRydWU7XHJcbiAgICAgIGN0eC5pbWFnZVNtb290aGluZ1F1YWxpdHkgPSAnaGlnaCc7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBleWVQb2ludHMsIGZhY2VCb3VuZHMsIGxhbmRtYXJrcyB9ID0gZmFjZVJlc3VsdDtcclxuICAgIGNvbnN0IHsgd2lkdGg6IGNhbnZhc1dpZHRoLCBoZWlnaHQ6IGNhbnZhc0hlaWdodCB9ID0gdGFyZ2V0UmVzb2x1dGlvbjtcclxuXHJcbiAgICBpZiAoIWZhY2VCb3VuZHMpIHtcclxuICAgICAgLy8gRmFsbGJhY2sgdG8gZnVsbCBhbGlnbm1lbnQgaWYgbm8gZmFjZSBib3VuZHNcclxuICAgICAgcmV0dXJuIHRoaXMuYWxpZ25JbWFnZUZ1bGwoc291cmNlSW1hZ2UsIGV5ZVBvaW50cywgdGFyZ2V0UmVzb2x1dGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJ5IHRvIHVzZSBlbmhhbmNlZCBleWUgZGV0ZWN0aW9uIGlmIGxhbmRtYXJrcyBhcmUgYXZhaWxhYmxlXHJcbiAgICBsZXQgZW5oYW5jZWRFeWVQb2ludHMgPSBleWVQb2ludHM7XHJcbiAgICBpZiAobGFuZG1hcmtzICYmIGxhbmRtYXJrcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgbGVmdEV5ZUluZGljZXMgPSBbMzMsIDcsIDE2MywgMTQ0LCAxNDUsIDE1MywgMTU0LCAxNTUsIDEzMywgMTczLCAxNTcsIDE1OCwgMTU5LCAxNjAsIDE2MV07XHJcbiAgICAgICAgY29uc3QgcmlnaHRFeWVJbmRpY2VzID0gWzM2MiwgMzgyLCAzODEsIDM4MCwgMzc0LCAzNzMsIDM5MCwgMjQ5LCAyNjMsIDQ2NiwgMzg4LCAzODcsIDM4NiwgMzg1LCAzODRdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IGxlZnRFeWVDZW50ZXIgPSB0aGlzLmNhbGN1bGF0ZVByZWNpc2VFeWVDZW50ZXIobGFuZG1hcmtzLCBsZWZ0RXllSW5kaWNlcyk7XHJcbiAgICAgICAgY29uc3QgcmlnaHRFeWVDZW50ZXIgPSB0aGlzLmNhbGN1bGF0ZVByZWNpc2VFeWVDZW50ZXIobGFuZG1hcmtzLCByaWdodEV5ZUluZGljZXMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGVuaGFuY2VkRXllUG9pbnRzID0ge1xyXG4gICAgICAgICAgbGVmdDogW2xlZnRFeWVDZW50ZXJbMF0gKiBzb3VyY2VJbWFnZS53aWR0aCwgbGVmdEV5ZUNlbnRlclsxXSAqIHNvdXJjZUltYWdlLmhlaWdodF0sXHJcbiAgICAgICAgICByaWdodDogW3JpZ2h0RXllQ2VudGVyWzBdICogc291cmNlSW1hZ2Uud2lkdGgsIHJpZ2h0RXllQ2VudGVyWzFdICogc291cmNlSW1hZ2UuaGVpZ2h0XVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0VuaGFuY2VkIGV5ZSBkZXRlY3Rpb24gZmFpbGVkLCB1c2luZyBmYWxsYmFjazonLCBlcnJvcik7XHJcbiAgICAgICAgLy8gQ29udGludWUgd2l0aCBvcmlnaW5hbCBleWUgcG9pbnRzXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgcGFkZGVkIGZhY2UgcmVnaW9uIHdpdGggZXh0cmEgdmVydGljYWwgcGFkZGluZ1xyXG4gICAgY29uc3QgZmFjZVdpZHRoID0gZmFjZUJvdW5kcy53aWR0aDtcclxuICAgIGNvbnN0IGZhY2VIZWlnaHQgPSBmYWNlQm91bmRzLmhlaWdodDtcclxuICAgIGNvbnN0IHBhZGRpbmdYID0gZmFjZVdpZHRoICogcGFkZGluZztcclxuICAgIGNvbnN0IHBhZGRpbmdZID0gZmFjZUhlaWdodCAqIChwYWRkaW5nICsgMC4yKTsgLy8gRXh0cmEgMjAlIHZlcnRpY2FsIHBhZGRpbmcgZm9yIGZvcmVoZWFkL2NoaW5cclxuXHJcbiAgICBjb25zdCBjcm9wTGVmdCA9IE1hdGgubWF4KDAsIGZhY2VCb3VuZHMubGVmdCAtIHBhZGRpbmdYKTtcclxuICAgIGNvbnN0IGNyb3BUb3AgPSBNYXRoLm1heCgwLCBmYWNlQm91bmRzLnRvcCAtIHBhZGRpbmdZKTtcclxuICAgIGNvbnN0IGNyb3BSaWdodCA9IE1hdGgubWluKHNvdXJjZUltYWdlLndpZHRoLCBmYWNlQm91bmRzLnJpZ2h0ICsgcGFkZGluZ1gpO1xyXG4gICAgY29uc3QgY3JvcEJvdHRvbSA9IE1hdGgubWluKHNvdXJjZUltYWdlLmhlaWdodCwgZmFjZUJvdW5kcy5ib3R0b20gKyBwYWRkaW5nWSk7XHJcblxyXG4gICAgY29uc3QgY3JvcFdpZHRoID0gY3JvcFJpZ2h0IC0gY3JvcExlZnQ7XHJcbiAgICBjb25zdCBjcm9wSGVpZ2h0ID0gY3JvcEJvdHRvbSAtIGNyb3BUb3A7XHJcblxyXG4gICAgLy8gQWRqdXN0IGV5ZSBwb2ludHMgcmVsYXRpdmUgdG8gY3JvcCByZWdpb25cclxuICAgIGNvbnN0IGFkanVzdGVkRXllUG9pbnRzOiBFeWVQb2ludHMgPSB7XHJcbiAgICAgIGxlZnQ6IFtleWVQb2ludHMubGVmdFswXSAtIGNyb3BMZWZ0LCBleWVQb2ludHMubGVmdFsxXSAtIGNyb3BUb3BdLFxyXG4gICAgICByaWdodDogW2V5ZVBvaW50cy5yaWdodFswXSAtIGNyb3BMZWZ0LCBleWVQb2ludHMucmlnaHRbMV0gLSBjcm9wVG9wXVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgZXllIHByb3BlcnRpZXMgaW4gY3JvcHBlZCByZWdpb25cclxuICAgIGNvbnN0IGV5ZUNlbnRlclggPSAoYWRqdXN0ZWRFeWVQb2ludHMubGVmdFswXSArIGFkanVzdGVkRXllUG9pbnRzLnJpZ2h0WzBdKSAvIDI7XHJcbiAgICBjb25zdCBleWVDZW50ZXJZID0gKGFkanVzdGVkRXllUG9pbnRzLmxlZnRbMV0gKyBhZGp1c3RlZEV5ZVBvaW50cy5yaWdodFsxXSkgLyAyO1xyXG4gICAgY29uc3QgZXllQW5nbGUgPSBNYXRoLmF0YW4yKFxyXG4gICAgICBhZGp1c3RlZEV5ZVBvaW50cy5yaWdodFsxXSAtIGFkanVzdGVkRXllUG9pbnRzLmxlZnRbMV0sXHJcbiAgICAgIGFkanVzdGVkRXllUG9pbnRzLnJpZ2h0WzBdIC0gYWRqdXN0ZWRFeWVQb2ludHMubGVmdFswXVxyXG4gICAgKTtcclxuICAgIGNvbnN0IGN1cnJlbnRFeWVEaXN0YW5jZSA9IE1hdGguc3FydChcclxuICAgICAgTWF0aC5wb3coYWRqdXN0ZWRFeWVQb2ludHMucmlnaHRbMF0gLSBhZGp1c3RlZEV5ZVBvaW50cy5sZWZ0WzBdLCAyKSArXHJcbiAgICAgIE1hdGgucG93KGFkanVzdGVkRXllUG9pbnRzLnJpZ2h0WzFdIC0gYWRqdXN0ZWRFeWVQb2ludHMubGVmdFsxXSwgMilcclxuICAgICk7XHJcblxyXG4gICAgLy8gVGFyZ2V0IGV5ZSBwcm9wZXJ0aWVzXHJcbiAgICBjb25zdCB0YXJnZXRFeWVEaXN0YW5jZSA9IGNhbnZhc1dpZHRoICogdGhpcy50YXJnZXRFeWVEaXN0YW5jZTtcclxuICAgIGNvbnN0IHRhcmdldEV5ZUNlbnRlclggPSBjYW52YXNXaWR0aCAvIDI7XHJcbiAgICBjb25zdCB0YXJnZXRFeWVDZW50ZXJZID0gY2FudmFzSGVpZ2h0ICogdGhpcy50YXJnZXRFeWVZO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBzY2FsZSB0byBmaXQgY3JvcHBlZCByZWdpb24gdG8gY2FudmFzXHJcbiAgICBjb25zdCBleWVTY2FsZSA9IHRhcmdldEV5ZURpc3RhbmNlIC8gY3VycmVudEV5ZURpc3RhbmNlO1xyXG4gICAgY29uc3Qgc2NhbGVUb0ZpdFggPSBjYW52YXNXaWR0aCAvIGNyb3BXaWR0aDtcclxuICAgIGNvbnN0IHNjYWxlVG9GaXRZID0gY2FudmFzSGVpZ2h0IC8gY3JvcEhlaWdodDtcclxuICAgIGNvbnN0IGZpdFNjYWxlID0gTWF0aC5taW4oc2NhbGVUb0ZpdFgsIHNjYWxlVG9GaXRZKTtcclxuICAgIFxyXG4gICAgLy8gVXNlIHRoZSBtb3JlIGFwcHJvcHJpYXRlIHNjYWxlXHJcbiAgICBjb25zdCBmaW5hbFNjYWxlID0gTWF0aC5taW4oZXllU2NhbGUsIGZpdFNjYWxlICogMS4yKTsgLy8gQWxsb3cgc2xpZ2h0IG92ZXJmbG93IGZvciBiZXR0ZXIgZnJhbWluZ1xyXG5cclxuICAgIC8vIEFwcGx5IHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdhbGlnbkltYWdlRmFjZUNyb3AgZGVidWc6Jywge1xyXG4gICAgICBjcm9wUmVnaW9uOiB7IGxlZnQ6IGNyb3BMZWZ0LCB0b3A6IGNyb3BUb3AsIHdpZHRoOiBjcm9wV2lkdGgsIGhlaWdodDogY3JvcEhlaWdodCB9LFxyXG4gICAgICBjYW52YXNTaXplOiB7IHdpZHRoOiBjYW52YXNXaWR0aCwgaGVpZ2h0OiBjYW52YXNIZWlnaHQgfSxcclxuICAgICAgZXllU2NhbGUsXHJcbiAgICAgIGZpdFNjYWxlLFxyXG4gICAgICBmaW5hbFNjYWxlLFxyXG4gICAgICBleWVDZW50ZXJYLFxyXG4gICAgICBleWVDZW50ZXJZLFxyXG4gICAgICB0YXJnZXRFeWVDZW50ZXJYLFxyXG4gICAgICB0YXJnZXRFeWVDZW50ZXJZLFxyXG4gICAgICBleWVBbmdsZTogZXllQW5nbGUgKiAoMTgwIC8gTWF0aC5QSSkgKyAnIGRlZ3JlZXMnXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBNb3ZlIHRvIHRhcmdldCBleWUgY2VudGVyXHJcbiAgICBjdHgudHJhbnNsYXRlKHRhcmdldEV5ZUNlbnRlclgsIHRhcmdldEV5ZUNlbnRlclkpO1xyXG5cclxuICAgIC8vIFJvdGF0ZSB0byBhbGlnbiBleWVzIGhvcml6b250YWxseVxyXG4gICAgY3R4LnJvdGF0ZSgtZXllQW5nbGUpO1xyXG5cclxuICAgIC8vIFNjYWxlIHRoZSBjcm9wcGVkIHJlZ2lvblxyXG4gICAgY3R4LnNjYWxlKGZpbmFsU2NhbGUsIGZpbmFsU2NhbGUpO1xyXG5cclxuICAgIC8vIERyYXcgdGhlIGNyb3BwZWQgcmVnaW9uIGNlbnRlcmVkIG9uIGV5ZSBjZW50ZXJcclxuICAgIGN0eC5kcmF3SW1hZ2UoXHJcbiAgICAgIHNvdXJjZUltYWdlLFxyXG4gICAgICBjcm9wTGVmdCwgY3JvcFRvcCwgY3JvcFdpZHRoLCBjcm9wSGVpZ2h0LCAvLyBTb3VyY2UgY3JvcFxyXG4gICAgICAtZXllQ2VudGVyWCwgLWV5ZUNlbnRlclksIGNyb3BXaWR0aCwgY3JvcEhlaWdodCAvLyBEZXN0aW5hdGlvblxyXG4gICAgKTtcclxuXHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgXHJcbiAgICAvLyBEZWJ1ZzogQ2hlY2sgaWYgY2FudmFzIGhhcyBjb250ZW50XHJcbiAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xyXG4gICAgY29uc3QgaGFzQ29udGVudCA9IGltYWdlRGF0YS5kYXRhLnNvbWUoKHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICByZXR1cm4gaW5kZXggJSA0ID09PSAzICYmIHZhbHVlID4gMDsgLy8gQ2hlY2sgYWxwaGEgY2hhbm5lbCBmb3Igbm9uLXRyYW5zcGFyZW50IHBpeGVsc1xyXG4gICAgfSk7XHJcbiAgICBjb25zb2xlLmxvZygnQ2FudmFzIGhhcyBjb250ZW50IGFmdGVyIGZhY2UgY3JvcCBkcmF3aW5nOicsIGhhc0NvbnRlbnQpO1xyXG4gICAgXHJcbiAgICBpZiAoIWhhc0NvbnRlbnQpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBGYWNlIGNyb3AgY2FudmFzIGFwcGVhcnMgdG8gYmUgZW1wdHkgYWZ0ZXIgYWxpZ25tZW50Jyk7XHJcbiAgICAgIC8vIERlYnVnOiBUcnkgYSBzaW1wbGUgYmx1ZSByZWN0YW5nbGUgdG8gdmVyaWZ5IGNhbnZhcyBpcyB3b3JraW5nXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnYmx1ZSc7XHJcbiAgICAgIGN0eC5maWxsUmVjdCgxMCwgMTAsIDUwLCA1MCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRlZCBkZWJ1ZyBibHVlIHJlY3RhbmdsZSB0byBlbXB0eSBmYWNlIGNyb3AgY2FudmFzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNhbnZhcztcclxuICB9XHJcblxyXG4gIC8vIEFsdGVybmF0aXZlIHNpbXBsZXIgYWxpZ25tZW50IG1ldGhvZCB1c2luZyBjYW52YXMgdHJhbnNmb3Jtc1xyXG4gIGFsaWduSW1hZ2VTaW1wbGUoXHJcbiAgICBzb3VyY2VJbWFnZTogSFRNTEltYWdlRWxlbWVudCxcclxuICAgIGV5ZVBvaW50czogRXllUG9pbnRzLFxyXG4gICAgdGFyZ2V0UmVzb2x1dGlvbjogUmVzb2x1dGlvbkNvbmZpZ1xyXG4gICk6IEhUTUxDYW52YXNFbGVtZW50IHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgY2FudmFzLndpZHRoID0gdGFyZ2V0UmVzb2x1dGlvbi53aWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSB0YXJnZXRSZXNvbHV0aW9uLmhlaWdodDtcclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpITtcclxuXHJcbiAgICBjb25zdCB7IGxlZnQsIHJpZ2h0IH0gPSBleWVQb2ludHM7XHJcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRhcmdldFJlc29sdXRpb247XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGV5ZSBjZW50ZXIgYW5kIGFuZ2xlXHJcbiAgICBjb25zdCBleWVDZW50ZXJYID0gKGxlZnRbMF0gKyByaWdodFswXSkgLyAyO1xyXG4gICAgY29uc3QgZXllQ2VudGVyWSA9IChsZWZ0WzFdICsgcmlnaHRbMV0pIC8gMjtcclxuICAgIGNvbnN0IGV5ZUFuZ2xlID0gTWF0aC5hdGFuMihyaWdodFsxXSAtIGxlZnRbMV0sIHJpZ2h0WzBdIC0gbGVmdFswXSk7XHJcbiAgICBjb25zdCBjdXJyZW50RXllRGlzdGFuY2UgPSBNYXRoLnNxcnQoXHJcbiAgICAgIE1hdGgucG93KHJpZ2h0WzBdIC0gbGVmdFswXSwgMikgKyBNYXRoLnBvdyhyaWdodFsxXSAtIGxlZnRbMV0sIDIpXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFRhcmdldCBwcm9wZXJ0aWVzXHJcbiAgICBjb25zdCB0YXJnZXRFeWVEaXN0YW5jZSA9IHdpZHRoICogdGhpcy50YXJnZXRFeWVEaXN0YW5jZTtcclxuICAgIGNvbnN0IHRhcmdldENlbnRlclggPSB3aWR0aCAvIDI7XHJcbiAgICBjb25zdCB0YXJnZXRDZW50ZXJZID0gaGVpZ2h0ICogdGhpcy50YXJnZXRFeWVZO1xyXG4gICAgY29uc3Qgc2NhbGUgPSB0YXJnZXRFeWVEaXN0YW5jZSAvIGN1cnJlbnRFeWVEaXN0YW5jZTtcclxuXHJcbiAgICAvLyBBcHBseSB0cmFuc2Zvcm1hdGlvbnNcclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBcclxuICAgIC8vIE1vdmUgdG8gdGFyZ2V0IGNlbnRlclxyXG4gICAgY3R4LnRyYW5zbGF0ZSh0YXJnZXRDZW50ZXJYLCB0YXJnZXRDZW50ZXJZKTtcclxuICAgIFxyXG4gICAgLy8gUm90YXRlIHRvIGFsaWduIGV5ZXMgaG9yaXpvbnRhbGx5XHJcbiAgICBjdHgucm90YXRlKC1leWVBbmdsZSk7XHJcbiAgICBcclxuICAgIC8vIFNjYWxlIHRvIG1hdGNoIHRhcmdldCBleWUgZGlzdGFuY2VcclxuICAgIGN0eC5zY2FsZShzY2FsZSwgc2NhbGUpO1xyXG4gICAgXHJcbiAgICAvLyBEcmF3IGltYWdlIGNlbnRlcmVkIG9uIGV5ZSBjZW50ZXJcclxuICAgIGN0eC5kcmF3SW1hZ2UoXHJcbiAgICAgIHNvdXJjZUltYWdlLFxyXG4gICAgICAtZXllQ2VudGVyWCxcclxuICAgICAgLWV5ZUNlbnRlcllcclxuICAgICk7XHJcbiAgICBcclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcblxyXG4gICAgcmV0dXJuIGNhbnZhcztcclxuICB9XHJcblxyXG4gIC8vIE1ldGhvZCB0byBjaGVjayBpZiBleWUgcG9pbnRzIGFyZSB2YWxpZCBmb3IgYWxpZ25tZW50XHJcbiAgdmFsaWRhdGVFeWVQb2ludHMoZXllUG9pbnRzOiBFeWVQb2ludHMsIGltYWdlV2lkdGg6IG51bWJlciwgaW1hZ2VIZWlnaHQ6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgeyBsZWZ0LCByaWdodCB9ID0gZXllUG9pbnRzO1xyXG5cclxuICAgIC8vIENoZWNrIGlmIHBvaW50cyBhcmUgd2l0aGluIGltYWdlIGJvdW5kc1xyXG4gICAgaWYgKGxlZnRbMF0gPCAwIHx8IGxlZnRbMF0gPiBpbWFnZVdpZHRoIHx8IGxlZnRbMV0gPCAwIHx8IGxlZnRbMV0gPiBpbWFnZUhlaWdodCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAocmlnaHRbMF0gPCAwIHx8IHJpZ2h0WzBdID4gaW1hZ2VXaWR0aCB8fCByaWdodFsxXSA8IDAgfHwgcmlnaHRbMV0gPiBpbWFnZUhlaWdodCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgZXllcyBhcmUgcmVhc29uYWJseSBmYXIgYXBhcnRcclxuICAgIGNvbnN0IGV5ZURpc3RhbmNlID0gTWF0aC5zcXJ0KFxyXG4gICAgICBNYXRoLnBvdyhyaWdodFswXSAtIGxlZnRbMF0sIDIpICsgTWF0aC5wb3cocmlnaHRbMV0gLSBsZWZ0WzFdLCAyKVxyXG4gICAgKTtcclxuICAgIGNvbnN0IG1pbkV5ZURpc3RhbmNlID0gTWF0aC5taW4oaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQpICogMC4wNTsgLy8gNSUgb2Ygc21hbGxlciBkaW1lbnNpb25cclxuICAgIGNvbnN0IG1heEV5ZURpc3RhbmNlID0gTWF0aC5tYXgoaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQpICogMC44OyAgLy8gODAlIG9mIGxhcmdlciBkaW1lbnNpb25cclxuXHJcbiAgICByZXR1cm4gZXllRGlzdGFuY2UgPj0gbWluRXllRGlzdGFuY2UgJiYgZXllRGlzdGFuY2UgPD0gbWF4RXllRGlzdGFuY2U7XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgcHJldmlldyBvZiBhbGlnbm1lbnQgdHJhbnNmb3JtYXRpb25cclxuICBnZXRBbGlnbm1lbnRQcmV2aWV3KFxyXG4gICAgc291cmNlSW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQsXHJcbiAgICBleWVQb2ludHM6IEV5ZVBvaW50cyxcclxuICAgIHRhcmdldFJlc29sdXRpb246IFJlc29sdXRpb25Db25maWcsXHJcbiAgICBwcmV2aWV3U2l6ZSA9IDIwMFxyXG4gICk6IEhUTUxDYW52YXNFbGVtZW50IHtcclxuICAgIC8vIENyZWF0ZSBzbWFsbGVyIHByZXZpZXdcclxuICAgIGNvbnN0IHByZXZpZXdSZXNvbHV0aW9uID0ge1xyXG4gICAgICB3aWR0aDogcHJldmlld1NpemUsXHJcbiAgICAgIGhlaWdodDogKHByZXZpZXdTaXplICogdGFyZ2V0UmVzb2x1dGlvbi5oZWlnaHQpIC8gdGFyZ2V0UmVzb2x1dGlvbi53aWR0aFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5hbGlnbkltYWdlRnVsbChzb3VyY2VJbWFnZSwgZXllUG9pbnRzLCBwcmV2aWV3UmVzb2x1dGlvbik7XHJcbiAgfVxyXG59Il0sIm5hbWVzIjpbIkltYWdlQWxpZ25lciIsImNhbGN1bGF0ZVByZWNpc2VFeWVDZW50ZXIiLCJsYW5kbWFya3MiLCJleWVJbmRpY2VzIiwidmFsaWRMYW5kbWFya3MiLCJtYXAiLCJpZHgiLCJmaWx0ZXIiLCJsYW5kbWFyayIsImxlbmd0aCIsIkVycm9yIiwid2VpZ2h0ZWRYIiwid2VpZ2h0ZWRZIiwidG90YWxXZWlnaHQiLCJmb3JFYWNoIiwiaSIsImlzQ29ybmVyIiwid2VpZ2h0IiwieCIsInkiLCJhbGlnbkltYWdlIiwic291cmNlSW1hZ2UiLCJleWVQb2ludHMiLCJ0YXJnZXRSZXNvbHV0aW9uIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwid2lkdGgiLCJoZWlnaHQiLCJjdHgiLCJnZXRDb250ZXh0IiwidHJhbnNmb3JtIiwiY2FsY3VsYXRlQWxpZ25tZW50VHJhbnNmb3JtIiwic2F2ZSIsInNldFRyYW5zZm9ybSIsIm1hdHJpeCIsImRyYXdJbWFnZSIsInJlc3RvcmUiLCJsZWZ0IiwicmlnaHQiLCJleWVDZW50ZXJYIiwiZXllQ2VudGVyWSIsImN1cnJlbnRFeWVEaXN0YW5jZSIsIk1hdGgiLCJzcXJ0IiwicG93IiwiZXllQW5nbGUiLCJhdGFuMiIsInRhcmdldEV5ZURpc3RhbmNlUGl4ZWxzIiwidGFyZ2V0RXllRGlzdGFuY2UiLCJ0YXJnZXRFeWVDZW50ZXJYIiwidGFyZ2V0RXllQ2VudGVyWSIsInRhcmdldEV5ZVkiLCJzY2FsZSIsInJvdGF0aW9uIiwiUEkiLCJ0cmFuc2xhdGlvbiIsImNyZWF0ZVRyYW5zZm9ybU1hdHJpeCIsImFwcGx5U21vb3RoaW5nVG9UcmFuc2Zvcm0iLCJ0eCIsInR5IiwiY29zIiwic2luIiwicHJldmlvdXNUcmFuc2Zvcm1zIiwicHVzaCIsInJlY2VudCIsImFscGhhIiwic21vb3RoaW5nRmFjdG9yIiwic21vb3RoZWQiLCJpbnRlcnBvbGF0ZUFuZ2xlIiwicmFkaWFucyIsInNoaWZ0IiwiYW5nbGUxIiwiYW5nbGUyIiwiZGlmZiIsInJlc2V0U21vb3RoaW5nU3RhdGUiLCJhbGlnbkltYWdlRnVsbCIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiZXllU2NhbGUiLCJzY2FsZWRJbWFnZVdpZHRoIiwic2NhbGVkSW1hZ2VIZWlnaHQiLCJjYW52YXNGaXRTY2FsZVgiLCJjYW52YXNGaXRTY2FsZVkiLCJjYW52YXNGaXRTY2FsZSIsIm1pbiIsImZpbmFsU2NhbGUiLCJzY2FsZWRFeWVDZW50ZXJYIiwic2NhbGVkRXllQ2VudGVyWSIsImNsZWFyUmVjdCIsImNvbnNvbGUiLCJsb2ciLCJzb3VyY2VJbWFnZVNpemUiLCJjYW52YXNTaXplIiwiaW1hZ2VDb21wbGV0ZSIsImNvbXBsZXRlIiwiaW1hZ2VTcmMiLCJzcmMiLCJzdWJzdHJpbmciLCJ0ZXN0Q2FudmFzIiwidGVzdEN0eCIsInRlc3RJbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJzb3VyY2VIYXNDb250ZW50IiwiZGF0YSIsInNvbWUiLCJ2YWx1ZSIsImluZGV4IiwidHJhbnNsYXRlIiwicm90YXRlIiwiZHgiLCJkeSIsImRXaWR0aCIsImRIZWlnaHQiLCJjdXJyZW50VHJhbnNmb3JtIiwiZ2V0VHJhbnNmb3JtIiwiaW1tZWRpYXRlQ2hlY2siLCJkcmV3U29tZXRoaW5nIiwiaW1hZ2VEYXRhIiwiaGFzQ29udGVudCIsIndhcm4iLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImFsaWduSW1hZ2VGYWNlQ3JvcCIsImZhY2VSZXN1bHQiLCJwYWRkaW5nIiwidXNlU3ViUGl4ZWxQcmVjaXNpb24iLCJpbWFnZVNtb290aGluZ0VuYWJsZWQiLCJpbWFnZVNtb290aGluZ1F1YWxpdHkiLCJmYWNlQm91bmRzIiwiZW5oYW5jZWRFeWVQb2ludHMiLCJsZWZ0RXllSW5kaWNlcyIsInJpZ2h0RXllSW5kaWNlcyIsImxlZnRFeWVDZW50ZXIiLCJyaWdodEV5ZUNlbnRlciIsImVycm9yIiwiZmFjZVdpZHRoIiwiZmFjZUhlaWdodCIsInBhZGRpbmdYIiwicGFkZGluZ1kiLCJjcm9wTGVmdCIsIm1heCIsImNyb3BUb3AiLCJ0b3AiLCJjcm9wUmlnaHQiLCJjcm9wQm90dG9tIiwiYm90dG9tIiwiY3JvcFdpZHRoIiwiY3JvcEhlaWdodCIsImFkanVzdGVkRXllUG9pbnRzIiwic2NhbGVUb0ZpdFgiLCJzY2FsZVRvRml0WSIsImZpdFNjYWxlIiwiY3JvcFJlZ2lvbiIsImFsaWduSW1hZ2VTaW1wbGUiLCJ0YXJnZXRDZW50ZXJYIiwidGFyZ2V0Q2VudGVyWSIsInZhbGlkYXRlRXllUG9pbnRzIiwiaW1hZ2VXaWR0aCIsImltYWdlSGVpZ2h0IiwiZXllRGlzdGFuY2UiLCJtaW5FeWVEaXN0YW5jZSIsIm1heEV5ZURpc3RhbmNlIiwiZ2V0QWxpZ25tZW50UHJldmlldyIsInByZXZpZXdTaXplIiwicHJldmlld1Jlc29sdXRpb24iLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/imageAlignment.ts\n"));

/***/ })

});